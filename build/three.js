console.warn( 'Scripts "build/three.js" and "build/three.min.js" are deprecated with r150+, and will be removed with r160. Please use ES Modules or alternatives: https://threejs.org/docs/index.html#manual/en/introduction/Installation' );
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
})(this, (function (exports) { 'use strict';

	const REVISION = '155dev';

	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
	const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const TwoPassDoubleSide = 2; // r149
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBAIntegerFormat = 1033;

	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const RED_RGTC1_Format = 36283;
	const SIGNED_RED_RGTC1_Format = 36284;
	const RED_GREEN_RGTC2_Format = 36285;
	const SIGNED_RED_GREEN_RGTC2_Format = 36286;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */
	const LinearEncoding = 3000;
	/** @deprecated Use SRGBColorSpace in three.js r152+. */
	const sRGBEncoding = 3001;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;

	// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
	const NoColorSpace = '';
	const SRGBColorSpace = 'srgb';
	const LinearSRGBColorSpace = 'srgb-linear';
	const DisplayP3ColorSpace = 'display-p3';

	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;

	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;

	const NeverCompare = 512;
	const LessCompare = 513;
	const EqualCompare = 514;
	const LessEqualCompare = 515;
	const GreaterCompare = 516;
	const NotEqualCompare = 517;
	const GreaterEqualCompare = 518;
	const AlwaysCompare = 519;

	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const StreamDrawUsage = 35040;
	const StaticReadUsage = 35045;
	const DynamicReadUsage = 35049;
	const StreamReadUsage = 35041;
	const StaticCopyUsage = 35046;
	const DynamicCopyUsage = 35050;
	const StreamCopyUsage = 35042;

	const GLSL1 = '100';
	const GLSL3 = '300 es';

	const _SRGBAFormat = 1035; // fallback for WebGL 1

	const WebGLCoordinateSystem = 2000;
	const WebGPUCoordinateSystem = 2001;

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	class EventDispatcher {

		addEventListener( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		}

		hasEventListener( type, listener ) {

			if ( this._listeners === undefined ) return false;

			const listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		}

		removeEventListener( type, listener ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		}

		dispatchEvent( event ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

				event.target = null;

			}

		}

	}

	const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

	let _seed = 1234567;


	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI;

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID() {

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toLowerCase() here flattens concatenated strings to save heap memory space.
		return uuid.toLowerCase();

	}

	function clamp( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	}

	// compute euclidean modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo( n, m ) {

		return ( ( n % m ) + m ) % m;

	}

	// Linear mapping from range <a1, a2> to range <b1, b2>
	function mapLinear( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	}

	// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
	function inverseLerp( x, y, value ) {

		if ( x !== y ) {

			return ( value - x ) / ( y - x );

		} else {

			return 0;

		}

	}

	// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	}

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
	function damp( x, y, lambda, dt ) {

		return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

	}

	// https://www.desmos.com/calculator/vcsjnyz7x4
	function pingpong( x, length = 1 ) {

		return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

	}

	// http://en.wikipedia.org/wiki/Smoothstep
	function smoothstep( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	}

	function smootherstep( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	}

	// Random integer from <low, high> interval
	function randInt( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	}

	// Random float from <low, high> interval
	function randFloat( low, high ) {

		return low + Math.random() * ( high - low );

	}

	// Random float from <-range/2, range/2> interval
	function randFloatSpread( range ) {

		return range * ( 0.5 - Math.random() );

	}

	// Deterministic pseudo-random float in the interval [ 0, 1 ]
	function seededRandom( s ) {

		if ( s !== undefined ) _seed = s;

		// Mulberry32 generator

		let t = _seed += 0x6D2B79F5;

		t = Math.imul( t ^ t >>> 15, t | 1 );

		t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

		return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

	}

	function degToRad( degrees ) {

		return degrees * DEG2RAD;

	}

	function radToDeg( radians ) {

		return radians * RAD2DEG;

	}

	function isPowerOfTwo( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	function ceilPowerOfTwo( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	}

	function floorPowerOfTwo( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

	function setQuaternionFromProperEuler( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

	function denormalize( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint32Array:

				return value / 4294967295.0;

			case Uint16Array:

				return value / 65535.0;

			case Uint8Array:

				return value / 255.0;

			case Int32Array:

				return Math.max( value / 2147483647.0, - 1.0 );

			case Int16Array:

				return Math.max( value / 32767.0, - 1.0 );

			case Int8Array:

				return Math.max( value / 127.0, - 1.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	function normalize( value, array ) {

		switch ( array.constructor ) {

			case Float32Array:

				return value;

			case Uint32Array:

				return Math.round( value * 4294967295.0 );

			case Uint16Array:

				return Math.round( value * 65535.0 );

			case Uint8Array:

				return Math.round( value * 255.0 );

			case Int32Array:

				return Math.round( value * 2147483647.0 );

			case Int16Array:

				return Math.round( value * 32767.0 );

			case Int8Array:

				return Math.round( value * 127.0 );

			default:

				throw new Error( 'Invalid component type.' );

		}

	}

	const MathUtils = {
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler,
		normalize: normalize,
		denormalize: denormalize
	};

	class Vector2 {

		constructor( x = 0, y = 0 ) {

			Vector2.prototype.isVector2 = true;

			this.x = x;
			this.y = y;

		}

		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		angle() {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;

		}

	}

	class Matrix3 {

		constructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			Matrix3.prototype.isMatrix3 = true;

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( n11 !== undefined ) {

				this.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );

			}

		}

		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).invert().transpose();

		}

		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		//

		scale( sx, sy ) {

			this.premultiply( _m3.makeScale( sx, sy ) );

			return this;

		}

		rotate( theta ) {

			this.premultiply( _m3.makeRotation( - theta ) );

			return this;

		}

		translate( tx, ty ) {

			this.premultiply( _m3.makeTranslation( tx, ty ) );

			return this;

		}

		// for 2D Transforms

		makeTranslation( x, y ) {

			if ( x.isVector2 ) {

				this.set(

					1, 0, x.x,
					0, 1, x.y,
					0, 0, 1

				);

			} else {

				this.set(

					1, 0, x,
					0, 1, y,
					0, 0, 1

				);

			}

			return this;

		}

		makeRotation( theta ) {

			// counterclockwise

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			this.set(

				c, - s, 0,
				s, c, 0,
				0, 0, 1

			);

			return this;

		}

		makeScale( x, y ) {

			this.set(

				x, 0, 0,
				0, y, 0,
				0, 0, 1

			);

			return this;

		}

		//

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

		clone() {

			return new this.constructor().fromArray( this.elements );

		}

	}

	const _m3 = /*@__PURE__*/ new Matrix3();

	function arrayNeedsUint32( array ) {

		// assumes larger values usually on last

		for ( let i = array.length - 1; i >= 0; -- i ) {

			if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

		}

		return false;

	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray( type, buffer ) {

		return new TYPED_ARRAYS[ type ]( buffer );

	}

	function createElementNS( name ) {

		return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

	}

	const _cache = {};

	function warnOnce( message ) {

		if ( message in _cache ) return;

		_cache[ message ] = true;

		console.warn( message );

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	/**
	 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
	 * or clipping. Based on W3C specifications for sRGB and Display P3,
	 * and ICC specifications for the D50 connection space. Values in/out
	 * are _linear_ sRGB and _linear_ Display P3.
	 *
	 * Note that both sRGB and Display P3 use the sRGB transfer functions.
	 *
	 * Reference:
	 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
	 */

	const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().fromArray( [
		0.8224621, 0.0331941, 0.0170827,
		0.1775380, 0.9668058, 0.0723974,
		- 0.0000001, 0.0000001, 0.9105199
	] );

	const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().fromArray( [
		1.2249401, - 0.0420569, - 0.0196376,
		- 0.2249404, 1.0420571, - 0.0786361,
		0.0000001, 0.0000000, 1.0982735
	] );

	function DisplayP3ToLinearSRGB( color ) {

		// Display P3 uses the sRGB transfer functions
		return color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB );

	}

	function LinearSRGBToDisplayP3( color ) {

		// Display P3 uses the sRGB transfer functions
		return color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB();

	}

	// Conversions from <source> to Linear-sRGB reference space.
	const TO_LINEAR = {
		[ LinearSRGBColorSpace ]: ( color ) => color,
		[ SRGBColorSpace ]: ( color ) => color.convertSRGBToLinear(),
		[ DisplayP3ColorSpace ]: DisplayP3ToLinearSRGB,
	};

	// Conversions to <target> from Linear-sRGB reference space.
	const FROM_LINEAR = {
		[ LinearSRGBColorSpace ]: ( color ) => color,
		[ SRGBColorSpace ]: ( color ) => color.convertLinearToSRGB(),
		[ DisplayP3ColorSpace ]: LinearSRGBToDisplayP3,
	};

	const ColorManagement = {

		enabled: true,

		get legacyMode() {

			console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );

			return ! this.enabled;

		},

		set legacyMode( legacyMode ) {

			console.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );

			this.enabled = ! legacyMode;

		},

		get workingColorSpace() {

			return LinearSRGBColorSpace;

		},

		set workingColorSpace( colorSpace ) {

			console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

		},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			const sourceToLinear = TO_LINEAR[ sourceColorSpace ];
			const targetFromLinear = FROM_LINEAR[ targetColorSpace ];

			if ( sourceToLinear === undefined || targetFromLinear === undefined ) {

				throw new Error( `Unsupported color space conversion, "${ sourceColorSpace }" to "${ targetColorSpace }".` );

			}

			return targetFromLinear( sourceToLinear( color ) );

		},

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

	};

	let _canvas;

	class ImageUtils {

		static getDataURL( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement === 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		static sRGBToLinear( image ) {

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const canvas = createElementNS( 'canvas' );

				canvas.width = image.width;
				canvas.height = image.height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height );

				const imageData = context.getImageData( 0, 0, image.width, image.height );
				const data = imageData.data;

				for ( let i = 0; i < data.length; i ++ ) {

					data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

				}

				context.putImageData( imageData, 0, 0 );

				return canvas;

			} else if ( image.data ) {

				const data = image.data.slice( 0 );

				for ( let i = 0; i < data.length; i ++ ) {

					if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

						data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

					} else {

						// assuming float

						data[ i ] = SRGBToLinear( data[ i ] );

					}

				}

				return {
					data: data,
					width: image.width,
					height: image.height
				};

			} else {

				console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
				return image;

			}

		}

	}

	let sourceId = 0;

	class Source {

		constructor( data = null ) {

			this.isSource = true;

			Object.defineProperty( this, 'id', { value: sourceId ++ } );

			this.uuid = generateUUID();

			this.data = data;

			this.version = 0;

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

				return meta.images[ this.uuid ];

			}

			const output = {
				uuid: this.uuid,
				url: ''
			};

			const data = this.data;

			if ( data !== null ) {

				let url;

				if ( Array.isArray( data ) ) {

					// cube texture

					url = [];

					for ( let i = 0, l = data.length; i < l; i ++ ) {

						if ( data[ i ].isDataTexture ) {

							url.push( serializeImage( data[ i ].image ) );

						} else {

							url.push( serializeImage( data[ i ] ) );

						}

					}

				} else {

					// texture

					url = serializeImage( data );

				}

				output.url = url;

			}

			if ( ! isRootObject ) {

				meta.images[ this.uuid ] = output;

			}

			return output;

		}

	}

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.from( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				console.warn( 'THREE.Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {

		constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {

			super();

			this.isTexture = true;

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = generateUUID();

			this.name = '';

			this.source = new Source( image );
			this.mipmaps = [];

			this.mapping = mapping;
			this.channel = 0;

			this.wrapS = wrapS;
			this.wrapT = wrapT;

			this.magFilter = magFilter;
			this.minFilter = minFilter;

			this.anisotropy = anisotropy;

			this.format = format;
			this.internalFormat = null;
			this.type = type;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			if ( typeof colorSpace === 'string' ) {

				this.colorSpace = colorSpace;

			} else { // @deprecated, r152

				warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );
				this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

			}


			this.userData = {};

			this.version = 0;
			this.onUpdate = null;

			this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
			this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

		}

		get image() {

			return this.source.data;

		}

		set image( value = null ) {

			this.source.data = value;

		}

		updateMatrix() {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.source = source.source;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;
			this.channel = source.channel;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.colorSpace = source.colorSpace;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.needsUpdate = true;

			return this;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.6,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				image: this.source.toJSON( meta ).uuid,

				mapping: this.mapping,
				channel: this.channel,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				internalFormat: this.internalFormat,
				type: this.type,
				colorSpace: this.colorSpace,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				generateMipmaps: this.generateMipmaps,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		transformUv( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

		set needsUpdate( value ) {

			if ( value === true ) {

				this.version ++;
				this.source.needsUpdate = true;

			}

		}

		get encoding() { // @deprecated, r152

			warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );
			return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;

		}

		set encoding( encoding ) { // @deprecated, r152

			warnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );
			this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

		}

	}

	Texture.DEFAULT_IMAGE = null;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.DEFAULT_ANISOTROPY = 1;

	class Vector4 {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			Vector4.prototype.isVector4 = true;

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

		}

		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setW( w ) {

			this.w = w;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;
			yield this.w;

		}

	}

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class WebGLRenderTarget extends EventDispatcher {

		constructor( width = 1, height = 1, options = {} ) {

			super();

			this.isWebGLRenderTarget = true;

			this.width = width;
			this.height = height;
			this.depth = 1;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			const image = { width: width, height: height, depth: 1 };

			if ( options.encoding !== undefined ) {

				// @deprecated, r152
				warnOnce( 'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.' );
				options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

			}

			this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );
			this.texture.isRenderTargetTexture = true;

			this.texture.flipY = false;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

			this.samples = options.samples !== undefined ? options.samples : 0;

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.scissor.copy( source.scissor );
			this.scissorTest = source.scissorTest;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();
			this.texture.isRenderTargetTexture = true;

			// ensure image object is not shared, see #20328

			const image = Object.assign( {}, source.texture.image );
			this.texture.source = new Source( image );

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

			this.samples = source.samples;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	class DataArrayTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			super( null );

			this.isDataArrayTexture = true;

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	class WebGLArrayRenderTarget extends WebGLRenderTarget {

		constructor( width = 1, height = 1, depth = 1 ) {

			super( width, height );

			this.isWebGLArrayRenderTarget = true;

			this.depth = depth;

			this.texture = new DataArrayTexture( null, width, height, depth );

			this.texture.isRenderTargetTexture = true;

		}

	}

	class Data3DTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super( null );

			this.isData3DTexture = true;

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	class WebGL3DRenderTarget extends WebGLRenderTarget {

		constructor( width = 1, height = 1, depth = 1 ) {

			super( width, height );

			this.isWebGL3DRenderTarget = true;

			this.depth = depth;

			this.texture = new Data3DTexture( null, width, height, depth );

			this.texture.isRenderTargetTexture = true;

		}

	}

	class WebGLMultipleRenderTargets extends WebGLRenderTarget {

		constructor( width = 1, height = 1, count = 1, options = {} ) {

			super( width, height, options );

			this.isWebGLMultipleRenderTargets = true;

			const texture = this.texture;

			this.texture = [];

			for ( let i = 0; i < count; i ++ ) {

				this.texture[ i ] = texture.clone();
				this.texture[ i ].isRenderTargetTexture = true;

			}

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				for ( let i = 0, il = this.texture.length; i < il; i ++ ) {

					this.texture[ i ].image.width = width;
					this.texture[ i ].image.height = height;
					this.texture[ i ].image.depth = depth;

				}

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

			return this;

		}

		copy( source ) {

			this.dispose();

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.scissor.copy( source.scissor );
			this.scissorTest = source.scissorTest;

			this.viewport.copy( source.viewport );

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

			this.texture.length = 0;

			for ( let i = 0, il = source.texture.length; i < il; i ++ ) {

				this.texture[ i ] = source.texture[ i ].clone();
				this.texture[ i ].isRenderTargetTexture = true;

			}

			return this;

		}

	}

	class Quaternion {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this.isQuaternion = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( t === 0 ) {

				dst[ dstOffset + 0 ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
				return;

			}

			if ( t === 1 ) {

				dst[ dstOffset + 0 ] = x1;
				dst[ dstOffset + 1 ] = y1;
				dst[ dstOffset + 2 ] = z1;
				dst[ dstOffset + 3 ] = w1;
				return;

			}

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					const sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		setFromEuler( euler, update ) {

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			let r = vFrom.dot( vTo ) + 1;

			if ( r < Number.EPSILON ) {

				// vFrom and vTo point in opposite directions

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		angleTo( q ) {

			return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

		}

		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		invert() {

			// quaternion is assumed to have unit length

			return this.conjugate();

		}

		conjugate() {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		}

		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		multiply( q ) {

			return this.multiplyQuaternions( this, q );

		}

		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		slerp( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			const x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		}

		slerpQuaternions( qa, qb, t ) {

			return this.copy( qa ).slerp( qb, t );

		}

		random() {

			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.

			const u1 = Math.random();
			const sqrt1u1 = Math.sqrt( 1 - u1 );
			const sqrtu1 = Math.sqrt( u1 );

			const u2 = 2 * Math.PI * Math.random();

			const u3 = 2 * Math.PI * Math.random();

			return this.set(
				sqrt1u1 * Math.cos( u2 ),
				sqrtu1 * Math.sin( u3 ),
				sqrtu1 * Math.cos( u3 ),
				sqrt1u1 * Math.sin( u2 ),
			);

		}

		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		}

		toJSON() {

			return this.toArray();

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._w;

		}

	}

	class Vector3 {

		constructor( x = 0, y = 0, z = 0 ) {

			Vector3.prototype.isVector3 = true;

			this.x = x;
			this.y = y;
			this.z = z;

		}

		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		applyEuler( euler ) {

			return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

		}

		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		applyQuaternion( q ) {

			const x = this.x, y = this.y, z = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}

		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		cross( v ) {

			return this.crossVectors( this, v );

		}

		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		projectOnPlane( planeNormal ) {

			_vector$b.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector$b );

		}

		reflect( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector$b.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		setFromEuler( e ) {

			this.x = e._x;
			this.y = e._y;
			this.z = e._z;

			return this;

		}

		setFromColor( c ) {

			this.x = c.r;
			this.y = c.g;
			this.z = c.b;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

		randomDirection() {

			// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

			const u = ( Math.random() - 0.5 ) * 2;
			const t = Math.random() * Math.PI * 2;
			const f = Math.sqrt( 1 - u ** 2 );

			this.x = f * Math.cos( t );
			this.y = f * Math.sin( t );
			this.z = u;

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;

		}

	}

	const _vector$b = /*@__PURE__*/ new Vector3();
	const _quaternion$4 = /*@__PURE__*/ new Quaternion();

	class Box3 {

		constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

			this.isBox3 = true;

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromArray( array ) {

			this.makeEmpty();

			for ( let i = 0, il = array.length; i < il; i += 3 ) {

				this.expandByPoint( _vector$a.fromArray( array, i ) );

			}

			return this;

		}

		setFromBufferAttribute( attribute ) {

			this.makeEmpty();

			for ( let i = 0, il = attribute.count; i < il; i ++ ) {

				this.expandByPoint( _vector$a.fromBufferAttribute( attribute, i ) );

			}

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$a.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		setFromObject( object, precise = false ) {

			this.makeEmpty();

			return this.expandByObject( object, precise );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		expandByObject( object, precise = false ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			if ( object.boundingBox !== undefined ) {

				if ( object.boundingBox === null ) {

					object.computeBoundingBox();

				}

				_box$3.copy( object.boundingBox );
				_box$3.applyMatrix4( object.matrixWorld );

				this.union( _box$3 );

			} else {

				const geometry = object.geometry;

				if ( geometry !== undefined ) {

					if ( precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined ) {

						const position = geometry.attributes.position;
						for ( let i = 0, l = position.count; i < l; i ++ ) {

							_vector$a.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
							this.expandByPoint( _vector$a );

						}

					} else {

						if ( geometry.boundingBox === null ) {

							geometry.computeBoundingBox();

						}

						_box$3.copy( geometry.boundingBox );
						_box$3.applyMatrix4( object.matrixWorld );

						this.union( _box$3 );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ], precise );

			}

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		}

		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$a );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$a.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0$2.subVectors( triangle.a, _center );
			_v1$7.subVectors( triangle.b, _center );
			_v2$4.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$7, _v0$2 );
			_f1.subVectors( _v2$4, _v1$7 );
			_f2.subVectors( _v0$2, _v2$4 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

		}

		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			return this.clampPoint( point, _vector$a ).distanceTo( point );

		}

		getBoundingSphere( target ) {

			if ( this.isEmpty() ) {

				target.makeEmpty();

			} else {

				this.getCenter( target.center );

				target.radius = this.getSize( _vector$a ).length() * 0.5;

			}

			return target;

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$a = /*@__PURE__*/ new Vector3();

	const _box$3 = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0$2 = /*@__PURE__*/ new Vector3();
	const _v1$7 = /*@__PURE__*/ new Vector3();
	const _v2$4 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the separating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the separating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is separating and we can exit
				return false;

			}

		}

		return true;

	}

	const _box$2 = /*@__PURE__*/ new Box3();
	const _v1$6 = /*@__PURE__*/ new Vector3();
	const _v2$3 = /*@__PURE__*/ new Vector3();

	class Sphere {

		constructor( center = new Vector3(), radius = - 1 ) {

			this.center = center;
			this.radius = radius;

		}

		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$2.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		isEmpty() {

			return ( this.radius < 0 );

		}

		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = - 1;

			return this;

		}

		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		getBoundingBox( target ) {

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		expandByPoint( point ) {

			if ( this.isEmpty() ) {

				this.center.copy( point );

				this.radius = 0;

				return this;

			}

			_v1$6.subVectors( point, this.center );

			const lengthSq = _v1$6.lengthSq();

			if ( lengthSq > ( this.radius * this.radius ) ) {

				// calculate the minimal sphere

				const length = Math.sqrt( lengthSq );

				const delta = ( length - this.radius ) * 0.5;

				this.center.addScaledVector( _v1$6, delta / length );

				this.radius += delta;

			}

			return this;

		}

		union( sphere ) {

			if ( sphere.isEmpty() ) {

				return this;

			}

			if ( this.isEmpty() ) {

				this.copy( sphere );

				return this;

			}

			if ( this.center.equals( sphere.center ) === true ) {

				 this.radius = Math.max( this.radius, sphere.radius );

			} else {

				_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

				this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

				this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

			}

			return this;

		}

		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$9 = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal$1 = /*@__PURE__*/ new Vector3();

	class Ray {

		constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

			this.origin = origin;
			this.direction = direction;

		}

		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		at( t, target ) {

			return target.copy( this.origin ).addScaledVector( this.direction, t );

		}

		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		recast( t ) {

			this.origin.copy( this.at( t, _vector$9 ) );

			return this;

		}

		closestPointToPoint( point, target ) {

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.origin ).addScaledVector( this.direction, directionDistance );

		}

		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		distanceSqToPoint( point ) {

			const directionDistance = _vector$9.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector$9.copy( this.origin ).addScaledVector( this.direction, directionDistance );

			return _vector$9.distanceToSquared( point );

		}

		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );

			}

			return sqrDist;

		}

		intersectSphere( sphere, target ) {

			_vector$9.subVectors( sphere.center, this.origin );
			const tca = _vector$9.dot( this.direction );
			const d2 = _vector$9.dot( _vector$9 ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if t1 is behind the ray - if so, return null
			if ( t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		intersectsSphere( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

			if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		intersectsBox( box ) {

			return this.intersectBox( box, _vector$9 ) !== null;

		}

		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal$1.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal$1 );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal$1 );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class Matrix4 {

		constructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			Matrix4.prototype.isMatrix4 = true;

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( n11 !== undefined ) {

				this.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );

			}

		}

		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		setFromMatrix3( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ], 0,
				me[ 1 ], me[ 4 ], me[ 7 ], 0,
				me[ 2 ], me[ 5 ], me[ 8 ], 0,
				0, 0, 0, 1

			);

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		extractRotation( m ) {

			// this method does not support reflection matrices

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromEuler( euler ) {

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		makeTranslation( x, y, z ) {

			if ( x.isVector3 ) {

				this.set(

					1, 0, 0, x.x,
					0, 1, 0, x.y,
					0, 0, 1, x.z,
					0, 0, 0, 1

				);

			} else {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

			}

			return this;

		}

		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeShear( xy, xz, yx, yz, zx, zy ) {

			this.set(

				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1$2.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1$2.elements[ 0 ] *= invSX;
			_m1$2.elements[ 1 ] *= invSX;
			_m1$2.elements[ 2 ] *= invSX;

			_m1$2.elements[ 4 ] *= invSY;
			_m1$2.elements[ 5 ] *= invSY;
			_m1$2.elements[ 6 ] *= invSY;

			_m1$2.elements[ 8 ] *= invSZ;
			_m1$2.elements[ 9 ] *= invSZ;
			_m1$2.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1$2 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		makePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

			const te = this.elements;
			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );

			let c, d;

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				c = - ( far + near ) / ( far - near );
				d = ( - 2 * far * near ) / ( far - near );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				c = - far / ( far - near );
				d = ( - far * near ) / ( far - near );

			} else {

				throw new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );

			}

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a; 	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b; 	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c; 	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		}

		makeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {

			const te = this.elements;
			const w = 1.0 / ( right - left );
			const h = 1.0 / ( top - bottom );
			const p = 1.0 / ( far - near );

			const x = ( right + left ) * w;
			const y = ( top + bottom ) * h;

			let z, zInv;

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				z = ( far + near ) * p;
				zInv = - 2 * p;

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				z = near * p;
				zInv = - 1 * p;

			} else {

				throw new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );

			}

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;		te[ 8 ] = 0; 		te[ 12 ] = - x;
			te[ 1 ] = 0; 		te[ 5 ] = 2 * h;	te[ 9 ] = 0; 		te[ 13 ] = - y;
			te[ 2 ] = 0; 		te[ 6 ] = 0;		te[ 10 ] = zInv;	te[ 14 ] = - z;
			te[ 3 ] = 0; 		te[ 7 ] = 0;		te[ 11 ] = 0;		te[ 15 ] = 1;

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	const _v1$5 = /*@__PURE__*/ new Vector3();
	const _m1$2 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	const _matrix = /*@__PURE__*/ new Matrix4();
	const _quaternion$3 = /*@__PURE__*/ new Quaternion();

	class Euler {

		constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

			this.isEuler = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		set( x, y, z, order = this._order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m, order = this._order, update = true ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

				default:

					console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

			}

			this._order = order;

			if ( update === true ) this._onChangeCallback();

			return this;

		}

		setFromQuaternion( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		}

		setFromVector3( v, order = this._order ) {

			return this.set( v.x, v.y, v.z, order );

		}

		reorder( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$3.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$3, newOrder );

		}

		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._order;

		}

	}

	Euler.DEFAULT_ORDER = 'XYZ';

	class Layers {

		constructor() {

			this.mask = 1 | 0;

		}

		set( channel ) {

			this.mask = ( 1 << channel | 0 ) >>> 0;

		}

		enable( channel ) {

			this.mask |= 1 << channel | 0;

		}

		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		toggle( channel ) {

			this.mask ^= 1 << channel | 0;

		}

		disable( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		}

		disableAll() {

			this.mask = 0;

		}

		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

		isEnabled( channel ) {

			return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

		}

	}

	let _object3DId = 0;

	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _q1 = /*@__PURE__*/ new Quaternion();
	const _m1$1 = /*@__PURE__*/ new Matrix4();
	const _target = /*@__PURE__*/ new Vector3();

	const _position$3 = /*@__PURE__*/ new Vector3();
	const _scale$2 = /*@__PURE__*/ new Vector3();
	const _quaternion$2 = /*@__PURE__*/ new Quaternion();

	const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
	const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

	const _addedEvent = { type: 'added' };
	const _removedEvent = { type: 'removed' };

	class Object3D extends EventDispatcher {

		constructor() {

			super();

			this.isObject3D = true;

			Object.defineProperty( this, 'id', { value: _object3DId ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DEFAULT_UP.clone();

			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation._onChange( onRotationChange );
			quaternion._onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
			this.matrixWorldNeedsUpdate = false;

			this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.animations = [];

			this.userData = {};

		}

		onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		applyMatrix4( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		}

		applyQuaternion( q ) {

			this.quaternion.premultiply( q );

			return this;

		}

		setRotationFromAxisAngle( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		}

		setRotationFromEuler( euler ) {

			this.quaternion.setFromEuler( euler, true );

		}

		setRotationFromMatrix( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		}

		setRotationFromQuaternion( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		}

		rotateOnAxis( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		}

		rotateOnWorldAxis( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		}

		rotateX( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		}

		rotateY( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		}

		rotateZ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		}

		translateOnAxis( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$4.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$4.multiplyScalar( distance ) );

			return this;

		}

		translateX( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		}

		translateY( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		}

		translateZ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		}

		localToWorld( vector ) {

			this.updateWorldMatrix( true, false );

			return vector.applyMatrix4( this.matrixWorld );

		}

		worldToLocal( vector ) {

			this.updateWorldMatrix( true, false );

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		}

		lookAt( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position$3.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position$3, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position$3, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		}

		add( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		}

		remove( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		}

		removeFromParent() {

			const parent = this.parent;

			if ( parent !== null ) {

				parent.remove( this );

			}

			return this;

		}

		clear() {

			for ( let i = 0; i < this.children.length; i ++ ) {

				const object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		}

		attach( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			this.add( object );

			object.updateWorldMatrix( false, true );

			return this;

		}

		getObjectById( id ) {

			return this.getObjectByProperty( 'id', id );

		}

		getObjectByName( name ) {

			return this.getObjectByProperty( 'name', name );

		}

		getObjectByProperty( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		}

		getObjectsByProperty( name, value ) {

			let result = [];

			if ( this[ name ] === value ) result.push( this );

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const childResult = this.children[ i ].getObjectsByProperty( name, value );

				if ( childResult.length > 0 ) {

					result = result.concat( childResult );

				}

			}

			return result;

		}

		getWorldPosition( target ) {

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		}

		getWorldQuaternion( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$3, target, _scale$2 );

			return target;

		}

		getWorldScale( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$3, _quaternion$2, target );

			return target;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		}

		raycast( /* raycaster, intersects */ ) {}

		traverse( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		}

		traverseVisible( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		}

		traverseAncestors( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		}

		updateMatrix() {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		}

		updateMatrixWorld( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				if ( child.matrixWorldAutoUpdate === true || force === true ) {

					child.updateMatrixWorld( force );

				}

			}

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					const child = children[ i ];

					if ( child.matrixWorldAutoUpdate === true ) {

						child.updateWorldMatrix( false, true );

					}

				}

			}

		}

		toJSON( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				};

				output.metadata = {
					version: 4.6,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			object.up = this.up.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isScene ) {

				if ( this.background ) {

					if ( this.background.isColor ) {

						object.background = this.background.toJSON();

					} else if ( this.background.isTexture ) {

						object.background = this.background.toJSON( meta ).uuid;

					}

				}

				if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

					object.environment = this.environment.toJSON( meta ).uuid;

				}

			} else if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );
				const nodes = extractFromCache( meta.nodes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;
				if ( nodes.length > 0 ) output.nodes = nodes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		}

		clone( recursive ) {

			return new this.constructor().copy( this, recursive );

		}

		copy( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.animations = source.animations;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	}

	Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
	Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _v2$2 = /*@__PURE__*/ new Vector3();
	const _v3$1 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	let warnedGetUV = false;

	class Triangle {

		constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

			this.a = a;
			this.b = b;
			this.c = c;

		}

		static getNormal( a, b, c, target ) {

			target.subVectors( c, b );
			_v0$1.subVectors( a, b );
			target.cross( _v0$1 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord( point, a, b, c, target ) {

			_v0$1.subVectors( c, a );
			_v1$3.subVectors( b, a );
			_v2$2.subVectors( point, a );

			const dot00 = _v0$1.dot( _v0$1 );
			const dot01 = _v0$1.dot( _v1$3 );
			const dot02 = _v0$1.dot( _v2$2 );
			const dot11 = _v1$3.dot( _v1$3 );
			const dot12 = _v1$3.dot( _v2$2 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		static containsPoint( point, a, b, c ) {

			this.getBarycoord( point, a, b, c, _v3$1 );

			return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

		}

		static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) { // @deprecated, r151

			if ( warnedGetUV === false ) {

				console.warn( 'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().' );

				warnedGetUV = true;

			}

			return this.getInterpolation( point, p1, p2, p3, uv1, uv2, uv3, target );

		}

		static getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3$1 );

			target.setScalar( 0 );
			target.addScaledVector( v1, _v3$1.x );
			target.addScaledVector( v2, _v3$1.y );
			target.addScaledVector( v3, _v3$1.z );

			return target;

		}

		static isFrontFacing( a, b, c, direction ) {

			_v0$1.subVectors( c, b );
			_v1$3.subVectors( a, b );

			// strictly front facing
			return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

		}

		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

			this.a.fromBufferAttribute( attribute, i0 );
			this.b.fromBufferAttribute( attribute, i1 );
			this.c.fromBufferAttribute( attribute, i2 );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		getArea() {

			_v0$1.subVectors( this.c, this.b );
			_v1$3.subVectors( this.a, this.b );

			return _v0$1.cross( _v1$3 ).length() * 0.5;

		}

		getMidpoint( target ) {

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		getPlane( target ) {

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		getUV( point, uv1, uv2, uv3, target ) { // @deprecated, r151

			if ( warnedGetUV === false ) {

				console.warn( 'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().' );

				warnedGetUV = true;

			}

			return Triangle.getInterpolation( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		}

		getInterpolation( point, v1, v2, v3, target ) {

			return Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );

		}

		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		closestPointToPoint( p, target ) {

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	let materialId = 0;

	class Material extends EventDispatcher {

		constructor() {

			super();

			this.isMaterial = true;

			Object.defineProperty( this, 'id', { value: materialId ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'Material';

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;

			this.opacity = 1;
			this.transparent = false;
			this.alphaHash = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.shadowSide = null;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.dithering = false;

			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;
			this.forceSinglePass = false;

			this.visible = true;

			this.toneMapped = true;

			this.userData = {};

			this.version = 0;

			this._alphaTest = 0;

		}

		get alphaTest() {

			return this._alphaTest;

		}

		set alphaTest( value ) {

			if ( this._alphaTest > 0 !== value > 0 ) {

				this.version ++;

			}

			this._alphaTest = value;

		}

		onBuild( /* shaderobject, renderer */ ) {}

		onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

		onBeforeCompile( /* shaderobject, renderer */ ) {}

		customProgramCacheKey() {

			return this.onBeforeCompile.toString();

		}

		setValues( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( isRootObject ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.6,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen !== undefined ) data.sheen = this.sheen;
			if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
			if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
			if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
			if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
			if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

			if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

				data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

			}

			if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

				data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

			}

			if ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;
			if ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;

			if ( this.anisotropyMap && this.anisotropyMap.isTexture ) {

				data.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
			if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;

				if ( this.combine !== undefined ) data.combine = this.combine;

			}

			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
			if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
			if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.transmission !== undefined ) data.transmission = this.transmission;
			if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
			if ( this.thickness !== undefined ) data.thickness = this.thickness;
			if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
			if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
			if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.alphaHash === true ) data.alphaHash = this.alphaHash;
			if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
			if ( this.forceSinglePass === true ) data.forceSinglePass = this.forceSinglePass;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.flatShading === true ) data.flatShading = this.flatShading;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( this.fog === false ) data.fog = false;

			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRootObject ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.alphaHash = source.alphaHash;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.forceSinglePass = source.forceSinglePass;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

	}

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	class Color {

		constructor( r, g, b ) {

			this.isColor = true;

			this.r = 1;
			this.g = 1;
			this.b = 1;

			return this.set( r, g, b );

		}

		set( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string

				const value = r;

				if ( value && value.isColor ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

			} else {

				this.setRGB( r, g, b );

			}

			return this;

		}

		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		setHex( hex, colorSpace = SRGBColorSpace ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

			this.r = r;
			this.g = g;
			this.b = b;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo( h, 1 );
			s = clamp( s, 0, 1 );
			l = clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setStyle( style, colorSpace = SRGBColorSpace ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			let m;

			if ( m = /^(\w+)\(([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)

							handleAlpha( color[ 4 ] );

							return this.setRGB(
								Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,
								Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,
								Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,
								colorSpace
							);

						}

						if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

							handleAlpha( color[ 4 ] );

							return this.setRGB(
								Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,
								Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,
								Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,
								colorSpace
							);

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)

							handleAlpha( color[ 4 ] );

							return this.setHSL(
								parseFloat( color[ 1 ] ) / 360,
								parseFloat( color[ 2 ] ) / 100,
								parseFloat( color[ 3 ] ) / 100,
								colorSpace
							);

						}

						break;

					default:

						console.warn( 'THREE.Color: Unknown color model ' + style );

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					return this.setRGB(
						parseInt( hex.charAt( 0 ), 16 ) / 15,
						parseInt( hex.charAt( 1 ), 16 ) / 15,
						parseInt( hex.charAt( 2 ), 16 ) / 15,
						colorSpace
					);

				} else if ( size === 6 ) {

					// #ff0000
					return this.setHex( parseInt( hex, 16 ), colorSpace );

				} else {

					console.warn( 'THREE.Color: Invalid hex color ' + style );

				}

			} else if ( style && style.length > 0 ) {

				return this.setColorName( style, colorSpace );

			}

			return this;

		}

		setColorName( style, colorSpace = SRGBColorSpace ) {

			// color keywords
			const hex = _colorKeywords[ style.toLowerCase() ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex, colorSpace );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

			return this;

		}

		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		getHex( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			return Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );

		}

		getHexString( colorSpace = SRGBColorSpace ) {

			return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

		}

		getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			const r = _color.r, g = _color.g, b = _color.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			target.r = _color.r;
			target.g = _color.g;
			target.b = _color.b;

			return target;

		}

		getStyle( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );

			const r = _color.r, g = _color.g, b = _color.b;

			if ( colorSpace !== SRGBColorSpace ) {

				// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
				return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;

			}

			return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;

		}

		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		}

		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		lerpColors( color1, color2, alpha ) {

			this.r = color1.r + ( color2.r - color1.r ) * alpha;
			this.g = color1.g + ( color2.g - color1.g ) * alpha;
			this.b = color1.b + ( color2.b - color1.b ) * alpha;

			return this;

		}

		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = lerp( _hslA.h, _hslB.h, alpha );
			const s = lerp( _hslA.s, _hslB.s, alpha );
			const l = lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		setFromVector3( v ) {

			this.r = v.x;
			this.g = v.y;
			this.b = v.z;

			return this;

		}

		applyMatrix3( m ) {

			const r = this.r, g = this.g, b = this.b;
			const e = m.elements;

			this.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;
			this.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;
			this.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;

			return this;

		}

		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			return this;

		}

		toJSON() {

			return this.getHex();

		}

		*[ Symbol.iterator ]() {

			yield this.r;
			yield this.g;
			yield this.b;

		}

	}

	const _color = /*@__PURE__*/ new Color();

	Color.NAMES = _colorKeywords;

	class MeshBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshBasicMaterial = true;

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf

	const _tables = /*@__PURE__*/ _generateTables();

	function _generateTables() {

		// float32 to float16 helpers

		const buffer = new ArrayBuffer( 4 );
		const floatView = new Float32Array( buffer );
		const uint32View = new Uint32Array( buffer );

		const baseTable = new Uint32Array( 512 );
		const shiftTable = new Uint32Array( 512 );

		for ( let i = 0; i < 256; ++ i ) {

			const e = i - 127;

			// very small number (0, -0)

			if ( e < - 27 ) {

				baseTable[ i ] = 0x0000;
				baseTable[ i | 0x100 ] = 0x8000;
				shiftTable[ i ] = 24;
				shiftTable[ i | 0x100 ] = 24;

				// small number (denorm)

			} else if ( e < - 14 ) {

				baseTable[ i ] = 0x0400 >> ( - e - 14 );
				baseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;
				shiftTable[ i ] = - e - 1;
				shiftTable[ i | 0x100 ] = - e - 1;

				// normal number

			} else if ( e <= 15 ) {

				baseTable[ i ] = ( e + 15 ) << 10;
				baseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;
				shiftTable[ i ] = 13;
				shiftTable[ i | 0x100 ] = 13;

				// large number (Infinity, -Infinity)

			} else if ( e < 128 ) {

				baseTable[ i ] = 0x7c00;
				baseTable[ i | 0x100 ] = 0xfc00;
				shiftTable[ i ] = 24;
				shiftTable[ i | 0x100 ] = 24;

				// stay (NaN, Infinity, -Infinity)

			} else {

				baseTable[ i ] = 0x7c00;
				baseTable[ i | 0x100 ] = 0xfc00;
				shiftTable[ i ] = 13;
				shiftTable[ i | 0x100 ] = 13;

			}

		}

		// float16 to float32 helpers

		const mantissaTable = new Uint32Array( 2048 );
		const exponentTable = new Uint32Array( 64 );
		const offsetTable = new Uint32Array( 64 );

		for ( let i = 1; i < 1024; ++ i ) {

			let m = i << 13; // zero pad mantissa bits
			let e = 0; // zero exponent

			// normalized
			while ( ( m & 0x00800000 ) === 0 ) {

				m <<= 1;
				e -= 0x00800000; // decrement exponent

			}

			m &= ~ 0x00800000; // clear leading 1 bit
			e += 0x38800000; // adjust bias

			mantissaTable[ i ] = m | e;

		}

		for ( let i = 1024; i < 2048; ++ i ) {

			mantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );

		}

		for ( let i = 1; i < 31; ++ i ) {

			exponentTable[ i ] = i << 23;

		}

		exponentTable[ 31 ] = 0x47800000;
		exponentTable[ 32 ] = 0x80000000;

		for ( let i = 33; i < 63; ++ i ) {

			exponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );

		}

		exponentTable[ 63 ] = 0xc7800000;

		for ( let i = 1; i < 64; ++ i ) {

			if ( i !== 32 ) {

				offsetTable[ i ] = 1024;

			}

		}

		return {
			floatView: floatView,
			uint32View: uint32View,
			baseTable: baseTable,
			shiftTable: shiftTable,
			mantissaTable: mantissaTable,
			exponentTable: exponentTable,
			offsetTable: offsetTable
		};

	}

	// float32 to float16

	function toHalfFloat( val ) {

		if ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );

		val = clamp( val, - 65504, 65504 );

		_tables.floatView[ 0 ] = val;
		const f = _tables.uint32View[ 0 ];
		const e = ( f >> 23 ) & 0x1ff;
		return _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );

	}

	// float16 to float32

	function fromHalfFloat( val ) {

		const m = val >> 10;
		_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];
		return _tables.floatView[ 0 ];

	}

	const DataUtils = {
		toHalfFloat: toHalfFloat,
		fromHalfFloat: fromHalfFloat,
	};

	const _vector$8 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector2();

	class BufferAttribute {

		constructor( array, itemSize, normalized = false ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.isBufferAttribute = true;

			this.name = '';

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };
			this.gpuType = FloatType;

			this.version = 0;

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;
			this.gpuType = source.gpuType;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		copyArray( array ) {

			this.array.set( array );

			return this;

		}

		applyMatrix3( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2$1.fromBufferAttribute( this, i );
					_vector2$1.applyMatrix3( m );

					this.setXY( i, _vector2$1.x, _vector2$1.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$8.fromBufferAttribute( this, i );
					_vector$8.applyMatrix3( m );

					this.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

				}

			}

			return this;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$8.fromBufferAttribute( this, i );

				_vector$8.applyMatrix4( m );

				this.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$8.fromBufferAttribute( this, i );

				_vector$8.applyNormalMatrix( m );

				this.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$8.fromBufferAttribute( this, i );

				_vector$8.transformDirection( m );

				this.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

			}

			return this;

		}

		set( value, offset = 0 ) {

			// Matching BufferAttribute constructor, do not normalize the array.
			this.array.set( value, offset );

			return this;

		}

		getX( index ) {

			let x = this.array[ index * this.itemSize ];

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		setX( index, x ) {

			if ( this.normalized ) x = normalize( x, this.array );

			this.array[ index * this.itemSize ] = x;

			return this;

		}

		getY( index ) {

			let y = this.array[ index * this.itemSize + 1 ];

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		setY( index, y ) {

			if ( this.normalized ) y = normalize( y, this.array );

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		}

		getZ( index ) {

			let z = this.array[ index * this.itemSize + 2 ];

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		setZ( index, z ) {

			if ( this.normalized ) z = normalize( z, this.array );

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		}

		getW( index ) {

			let w = this.array[ index * this.itemSize + 3 ];

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		setW( index, w ) {

			if ( this.normalized ) w = normalize( w, this.array );

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		}

		setXY( index, x, y ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );
				w = normalize( w, this.array );

			}

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		clone() {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

		toJSON() {

			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.from( this.array ),
				normalized: this.normalized
			};

			if ( this.name !== '' ) data.name = this.name;
			if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
			if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

			return data;

		}

	}

	//

	class Int8BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Int8Array( array ), itemSize, normalized );

		}

	}

	class Uint8BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint8Array( array ), itemSize, normalized );

		}

	}

	class Uint8ClampedBufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint8ClampedArray( array ), itemSize, normalized );

		}

	}

	class Int16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Int16Array( array ), itemSize, normalized );

		}

	}

	class Uint16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

		}

	}

	class Int32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Int32Array( array ), itemSize, normalized );

		}

	}

	class Uint32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint32Array( array ), itemSize, normalized );

		}

	}

	class Float16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

			this.isFloat16BufferAttribute = true;

		}

		getX( index ) {

			let x = fromHalfFloat( this.array[ index * this.itemSize ] );

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		setX( index, x ) {

			if ( this.normalized ) x = normalize( x, this.array );

			this.array[ index * this.itemSize ] = toHalfFloat( x );

			return this;

		}

		getY( index ) {

			let y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		setY( index, y ) {

			if ( this.normalized ) y = normalize( y, this.array );

			this.array[ index * this.itemSize + 1 ] = toHalfFloat( y );

			return this;

		}

		getZ( index ) {

			let z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		setZ( index, z ) {

			if ( this.normalized ) z = normalize( z, this.array );

			this.array[ index * this.itemSize + 2 ] = toHalfFloat( z );

			return this;

		}

		getW( index ) {

			let w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		setW( index, w ) {

			if ( this.normalized ) w = normalize( w, this.array );

			this.array[ index * this.itemSize + 3 ] = toHalfFloat( w );

			return this;

		}

		setXY( index, x, y ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );

			}

			this.array[ index + 0 ] = toHalfFloat( x );
			this.array[ index + 1 ] = toHalfFloat( y );

			return this;

		}

		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );

			}

			this.array[ index + 0 ] = toHalfFloat( x );
			this.array[ index + 1 ] = toHalfFloat( y );
			this.array[ index + 2 ] = toHalfFloat( z );

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );
				w = normalize( w, this.array );

			}

			this.array[ index + 0 ] = toHalfFloat( x );
			this.array[ index + 1 ] = toHalfFloat( y );
			this.array[ index + 2 ] = toHalfFloat( z );
			this.array[ index + 3 ] = toHalfFloat( w );

			return this;

		}

	}


	class Float32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Float32Array( array ), itemSize, normalized );

		}

	}

	class Float64BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Float64Array( array ), itemSize, normalized );

		}

	}

	let _id$1 = 0;

	const _m1 = /*@__PURE__*/ new Matrix4();
	const _obj = /*@__PURE__*/ new Object3D();
	const _offset = /*@__PURE__*/ new Vector3();
	const _box$1 = /*@__PURE__*/ new Box3();
	const _boxMorphTargets = /*@__PURE__*/ new Box3();
	const _vector$7 = /*@__PURE__*/ new Vector3();

	class BufferGeometry extends EventDispatcher {

		constructor() {

			super();

			this.isBufferGeometry = true;

			Object.defineProperty( this, 'id', { value: _id$1 ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};
			this.morphTargetsRelative = false;

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

			this.userData = {};

		}

		getIndex() {

			return this.index;

		}

		setIndex( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		}

		getAttribute( name ) {

			return this.attributes[ name ];

		}

		setAttribute( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		}

		deleteAttribute( name ) {

			delete this.attributes[ name ];

			return this;

		}

		hasAttribute( name ) {

			return this.attributes[ name ] !== undefined;

		}

		addGroup( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		}

		clearGroups() {

			this.groups = [];

		}

		setDrawRange( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		}

		applyMatrix4( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		}

		applyQuaternion( q ) {

			_m1.makeRotationFromQuaternion( q );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateX( angle ) {

			// rotate geometry around world x-axis

			_m1.makeRotationX( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateY( angle ) {

			// rotate geometry around world y-axis

			_m1.makeRotationY( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateZ( angle ) {

			// rotate geometry around world z-axis

			_m1.makeRotationZ( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		translate( x, y, z ) {

			// translate geometry

			_m1.makeTranslation( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		scale( x, y, z ) {

			// scale geometry

			_m1.makeScale( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		lookAt( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		}

		center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		}

		setFromPoints( points ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		}

		computeBoundingBox() {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box$1.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$7.addVectors( this.boundingBox.min, _box$1.min );
							this.boundingBox.expandByPoint( _vector$7 );

							_vector$7.addVectors( this.boundingBox.max, _box$1.max );
							this.boundingBox.expandByPoint( _vector$7 );

						} else {

							this.boundingBox.expandByPoint( _box$1.min );
							this.boundingBox.expandByPoint( _box$1.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		}

		computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$7.addVectors( _box$1.min, _boxMorphTargets.min );
							_box$1.expandByPoint( _vector$7 );

							_vector$7.addVectors( _box$1.max, _boxMorphTargets.max );
							_box$1.expandByPoint( _vector$7 );

						} else {

							_box$1.expandByPoint( _boxMorphTargets.min );
							_box$1.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$1.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$7.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$7 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$7.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$7.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$7 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		}

		computeTangents() {

			const index = this.index;
			const attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {

				console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
				return;

			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;

			const nVertices = positions.length / 3;

			if ( this.hasAttribute( 'tangent' ) === false ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			const tangents = this.getAttribute( 'tangent' ).array;

			const tan1 = [], tan2 = [];

			for ( let i = 0; i < nVertices; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) return;

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			let groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: indices.length
				} ];

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						indices[ j + 0 ],
						indices[ j + 1 ],
						indices[ j + 2 ]
					);

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3();
			const n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				const t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				const test = tmp2.dot( tan2[ v ] );
				const w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4 ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleVertex( indices[ j + 0 ] );
					handleVertex( indices[ j + 1 ] );
					handleVertex( indices[ j + 2 ] );

				}

			}

		}

		computeVertexNormals() {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		}

		normalizeNormals() {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$7.fromBufferAttribute( normals, i );

				_vector$7.normalize();

				normals.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );

			}

		}

		toNonIndexed() {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					if ( attribute.isInterleavedBufferAttribute ) {

						index = indices[ i ] * attribute.data.stride + attribute.offset;

					} else {

						index = indices[ i ] * itemSize;

					}

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.6,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				data.data.attributes[ key ] = attribute.toJSON( data.data );

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					array.push( attribute.toJSON( data.data ) );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	const _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();
	const _ray$3 = /*@__PURE__*/ new Ray();
	const _sphere$5 = /*@__PURE__*/ new Sphere();
	const _sphereHitAt = /*@__PURE__*/ new Vector3();

	const _vA$1 = /*@__PURE__*/ new Vector3();
	const _vB$1 = /*@__PURE__*/ new Vector3();
	const _vC$1 = /*@__PURE__*/ new Vector3();

	const _tempA = /*@__PURE__*/ new Vector3();
	const _morphA = /*@__PURE__*/ new Vector3();

	const _uvA$1 = /*@__PURE__*/ new Vector2();
	const _uvB$1 = /*@__PURE__*/ new Vector2();
	const _uvC$1 = /*@__PURE__*/ new Vector2();

	const _normalA = /*@__PURE__*/ new Vector3();
	const _normalB = /*@__PURE__*/ new Vector3();
	const _normalC = /*@__PURE__*/ new Vector3();

	const _intersectionPoint = /*@__PURE__*/ new Vector3();
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

	class Mesh extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

			super();

			this.isMesh = true;

			this.type = 'Mesh';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

		getVertexPosition( index, target ) {

			const geometry = this.geometry;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;

			target.fromBufferAttribute( position, index );

			const morphInfluences = this.morphTargetInfluences;

			if ( morphPosition && morphInfluences ) {

				_morphA.set( 0, 0, 0 );

				for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

					const influence = morphInfluences[ i ];
					const morphAttribute = morphPosition[ i ];

					if ( influence === 0 ) continue;

					_tempA.fromBufferAttribute( morphAttribute, index );

					if ( morphTargetsRelative ) {

						_morphA.addScaledVector( _tempA, influence );

					} else {

						_morphA.addScaledVector( _tempA.sub( target ), influence );

					}

				}

				target.add( _morphA );

			}

			return target;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// test with bounding sphere in world space

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$5.copy( geometry.boundingSphere );
			_sphere$5.applyMatrix4( matrixWorld );

			// check distance from ray origin to bounding sphere

			_ray$3.copy( raycaster.ray ).recast( raycaster.near );

			if ( _sphere$5.containsPoint( _ray$3.origin ) === false ) {

				if ( _ray$3.intersectSphere( _sphere$5, _sphereHitAt ) === null ) return;

				if ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;

			}

			// convert ray to local space of mesh

			_inverseMatrix$3.copy( matrixWorld ).invert();
			_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );

			// test with bounding box in local space

			if ( geometry.boundingBox !== null ) {

				if ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			// test for intersections with geometry

			this._computeIntersections( raycaster, intersects, _ray$3 );

		}

		_computeIntersections( raycaster, intersects, rayLocalSpace ) {

			let intersection;

			const geometry = this.geometry;
			const material = this.material;

			const index = geometry.index;
			const position = geometry.attributes.position;
			const uv = geometry.attributes.uv;
			const uv1 = geometry.attributes.uv1;
			const normal = geometry.attributes.normal;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		}

	}

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {

		object.getVertexPosition( a, _vA$1 );
		object.getVertexPosition( b, _vB$1 );
		object.getVertexPosition( c, _vC$1 );

		const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA$1.fromBufferAttribute( uv, a );
				_uvB$1.fromBufferAttribute( uv, b );
				_uvC$1.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

			}

			if ( uv1 ) {

				_uvA$1.fromBufferAttribute( uv1, a );
				_uvB$1.fromBufferAttribute( uv1, b );
				_uvC$1.fromBufferAttribute( uv1, c );

				intersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );
				intersection.uv2 = intersection.uv1; // @deprecated, r152

			}

			if ( normal ) {

				_normalA.fromBufferAttribute( normal, a );
				_normalB.fromBufferAttribute( normal, b );
				_normalC.fromBufferAttribute( normal, c );

				intersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );

				if ( intersection.normal.dot( ray.direction ) > 0 ) {

					intersection.normal.multiplyScalar( - 1 );

				}

			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	class BoxGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

		}

	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					if ( property.isRenderTargetTexture ) {

						console.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );
						dst[ u ][ p ] = null;

					} else {

						dst[ u ][ p ] = property.clone();

					}

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	function cloneUniformsGroups( src ) {

		const dst = [];

		for ( let u = 0; u < src.length; u ++ ) {

			dst.push( src[ u ].clone() );

		}

		return dst;

	}

	function getUnlitUniformColorSpace( renderer ) {

		if ( renderer.getRenderTarget() === null ) {

			// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
			return renderer.outputColorSpace;

		}

		return LinearSRGBColorSpace;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	class ShaderMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isShaderMaterial = true;

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};
			this.uniformsGroups = [];

			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.forceSinglePass = true;

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv1': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;

			this.glslVersion = null;

			if ( parameters !== undefined ) {

				this.setValues( parameters );

			}

		}

		copy( source ) {

			super.copy( source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = cloneUniforms( source.uniforms );
			this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

			this.defines = Object.assign( {}, source.defines );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.fog = source.fog;
			this.lights = source.lights;
			this.clipping = source.clipping;

			this.extensions = Object.assign( {}, source.extensions );

			this.glslVersion = source.glslVersion;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for ( const name in this.uniforms ) {

				const uniform = this.uniforms[ name ];
				const value = uniform.value;

				if ( value && value.isTexture ) {

					data.uniforms[ name ] = {
						type: 't',
						value: value.toJSON( meta ).uuid
					};

				} else if ( value && value.isColor ) {

					data.uniforms[ name ] = {
						type: 'c',
						value: value.getHex()
					};

				} else if ( value && value.isVector2 ) {

					data.uniforms[ name ] = {
						type: 'v2',
						value: value.toArray()
					};

				} else if ( value && value.isVector3 ) {

					data.uniforms[ name ] = {
						type: 'v3',
						value: value.toArray()
					};

				} else if ( value && value.isVector4 ) {

					data.uniforms[ name ] = {
						type: 'v4',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix3 ) {

					data.uniforms[ name ] = {
						type: 'm3',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix4 ) {

					data.uniforms[ name ] = {
						type: 'm4',
						value: value.toArray()
					};

				} else {

					data.uniforms[ name ] = {
						value: value
					};

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			data.lights = this.lights;
			data.clipping = this.clipping;

			const extensions = {};

			for ( const key in this.extensions ) {

				if ( this.extensions[ key ] === true ) extensions[ key ] = true;

			}

			if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

			return data;

		}

	}

	class Camera extends Object3D {

		constructor() {

			super();

			this.isCamera = true;

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();

			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();

			this.coordinateSystem = WebGLCoordinateSystem;

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			this.coordinateSystem = source.coordinateSystem;

			return this;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			super.updateWorldMatrix( updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class PerspectiveCamera extends Camera {

		constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

			super();

			this.isPerspectiveCamera = true;

			this.type = 'PerspectiveCamera';

			this.fov = fov;
			this.zoom = 1;

			this.near = near;
			this.far = far;
			this.focus = 10;

			this.aspect = aspect;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		}

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		}

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength() {

			const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		}

		getEffectiveFOV() {

			return RAD2DEG * 2 * Math.atan(
				Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

		}

		getFilmWidth() {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		}

		getFilmHeight() {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const near = this.near;
			let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = - 0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	}

	const fov = - 90; // negative fov is not an error
	const aspect = 1;

	class CubeCamera extends Object3D {

		constructor( near, far, renderTarget ) {

			super();

			this.type = 'CubeCamera';

			this.renderTarget = renderTarget;
			this.coordinateSystem = null;

			const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			this.add( cameraPX );

			const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			this.add( cameraNX );

			const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			this.add( cameraPY );

			const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			this.add( cameraNY );

			const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			this.add( cameraPZ );

			const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			this.add( cameraNZ );

		}

		updateCoordinateSystem() {

			const coordinateSystem = this.coordinateSystem;

			const cameras = this.children.concat();

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;

			for ( const camera of cameras ) this.remove( camera );

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				cameraPX.up.set( 0, 1, 0 );
				cameraPX.lookAt( 1, 0, 0 );

				cameraNX.up.set( 0, 1, 0 );
				cameraNX.lookAt( - 1, 0, 0 );

				cameraPY.up.set( 0, 0, - 1 );
				cameraPY.lookAt( 0, 1, 0 );

				cameraNY.up.set( 0, 0, 1 );
				cameraNY.lookAt( 0, - 1, 0 );

				cameraPZ.up.set( 0, 1, 0 );
				cameraPZ.lookAt( 0, 0, 1 );

				cameraNZ.up.set( 0, 1, 0 );
				cameraNZ.lookAt( 0, 0, - 1 );

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				cameraPX.up.set( 0, - 1, 0 );
				cameraPX.lookAt( - 1, 0, 0 );

				cameraNX.up.set( 0, - 1, 0 );
				cameraNX.lookAt( 1, 0, 0 );

				cameraPY.up.set( 0, 0, 1 );
				cameraPY.lookAt( 0, 1, 0 );

				cameraNY.up.set( 0, 0, - 1 );
				cameraNY.lookAt( 0, - 1, 0 );

				cameraPZ.up.set( 0, - 1, 0 );
				cameraPZ.lookAt( 0, 0, 1 );

				cameraNZ.up.set( 0, - 1, 0 );
				cameraNZ.lookAt( 0, 0, - 1 );

			} else {

				throw new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );

			}

			for ( const camera of cameras ) {

				this.add( camera );

				camera.updateMatrixWorld();

			}

		}

		update( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const renderTarget = this.renderTarget;

			if ( this.coordinateSystem !== renderer.coordinateSystem ) {

				this.coordinateSystem = renderer.coordinateSystem;

				this.updateCoordinateSystem();

			}

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

			const currentRenderTarget = renderer.getRenderTarget();

			const currentToneMapping = renderer.toneMapping;
			const currentXrEnabled = renderer.xr.enabled;

			renderer.toneMapping = NoToneMapping;
			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.toneMapping = currentToneMapping;
			renderer.xr.enabled = currentXrEnabled;

			renderTarget.texture.needsPMREMUpdate = true;

		}

	}

	class CubeTexture extends Texture {

		constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

			this.isCubeTexture = true;

			this.flipY = false;

		}

		get images() {

			return this.image;

		}

		set images( value ) {

			this.image = value;

		}

	}

	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		constructor( size = 1, options = {} ) {

			super( size, size, options );

			this.isWebGLCubeRenderTarget = true;

			const image = { width: size, height: size, depth: 1 };
			const images = [ image, image, image, image, image, image ];

			if ( options.encoding !== undefined ) {

				// @deprecated, r152
				warnOnce( 'THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.' );
				options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;

			}

			this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );

			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture.isRenderTargetTexture = true;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		}

		fromEquirectangularTexture( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.colorSpace = texture.colorSpace;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};

			const geometry = new BoxGeometry( 5, 5, 5 );

			const material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			const mesh = new Mesh( geometry, material );

			const currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

		clear( renderer, color, depth, stencil ) {

			const currentRenderTarget = renderer.getRenderTarget();

			for ( let i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		}

	}

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	class Plane {

		constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

			this.isPlane = true;

			// normal is assumed to be normalized

			this.normal = normal;
			this.constant = constant;

		}

		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		negate() {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		}

		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		projectPoint( point, target ) {

			return target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );

		}

		intersectLine( line, target ) {

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return null;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return null;

			}

			return target.copy( line.start ).addScaledVector( direction, t );

		}

		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		coplanarPoint( target ) {

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _sphere$4 = /*@__PURE__*/ new Sphere();
	const _vector$6 = /*@__PURE__*/ new Vector3();

	class Frustum {

		constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

			this.planes = [ p0, p1, p2, p3, p4, p5 ];

		}

		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		setFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();

			if ( coordinateSystem === WebGLCoordinateSystem ) {

				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			} else if ( coordinateSystem === WebGPUCoordinateSystem ) {

				planes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();

			} else {

				throw new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );

			}

			return this;

		}

		intersectsObject( object ) {

			if ( object.boundingSphere !== undefined ) {

				if ( object.boundingSphere === null ) object.computeBoundingSphere();

				_sphere$4.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );

			} else {

				const geometry = object.geometry;

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			}

			return this.intersectsSphere( _sphere$4 );

		}

		intersectsSprite( sprite ) {

			_sphere$4.center.set( 0, 0, 0 );
			_sphere$4.radius = 0.7071067811865476;
			_sphere$4.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$4 );

		}

		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = gl.HALF_FLOAT;

					} else {

						throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = gl.UNSIGNED_SHORT;

				}

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			} else if ( array instanceof Uint8ClampedArray ) {

				type = gl.UNSIGNED_BYTE;

			} else {

				throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

			attribute.onUploadCallback();

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	class PlaneGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

		}

	}

	var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";

	var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";

	var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var colorspace_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";

	var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";

	var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

	var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";

	var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";

	var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";

	const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

	const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

	const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

	const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";

	const ShaderChunk = {
		alphahash_fragment: alphahash_fragment,
		alphahash_pars_fragment: alphahash_pars_fragment,
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		iridescence_fragment: iridescence_fragment,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		colorspace_fragment: colorspace_fragment,
		colorspace_pars_fragment: colorspace_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_fragment: lights_lambert_fragment,
		lights_lambert_pars_fragment: lights_lambert_pars_fragment,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphcolor_vertex: morphcolor_vertex,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		iridescence_pars_fragment: iridescence_pars_fragment,
		opaque_fragment: opaque_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		worldpos_vertex: worldpos_vertex,

		background_vert: vertex$h,
		background_frag: fragment$h,
		backgroundCube_vert: vertex$g,
		backgroundCube_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },

			map: { value: null },
			mapTransform: { value: /*@__PURE__*/ new Matrix3() },

			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },

			alphaTest: { value: 0 }

		},

		specularmap: {

			specularMap: { value: null },
			specularMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 }, // basic, lambert, phong
			ior: { value: 1.5 }, // physical
			refractionRatio: { value: 0.98 }, // basic, lambert, phong

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 },
			aoMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 },
			lightMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		emissivemap: {

			emissiveMap: { value: null },
			emissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		metalnessmap: {

			metalnessMap: { value: null },
			metalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		roughnessmap: {

			roughnessMap: { value: null },
			roughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotLightMap: { value: [] },
			spotShadowMap: { value: [] },
			spotLightMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaTest: { value: 0 },
			uvTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		sprite: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			mapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaMap: { value: null },
			alphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			alphaTest: { value: 0 }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag

		},

		sprite: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: /*@__PURE__*/ new Matrix3() },
				t2D: { value: null },
				backgroundIntensity: { value: 1 }
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},

		backgroundCube: {

			uniforms: {
				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				backgroundBlurriness: { value: 0 },
				backgroundIntensity: { value: 1 }
			},

			vertexShader: ShaderChunk.backgroundCube_vert,
			fragmentShader: ShaderChunk.backgroundCube_frag

		},

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: /*@__PURE__*/ new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				clearcoatNormalMap: { value: null },
				clearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				iridescence: { value: 0 },
				iridescenceMap: { value: null },
				iridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				iridescenceIOR: { value: 1.3 },
				iridescenceThicknessMinimum: { value: 100 },
				iridescenceThicknessMaximum: { value: 400 },
				iridescenceThicknessMap: { value: null },
				iridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				sheen: { value: 0 },
				sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				sheenColorMap: { value: null },
				sheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				sheenRoughness: { value: 1 },
				sheenRoughnessMap: { value: null },
				sheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				thicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				attenuationDistance: { value: 0 },
				attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
				specularColorMap: { value: null },
				specularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				specularIntensity: { value: 1 },
				specularIntensityMap: { value: null },
				specularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },
				anisotropyVector: { value: /*@__PURE__*/ new Vector2() },
				anisotropyMap: { value: null },
				anisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	const _rgb = { r: 0, b: 0, g: 0 };

	function WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = alpha === true ? 0 : 1;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render( renderList, scene ) {

			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				const usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background
				background = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			const xr = renderer.xr;
			const environmentBlendMode = xr.getEnvironmentBlendMode();

			switch ( environmentBlendMode ) {

				case 'opaque':
					forceClear = true;
					break;

				case 'additive':
					state.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );
					forceClear = true;
					break;

				case 'alpha-blend':
					state.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );
					forceClear = true;
					break;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),
							vertexShader: ShaderLib.backgroundCube.vertexShader,
							fragmentShader: ShaderLib.backgroundCube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// add "envMap" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;
				boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
				boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				boxMesh.material.toneMapped = ( background.colorSpace === SRGBColorSpace ) ? false : true;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				boxMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// add "map" material property so the renderer can evaluate it like for built-in materials
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;
				planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
				planeMesh.material.toneMapped = ( background.colorSpace === SRGBColorSpace ) ? false : true;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				planeMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			color.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );

			state.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

		const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;
		let forceUpdate = false;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			if ( vaoAvailable ) {

				const state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( object, geometry, program, index );

				if ( updateBuffers ) saveCache( object, geometry, program, index );

			} else {

				const wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			if ( updateBuffers || forceUpdate ) {

				forceUpdate = false;

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) return gl.createVertexArray();

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( object, geometry, program, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					const cachedAttribute = cachedAttributes[ name ];
					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( cachedAttribute === undefined ) return true;

					if ( cachedAttribute.attribute !== geometryAttribute ) return true;

					if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

					attributesNum ++;

				}

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( object, geometry, program, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let attribute = attributes[ name ];

					if ( attribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

					}

					const data = {};
					data.attribute = attribute;

					if ( attribute && attribute.data ) {

						data.data = attribute.data;

					}

					cache[ name ] = data;

					attributesNum ++;

				}

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {

			if ( integer === true ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						// check for integer attributes (WebGL 2 only)

						const integer = ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType ) );

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data.isInstancedInterleavedBuffer ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									stride * bytesPerElement,
									( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,
									integer
								);

							}

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									size * bytesPerElement,
									( size / programAttribute.locationSize ) * i * bytesPerElement,
									integer
								);

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute.location, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute.location, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute.location, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute.location, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();
			forceUpdate = true;

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatibility

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl.constructor.name === 'WebGL2RenderingContext';

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		const maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

		return {

			isWebGL2: isWebGL2,

			drawBuffers: drawBuffers,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;

		};

		this.setGlobalState = function ( planes, camera ) {

			globalState = projectPlanes( planes, camera, 0 );

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class OrthographicCamera extends Camera {

		constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

			super();

			this.isOrthographicCamera = true;

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = near;
			this.far = far;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		}

		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	}

	const LOD_MIN = 4;

	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20;

	const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
	const _clearColor = /*@__PURE__*/ new Color();
	let _oldTarget = null;

	// Golden Ratio
	const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
	const INV_PHI = 1 / PHI;

	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/ new Vector3( 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
		/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
		/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
		/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	class PMREMGenerator {

		constructor( renderer ) {

			this._renderer = renderer;
			this._pingPongRenderTarget = null;

			this._lodMax = 0;
			this._cubeSize = 0;
			this._lodPlanes = [];
			this._sizeLods = [];
			this._sigmas = [];

			this._blurMaterial = null;
			this._cubemapMaterial = null;
			this._equirectMaterial = null;

			this._compileMaterial( this._blurMaterial );

		}

		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */
		fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

			_oldTarget = this._renderer.getRenderTarget();

			this._setSize( 256 );

			const cubeUVRenderTarget = this._allocateTargets();
			cubeUVRenderTarget.depthBuffer = true;

			this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

			if ( sigma > 0 ) {

				this._blur( cubeUVRenderTarget, 0, 0, sigma );

			}

			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromEquirectangular( equirectangular, renderTarget = null ) {

			return this._fromTexture( equirectangular, renderTarget );

		}

		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromCubemap( cubemap, renderTarget = null ) {

			return this._fromTexture( cubemap, renderTarget );

		}

		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader() {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();
				this._compileMaterial( this._cubemapMaterial );

			}

		}

		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader() {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();
				this._compileMaterial( this._equirectMaterial );

			}

		}

		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose() {

			this._dispose();

			if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
			if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

		}

		// private interface

		_setSize( cubeSize ) {

			this._lodMax = Math.floor( Math.log2( cubeSize ) );
			this._cubeSize = Math.pow( 2, this._lodMax );

		}

		_dispose() {

			if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

			if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

			for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

				this._lodPlanes[ i ].dispose();

			}

		}

		_cleanup( outputTarget ) {

			this._renderer.setRenderTarget( _oldTarget );
			outputTarget.scissorTest = false;
			_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

		}

		_fromTexture( texture, renderTarget ) {

			if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

				this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

			} else { // Equirectangular

				this._setSize( texture.image.width / 4 );

			}

			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();
			this._textureToCubeUV( texture, cubeUVRenderTarget );
			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_allocateTargets() {

			const width = 3 * Math.max( this._cubeSize, 16 * 7 );
			const height = 4 * this._cubeSize;

			const params = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: false,
				type: HalfFloatType,
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget( width, height, params );

			if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

				if ( this._pingPongRenderTarget !== null ) {

					this._dispose();

				}

				this._pingPongRenderTarget = _createRenderTarget( width, height, params );

				const { _lodMax } = this;
				( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

				this._blurMaterial = _getBlurShader( _lodMax, width, height );

			}

			return cubeUVRenderTarget;

		}

		_compileMaterial( material ) {

			const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
			this._renderer.compile( tmpMesh, _flatCamera );

		}

		_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
			const upSign = [ 1, - 1, 1, 1, 1, 1 ];
			const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
			const renderer = this._renderer;

			const originalAutoClear = renderer.autoClear;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor( _clearColor );

			renderer.toneMapping = NoToneMapping;
			renderer.autoClear = false;

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false,
			} );

			const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

			let useSolidColor = false;
			const background = scene.background;

			if ( background ) {

				if ( background.isColor ) {

					backgroundMaterial.color.copy( background );
					scene.background = null;
					useSolidColor = true;

				}

			} else {

				backgroundMaterial.color.copy( _clearColor );
				useSolidColor = true;

			}

			for ( let i = 0; i < 6; i ++ ) {

				const col = i % 3;

				if ( col === 0 ) {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

				} else if ( col === 1 ) {

					cubeCamera.up.set( 0, 0, upSign[ i ] );
					cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

				} else {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

				}

				const size = this._cubeSize;

				_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

				renderer.setRenderTarget( cubeUVRenderTarget );

				if ( useSolidColor ) {

					renderer.render( backgroundBox, cubeCamera );

				}

				renderer.render( scene, cubeCamera );

			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();

			renderer.toneMapping = toneMapping;
			renderer.autoClear = originalAutoClear;
			scene.background = background;

		}

		_textureToCubeUV( texture, cubeUVRenderTarget ) {

			const renderer = this._renderer;

			const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

			if ( isCubeTexture ) {

				if ( this._cubemapMaterial === null ) {

					this._cubemapMaterial = _getCubemapMaterial();

				}

				this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

			} else {

				if ( this._equirectMaterial === null ) {

					this._equirectMaterial = _getEquirectMaterial();

				}

			}

			const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
			const mesh = new Mesh( this._lodPlanes[ 0 ], material );

			const uniforms = material.uniforms;

			uniforms[ 'envMap' ].value = texture;

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( mesh, _flatCamera );

		}

		_applyPMREM( cubeUVRenderTarget ) {

			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

				const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

				const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

				this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

			}

			renderer.autoClear = autoClear;

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis );

			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis );

		}

		_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

				console.error(
					'blur direction must be either latitudinal or longitudinal!' );

			}

			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3;

			const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
			const blurUniforms = blurMaterial.uniforms;

			const pixels = this._sizeLods[ lodIn ] - 1;
			const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

			if ( samples > MAX_SAMPLES ) {

				console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

			}

			const weights = [];
			let sum = 0;

			for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

				const x = i / sigmaPixels;
				const weight = Math.exp( - x * x / 2 );
				weights.push( weight );

				if ( i === 0 ) {

					sum += weight;

				} else if ( i < samples ) {

					sum += 2 * weight;

				}

			}

			for ( let i = 0; i < weights.length; i ++ ) {

				weights[ i ] = weights[ i ] / sum;

			}

			blurUniforms[ 'envMap' ].value = targetIn.texture;
			blurUniforms[ 'samples' ].value = samples;
			blurUniforms[ 'weights' ].value = weights;
			blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

			if ( poleAxis ) {

				blurUniforms[ 'poleAxis' ].value = poleAxis;

			}

			const { _lodMax } = this;
			blurUniforms[ 'dTheta' ].value = radiansPerPixel;
			blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

			const outputSize = this._sizeLods[ lodOut ];
			const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
			const y = 4 * ( this._cubeSize - outputSize );

			_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
			renderer.setRenderTarget( targetOut );
			renderer.render( blurMesh, _flatCamera );

		}

	}



	function _createPlanes( lodMax ) {

		const lodPlanes = [];
		const sizeLods = [];
		const sigmas = [];

		let lod = lodMax;

		const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

		for ( let i = 0; i < totalLods; i ++ ) {

			const sizeLod = Math.pow( 2, lod );
			sizeLods.push( sizeLod );
			let sigma = 1.0 / sizeLod;

			if ( i > lodMax - LOD_MIN ) {

				sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

			} else if ( i === 0 ) {

				sigma = 0;

			}

			sigmas.push( sigma );

			const texelSize = 1.0 / ( sizeLod - 2 );
			const min = - texelSize;
			const max = 1 + texelSize;
			const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;

			const position = new Float32Array( positionSize * vertices * cubeFaces );
			const uv = new Float32Array( uvSize * vertices * cubeFaces );
			const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

			for ( let face = 0; face < cubeFaces; face ++ ) {

				const x = ( face % 3 ) * 2 / 3 - 1;
				const y = face > 2 ? 0 : - 1;
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				];
				position.set( coordinates, positionSize * vertices * face );
				uv.set( uv1, uvSize * vertices * face );
				const fill = [ face, face, face, face, face, face ];
				faceIndex.set( fill, faceIndexSize * vertices * face );

			}

			const planes = new BufferGeometry();
			planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
			planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
			planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
			lodPlanes.push( planes );

			if ( lod > LOD_MIN ) {

				lod --;

			}

		}

		return { lodPlanes, sizeLods, sigmas };

	}

	function _createRenderTarget( width, height, params ) {

		const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;

	}

	function _setViewport( target, x, y, width, height ) {

		target.viewport.set( x, y, width, height );
		target.scissor.set( x, y, width, height );

	}

	function _getBlurShader( lodMax, width, height ) {

		const weights = new Float32Array( MAX_SAMPLES );
		const poleAxis = new Vector3( 0, 1, 0 );
		const shaderMaterial = new ShaderMaterial( {

			name: 'SphericalGaussianBlur',

			defines: {
				'n': MAX_SAMPLES,
				'CUBEUV_TEXEL_WIDTH': 1.0 / width,
				'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
				'CUBEUV_MAX_MIP': `${lodMax}.0`,
			},

			uniforms: {
				'envMap': { value: null },
				'samples': { value: 1 },
				'weights': { value: weights },
				'latitudinal': { value: false },
				'dTheta': { value: 0 },
				'mipInt': { value: 0 },
				'poleAxis': { value: poleAxis }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

		return shaderMaterial;

	}

	function _getEquirectMaterial() {

		return new ShaderMaterial( {

			name: 'EquirectangularToCubeUV',

			uniforms: {
				'envMap': { value: null }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCubemapMaterial() {

		return new ShaderMaterial( {

			name: 'CubemapToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'flipEnvMap': { value: - 1 }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCommonVertexShader() {

		return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

	}

	function WebGLCubeUVMaps( renderer ) {

		let cubeUVmaps = new WeakMap();

		let pmremGenerator = null;

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
				const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

				// equirect/cube map to cubeUV conversion

				if ( isEquirectMap || isCubeMap ) {

					if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

						texture.needsPMREMUpdate = false;

						let renderTarget = cubeUVmaps.get( texture );

						if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
						cubeUVmaps.set( texture, renderTarget );

						return renderTarget.texture;

					} else {

						if ( cubeUVmaps.has( texture ) ) {

							return cubeUVmaps.get( texture ).texture;

						} else {

							const image = texture.image;

							if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

								if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

								const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
								cubeUVmaps.set( texture, renderTarget );

								texture.addEventListener( 'dispose', onTextureDispose );

								return renderTarget.texture;

							} else {

								// image not yet ready. try the conversion next frame

								return null;

							}

						}

					}

				}

			}

			return texture;

		}

		function isCubeTextureComplete( image ) {

			let count = 0;
			const length = 6;

			for ( let i = 0; i < length; i ++ ) {

				if ( image[ i ] !== undefined ) count ++;

			}

			return count === length;


		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemapUV = cubeUVmaps.get( texture );

			if ( cubemapUV !== undefined ) {

				cubeUVmaps.delete( texture );
				cubemapUV.dispose();

			}

		}

		function dispose() {

			cubeUVmaps = new WeakMap();

			if ( pmremGenerator !== null ) {

				pmremGenerator.dispose();
				pmremGenerator = null;

			}

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function ( capabilities ) {

				if ( capabilities.isWebGL2 ) {

					getExtension( 'EXT_color_buffer_float' );

				} else {

					getExtension( 'WEBGL_depth_texture' );
					getExtension( 'OES_texture_float' );
					getExtension( 'OES_texture_half_float' );
					getExtension( 'OES_texture_half_float_linear' );
					getExtension( 'OES_standard_derivatives' );
					getExtension( 'OES_element_index_uint' );
					getExtension( 'OES_vertex_array_object' );
					getExtension( 'ANGLE_instanced_arrays' );

				}

				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );
				getExtension( 'WEBGL_multisampled_render_to_texture' );

			},

			get: function ( name ) {

				const extension = getExtension( name );

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( const name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			for ( const name in geometry.morphAttributes ) {

				const array = geometry.morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.remove( array[ i ] );

				}

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			const attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) return geometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl, capabilities, textures ) {

		const influencesList = {};
		const morphInfluences = new Float32Array( 8 );
		const morphTextures = new WeakMap();
		const morph = new Vector4();

		const workInfluences = [];

		for ( let i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, program ) {

			const objectInfluences = object.morphTargetInfluences;

			if ( capabilities.isWebGL2 === true ) {

				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				let entry = morphTextures.get( geometry );

				if ( entry === undefined || entry.count !== morphTargetsCount ) {

					if ( entry !== undefined ) entry.texture.dispose();

					const hasMorphPosition = geometry.morphAttributes.position !== undefined;
					const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					const hasMorphColors = geometry.morphAttributes.color !== undefined;

					const morphTargets = geometry.morphAttributes.position || [];
					const morphNormals = geometry.morphAttributes.normal || [];
					const morphColors = geometry.morphAttributes.color || [];

					let vertexDataCount = 0;

					if ( hasMorphPosition === true ) vertexDataCount = 1;
					if ( hasMorphNormals === true ) vertexDataCount = 2;
					if ( hasMorphColors === true ) vertexDataCount = 3;

					let width = geometry.attributes.position.count * vertexDataCount;
					let height = 1;

					if ( width > capabilities.maxTextureSize ) {

						height = Math.ceil( width / capabilities.maxTextureSize );
						width = capabilities.maxTextureSize;

					}

					const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

					const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
					texture.type = FloatType;
					texture.needsUpdate = true;

					// fill buffer

					const vertexDataStride = vertexDataCount * 4;

					for ( let i = 0; i < morphTargetsCount; i ++ ) {

						const morphTarget = morphTargets[ i ];
						const morphNormal = morphNormals[ i ];
						const morphColor = morphColors[ i ];

						const offset = width * height * 4 * i;

						for ( let j = 0; j < morphTarget.count; j ++ ) {

							const stride = j * vertexDataStride;

							if ( hasMorphPosition === true ) {

								morph.fromBufferAttribute( morphTarget, j );

								buffer[ offset + stride + 0 ] = morph.x;
								buffer[ offset + stride + 1 ] = morph.y;
								buffer[ offset + stride + 2 ] = morph.z;
								buffer[ offset + stride + 3 ] = 0;

							}

							if ( hasMorphNormals === true ) {

								morph.fromBufferAttribute( morphNormal, j );

								buffer[ offset + stride + 4 ] = morph.x;
								buffer[ offset + stride + 5 ] = morph.y;
								buffer[ offset + stride + 6 ] = morph.z;
								buffer[ offset + stride + 7 ] = 0;

							}

							if ( hasMorphColors === true ) {

								morph.fromBufferAttribute( morphColor, j );

								buffer[ offset + stride + 8 ] = morph.x;
								buffer[ offset + stride + 9 ] = morph.y;
								buffer[ offset + stride + 10 ] = morph.z;
								buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

							}

						}

					}

					entry = {
						count: morphTargetsCount,
						texture: texture,
						size: new Vector2( width, height )
					};

					morphTextures.set( geometry, entry );

					function disposeTexture() {

						texture.dispose();

						morphTextures.delete( geometry );

						geometry.removeEventListener( 'dispose', disposeTexture );

					}

					geometry.addEventListener( 'dispose', disposeTexture );

				}

				//

				let morphInfluencesSum = 0;

				for ( let i = 0; i < objectInfluences.length; i ++ ) {

					morphInfluencesSum += objectInfluences[ i ];

				}

				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

				program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
				program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


			} else {

				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

				const length = objectInfluences === undefined ? 0 : objectInfluences.length;

				let influences = influencesList[ geometry.id ];

				if ( influences === undefined || influences.length !== length ) {

					// initialise list

					influences = [];

					for ( let i = 0; i < length; i ++ ) {

						influences[ i ] = [ i, 0 ];

					}

					influencesList[ geometry.id ] = influences;

				}

				// Collect influences

				for ( let i = 0; i < length; i ++ ) {

					const influence = influences[ i ];

					influence[ 0 ] = i;
					influence[ 1 ] = objectInfluences[ i ];

				}

				influences.sort( absNumericalSort );

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < length && influences[ i ][ 1 ] ) {

						workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
						workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

					} else {

						workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
						workInfluences[ i ][ 1 ] = 0;

					}

				}

				workInfluences.sort( numericalSort );

				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal;

				let morphInfluencesSum = 0;

				for ( let i = 0; i < 8; i ++ ) {

					const influence = workInfluences[ i ];
					const index = influence[ 0 ];
					const value = influence[ 1 ];

					if ( index !== Number.MAX_SAFE_INTEGER && value ) {

						if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

							geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

						}

						if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

							geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

						}

						morphInfluences[ i ] = value;
						morphInfluencesSum += value;

					} else {

						if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

							geometry.deleteAttribute( 'morphTarget' + i );

						}

						if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

							geometry.deleteAttribute( 'morphNormal' + i );

						}

						morphInfluences[ i ] = 0;

					}

				}

				// GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

			}

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				if ( updateMap.get( object ) !== frame ) {

					attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

					if ( object.instanceColor !== null ) {

						attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

					}

					updateMap.set( object, frame );

				}

			}

			if ( object.isSkinnedMesh ) {

				const skeleton = object.skeleton;

				if ( updateMap.get( skeleton ) !== frame ) {

					skeleton.update();

					updateMap.set( skeleton, frame );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */


	const emptyTexture = /*@__PURE__*/ new Texture();
	const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
	const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
	const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single integer / boolean

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single integer / boolean vector (from flat array or THREE.VectorN)

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2i( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3i( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4i( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4iv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single unsigned integer

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single unsigned integer vector (from flat array or THREE.VectorN)

	function setValueV2ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2ui( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2uiv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3ui( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3uiv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4ui( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4uiv( this.addr, v );

			copyArray( cache, v );

		}

	}


	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || empty3dTexture, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTextureCube( v || emptyCubeTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyArrayTexture, unit );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT
			case 0x8dc6: return setValueV2ui; // _VEC2
			case 0x8dc7: return setValueV3ui; // _VEC3
			case 0x8dc8: return setValueV4ui; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}


	// Array of scalars

	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of integer / boolean

	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Array of unsigned integer

	function setValueV1uiArray( gl, v ) {

		gl.uniform1uiv( this.addr, v );

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray( gl, v ) {

		gl.uniform2uiv( this.addr, v );

	}

	function setValueV3uiArray( gl, v ) {

		gl.uniform3uiv( this.addr, v );

	}

	function setValueV4uiArray( gl, v ) {

		gl.uniform4uiv( this.addr, v );

	}


	// Array of textures (2D / 3D / Cube / 2DArray)

	function setValueT1Array( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT3DArray( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	function setValueT2DArrayArray( gl, v, textures ) {

		const cache = this.cache;

		const n = v.length;

		const units = allocTexUnits( textures, n );

		if ( ! arraysEqual( cache, units ) ) {

			gl.uniform1iv( this.addr, units );

			copyArray( cache, units );

		}

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

		}

	}


	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x1405: return setValueV1uiArray; // UINT
			case 0x8dc6: return setValueV2uiArray; // _VEC2
			case 0x8dc7: return setValueV3uiArray; // _VEC3
			case 0x8dc8: return setValueV4uiArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;

		}

	}

	// --- Uniform Classes ---

	class SingleUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class PureArrayUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class StructuredUniform {

		constructor( id ) {

			this.id = id;

			this.seq = [];
			this.map = {};

		}

		setValue( gl, value, textures ) {

			const seq = this.seq;

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				u.setValue( gl, value[ u.id ], textures );

			}

		}

	}

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	class WebGLUniforms {

		constructor( gl, program ) {

			this.seq = [];
			this.map = {};

			const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( let i = 0; i < n; ++ i ) {

				const info = gl.getActiveUniform( program, i ),
					addr = gl.getUniformLocation( program, info.name );

				parseUniform( info, addr, this );

			}

		}

		setValue( gl, name, value, textures ) {

			const u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, textures );

		}

		setOptional( gl, object, name ) {

			const v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		}

		static upload( gl, seq, values, textures ) {

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {

					// note: always updating when .needsUpdate is undefined
					u.setValue( gl, v.value, textures );

				}

			}

		}

		static seqWithValue( seq, values ) {

			const r = [];

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		}

	}

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	let programIdCount = 0;

	function handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	function getEncodingComponents( colorSpace ) {

		switch ( colorSpace ) {

			case LinearSRGBColorSpace:
				return [ 'Linear', '( value )' ];
			case SRGBColorSpace:
				return [ 'sRGB', '( value )' ];
			default:
				console.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			// --enable-privileged-webgl-extension
			// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	function getTexelEncodingFunction( functionName, colorSpace ) {

		const components = getEncodingComponents( colorSpace );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		const chunks = [
			( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			let locationSize = 1;
			if ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;
			if ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;
			if ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = {
				type: info.type,
				location: gl.getAttribLocation( program, name ),
				locationSize: locationSize
			};

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )
			.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	const shaderChunkMap = new Map( [
		[ 'encodings_fragment', 'colorspace_fragment' ], // @deprecated, r154
		[ 'encodings_pars_fragment', 'colorspace_pars_fragment' ], // @deprecated, r154
		[ 'output_fragment', 'opaque_fragment' ], // @deprecated, r154
	] );

	function includeReplacer( match, include ) {

		let string = ShaderChunk[ include ];

		if ( string === undefined ) {

			const newInclude = shaderChunkMap.get( include );

			if ( newInclude !== undefined ) {

				string = ShaderChunk[ newInclude ];
				console.warn( 'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude );

			} else {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string.replace( unrollLoopPattern, loopReplacer );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function generateCubeUVSize( parameters ) {

		const imageHeight = parameters.envMapCubeUVHeight;

		if ( imageHeight === null ) return null;

		const maxMip = Math.log2( imageHeight ) - 2;

		const texelHeight = 1.0 / imageHeight;

		const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

		return { texelWidth, texelHeight, maxMip };

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
		const envMapCubeUVSize = generateCubeUVSize( parameters );

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

				parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

				//

				parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',
				parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',
				parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',
				parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',
				parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',
				parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',
				parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',
				parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',

				parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',
				parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',

				parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',

				parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',
				parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',
				parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',

				parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',
				parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',

				parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',
				parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',

				parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',
				parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',
				parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',

				parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',
				parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',

				//

				parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUv1s ? '#define USE_UV1' : '',
				parameters.vertexUv2s ? '#define USE_UV2' : '',
				parameters.vertexUv3s ? '#define USE_UV3' : '',

				parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_UV1',

				'	attribute vec2 uv1;',

				'#endif',

				'#ifdef USE_UV2',

				'	attribute vec2 uv2;',

				'#endif',

				'#ifdef USE_UV3',

				'	attribute vec2 uv3;',

				'#endif',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_TYPE ' + parameters.shaderType,
				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
				parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
				envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',

				parameters.anisotropy ? '#define USE_ANISOTROPY' : '',
				parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',

				parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaTest ? '#define USE_ALPHATEST' : '',
				parameters.alphaHash ? '#define USE_ALPHAHASH' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUv1s ? '#define USE_UV1' : '',
				parameters.vertexUv2s ? '#define USE_UV2' : '',
				parameters.vertexUv3s ? '#define USE_UV3' : '',

				parameters.pointsUvs ? '#define USE_POINTS_UV' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',
				parameters.opaque ? '#define OPAQUE' : '',

				ShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),

				parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'precision mediump sampler2DArray;',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				if ( typeof renderer.debug.onShaderError === 'function' ) {

					renderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.type = parameters.shaderType;
		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	let _id = 0;

	class WebGLShaderCache {

		constructor() {

			this.shaderCache = new Map();
			this.materialCache = new Map();

		}

		update( material ) {

			const vertexShader = material.vertexShader;
			const fragmentShader = material.fragmentShader;

			const vertexShaderStage = this._getShaderStage( vertexShader );
			const fragmentShaderStage = this._getShaderStage( fragmentShader );

			const materialShaders = this._getShaderCacheForMaterial( material );

			if ( materialShaders.has( vertexShaderStage ) === false ) {

				materialShaders.add( vertexShaderStage );
				vertexShaderStage.usedTimes ++;

			}

			if ( materialShaders.has( fragmentShaderStage ) === false ) {

				materialShaders.add( fragmentShaderStage );
				fragmentShaderStage.usedTimes ++;

			}

			return this;

		}

		remove( material ) {

			const materialShaders = this.materialCache.get( material );

			for ( const shaderStage of materialShaders ) {

				shaderStage.usedTimes --;

				if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

			}

			this.materialCache.delete( material );

			return this;

		}

		getVertexShaderID( material ) {

			return this._getShaderStage( material.vertexShader ).id;

		}

		getFragmentShaderID( material ) {

			return this._getShaderStage( material.fragmentShader ).id;

		}

		dispose() {

			this.shaderCache.clear();
			this.materialCache.clear();

		}

		_getShaderCacheForMaterial( material ) {

			const cache = this.materialCache;
			let set = cache.get( material );

			if ( set === undefined ) {

				set = new Set();
				cache.set( material, set );

			}

			return set;

		}

		_getShaderStage( code ) {

			const cache = this.shaderCache;
			let stage = cache.get( code );

			if ( stage === undefined ) {

				stage = new WebGLShaderStage( code );
				cache.set( code, stage );

			}

			return stage;

		}

	}

	class WebGLShaderStage {

		constructor( code ) {

			this.id = _id ++;

			this.code = code;
			this.usedTimes = 0;

		}

	}

	function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

		const _programLayers = new Layers();
		const _customShaders = new WebGLShaderCache();
		const programs = [];

		const IS_WEBGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;

		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getChannel( value ) {

			if ( value === 0 ) return 'uv';

			return `uv${ value }`;

		}

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const geometry = object.geometry;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			//

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let morphTextureStride = 0;

			if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
			if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
			if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

			//

			let vertexShader, fragmentShader;
			let customVertexShaderID, customFragmentShaderID;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

				_customShaders.update( material );

				customVertexShaderID = _customShaders.getVertexShaderID( material );
				customFragmentShaderID = _customShaders.getFragmentShaderID( material );

			}

			const currentRenderTarget = renderer.getRenderTarget();

			const IS_INSTANCEDMESH = object.isInstancedMesh === true;

			const HAS_MAP = !! material.map;
			const HAS_MATCAP = !! material.matcap;
			const HAS_ENVMAP = !! envMap;
			const HAS_AOMAP = !! material.aoMap;
			const HAS_LIGHTMAP = !! material.lightMap;
			const HAS_BUMPMAP = !! material.bumpMap;
			const HAS_NORMALMAP = !! material.normalMap;
			const HAS_DISPLACEMENTMAP = !! material.displacementMap;
			const HAS_EMISSIVEMAP = !! material.emissiveMap;

			const HAS_METALNESSMAP = !! material.metalnessMap;
			const HAS_ROUGHNESSMAP = !! material.roughnessMap;

			const HAS_ANISOTROPY = material.anisotropy > 0;
			const HAS_CLEARCOAT = material.clearcoat > 0;
			const HAS_IRIDESCENCE = material.iridescence > 0;
			const HAS_SHEEN = material.sheen > 0;
			const HAS_TRANSMISSION = material.transmission > 0;

			const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;

			const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;
			const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;
			const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;

			const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;
			const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;

			const HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;
			const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;

			const HAS_SPECULARMAP = !! material.specularMap;
			const HAS_SPECULAR_COLORMAP = !! material.specularColorMap;
			const HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;

			const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;
			const HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;

			const HAS_GRADIENTMAP = !! material.gradientMap;

			const HAS_ALPHAMAP = !! material.alphaMap;

			const HAS_ALPHATEST = material.alphaTest > 0;

			const HAS_ALPHAHASH = !! material.alphaHash;

			const HAS_EXTENSIONS = !! material.extensions;

			const HAS_ATTRIBUTE_UV1 = !! geometry.attributes.uv1;
			const HAS_ATTRIBUTE_UV2 = !! geometry.attributes.uv2;
			const HAS_ATTRIBUTE_UV3 = !! geometry.attributes.uv3;

			const parameters = {

				isWebGL2: IS_WEBGL2,

				shaderID: shaderID,
				shaderType: material.type,
				shaderName: material.name,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: IS_INSTANCEDMESH,
				instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,

				supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
				outputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),

				map: HAS_MAP,
				matcap: HAS_MATCAP,
				envMap: HAS_ENVMAP,
				envMapMode: HAS_ENVMAP && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				aoMap: HAS_AOMAP,
				lightMap: HAS_LIGHTMAP,
				bumpMap: HAS_BUMPMAP,
				normalMap: HAS_NORMALMAP,
				displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
				emissiveMap: HAS_EMISSIVEMAP,

				normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
				normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,

				metalnessMap: HAS_METALNESSMAP,
				roughnessMap: HAS_ROUGHNESSMAP,

				anisotropy: HAS_ANISOTROPY,
				anisotropyMap: HAS_ANISOTROPYMAP,

				clearcoat: HAS_CLEARCOAT,
				clearcoatMap: HAS_CLEARCOATMAP,
				clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
				clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,

				iridescence: HAS_IRIDESCENCE,
				iridescenceMap: HAS_IRIDESCENCEMAP,
				iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,

				sheen: HAS_SHEEN,
				sheenColorMap: HAS_SHEEN_COLORMAP,
				sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,

				specularMap: HAS_SPECULARMAP,
				specularColorMap: HAS_SPECULAR_COLORMAP,
				specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,

				transmission: HAS_TRANSMISSION,
				transmissionMap: HAS_TRANSMISSIONMAP,
				thicknessMap: HAS_THICKNESSMAP,

				gradientMap: HAS_GRADIENTMAP,

				opaque: material.transparent === false && material.blending === NormalBlending,

				alphaMap: HAS_ALPHAMAP,
				alphaTest: HAS_ALPHATEST,
				alphaHash: HAS_ALPHAHASH,

				combine: material.combine,

				//

				mapUv: HAS_MAP && getChannel( material.map.channel ),
				aoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),
				lightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),
				bumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),
				normalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),
				displacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),
				emissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),

				metalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),
				roughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),

				anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),

				clearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),
				clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),
				clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),

				iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),
				iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),

				sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),
				sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),

				specularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),
				specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),
				specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),

				transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),
				thicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),

				alphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),

				//

				vertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
				vertexUv1s: HAS_ATTRIBUTE_UV1,
				vertexUv2s: HAS_ATTRIBUTE_UV2,
				vertexUv3s: HAS_ATTRIBUTE_UV3,

				pointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),

				fog: !! fog,
				useFog: material.fog === true,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading === true,

				sizeAttenuation: material.sizeAttenuation === true,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: object.isSkinnedMesh === true,

				morphTargets: geometry.morphAttributes.position !== undefined,
				morphNormals: geometry.morphAttributes.normal !== undefined,
				morphColors: geometry.morphAttributes.color !== undefined,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numSpotLightMaps: lights.spotLightMap.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				useLegacyLights: renderer.useLegacyLights,

				premultipliedAlpha: material.premultipliedAlpha,

				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				useDepthPacking: material.depthPacking >= 0,
				depthPacking: material.depthPacking || 0,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
				extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
				extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
				extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,

				rendererExtensionFragDepth: IS_WEBGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.customVertexShaderID );
				array.push( parameters.customFragmentShaderID );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				getProgramCacheKeyParameters( array, parameters );
				getProgramCacheKeyBooleans( array, parameters );
				array.push( renderer.outputColorSpace );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getProgramCacheKeyParameters( array, parameters ) {

			array.push( parameters.precision );
			array.push( parameters.outputColorSpace );
			array.push( parameters.envMapMode );
			array.push( parameters.envMapCubeUVHeight );
			array.push( parameters.mapUv );
			array.push( parameters.alphaMapUv );
			array.push( parameters.lightMapUv );
			array.push( parameters.aoMapUv );
			array.push( parameters.bumpMapUv );
			array.push( parameters.normalMapUv );
			array.push( parameters.displacementMapUv );
			array.push( parameters.emissiveMapUv );
			array.push( parameters.metalnessMapUv );
			array.push( parameters.roughnessMapUv );
			array.push( parameters.anisotropyMapUv );
			array.push( parameters.clearcoatMapUv );
			array.push( parameters.clearcoatNormalMapUv );
			array.push( parameters.clearcoatRoughnessMapUv );
			array.push( parameters.iridescenceMapUv );
			array.push( parameters.iridescenceThicknessMapUv );
			array.push( parameters.sheenColorMapUv );
			array.push( parameters.sheenRoughnessMapUv );
			array.push( parameters.specularMapUv );
			array.push( parameters.specularColorMapUv );
			array.push( parameters.specularIntensityMapUv );
			array.push( parameters.transmissionMapUv );
			array.push( parameters.thicknessMapUv );
			array.push( parameters.combine );
			array.push( parameters.fogExp2 );
			array.push( parameters.sizeAttenuation );
			array.push( parameters.morphTargetsCount );
			array.push( parameters.morphAttributeCount );
			array.push( parameters.numDirLights );
			array.push( parameters.numPointLights );
			array.push( parameters.numSpotLights );
			array.push( parameters.numSpotLightMaps );
			array.push( parameters.numHemiLights );
			array.push( parameters.numRectAreaLights );
			array.push( parameters.numDirLightShadows );
			array.push( parameters.numPointLightShadows );
			array.push( parameters.numSpotLightShadows );
			array.push( parameters.numSpotLightShadowsWithMaps );
			array.push( parameters.shadowMapType );
			array.push( parameters.toneMapping );
			array.push( parameters.numClippingPlanes );
			array.push( parameters.numClipIntersection );
			array.push( parameters.depthPacking );

		}

		function getProgramCacheKeyBooleans( array, parameters ) {

			_programLayers.disableAll();

			if ( parameters.isWebGL2 )
				_programLayers.enable( 0 );
			if ( parameters.supportsVertexTextures )
				_programLayers.enable( 1 );
			if ( parameters.instancing )
				_programLayers.enable( 2 );
			if ( parameters.instancingColor )
				_programLayers.enable( 3 );
			if ( parameters.matcap )
				_programLayers.enable( 4 );
			if ( parameters.envMap )
				_programLayers.enable( 5 );
			if ( parameters.normalMapObjectSpace )
				_programLayers.enable( 6 );
			if ( parameters.normalMapTangentSpace )
				_programLayers.enable( 7 );
			if ( parameters.clearcoat )
				_programLayers.enable( 8 );
			if ( parameters.iridescence )
				_programLayers.enable( 9 );
			if ( parameters.alphaTest )
				_programLayers.enable( 10 );
			if ( parameters.vertexColors )
				_programLayers.enable( 11 );
			if ( parameters.vertexAlphas )
				_programLayers.enable( 12 );
			if ( parameters.vertexUv1s )
				_programLayers.enable( 13 );
			if ( parameters.vertexUv2s )
				_programLayers.enable( 14 );
			if ( parameters.vertexUv3s )
				_programLayers.enable( 15 );
			if ( parameters.vertexTangents )
				_programLayers.enable( 16 );
			if ( parameters.anisotropy )
				_programLayers.enable( 17 );

			array.push( _programLayers.mask );
			_programLayers.disableAll();

			if ( parameters.fog )
				_programLayers.enable( 0 );
			if ( parameters.useFog )
				_programLayers.enable( 1 );
			if ( parameters.flatShading )
				_programLayers.enable( 2 );
			if ( parameters.logarithmicDepthBuffer )
				_programLayers.enable( 3 );
			if ( parameters.skinning )
				_programLayers.enable( 4 );
			if ( parameters.morphTargets )
				_programLayers.enable( 5 );
			if ( parameters.morphNormals )
				_programLayers.enable( 6 );
			if ( parameters.morphColors )
				_programLayers.enable( 7 );
			if ( parameters.premultipliedAlpha )
				_programLayers.enable( 8 );
			if ( parameters.shadowMapEnabled )
				_programLayers.enable( 9 );
			if ( parameters.useLegacyLights )
				_programLayers.enable( 10 );
			if ( parameters.doubleSided )
				_programLayers.enable( 11 );
			if ( parameters.flipSided )
				_programLayers.enable( 12 );
			if ( parameters.useDepthPacking )
				_programLayers.enable( 13 );
			if ( parameters.dithering )
				_programLayers.enable( 14 );
			if ( parameters.transmission )
				_programLayers.enable( 15 );
			if ( parameters.sheen )
				_programLayers.enable( 16 );
			if ( parameters.opaque )
				_programLayers.enable( 17 );
			if ( parameters.pointsUvs )
				_programLayers.enable( 18 );

			array.push( _programLayers.mask );

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		function releaseShaderCache( material ) {

			_customShaders.remove( material );

		}

		function dispose() {

			_customShaders.dispose();

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			releaseShaderCache: releaseShaderCache,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs,
			dispose: dispose
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transmissive = [];
		const transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.push( renderItem );

			} else if ( material.transparent === true ) {

				transparent.push( renderItem );

			} else {

				opaque.push( renderItem );

			}

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.unshift( renderItem );

			} else if ( material.transparent === true ) {

				transparent.unshift( renderItem );

			} else {

				opaque.unshift( renderItem );

			}

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		let lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			const listArray = lists.get( scene );
			let list;

			if ( listArray === undefined ) {

				list = new WebGLRenderList();
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= listArray.length ) {

					list = new WebGLRenderList();
					listArray.push( list );

				} else {

					list = listArray[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingAndTexturingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1,
				numSpotMaps: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights, useLegacyLights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			let numSpotMaps = 0;
			let numSpotShadowsWithMaps = 0;

			// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
			lights.sort( shadowCastingAndTexturingLightsFirst );

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					state.spot[ spotLength ] = uniforms;

					const shadow = light.shadow;

					if ( light.map ) {

						state.spotLightMap[ numSpotMaps ] = light.map;
						numSpotMaps ++;

						// make sure the lightMatrix is up to date
						// TODO : do it if required only
						shadow.updateMatrices( light );

						if ( light.castShadow ) numSpotShadowsWithMaps ++;

					}

					state.spotLightMatrix[ spotLength ] = shadow.matrix;

					if ( light.castShadow ) {

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;

						numSpotShadows ++;

					}

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else {

						console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

					}

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ||
				hash.numSpotMaps !== numSpotMaps ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
				state.spotLightMap.length = numSpotMaps;
				state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				hash.numSpotMaps = numSpotMaps;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		const lights = new WebGLLights( extensions, capabilities );

		const lightsArray = [];
		const shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( useLegacyLights ) {

			lights.setup( lightsArray, useLegacyLights );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			const renderStateArray = renderStates.get( scene );
			let renderState;

			if ( renderStateArray === undefined ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStateArray.length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStateArray.push( renderState );

				} else {

					renderState = renderStateArray[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class MeshDepthMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshDepthMaterial = true;

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.depthPacking = source.depthPacking;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		}

	}

	class MeshDistanceMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshDistanceMaterial = true;

			this.type = 'MeshDistanceMaterial';

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		}

	}

	const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap( _renderer, _objects, _capabilities ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
			_distanceMaterial = new MeshDistanceMaterial(),

			_materialCache = {},

			_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vertex,
			fragmentShader: fragment

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;
		let _previousType = this.type;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// check for shadow map type changes

			const toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );
			const fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

					if ( _shadowMapSize.x > _maxTextureSize ) {

						_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > _maxTextureSize ) {

						_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null || toVSM === true || fromVSM === true ) {

					const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

					if ( shadow.map !== null ) {

						shadow.map.dispose();

					}

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			_previousType = this.type;

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = _objects.update( fullScreenMesh );

			if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;

			}

			if ( shadow.mapPass === null ) {

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

			}

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterial( object, material, light, type ) {

			let result = null;

			const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

			if ( customMaterial !== undefined ) {

				result = customMaterial;

			} else {

				result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

				if ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
					( material.displacementMap && material.displacementScale !== 0 ) ||
					( material.alphaMap && material.alphaTest > 0 ) ||
					( material.map && material.alphaTest > 0 ) ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					const keyA = result.uuid, keyB = material.uuid;

					let materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					let cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;

					}

					result = cachedMaterial;

				}

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;
			result.map = material.map;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				const materialProperties = _renderer.properties.get( result );
				materialProperties.light = light;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = _objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, groupMaterial, light, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, material, light, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		const uboBindings = new WeakMap();
		const uboProgramMap = new WeakMap();

		let enabledCapabilities = {};

		let currentBoundFramebuffers = {};
		let currentDrawbuffers = new WeakMap();
		let defaultDrawbuffers = [];

		let currentProgram = null;

		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const scissorParam = gl.getParameter( gl.SCISSOR_BOX );
		const viewportParam = gl.getParameter( gl.VIEWPORT );

		const currentScissor = new Vector4().fromArray( scissorParam );
		const currentViewport = new Vector4().fromArray( viewportParam );

		function createTexture( type, target, count, dimensions ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( let i = 0; i < count; i ++ ) {

				if ( isWebGL2 && ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) ) {

					gl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				} else {

					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				}

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		if ( isWebGL2 ) {

			emptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );
			emptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );

		}

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function bindFramebuffer( target, framebuffer ) {

			if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

				gl.bindFramebuffer( target, framebuffer );

				currentBoundFramebuffers[ target ] = framebuffer;

				if ( isWebGL2 ) {

					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

					if ( target === gl.DRAW_FRAMEBUFFER ) {

						currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

					}

					if ( target === gl.FRAMEBUFFER ) {

						currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

					}

				}

				return true;

			}

			return false;

		}

		function drawBuffers( renderTarget, framebuffer ) {

			let drawBuffers = defaultDrawbuffers;

			let needsUpdate = false;

			if ( renderTarget ) {

				drawBuffers = currentDrawbuffers.get( framebuffer );

				if ( drawBuffers === undefined ) {

					drawBuffers = [];
					currentDrawbuffers.set( framebuffer, drawBuffers );

				}

				if ( renderTarget.isWebGLMultipleRenderTargets ) {

					const textures = renderTarget.texture;

					if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

						}

						drawBuffers.length = textures.length;

						needsUpdate = true;

					}

				} else {

					if ( drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

						drawBuffers[ 0 ] = gl.COLOR_ATTACHMENT0;

						needsUpdate = true;

					}

				}

			} else {

				if ( drawBuffers[ 0 ] !== gl.BACK ) {

					drawBuffers[ 0 ] = gl.BACK;

					needsUpdate = true;

				}

			}

			if ( needsUpdate ) {

				if ( capabilities.isWebGL2 ) {

					gl.drawBuffers( drawBuffers );

				} else {

					extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

				}

			}


		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = gl.MIN;
			equationToGL[ MaxEquation ] = gl.MAX;

		} else {

			const extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		const factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( gl.BLEND );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( gl.BLEND );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( gl.FUNC_ADD );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.ONE, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
								break;

							case MultiplyBlending:
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = false;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			material.alphaToCoverage === true
				? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
				: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture, webglSlot ) {

			if ( webglSlot === undefined ) {

				if ( currentTextureSlot === null ) {

					webglSlot = gl.TEXTURE0 + maxTextures - 1;

				} else {

					webglSlot = currentTextureSlot;

				}

			}

			let boundTexture = currentBoundTextures[ webglSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ webglSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function compressedTexImage3D() {

			try {

				gl.compressedTexImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texSubImage2D() {

			try {

				gl.texSubImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texSubImage3D() {

			try {

				gl.texSubImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function compressedTexSubImage2D() {

			try {

				gl.compressedTexSubImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function compressedTexSubImage3D() {

			try {

				gl.compressedTexSubImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texStorage2D() {

			try {

				gl.texStorage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texStorage3D() {

			try {

				gl.texStorage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		function updateUBOMapping( uniformsGroup, program ) {

			let mapping = uboProgramMap.get( program );

			if ( mapping === undefined ) {

				mapping = new WeakMap();

				uboProgramMap.set( program, mapping );

			}

			let blockIndex = mapping.get( uniformsGroup );

			if ( blockIndex === undefined ) {

				blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

				mapping.set( uniformsGroup, blockIndex );

			}

		}

		function uniformBlockBinding( uniformsGroup, program ) {

			const mapping = uboProgramMap.get( program );
			const blockIndex = mapping.get( uniformsGroup );

			if ( uboBindings.get( program ) !== blockIndex ) {

				// bind shader specific block index to global block point
				gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

				uboBindings.set( program, blockIndex );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( gl.BLEND );
			gl.disable( gl.CULL_FACE );
			gl.disable( gl.DEPTH_TEST );
			gl.disable( gl.POLYGON_OFFSET_FILL );
			gl.disable( gl.SCISSOR_TEST );
			gl.disable( gl.STENCIL_TEST );
			gl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.ONE, gl.ZERO );
			gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( gl.LESS );
			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
			gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
			gl.clearStencil( 0 );

			gl.cullFace( gl.BACK );
			gl.frontFace( gl.CCW );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( gl.TEXTURE0 );

			gl.bindFramebuffer( gl.FRAMEBUFFER, null );

			if ( isWebGL2 === true ) {

				gl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );
				gl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );

			}

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentBoundFramebuffers = {};
			currentDrawbuffers = new WeakMap();
			defaultDrawbuffers = [];

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
			currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			drawBuffers: drawBuffers,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			compressedTexImage3D: compressedTexImage3D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			updateUBOMapping: updateUBOMapping,
			uniformBlockBinding: uniformBlockBinding,

			texStorage2D: texStorage2D,
			texStorage3D: texStorage3D,
			texSubImage2D: texSubImage2D,
			texSubImage3D: texSubImage3D,
			compressedTexSubImage2D: compressedTexSubImage2D,
			compressedTexSubImage3D: compressedTexSubImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;
		const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
		const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );

		const _videoTextures = new WeakMap();
		let _canvas;

		const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				// eslint-disable-next-line compat/compat
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				// eslint-disable-next-line compat/compat
				new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			let scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

					const width = floor( scale * image.width );
					const height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo$1( image ) {

			return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target ) {

			_gl.generateMipmap( target );

		}

		function getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			let internalFormat = glFormat;

			if ( glFormat === _gl.RED ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

			}

			if ( glFormat === _gl.RG ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;

			}

			if ( glFormat === _gl.RGBA ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
				if ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;
				if ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;

			}

			if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
				internalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||
				internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		function getMipLevels( texture, image, supportsMips ) {

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

				return Math.log2( Math.max( image.width, image.height ) ) + 1;

			} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

				// user-defined mipmaps

				return texture.mipmaps.length;

			} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

				return image.mipmaps.length;

			} else {

				// texture without mipmaps (only base level)

				return 1;

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			// check if it's necessary to remove the WebGLTexture object

			const source = texture.source;
			const webglTextures = _sources.get( source );

			if ( webglTextures ) {

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];
				webglTexture.usedTimes --;

				// the WebGLTexture object is not used anymore, remove it

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

				// remove the weak map entry if no WebGLTexture uses the source anymore

				if ( Object.keys( webglTextures ).length === 0 ) {

					_sources.delete( source );

				}

			}

			properties.remove( texture );

		}

		function deleteTexture( texture ) {

			const textureProperties = properties.get( texture );
			_gl.deleteTexture( textureProperties.__webglTexture );

			const source = texture.source;
			const webglTextures = _sources.get( source );
			delete webglTextures[ textureProperties.__cacheKey ];

			info.memory.textures --;

		}

		function deallocateRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

				info.memory.textures --;

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

				if ( renderTargetProperties.__webglColorRenderbuffer ) {

					for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

						if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

				}

				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				for ( let i = 0, il = texture.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( texture[ i ] );

					if ( attachmentProperties.__webglTexture ) {

						_gl.deleteTexture( attachmentProperties.__webglTexture );

						info.memory.textures --;

					}

					properties.remove( texture[ i ] );

				}

			}

			properties.remove( texture );
			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		function getTextureCacheKey( texture ) {

			const array = [];

			array.push( texture.wrapS );
			array.push( texture.wrapT );
			array.push( texture.wrapR || 0 );
			array.push( texture.magFilter );
			array.push( texture.minFilter );
			array.push( texture.anisotropy );
			array.push( texture.internalFormat );
			array.push( texture.format );
			array.push( texture.type );
			array.push( texture.generateMipmaps );
			array.push( texture.premultiplyAlpha );
			array.push( texture.flipY );
			array.push( texture.unpackAlignment );
			array.push( texture.colorSpace );

			return array.join();

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === null ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: _gl.REPEAT,
			[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
		};

		const filterToGL = {
			[ NearestFilter ]: _gl.NEAREST,
			[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: _gl.LINEAR,
			[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
		};

		const compareToGL = {
			[ NeverCompare ]: _gl.NEVER,
			[ AlwaysCompare ]: _gl.ALWAYS,
			[ LessCompare ]: _gl.LESS,
			[ LessEqualCompare ]: _gl.LEQUAL,
			[ EqualCompare ]: _gl.EQUAL,
			[ GreaterEqualCompare ]: _gl.GEQUAL,
			[ GreaterCompare ]: _gl.GREATER,
			[ NotEqualCompare ]: _gl.NOTEQUAL
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			if ( texture.compareFunction ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );
				_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( texture.magFilter === NearestFilter ) return;
				if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
				if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			let forceUpload = false;

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

			}

			// create Source <-> WebGLTextures mapping if necessary

			const source = texture.source;
			let webglTextures = _sources.get( source );

			if ( webglTextures === undefined ) {

				webglTextures = {};
				_sources.set( source, webglTextures );

			}

			// check if there is already a WebGLTexture object for the given texture parameters

			const textureCacheKey = getTextureCacheKey( texture );

			if ( textureCacheKey !== textureProperties.__cacheKey ) {

				// if not, create a new instance of WebGLTexture

				if ( webglTextures[ textureCacheKey ] === undefined ) {

					// create new entry

					webglTextures[ textureCacheKey ] = {
						texture: _gl.createTexture(),
						usedTimes: 0
					};

					info.memory.textures ++;

					// when a new instance of WebGLTexture was created, a texture upload is required
					// even if the image contents are identical

					forceUpload = true;

				}

				webglTextures[ textureCacheKey ].usedTimes ++;

				// every time the texture cache key changes, it's necessary to check if an instance of
				// WebGLTexture can be deleted in order to avoid a memory leak.

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];

				if ( webglTexture !== undefined ) {

					webglTextures[ textureProperties.__cacheKey ].usedTimes --;

					if ( webglTexture.usedTimes === 0 ) {

						deleteTexture( texture );

					}

				}

				// store references to cache key and WebGLTexture object

				textureProperties.__cacheKey = textureCacheKey;
				textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

			}

			return forceUpload;

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = _gl.TEXTURE_2D;

			if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;
			if ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

			const sourceProperties = properties.get( source );

			if ( source.version !== sourceProperties.__version || forceUpload === true ) {

				state.activeTexture( _gl.TEXTURE0 + slot );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
				_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

				const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
				let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
				image = verifyColorSpace( texture, image );

				const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.colorSpace );

				let glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

				setTextureParameters( textureType, texture, supportsMips );

				let mipmap;
				const mipmaps = texture.mipmaps;

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
				const levels = getMipLevels( texture, image, supportsMips );

				if ( texture.isDepthTexture ) {

					// populate depth texture with dummy data

					glInternalFormat = _gl.DEPTH_COMPONENT;

					if ( isWebGL2 ) {

						if ( texture.type === FloatType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT32F;

						} else if ( texture.type === UnsignedIntType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT24;

						} else if ( texture.type === UnsignedInt248Type ) {

							glInternalFormat = _gl.DEPTH24_STENCIL8;

						} else {

							glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D

						}

					} else {

						if ( texture.type === FloatType ) {

							console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

						}

					}

					// validation checks for WebGL 1

					if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

							texture.type = UnsignedIntType;
							glType = utils.convert( texture.type );

						}

					}

					if ( texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

						// Depth stencil textures need the DEPTH_STENCIL internal format
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						glInternalFormat = _gl.DEPTH_STENCIL;

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

							texture.type = UnsignedInt248Type;
							glType = utils.convert( texture.type );

						}

					}

					//

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

						}

					}

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

						}

					}

				} else if ( texture.isCompressedTexture ) {

					if ( texture.isCompressedArrayTexture ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );

									} else {

										state.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );

									}

								} else {

									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

								} else {

									state.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					} else {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									} else {

										state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								} else {

									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								} else {

									state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else if ( texture.isDataArrayTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isData3DTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isFramebufferTexture ) {

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

						} else {

							let width = image.width, height = image.height;

							for ( let i = 0; i < levels; i ++ ) {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );

								width >>= 1;
								height >>= 1;

							}

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );

							} else {

								state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );

						} else {

							state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( textureType );

				}

				sourceProperties.__version = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );

			const sourceProperties = properties.get( source );

			if ( source.version !== sourceProperties.__version || forceUpload === true ) {

				state.activeTexture( _gl.TEXTURE0 + slot );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
				_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

				const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
				const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				const cubeImage = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

					cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

				}

				const image = cubeImage[ 0 ],
					supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.colorSpace ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );
				let levels = getMipLevels( texture, image, supportsMips );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

				let mipmaps;

				if ( isCompressed ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						mipmaps = cubeImage[ i ].mipmaps;

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									} else {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								} else {

									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else {

					mipmaps = texture.mipmaps;

					if ( useTexStorage && allocateMemory ) {

						// TODO: Uniformly handle mipmap definitions
						// Normal textures and compressed cube textures define base level + mips with their mipmap array
						// Uncompressed cube textures use their mipmap array only for mips (no base level)

						if ( mipmaps.length > 0 ) levels ++;

						state.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						if ( isDataTexture ) {

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];
								const mipmapImage = mipmap.image[ i ].image;

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

								}

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];

								if ( useTexStorage ) {

									state.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

								}

							}

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					// We assume images for cube map have the same size.
					generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				sourceProperties.__version = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

			const glFormat = utils.convert( texture.format, texture.colorSpace );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
			const renderTargetProperties = properties.get( renderTarget );

			if ( ! renderTargetProperties.__hasExternalTextures ) {

				if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

					state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

				} else {

					state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				}

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

			} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}


		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

					const depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT32F;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT24;

						}

					}

					const samples = getRenderTargetSamples( renderTarget );

					if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];

					const glFormat = utils.convert( texture.format, texture.colorSpace );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );
					const samples = getRenderTargetSamples( renderTarget );

					if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				}

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
			const samples = getRenderTargetSamples( renderTarget );

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				}

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				}

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			state.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// rebind framebuffer with external textures
		function rebindTextures( renderTarget, colorTexture, depthTexture ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( colorTexture !== undefined ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			}

			if ( depthTexture !== undefined ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

				if ( textureProperties.__webglTexture === undefined ) {

					textureProperties.__webglTexture = _gl.createTexture();

				}

				textureProperties.__version = texture.version;
				info.memory.textures ++;

			}

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultipleRenderTargets ) {

					if ( capabilities.drawBuffers ) {

						const textures = renderTarget.texture;

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							const attachmentProperties = properties.get( textures[ i ] );

							if ( attachmentProperties.__webglTexture === undefined ) {

								attachmentProperties.__webglTexture = _gl.createTexture();

								info.memory.textures ++;

							}

						}

					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

					}

				}

				if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

					const textures = isMultipleRenderTargets ? texture : [ texture ];

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = [];

					state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const glFormat = utils.convert( texture.format, texture.colorSpace );
						const glType = utils.convert( texture.type );
						const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );
						const samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( _gl.FRAMEBUFFER, null );

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

				for ( let i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				state.unbindTexture();

			} else if ( isMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachment = textures[ i ];
					const attachmentProperties = properties.get( attachment );

					state.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, attachment, supportsMips );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D );

					if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

						generateMipmap( _gl.TEXTURE_2D );

					}

				}

				state.unbindTexture();

			} else {

				let glTextureType = _gl.TEXTURE_2D;

				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

					if ( isWebGL2 ) {

						glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

					} else {

						console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

					}

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType );

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( glTextureType );

				}

				state.unbindTexture();

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const texture = textures[ i ];

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					const webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					generateMipmap( target );
					state.unbindTexture();

				}

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = _gl.COLOR_BUFFER_BIT;
				const invalidationArray = [];
				const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
				const renderTargetProperties = properties.get( renderTarget );
				const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );

				// If MRT we need to remove FBO attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );

					}

				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					invalidationArray.push( _gl.COLOR_ATTACHMENT0 + i );

					if ( renderTarget.depthBuffer ) {

						invalidationArray.push( depthStyle );

					}

					const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

					if ( ignoreDepthValues === false ) {

						if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;
						if ( renderTarget.stencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					}

					if ( isMultipleRenderTargets ) {

						_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					if ( ignoreDepthValues === true ) {

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, [ depthStyle ] );
						_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );

					}

					if ( isMultipleRenderTargets ) {

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );

					}

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					if ( supportsInvalidateFramebuffer ) {

						_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArray );

					}


				}

				state.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );
				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );

				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

						state.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );

					}

				}

				state.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return Math.min( maxSamples, renderTarget.samples );

		}

		function useMultisampledRTT( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		function verifyColorSpace( texture, image ) {

			const colorSpace = texture.colorSpace;
			const format = texture.format;
			const type = texture.type;

			if ( texture.isCompressedTexture === true || texture.format === _SRGBAFormat ) return image;

			if ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {

				// sRGB

				if ( colorSpace === SRGBColorSpace ) {

					if ( isWebGL2 === false ) {

						// in WebGL 1, try to use EXT_sRGB extension and unsized formats

						if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

							texture.format = _SRGBAFormat;

							// it's not possible to generate mips in WebGL 1 with this extension

							texture.minFilter = LinearFilter;
							texture.generateMipmaps = false;

						} else {

							// slow fallback (CPU decode)

							image = ImageUtils.sRGBToLinear( image );

						}

					} else {

						// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

						if ( format !== RGBAFormat || type !== UnsignedByteType ) {

							console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

						}

					}

				} else {

					console.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );

				}

			}

			return image;

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.useMultisampledRTT = useMultisampledRTT;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function convert( p, colorSpace = NoColorSpace ) {

			let extension;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return gl.HALF_FLOAT;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			// WebGL 1 sRGB fallback

			if ( p === _SRGBAFormat ) {

				extension = extensions.get( 'EXT_sRGB' );

				if ( extension !== null ) {

					return extension.SRGB_ALPHA_EXT;

				} else {

					return null;

				}

			}

			// WebGL2 formats.

			if ( p === RedFormat ) return gl.RED;
			if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
			if ( p === RGFormat ) return gl.RG;
			if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
			if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

			// S3TC

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				if ( colorSpace === SRGBColorSpace ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				} else {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				}

			}

			// PVRTC

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			// ETC1

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			// ETC2

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

				} else {

					return null;

				}

			}

			// ASTC

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					if ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

				} else {

					return null;

				}

			}

			// BPTC

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

				} else {

					return null;

				}

			}

			// RGTC

			if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

				extension = extensions.get( 'EXT_texture_compression_rgtc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
					if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
					if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
					if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

				} else {

					return null;

				}

			}

			//

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return gl.UNSIGNED_INT_24_8;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

			// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

			return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

		}

		return { convert: convert };

	}

	class ArrayCamera extends PerspectiveCamera {

		constructor( array = [] ) {

			super();

			this.isArrayCamera = true;

			this.cameras = array;

		}

	}

	class Group extends Object3D {

		constructor() {

			super();

			this.isGroup = true;

			this.type = 'Group';

		}

	}

	const _moveEvent = { type: 'move' };

	class WebXRController {

		constructor() {

			this._targetRay = null;
			this._grip = null;
			this._hand = null;

		}

		getHandSpace() {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		}

		getTargetRaySpace() {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();

			}

			return this._targetRay;

		}

		getGripSpace() {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();

			}

			return this._grip;

		}

		dispatchEvent( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		}

		connect( inputSource ) {

			if ( inputSource && inputSource.hand ) {

				const hand = this._hand;

				if ( hand ) {

					for ( const inputjoint of inputSource.hand.values() ) {

						// Initialize hand with joints when connected
						this._getHandJoint( hand, inputjoint );

					}

				}

			}

			this.dispatchEvent( { type: 'connected', data: inputSource } );

			return this;

		}

		disconnect( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		}

		update( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( const inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputjoint, referenceSpace );

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = this._getHandJoint( hand, inputjoint );

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.matrixWorldNeedsUpdate = true;
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints[ 'index-finger-tip' ];
					const thumbTip = hand.joints[ 'thumb-tip' ];
					const distance = indexTip.position.distanceTo( thumbTip.position );

					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );
							grip.matrixWorldNeedsUpdate = true;

							if ( gripPose.linearVelocity ) {

								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy( gripPose.linearVelocity );

							} else {

								grip.hasLinearVelocity = false;

							}

							if ( gripPose.angularVelocity ) {

								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy( gripPose.angularVelocity );

							} else {

								grip.hasAngularVelocity = false;

							}

						}

					}

				}

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
					if ( inputPose === null && gripPose !== null ) {

						inputPose = gripPose;

					}

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );
						targetRay.matrixWorldNeedsUpdate = true;

						if ( inputPose.linearVelocity ) {

							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy( inputPose.linearVelocity );

						} else {

							targetRay.hasLinearVelocity = false;

						}

						if ( inputPose.angularVelocity ) {

							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy( inputPose.angularVelocity );

						} else {

							targetRay.hasAngularVelocity = false;

						}

						this.dispatchEvent( _moveEvent );

					}

				}


			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

		// private method

		_getHandJoint( hand, inputjoint ) {

			if ( hand.joints[ inputjoint.jointName ] === undefined ) {

				const joint = new Group();
				joint.matrixAutoUpdate = false;
				joint.visible = false;
				hand.joints[ inputjoint.jointName ] = joint;

				hand.add( joint );

			}

			return hand.joints[ inputjoint.jointName ];

		}

	}

	class DepthTexture extends Texture {

		constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

			}

			if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isDepthTexture = true;

			this.image = { width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps = false;

			this.compareFunction = null;

		}


		copy( source ) {

			super.copy( source );

			this.compareFunction = source.compareFunction;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;

			return data;

		}

	}

	class WebXRManager extends EventDispatcher {

		constructor( renderer, gl ) {

			super();

			const scope = this;

			let session = null;

			let framebufferScaleFactor = 1.0;

			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			// Set default foveation to maximum.
			let foveation = 1.0;
			let customReferenceSpace = null;

			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let xrFrame = null;
			const attributes = gl.getContextAttributes();
			let initialRenderTarget = null;
			let newRenderTarget = null;

			const controllers = [];
			const controllerInputSources = [];

			//

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable( 1 );
			cameraL.viewport = new Vector4();

			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable( 2 );
			cameraR.viewport = new Vector4();

			const cameras = [ cameraL, cameraR ];

			const cameraXR = new ArrayCamera();
			cameraXR.layers.enable( 1 );
			cameraXR.layers.enable( 2 );

			let _currentDepthNear = null;
			let _currentDepthFar = null;

			//

			this.cameraAutoUpdate = true;
			this.enabled = false;

			this.isPresenting = false;

			this.getController = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getTargetRaySpace();

			};

			this.getControllerGrip = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getGripSpace();

			};

			this.getHand = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getHandSpace();

			};

			//

			function onSessionEvent( event ) {

				const controllerIndex = controllerInputSources.indexOf( event.inputSource );

				if ( controllerIndex === - 1 ) {

					return;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller !== undefined ) {

					controller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );
					controller.dispatchEvent( { type: event.type, data: event.inputSource } );

				}

			}

			function onSessionEnd() {

				session.removeEventListener( 'select', onSessionEvent );
				session.removeEventListener( 'selectstart', onSessionEvent );
				session.removeEventListener( 'selectend', onSessionEvent );
				session.removeEventListener( 'squeeze', onSessionEvent );
				session.removeEventListener( 'squeezestart', onSessionEvent );
				session.removeEventListener( 'squeezeend', onSessionEvent );
				session.removeEventListener( 'end', onSessionEnd );
				session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];

					if ( inputSource === null ) continue;

					controllerInputSources[ i ] = null;

					controllers[ i ].disconnect( inputSource );

				}

				_currentDepthNear = null;
				_currentDepthFar = null;

				// restore framebuffer/rendering state

				renderer.setRenderTarget( initialRenderTarget );

				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null;

				//

				animation.stop();

				scope.isPresenting = false;

				scope.dispatchEvent( { type: 'sessionend' } );

			}

			this.setFramebufferScaleFactor = function ( value ) {

				framebufferScaleFactor = value;

				if ( scope.isPresenting === true ) {

					console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

				}

			};

			this.setReferenceSpaceType = function ( value ) {

				referenceSpaceType = value;

				if ( scope.isPresenting === true ) {

					console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

				}

			};

			this.getReferenceSpace = function () {

				return customReferenceSpace || referenceSpace;

			};

			this.setReferenceSpace = function ( space ) {

				customReferenceSpace = space;

			};

			this.getBaseLayer = function () {

				return glProjLayer !== null ? glProjLayer : glBaseLayer;

			};

			this.getBinding = function () {

				return glBinding;

			};

			this.getFrame = function () {

				return xrFrame;

			};

			this.getSession = function () {

				return session;

			};

			this.setSession = async function ( value ) {

				session = value;

				if ( session !== null ) {

					initialRenderTarget = renderer.getRenderTarget();

					session.addEventListener( 'select', onSessionEvent );
					session.addEventListener( 'selectstart', onSessionEvent );
					session.addEventListener( 'selectend', onSessionEvent );
					session.addEventListener( 'squeeze', onSessionEvent );
					session.addEventListener( 'squeezestart', onSessionEvent );
					session.addEventListener( 'squeezeend', onSessionEvent );
					session.addEventListener( 'end', onSessionEnd );
					session.addEventListener( 'inputsourceschange', onInputSourcesChange );

					if ( attributes.xrCompatible !== true ) {

						await gl.makeXRCompatible();

					}

					if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

						const layerInit = {
							antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
							alpha: true,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};

						glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

						session.updateRenderState( { baseLayer: glBaseLayer } );

						newRenderTarget = new WebGLRenderTarget(
							glBaseLayer.framebufferWidth,
							glBaseLayer.framebufferHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								colorSpace: renderer.outputColorSpace,
								stencilBuffer: attributes.stencil
							}
						);

					} else {

						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;

						if ( attributes.depth ) {

							glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

						}

						const projectionlayerInit = {
							colorFormat: gl.RGBA8,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};

						glBinding = new XRWebGLBinding( session, gl );

						glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

						session.updateRenderState( { layers: [ glProjLayer ] } );

						newRenderTarget = new WebGLRenderTarget(
							glProjLayer.textureWidth,
							glProjLayer.textureHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
								stencilBuffer: attributes.stencil,
								colorSpace: renderer.outputColorSpace,
								samples: attributes.antialias ? 4 : 0
							} );

						const renderTargetProperties = renderer.properties.get( newRenderTarget );
						renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

					}

					newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

					this.setFoveation( foveation );

					customReferenceSpace = null;
					referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

					animation.setContext( session );
					animation.start();

					scope.isPresenting = true;

					scope.dispatchEvent( { type: 'sessionstart' } );

				}

			};

			this.getEnvironmentBlendMode = function () {

				if ( session !== null ) {

					return session.environmentBlendMode;

				}

			};

			function onInputSourcesChange( event ) {

				// Notify disconnected

				for ( let i = 0; i < event.removed.length; i ++ ) {

					const inputSource = event.removed[ i ];
					const index = controllerInputSources.indexOf( inputSource );

					if ( index >= 0 ) {

						controllerInputSources[ index ] = null;
						controllers[ index ].disconnect( inputSource );

					}

				}

				// Notify connected

				for ( let i = 0; i < event.added.length; i ++ ) {

					const inputSource = event.added[ i ];

					let controllerIndex = controllerInputSources.indexOf( inputSource );

					if ( controllerIndex === - 1 ) {

						// Assign input source a controller that currently has no input source

						for ( let i = 0; i < controllers.length; i ++ ) {

							if ( i >= controllerInputSources.length ) {

								controllerInputSources.push( inputSource );
								controllerIndex = i;
								break;

							} else if ( controllerInputSources[ i ] === null ) {

								controllerInputSources[ i ] = inputSource;
								controllerIndex = i;
								break;

							}

						}

						// If all controllers do currently receive input we ignore new ones

						if ( controllerIndex === - 1 ) break;

					}

					const controller = controllers[ controllerIndex ];

					if ( controller ) {

						controller.connect( inputSource );

					}

				}

			}

			//

			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion( camera, cameraL, cameraR ) {

				cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
				cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

				const ipd = cameraLPos.distanceTo( cameraRPos );

				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements;

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
				const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
				const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
				const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

				const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
				const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
				const left = near * leftFov;
				const right = near * rightFov;

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / ( - leftFov + rightFov );
				const xOffset = zOffset * - leftFov;

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
				camera.translateX( xOffset );
				camera.translateZ( zOffset );
				camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + ( ipd - xOffset );
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;

				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
				camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();

			}

			function updateCamera( camera, parent ) {

				if ( parent === null ) {

					camera.matrixWorld.copy( camera.matrix );

				} else {

					camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

				}

				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			}

			this.updateCamera = function ( camera ) {

				if ( session === null ) return;

				cameraXR.near = cameraR.near = cameraL.near = camera.near;
				cameraXR.far = cameraR.far = cameraL.far = camera.far;

				if ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState( {
						depthNear: cameraXR.near,
						depthFar: cameraXR.far
					} );

					_currentDepthNear = cameraXR.near;
					_currentDepthFar = cameraXR.far;

				}

				const parent = camera.parent;
				const cameras = cameraXR.cameras;

				updateCamera( cameraXR, parent );

				for ( let i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update projection matrix for proper view frustum culling

				if ( cameras.length === 2 ) {

					setProjectionFromUnion( cameraXR, cameraL, cameraR );

				} else {

					// assume single camera setup (AR)

					cameraXR.projectionMatrix.copy( cameraL.projectionMatrix );

				}

				// update user camera and its children

				updateUserCamera( camera, cameraXR, parent );

			};

			function updateUserCamera( camera, cameraXR, parent ) {

				if ( parent === null ) {

					camera.matrix.copy( cameraXR.matrixWorld );

				} else {

					camera.matrix.copy( parent.matrixWorld );
					camera.matrix.invert();
					camera.matrix.multiply( cameraXR.matrixWorld );

				}

				camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
				camera.updateMatrixWorld( true );

				const children = camera.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				camera.projectionMatrix.copy( cameraXR.projectionMatrix );
				camera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );

				if ( camera.isPerspectiveCamera ) {

					camera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );
					camera.zoom = 1;

				}

			}

			this.getCamera = function () {

				return cameraXR;

			};

			this.getFoveation = function () {

				if ( glProjLayer === null && glBaseLayer === null ) {

					return undefined;

				}

				return foveation;

			};

			this.setFoveation = function ( value ) {

				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				foveation = value;

				if ( glProjLayer !== null ) {

					glProjLayer.fixedFoveation = value;

				}

				if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

					glBaseLayer.fixedFoveation = value;

				}

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time, frame ) {

				pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
				xrFrame = frame;

				if ( pose !== null ) {

					const views = pose.views;

					if ( glBaseLayer !== null ) {

						renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
						renderer.setRenderTarget( newRenderTarget );

					}

					let cameraXRNeedsUpdate = false;

					// check if it's necessary to rebuild cameraXR's camera list

					if ( views.length !== cameraXR.cameras.length ) {

						cameraXR.cameras.length = 0;
						cameraXRNeedsUpdate = true;

					}

					for ( let i = 0; i < views.length; i ++ ) {

						const view = views[ i ];

						let viewport = null;

						if ( glBaseLayer !== null ) {

							viewport = glBaseLayer.getViewport( view );

						} else {

							const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
							viewport = glSubImage.viewport;

							// For side-by-side projection, we only produce a single texture for both eyes.
							if ( i === 0 ) {

								renderer.setRenderTargetTextures(
									newRenderTarget,
									glSubImage.colorTexture,
									glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

								renderer.setRenderTarget( newRenderTarget );

							}

						}

						let camera = cameras[ i ];

						if ( camera === undefined ) {

							camera = new PerspectiveCamera();
							camera.layers.enable( i );
							camera.viewport = new Vector4();
							cameras[ i ] = camera;

						}

						camera.matrix.fromArray( view.transform.matrix );
						camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );
						camera.projectionMatrix.fromArray( view.projectionMatrix );
						camera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();
						camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

						if ( i === 0 ) {

							cameraXR.matrix.copy( camera.matrix );
							cameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );

						}

						if ( cameraXRNeedsUpdate === true ) {

							cameraXR.cameras.push( camera );

						}

					}

				}

				//

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];
					const controller = controllers[ i ];

					if ( inputSource !== null && controller !== undefined ) {

						controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

					}

				}

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

				if ( frame.detectedPlanes ) {

					scope.dispatchEvent( { type: 'planesdetected', data: frame } );

				}

				xrFrame = null;

			}

			const animation = new WebGLAnimation();

			animation.setAnimationLoop( onAnimationFrame );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;

			};

			this.dispose = function () {};

		}

	}

	function WebGLMaterials( renderer, properties ) {

		function refreshTransformUniform( map, uniform ) {

			if ( map.matrixAutoUpdate === true ) {

				map.updateMatrix();

			}

			uniform.value.copy( map.matrix );

		}

		function refreshFogUniforms( uniforms, fog ) {

			fog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsStandard( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;

				refreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );

				uniforms.bumpScale.value = material.bumpScale;

				if ( material.side === BackSide ) {

					uniforms.bumpScale.value *= - 1;

				}

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;

				refreshTransformUniform( material.normalMap, uniforms.normalMapTransform );

				uniforms.normalScale.value.copy( material.normalScale );

				if ( material.side === BackSide ) {

					uniforms.normalScale.value.negate();

				}

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;

				refreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );

				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

				refreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

				refreshTransformUniform( material.specularMap, uniforms.specularMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;

				// artist-friendly light intensity scaling factor
				const scaleFactor = ( renderer.useLegacyLights === true ) ? Math.PI : 1;

				uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

				refreshTransformUniform( material.lightMap, uniforms.lightMapTransform );

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

				refreshTransformUniform( material.aoMap, uniforms.aoMapTransform );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.uvTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

				refreshTransformUniform( material.map, uniforms.mapTransform );

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

				refreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.metalness.value = material.metalness;

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

				refreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );

			}

			uniforms.roughness.value = material.roughness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

				refreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

			uniforms.ior.value = material.ior; // also part of uniforms common

			if ( material.sheen > 0 ) {

				uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

				uniforms.sheenRoughness.value = material.sheenRoughness;

				if ( material.sheenColorMap ) {

					uniforms.sheenColorMap.value = material.sheenColorMap;

					refreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );

				}

				if ( material.sheenRoughnessMap ) {

					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

					refreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );

				}

			}

			if ( material.clearcoat > 0 ) {

				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if ( material.clearcoatMap ) {

					uniforms.clearcoatMap.value = material.clearcoatMap;

					refreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );

				}

				if ( material.clearcoatRoughnessMap ) {

					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

					refreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );

				}

				if ( material.clearcoatNormalMap ) {

					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					refreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );

					uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );

					if ( material.side === BackSide ) {

						uniforms.clearcoatNormalScale.value.negate();

					}

				}

			}

			if ( material.iridescence > 0 ) {

				uniforms.iridescence.value = material.iridescence;
				uniforms.iridescenceIOR.value = material.iridescenceIOR;
				uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
				uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

				if ( material.iridescenceMap ) {

					uniforms.iridescenceMap.value = material.iridescenceMap;

					refreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );

				}

				if ( material.iridescenceThicknessMap ) {

					uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

					refreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );

				}

			}

			if ( material.transmission > 0 ) {

				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

				if ( material.transmissionMap ) {

					uniforms.transmissionMap.value = material.transmissionMap;

					refreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );

				}

				uniforms.thickness.value = material.thickness;

				if ( material.thicknessMap ) {

					uniforms.thicknessMap.value = material.thicknessMap;

					refreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );

				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy( material.attenuationColor );

			}

			if ( material.anisotropy > 0 ) {

				uniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

				if ( material.anisotropyMap ) {

					uniforms.anisotropyMap.value = material.anisotropyMap;

					refreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );

				}

			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy( material.specularColor );

			if ( material.specularColorMap ) {

				uniforms.specularColorMap.value = material.specularColorMap;

				refreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );

			}

			if ( material.specularIntensityMap ) {

				uniforms.specularIntensityMap.value = material.specularIntensityMap;

				refreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			const light = properties.get( material ).light;

			uniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );
			uniforms.nearDistance.value = light.shadow.camera.near;
			uniforms.farDistance.value = light.shadow.camera.far;

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function WebGLUniformsGroups( gl, info, capabilities, state ) {

		let buffers = {};
		let updateList = {};
		let allocatedBindingPoints = [];

		const maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ) : 0; // binding points are global whereas block indices are per shader program

		function bind( uniformsGroup, program ) {

			const webglProgram = program.program;
			state.uniformBlockBinding( uniformsGroup, webglProgram );

		}

		function update( uniformsGroup, program ) {

			let buffer = buffers[ uniformsGroup.id ];

			if ( buffer === undefined ) {

				prepareUniformsGroup( uniformsGroup );

				buffer = createBuffer( uniformsGroup );
				buffers[ uniformsGroup.id ] = buffer;

				uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

			}

			// ensure to update the binding points/block indices mapping for this program

			const webglProgram = program.program;
			state.updateUBOMapping( uniformsGroup, webglProgram );

			// update UBO once per frame

			const frame = info.render.frame;

			if ( updateList[ uniformsGroup.id ] !== frame ) {

				updateBufferData( uniformsGroup );

				updateList[ uniformsGroup.id ] = frame;

			}

		}

		function createBuffer( uniformsGroup ) {

			// the setup of an UBO is independent of a particular shader program but global

			const bindingPointIndex = allocateBindingPointIndex();
			uniformsGroup.__bindingPointIndex = bindingPointIndex;

			const buffer = gl.createBuffer();
			const size = uniformsGroup.__size;
			const usage = uniformsGroup.usage;

			gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );
			gl.bufferData( gl.UNIFORM_BUFFER, size, usage );
			gl.bindBuffer( gl.UNIFORM_BUFFER, null );
			gl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );

			return buffer;

		}

		function allocateBindingPointIndex() {

			for ( let i = 0; i < maxBindingPoints; i ++ ) {

				if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

					allocatedBindingPoints.push( i );
					return i;

				}

			}

			console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

			return 0;

		}

		function updateBufferData( uniformsGroup ) {

			const buffer = buffers[ uniformsGroup.id ];
			const uniforms = uniformsGroup.uniforms;
			const cache = uniformsGroup.__cache;

			gl.bindBuffer( gl.UNIFORM_BUFFER, buffer );

			for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

				const uniform = uniforms[ i ];

				// partly update the buffer if necessary

				if ( hasUniformChanged( uniform, i, cache ) === true ) {

					const offset = uniform.__offset;

					const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

					let arrayOffset = 0;

					for ( let i = 0; i < values.length; i ++ ) {

						const value = values[ i ];

						const info = getUniformSize( value );

						if ( typeof value === 'number' ) {

							uniform.__data[ 0 ] = value;
							gl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );

						} else if ( value.isMatrix3 ) {

							// manually converting 3x3 to 3x4

							uniform.__data[ 0 ] = value.elements[ 0 ];
							uniform.__data[ 1 ] = value.elements[ 1 ];
							uniform.__data[ 2 ] = value.elements[ 2 ];
							uniform.__data[ 3 ] = value.elements[ 0 ];
							uniform.__data[ 4 ] = value.elements[ 3 ];
							uniform.__data[ 5 ] = value.elements[ 4 ];
							uniform.__data[ 6 ] = value.elements[ 5 ];
							uniform.__data[ 7 ] = value.elements[ 0 ];
							uniform.__data[ 8 ] = value.elements[ 6 ];
							uniform.__data[ 9 ] = value.elements[ 7 ];
							uniform.__data[ 10 ] = value.elements[ 8 ];
							uniform.__data[ 11 ] = value.elements[ 0 ];

						} else {

							value.toArray( uniform.__data, arrayOffset );

							arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;

						}

					}

					gl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );

				}

			}

			gl.bindBuffer( gl.UNIFORM_BUFFER, null );

		}

		function hasUniformChanged( uniform, index, cache ) {

			const value = uniform.value;

			if ( cache[ index ] === undefined ) {

				// cache entry does not exist so far

				if ( typeof value === 'number' ) {

					cache[ index ] = value;

				} else {

					const values = Array.isArray( value ) ? value : [ value ];

					const tempValues = [];

					for ( let i = 0; i < values.length; i ++ ) {

						tempValues.push( values[ i ].clone() );

					}

					cache[ index ] = tempValues;

				}

				return true;

			} else {

				// compare current value with cached entry

				if ( typeof value === 'number' ) {

					if ( cache[ index ] !== value ) {

						cache[ index ] = value;
						return true;

					}

				} else {

					const cachedObjects = Array.isArray( cache[ index ] ) ? cache[ index ] : [ cache[ index ] ];
					const values = Array.isArray( value ) ? value : [ value ];

					for ( let i = 0; i < cachedObjects.length; i ++ ) {

						const cachedObject = cachedObjects[ i ];

						if ( cachedObject.equals( values[ i ] ) === false ) {

							cachedObject.copy( values[ i ] );
							return true;

						}

					}

				}

			}

			return false;

		}

		function prepareUniformsGroup( uniformsGroup ) {

			// determine total buffer size according to the STD140 layout
			// Hint: STD140 is the only supported layout in WebGL 2

			const uniforms = uniformsGroup.uniforms;

			let offset = 0; // global buffer offset in bytes
			const chunkSize = 16; // size of a chunk in bytes
			let chunkOffset = 0; // offset within a single chunk in bytes

			for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

				const uniform = uniforms[ i ];

				const infos = {
					boundary: 0, // bytes
					storage: 0 // bytes
				};

				const values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];

				for ( let j = 0, jl = values.length; j < jl; j ++ ) {

					const value = values[ j ];

					const info = getUniformSize( value );

					infos.boundary += info.boundary;
					infos.storage += info.storage;

				}

				// the following two properties will be used for partial buffer updates

				uniform.__data = new Float32Array( infos.storage / Float32Array.BYTES_PER_ELEMENT );
				uniform.__offset = offset;

				//

				if ( i > 0 ) {

					chunkOffset = offset % chunkSize;

					const remainingSizeInChunk = chunkSize - chunkOffset;

					// check for chunk overflow

					if ( chunkOffset !== 0 && ( remainingSizeInChunk - infos.boundary ) < 0 ) {

						// add padding and adjust offset

						offset += ( chunkSize - chunkOffset );
						uniform.__offset = offset;

					}

				}

				offset += infos.storage;

			}

			// ensure correct final padding

			chunkOffset = offset % chunkSize;

			if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

			//

			uniformsGroup.__size = offset;
			uniformsGroup.__cache = {};

			return this;

		}

		function getUniformSize( value ) {

			const info = {
				boundary: 0, // bytes
				storage: 0 // bytes
			};

			// determine sizes according to STD140

			if ( typeof value === 'number' ) {

				// float/int

				info.boundary = 4;
				info.storage = 4;

			} else if ( value.isVector2 ) {

				// vec2

				info.boundary = 8;
				info.storage = 8;

			} else if ( value.isVector3 || value.isColor ) {

				// vec3

				info.boundary = 16;
				info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

			} else if ( value.isVector4 ) {

				// vec4

				info.boundary = 16;
				info.storage = 16;

			} else if ( value.isMatrix3 ) {

				// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

				info.boundary = 48;
				info.storage = 48;

			} else if ( value.isMatrix4 ) {

				// mat4

				info.boundary = 64;
				info.storage = 64;

			} else if ( value.isTexture ) {

				console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

			} else {

				console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

			}

			return info;

		}

		function onUniformsGroupsDispose( event ) {

			const uniformsGroup = event.target;

			uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

			const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
			allocatedBindingPoints.splice( index, 1 );

			gl.deleteBuffer( buffers[ uniformsGroup.id ] );

			delete buffers[ uniformsGroup.id ];
			delete updateList[ uniformsGroup.id ];

		}

		function dispose() {

			for ( const id in buffers ) {

				gl.deleteBuffer( buffers[ id ] );

			}

			allocatedBindingPoints = [];
			buffers = {};
			updateList = {};

		}

		return {

			bind: bind,
			update: update,

			dispose: dispose

		};

	}

	function createCanvasElement() {

		const canvas = createElementNS( 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	class WebGLRenderer {

		constructor( parameters = {} ) {

			const {
				canvas = createCanvasElement(),
				context = null,
				depth = true,
				stencil = true,
				alpha = false,
				antialias = false,
				premultipliedAlpha = true,
				preserveDrawingBuffer = false,
				powerPreference = 'default',
				failIfMajorPerformanceCaveat = false,
			} = parameters;

			this.isWebGLRenderer = true;

			let _alpha;

			if ( context !== null ) {

				_alpha = context.getContextAttributes().alpha;

			} else {

				_alpha = alpha;

			}

			const uintClearColor = new Uint32Array( 4 );
			const intClearColor = new Int32Array( 4 );

			let currentRenderList = null;
			let currentRenderState = null;

			// render() can be called from within a callback triggered by another render.
			// We track this so that the nested render call gets its list and state isolated from the parent render call.

			const renderListStack = [];
			const renderStateStack = [];

			// public properties

			this.domElement = canvas;

			// Debug configuration container
			this.debug = {

				/**
				 * Enables error checking and reporting when shader programs are being compiled
				 * @type {boolean}
				 */
				checkShaderErrors: true,
				/**
				 * Callback for custom error reporting.
				 * @type {?Function}
				 */
				onShaderError: null
			};

			// clearing

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			// scene graph

			this.sortObjects = true;

			// user-defined clipping

			this.clippingPlanes = [];
			this.localClippingEnabled = false;

			// physically based shading

			this.outputColorSpace = SRGBColorSpace;

			// physical lights

			this.useLegacyLights = true;

			// tone mapping

			this.toneMapping = NoToneMapping;
			this.toneMappingExposure = 1.0;

			// internal properties

			const _this = this;

			let _isContextLost = false;

			// internal state cache

			let _currentActiveCubeFace = 0;
			let _currentActiveMipmapLevel = 0;
			let _currentRenderTarget = null;
			let _currentMaterialId = - 1;

			let _currentCamera = null;

			const _currentViewport = new Vector4();
			const _currentScissor = new Vector4();
			let _currentScissorTest = null;

			const _currentClearColor = new Color( 0x000000 );
			let _currentClearAlpha = 0;

			//

			let _width = canvas.width;
			let _height = canvas.height;

			let _pixelRatio = 1;
			let _opaqueSort = null;
			let _transparentSort = null;

			const _viewport = new Vector4( 0, 0, _width, _height );
			const _scissor = new Vector4( 0, 0, _width, _height );
			let _scissorTest = false;

			// frustum

			const _frustum = new Frustum();

			// clipping

			let _clippingEnabled = false;
			let _localClippingEnabled = false;

			// transmission

			let _transmissionRenderTarget = null;

			// camera matrices cache

			const _projScreenMatrix = new Matrix4();

			const _vector2 = new Vector2();
			const _vector3 = new Vector3();

			const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			// initialize

			let _gl = context;

			function getContext( contextNames, contextAttributes ) {

				for ( let i = 0; i < contextNames.length; i ++ ) {

					const contextName = contextNames[ i ];
					const context = canvas.getContext( contextName, contextAttributes );
					if ( context !== null ) return context;

				}

				return null;

			}

			try {

				const contextAttributes = {
					alpha: true,
					depth,
					stencil,
					antialias,
					premultipliedAlpha,
					preserveDrawingBuffer,
					powerPreference,
					failIfMajorPerformanceCaveat,
				};

				// OffscreenCanvas does not have setAttribute, see #22811
				if ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

				// event listeners must be registered before WebGL context is created, see #12753
				canvas.addEventListener( 'webglcontextlost', onContextLost, false );
				canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
				canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

				if ( _gl === null ) {

					const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

					if ( _this.isWebGL1Renderer === true ) {

						contextNames.shift();

					}

					_gl = getContext( contextNames, contextAttributes );

					if ( _gl === null ) {

						if ( getContext( contextNames ) ) {

							throw new Error( 'Error creating WebGL context with your selected attributes.' );

						} else {

							throw new Error( 'Error creating WebGL context.' );

						}

					}

				}

				if ( typeof WebGLRenderingContext !== 'undefined' && _gl instanceof WebGLRenderingContext ) { // @deprecated, r153

					console.warn( 'THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.' );

				}

				// Some experimental-webgl implementations do not have getShaderPrecisionFormat

				if ( _gl.getShaderPrecisionFormat === undefined ) {

					_gl.getShaderPrecisionFormat = function () {

						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

					};

				}

			} catch ( error ) {

				console.error( 'THREE.WebGLRenderer: ' + error.message );
				throw error;

			}

			let extensions, capabilities, state, info;
			let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
			let programCache, materials, renderLists, renderStates, clipping, shadowMap;

			let background, morphtargets, bufferRenderer, indexedBufferRenderer;

			let utils, bindingStates, uniformsGroups;

			function initGLContext() {

				extensions = new WebGLExtensions( _gl );

				capabilities = new WebGLCapabilities( _gl, extensions, parameters );

				extensions.init( capabilities );

				utils = new WebGLUtils( _gl, extensions, capabilities );

				state = new WebGLState( _gl, extensions, capabilities );

				info = new WebGLInfo( _gl );
				properties = new WebGLProperties();
				textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
				cubemaps = new WebGLCubeMaps( _this );
				cubeuvmaps = new WebGLCubeUVMaps( _this );
				attributes = new WebGLAttributes( _gl, capabilities );
				bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
				geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
				objects = new WebGLObjects( _gl, geometries, attributes, info );
				morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
				clipping = new WebGLClipping( properties );
				programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
				materials = new WebGLMaterials( _this, properties );
				renderLists = new WebGLRenderLists();
				renderStates = new WebGLRenderStates( extensions, capabilities );
				background = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );
				shadowMap = new WebGLShadowMap( _this, objects, capabilities );
				uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

				bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
				indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

				info.programs = programCache.programs;

				_this.capabilities = capabilities;
				_this.extensions = extensions;
				_this.properties = properties;
				_this.renderLists = renderLists;
				_this.shadowMap = shadowMap;
				_this.state = state;
				_this.info = info;

			}

			initGLContext();

			// xr

			const xr = new WebXRManager( _this, _gl );

			this.xr = xr;

			// API

			this.getContext = function () {

				return _gl;

			};

			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			this.forceContextLoss = function () {

				const extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.loseContext();

			};

			this.forceContextRestore = function () {

				const extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.restoreContext();

			};

			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) return;

				_pixelRatio = value;

				this.setSize( _width, _height, false );

			};

			this.getSize = function ( target ) {

				return target.set( _width, _height );

			};

			this.setSize = function ( width, height, updateStyle = true ) {

				if ( xr.isPresenting ) {

					console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
					return;

				}

				_width = width;
				_height = height;

				canvas.width = Math.floor( width * _pixelRatio );
				canvas.height = Math.floor( height * _pixelRatio );

				if ( updateStyle === true ) {

					canvas.style.width = width + 'px';
					canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			this.getDrawingBufferSize = function ( target ) {

				return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

			};

			this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

				_width = width;
				_height = height;

				_pixelRatio = pixelRatio;

				canvas.width = Math.floor( width * pixelRatio );
				canvas.height = Math.floor( height * pixelRatio );

				this.setViewport( 0, 0, width, height );

			};

			this.getCurrentViewport = function ( target ) {

				return target.copy( _currentViewport );

			};

			this.getViewport = function ( target ) {

				return target.copy( _viewport );

			};

			this.setViewport = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_viewport.set( x.x, x.y, x.z, x.w );

				} else {

					_viewport.set( x, y, width, height );

				}

				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

			};

			this.getScissor = function ( target ) {

				return target.copy( _scissor );

			};

			this.setScissor = function ( x, y, width, height ) {

				if ( x.isVector4 ) {

					_scissor.set( x.x, x.y, x.z, x.w );

				} else {

					_scissor.set( x, y, width, height );

				}

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

			};

			this.getScissorTest = function () {

				return _scissorTest;

			};

			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			this.setOpaqueSort = function ( method ) {

				_opaqueSort = method;

			};

			this.setTransparentSort = function ( method ) {

				_transparentSort = method;

			};

			// Clearing

			this.getClearColor = function ( target ) {

				return target.copy( background.getClearColor() );

			};

			this.setClearColor = function () {

				background.setClearColor.apply( background, arguments );

			};

			this.getClearAlpha = function () {

				return background.getClearAlpha();

			};

			this.setClearAlpha = function () {

				background.setClearAlpha.apply( background, arguments );

			};

			this.clear = function ( color = true, depth = true, stencil = true ) {

				let bits = 0;

				if ( color ) {

					// check if we're trying to clear an integer target
					let isIntegerFormat = false;
					if ( _currentRenderTarget !== null ) {

						const targetFormat = _currentRenderTarget.texture.format;
						isIntegerFormat = targetFormat === RGBAIntegerFormat ||
							targetFormat === RGIntegerFormat ||
							targetFormat === RedIntegerFormat;

					}

					// use the appropriate clear functions to clear the target if it's a signed
					// or unsigned integer target
					if ( isIntegerFormat ) {

						const targetType = _currentRenderTarget.texture.type;
						const isUnsignedType = targetType === UnsignedByteType ||
							targetType === UnsignedIntType ||
							targetType === UnsignedShortType ||
							targetType === UnsignedInt248Type ||
							targetType === UnsignedShort4444Type ||
							targetType === UnsignedShort5551Type;

						const clearColor = background.getClearColor();
						const a = background.getClearAlpha();
						const r = clearColor.r;
						const g = clearColor.g;
						const b = clearColor.b;

						if ( isUnsignedType ) {

							uintClearColor[ 0 ] = r;
							uintClearColor[ 1 ] = g;
							uintClearColor[ 2 ] = b;
							uintClearColor[ 3 ] = a;
							_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );

						} else {

							intClearColor[ 0 ] = r;
							intClearColor[ 1 ] = g;
							intClearColor[ 2 ] = b;
							intClearColor[ 3 ] = a;
							_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );

						}

					} else {

						bits |= _gl.COLOR_BUFFER_BIT;

					}

				}

				if ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

				_gl.clear( bits );

			};

			this.clearColor = function () {

				this.clear( true, false, false );

			};

			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			//

			this.dispose = function () {

				canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
				canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
				canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

				renderLists.dispose();
				renderStates.dispose();
				properties.dispose();
				cubemaps.dispose();
				cubeuvmaps.dispose();
				objects.dispose();
				bindingStates.dispose();
				uniformsGroups.dispose();
				programCache.dispose();

				xr.dispose();

				xr.removeEventListener( 'sessionstart', onXRSessionStart );
				xr.removeEventListener( 'sessionend', onXRSessionEnd );

				if ( _transmissionRenderTarget ) {

					_transmissionRenderTarget.dispose();
					_transmissionRenderTarget = null;

				}

				animation.stop();

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				console.log( 'THREE.WebGLRenderer: Context Lost.' );

				_isContextLost = true;

			}

			function onContextRestore( /* event */ ) {

				console.log( 'THREE.WebGLRenderer: Context Restored.' );

				_isContextLost = false;

				const infoAutoReset = info.autoReset;
				const shadowMapEnabled = shadowMap.enabled;
				const shadowMapAutoUpdate = shadowMap.autoUpdate;
				const shadowMapNeedsUpdate = shadowMap.needsUpdate;
				const shadowMapType = shadowMap.type;

				initGLContext();

				info.autoReset = infoAutoReset;
				shadowMap.enabled = shadowMapEnabled;
				shadowMap.autoUpdate = shadowMapAutoUpdate;
				shadowMap.needsUpdate = shadowMapNeedsUpdate;
				shadowMap.type = shadowMapType;

			}

			function onContextCreationError( event ) {

				console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

			}

			function onMaterialDispose( event ) {

				const material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReferences( material );

				properties.remove( material );

			}


			function releaseMaterialProgramReferences( material ) {

				const programs = properties.get( material ).programs;

				if ( programs !== undefined ) {

					programs.forEach( function ( program ) {

						programCache.releaseProgram( program );

					} );

					if ( material.isShaderMaterial ) {

						programCache.releaseShaderCache( material );

					}

				}

			}

			// Buffer rendering

			this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

				if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

				const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				const program = setProgram( camera, scene, geometry, material, object );

				state.setMaterial( material, frontFaceCW );

				//

				let index = geometry.index;
				let rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = geometries.getWireframeAttribute( geometry );
					rangeFactor = 2;

				}

				//

				const drawRange = geometry.drawRange;
				const position = geometry.attributes.position;

				let drawStart = drawRange.start * rangeFactor;
				let drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;

				if ( group !== null ) {

					drawStart = Math.max( drawStart, group.start * rangeFactor );
					drawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );

				}

				if ( index !== null ) {

					drawStart = Math.max( drawStart, 0 );
					drawEnd = Math.min( drawEnd, index.count );

				} else if ( position !== undefined && position !== null ) {

					drawStart = Math.max( drawStart, 0 );
					drawEnd = Math.min( drawEnd, position.count );

				}

				const drawCount = drawEnd - drawStart;

				if ( drawCount < 0 || drawCount === Infinity ) return;

				//

				bindingStates.setup( object, material, program, geometry, index );

				let attribute;
				let renderer = bufferRenderer;

				if ( index !== null ) {

					attribute = attributes.get( index );

					renderer = indexedBufferRenderer;
					renderer.setIndex( attribute );

				}

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );

					} else {

						renderer.setMode( _gl.TRIANGLES );

					}

				} else if ( object.isLine ) {

					let lineWidth = material.linewidth;

					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( _gl.LINES );

					} else if ( object.isLineLoop ) {

						renderer.setMode( _gl.LINE_LOOP );

					} else {

						renderer.setMode( _gl.LINE_STRIP );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( _gl.POINTS );

				} else if ( object.isSprite ) {

					renderer.setMode( _gl.TRIANGLES );

				}

				if ( object.isInstancedMesh ) {

					renderer.renderInstances( drawStart, drawCount, object.count );

				} else if ( geometry.isInstancedBufferGeometry ) {

					const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
					const instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );

					renderer.renderInstances( drawStart, drawCount, instanceCount );

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			// Compile

			this.compile = function ( scene, camera ) {

				function prepare( material, scene, object ) {

					if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

						material.side = BackSide;
						material.needsUpdate = true;
						getProgram( material, scene, object );

						material.side = FrontSide;
						material.needsUpdate = true;
						getProgram( material, scene, object );

						material.side = DoubleSide;

					} else {

						getProgram( material, scene, object );

					}

				}

				currentRenderState = renderStates.get( scene );
				currentRenderState.init();

				renderStateStack.push( currentRenderState );

				scene.traverseVisible( function ( object ) {

					if ( object.isLight && object.layers.test( camera.layers ) ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					}

				} );

				currentRenderState.setupLights( _this.useLegacyLights );

				scene.traverse( function ( object ) {

					const material = object.material;

					if ( material ) {

						if ( Array.isArray( material ) ) {

							for ( let i = 0; i < material.length; i ++ ) {

								const material2 = material[ i ];

								prepare( material2, scene, object );

							}

						} else {

							prepare( material, scene, object );

						}

					}

				} );

				renderStateStack.pop();
				currentRenderState = null;

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time ) {

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

			}

			function onXRSessionStart() {

				animation.stop();

			}

			function onXRSessionEnd() {

				animation.start();

			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop( onAnimationFrame );

			if ( typeof self !== 'undefined' ) animation.setContext( self );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;
				xr.setAnimationLoop( callback );

				( callback === null ) ? animation.stop() : animation.start();

			};

			xr.addEventListener( 'sessionstart', onXRSessionStart );
			xr.addEventListener( 'sessionend', onXRSessionEnd );

			// Rendering

			this.render = function ( scene, camera ) {

				if ( camera !== undefined && camera.isCamera !== true ) {

					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;

				}

				if ( _isContextLost === true ) return;

				// update scene graph

				if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

				// update camera matrices and frustum

				if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

				if ( xr.enabled === true && xr.isPresenting === true ) {

					if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

					camera = xr.getCamera(); // use XR camera for rendering

				}

				//
				if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

				currentRenderState = renderStates.get( scene, renderStateStack.length );
				currentRenderState.init();

				renderStateStack.push( currentRenderState );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromProjectionMatrix( _projScreenMatrix );

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );

				currentRenderList = renderLists.get( scene, renderListStack.length );
				currentRenderList.init();

				renderListStack.push( currentRenderList );

				projectObject( scene, camera, 0, _this.sortObjects );

				currentRenderList.finish();

				if ( _this.sortObjects === true ) {

					currentRenderList.sort( _opaqueSort, _transparentSort );

				}

				//

				this.info.render.frame ++;

				if ( _clippingEnabled === true ) clipping.beginShadows();

				const shadowsArray = currentRenderState.state.shadowsArray;

				shadowMap.render( shadowsArray, scene, camera );

				if ( _clippingEnabled === true ) clipping.endShadows();

				//

				if ( this.info.autoReset === true ) this.info.reset();


				//

				background.render( currentRenderList, scene );

				// render scene

				currentRenderState.setupLights( _this.useLegacyLights );

				if ( camera.isArrayCamera ) {

					const cameras = camera.cameras;

					for ( let i = 0, l = cameras.length; i < l; i ++ ) {

						const camera2 = cameras[ i ];

						renderScene( currentRenderList, scene, camera2, camera2.viewport );

					}

				} else {

					renderScene( currentRenderList, scene, camera );

				}

				//

				if ( _currentRenderTarget !== null ) {

					// resolve multisample renderbuffers to a single-sample texture if necessary

					textures.updateMultisampleRenderTarget( _currentRenderTarget );

					// Generate mipmap if we're using any kind of mipmap filtering

					textures.updateRenderTargetMipmap( _currentRenderTarget );

				}

				//

				if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

				// _gl.finish();

				bindingStates.resetDefaultState();
				_currentMaterialId = - 1;
				_currentCamera = null;

				renderStateStack.pop();

				if ( renderStateStack.length > 0 ) {

					currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

				} else {

					currentRenderState = null;

				}

				renderListStack.pop();

				if ( renderListStack.length > 0 ) {

					currentRenderList = renderListStack[ renderListStack.length - 1 ];

				} else {

					currentRenderList = null;

				}

			};

			function projectObject( object, camera, groupOrder, sortObjects ) {

				if ( object.visible === false ) return;

				const visible = object.layers.test( camera.layers );

				if ( visible ) {

					if ( object.isGroup ) {

						groupOrder = object.renderOrder;

					} else if ( object.isLOD ) {

						if ( object.autoUpdate === true ) object.update( camera );

					} else if ( object.isLight ) {

						currentRenderState.pushLight( object );

						if ( object.castShadow ) {

							currentRenderState.pushShadow( object );

						}

					} else if ( object.isSprite ) {

						if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

							if ( sortObjects ) {

								_vector3.setFromMatrixPosition( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							const geometry = objects.update( object );
							const material = object.material;

							if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

							}

						}

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

							const geometry = objects.update( object );
							const material = object.material;

							if ( sortObjects ) {

								if ( object.boundingSphere !== undefined ) {

									if ( object.boundingSphere === null ) object.computeBoundingSphere();
									_vector3.copy( object.boundingSphere.center );

								} else {

									if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
									_vector3.copy( geometry.boundingSphere.center );

								}

								_vector3
									.applyMatrix4( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );

							}

							if ( Array.isArray( material ) ) {

								const groups = geometry.groups;

								for ( let i = 0, l = groups.length; i < l; i ++ ) {

									const group = groups[ i ];
									const groupMaterial = material[ group.materialIndex ];

									if ( groupMaterial && groupMaterial.visible ) {

										currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

									}

								}

							} else if ( material.visible ) {

								currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

							}

						}

					}

				}

				const children = object.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, groupOrder, sortObjects );

				}

			}

			function renderScene( currentRenderList, scene, camera, viewport ) {

				const opaqueObjects = currentRenderList.opaque;
				const transmissiveObjects = currentRenderList.transmissive;
				const transparentObjects = currentRenderList.transparent;

				currentRenderState.setupLightsView( camera );

				if ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );

				if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );

				if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

				if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
				if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
				if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.buffers.depth.setTest( true );
				state.buffers.depth.setMask( true );
				state.buffers.color.setMask( true );

				state.setPolygonOffset( false );

			}

			function renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {

				const isWebGL2 = capabilities.isWebGL2;

				if ( _transmissionRenderTarget === null ) {

					_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
						generateMipmaps: true,
						type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
						minFilter: LinearMipmapLinearFilter,
						samples: ( isWebGL2 ) ? 4 : 0
					} );

					// debug

					/*
					const geometry = new PlaneGeometry();
					const material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );

					const mesh = new Mesh( geometry, material );
					scene.add( mesh );
					*/

				}

				_this.getDrawingBufferSize( _vector2 );

				if ( isWebGL2 ) {

					_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

				} else {

					_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

				}

				//

				const currentRenderTarget = _this.getRenderTarget();
				_this.setRenderTarget( _transmissionRenderTarget );

				_this.getClearColor( _currentClearColor );
				_currentClearAlpha = _this.getClearAlpha();
				if ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );

				_this.clear();

				// Turn off the features which can affect the frag color for opaque objects pass.
				// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
				const currentToneMapping = _this.toneMapping;
				_this.toneMapping = NoToneMapping;

				renderObjects( opaqueObjects, scene, camera );

				textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
				textures.updateRenderTargetMipmap( _transmissionRenderTarget );

				let renderTargetNeedsUpdate = false;

				for ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {

					const renderItem = transmissiveObjects[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = renderItem.material;
					const group = renderItem.group;

					if ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {

						const currentSide = material.side;

						material.side = BackSide;
						material.needsUpdate = true;

						renderObject( object, scene, camera, geometry, material, group );

						material.side = currentSide;
						material.needsUpdate = true;

						renderTargetNeedsUpdate = true;

					}

				}

				if ( renderTargetNeedsUpdate === true ) {

					textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
					textures.updateRenderTargetMipmap( _transmissionRenderTarget );

				}

				_this.setRenderTarget( currentRenderTarget );

				_this.setClearColor( _currentClearColor, _currentClearAlpha );

				_this.toneMapping = currentToneMapping;

			}

			function renderObjects( renderList, scene, camera ) {

				const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

				for ( let i = 0, l = renderList.length; i < l; i ++ ) {

					const renderItem = renderList[ i ];

					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
					const group = renderItem.group;

					if ( object.layers.test( camera.layers ) ) {

						renderObject( object, scene, camera, geometry, material, group );

					}

				}

			}

			function renderObject( object, scene, camera, geometry, material, group ) {

				object.onBeforeRender( _this, scene, camera, geometry, material, group );

				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

				material.onBeforeRender( _this, scene, camera, geometry, object, group );

				if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

					material.side = BackSide;
					material.needsUpdate = true;
					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

					material.side = FrontSide;
					material.needsUpdate = true;
					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

					material.side = DoubleSide;

				} else {

					_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				}

				object.onAfterRender( _this, scene, camera, geometry, material, group );

			}

			function getProgram( material, scene, object ) {

				if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

				const materialProperties = properties.get( material );

				const lights = currentRenderState.state.lights;
				const shadowsArray = currentRenderState.state.shadowsArray;

				const lightsStateVersion = lights.state.version;

				const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
				const programCacheKey = programCache.getProgramCacheKey( parameters );

				let programs = materialProperties.programs;

				// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

				materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
				materialProperties.fog = scene.fog;
				materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

				if ( programs === undefined ) {

					// new material

					material.addEventListener( 'dispose', onMaterialDispose );

					programs = new Map();
					materialProperties.programs = programs;

				}

				let program = programs.get( programCacheKey );

				if ( program !== undefined ) {

					// early out if program and light state is identical

					if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

						updateCommonMaterialProperties( material, parameters );

						return program;

					}

				} else {

					parameters.uniforms = programCache.getUniforms( material );

					material.onBuild( object, parameters, _this );

					material.onBeforeCompile( parameters, _this );

					program = programCache.acquireProgram( parameters, programCacheKey );
					programs.set( programCacheKey, program );

					materialProperties.uniforms = parameters.uniforms;

				}

				const uniforms = materialProperties.uniforms;

				if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

					uniforms.clippingPlanes = clipping.uniform;

				}

				updateCommonMaterialProperties( material, parameters );

				// store the light setup it was created for

				materialProperties.needsLights = materialNeedsLights( material );
				materialProperties.lightsStateVersion = lightsStateVersion;

				if ( materialProperties.needsLights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = lights.state.ambient;
					uniforms.lightProbe.value = lights.state.probe;
					uniforms.directionalLights.value = lights.state.directional;
					uniforms.directionalLightShadows.value = lights.state.directionalShadow;
					uniforms.spotLights.value = lights.state.spot;
					uniforms.spotLightShadows.value = lights.state.spotShadow;
					uniforms.rectAreaLights.value = lights.state.rectArea;
					uniforms.ltc_1.value = lights.state.rectAreaLTC1;
					uniforms.ltc_2.value = lights.state.rectAreaLTC2;
					uniforms.pointLights.value = lights.state.point;
					uniforms.pointLightShadows.value = lights.state.pointShadow;
					uniforms.hemisphereLights.value = lights.state.hemi;

					uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
					uniforms.spotShadowMap.value = lights.state.spotShadowMap;
					uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
					uniforms.spotLightMap.value = lights.state.spotLightMap;
					uniforms.pointShadowMap.value = lights.state.pointShadowMap;
					uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms

				}

				const progUniforms = program.getUniforms();
				const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

				materialProperties.currentProgram = program;
				materialProperties.uniformsList = uniformsList;

				return program;

			}

			function updateCommonMaterialProperties( material, parameters ) {

				const materialProperties = properties.get( material );

				materialProperties.outputColorSpace = parameters.outputColorSpace;
				materialProperties.instancing = parameters.instancing;
				materialProperties.skinning = parameters.skinning;
				materialProperties.morphTargets = parameters.morphTargets;
				materialProperties.morphNormals = parameters.morphNormals;
				materialProperties.morphColors = parameters.morphColors;
				materialProperties.morphTargetsCount = parameters.morphTargetsCount;
				materialProperties.numClippingPlanes = parameters.numClippingPlanes;
				materialProperties.numIntersection = parameters.numClipIntersection;
				materialProperties.vertexAlphas = parameters.vertexAlphas;
				materialProperties.vertexTangents = parameters.vertexTangents;
				materialProperties.toneMapping = parameters.toneMapping;

			}

			function setProgram( camera, scene, geometry, material, object ) {

				if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

				textures.resetTextureUnits();

				const fog = scene.fog;
				const environment = material.isMeshStandardMaterial ? scene.environment : null;
				const colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );
				const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
				const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
				const vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );
				const morphTargets = !! geometry.morphAttributes.position;
				const morphNormals = !! geometry.morphAttributes.normal;
				const morphColors = !! geometry.morphAttributes.color;
				const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				const materialProperties = properties.get( material );
				const lights = currentRenderState.state.lights;

				if ( _clippingEnabled === true ) {

					if ( _localClippingEnabled === true || camera !== _currentCamera ) {

						const useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						clipping.setState( material, camera, useCache );

					}

				}

				//

				let needsProgramChange = false;

				if ( material.version === materialProperties.__version ) {

					if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

						needsProgramChange = true;

					} else if ( materialProperties.outputColorSpace !== colorSpace ) {

						needsProgramChange = true;

					} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

						needsProgramChange = true;

					} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

						needsProgramChange = true;

					} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

						needsProgramChange = true;

					} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

						needsProgramChange = true;

					} else if ( materialProperties.envMap !== envMap ) {

						needsProgramChange = true;

					} else if ( material.fog === true && materialProperties.fog !== fog ) {

						needsProgramChange = true;

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== clipping.numPlanes ||
						materialProperties.numIntersection !== clipping.numIntersection ) ) {

						needsProgramChange = true;

					} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

						needsProgramChange = true;

					} else if ( materialProperties.vertexTangents !== vertexTangents ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphTargets !== morphTargets ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphNormals !== morphNormals ) {

						needsProgramChange = true;

					} else if ( materialProperties.morphColors !== morphColors ) {

						needsProgramChange = true;

					} else if ( materialProperties.toneMapping !== toneMapping ) {

						needsProgramChange = true;

					} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

						needsProgramChange = true;

					}

				} else {

					needsProgramChange = true;
					materialProperties.__version = material.version;

				}

				//

				let program = materialProperties.currentProgram;

				if ( needsProgramChange === true ) {

					program = getProgram( material, scene, object );

				}

				let refreshProgram = false;
				let refreshMaterial = false;
				let refreshLights = false;

				const p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.uniforms;

				if ( state.useProgram( program.program ) ) {

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || _currentCamera !== camera ) {

					p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}

					if ( _currentCamera !== camera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)

					if ( material.isShaderMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshStandardMaterial ||
						material.envMap ) {

						const uCamPos = p_uniforms.map.cameraPosition;

						if ( uCamPos !== undefined ) {

							uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );

						}

					}

					if ( material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ) {

						p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

					}

					if ( material.isMeshPhongMaterial ||
						material.isMeshToonMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ||
						material.isShadowMaterial ||
						object.isSkinnedMesh ) {

						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					}

				}

				// skinning and morph target uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone and morph texture must go before other textures
				// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

				if ( object.isSkinnedMesh ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					const skeleton = object.skeleton;

					if ( skeleton ) {

						if ( capabilities.floatVertexTextures ) {

							if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

							p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
							p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

						} else {

							console.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );

						}

					}

				}

				const morphAttributes = geometry.morphAttributes;

				if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

					morphtargets.update( object, geometry, program );

				}

				if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

					materialProperties.receiveShadow = object.receiveShadow;
					p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

				}

				// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512

				if ( material.isMeshGouraudMaterial && material.envMap !== null ) {

					m_uniforms.envMap.value = envMap;

					m_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

				}

				if ( refreshMaterial ) {

					p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

					if ( materialProperties.needsLights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog === true ) {

						materials.refreshFogUniforms( m_uniforms, fog );

					}

					materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

					WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

				}

				if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

					WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
					material.uniformsNeedUpdate = false;

				}

				if ( material.isSpriteMaterial ) {

					p_uniforms.setValue( _gl, 'center', object.center );

				}

				// common matrices

				p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
				p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				// UBOs

				if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

					const groups = material.uniformsGroups;

					for ( let i = 0, l = groups.length; i < l; i ++ ) {

						if ( capabilities.isWebGL2 ) {

							const group = groups[ i ];

							uniformsGroups.update( group, program );
							uniformsGroups.bind( group, program );

						} else {

							console.warn( 'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.' );

						}

					}

				}

				return program;

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;
				uniforms.lightProbe.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.directionalLightShadows.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.pointLightShadows.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.spotLightShadows.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			function materialNeedsLights( material ) {

				return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial || material.isShadowMaterial ||
					( material.isShaderMaterial && material.lights === true );

			}

			this.getActiveCubeFace = function () {

				return _currentActiveCubeFace;

			};

			this.getActiveMipmapLevel = function () {

				return _currentActiveMipmapLevel;

			};

			this.getRenderTarget = function () {

				return _currentRenderTarget;

			};

			this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

				properties.get( renderTarget.texture ).__webglTexture = colorTexture;
				properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

				const renderTargetProperties = properties.get( renderTarget );
				renderTargetProperties.__hasExternalTextures = true;

				if ( renderTargetProperties.__hasExternalTextures ) {

					renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

					if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

						// The multisample_render_to_texture extension doesn't work properly if there
						// are midframe flushes and an external depth buffer. Disable use of the extension.
						if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

							console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
							renderTargetProperties.__useRenderToTexture = false;

						}

					}

				}

			};

			this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

				const renderTargetProperties = properties.get( renderTarget );
				renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
				renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

			};

			this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

				_currentRenderTarget = renderTarget;
				_currentActiveCubeFace = activeCubeFace;
				_currentActiveMipmapLevel = activeMipmapLevel;

				let useDefaultFramebuffer = true;
				let framebuffer = null;
				let isCube = false;
				let isRenderTarget3D = false;

				if ( renderTarget ) {

					const renderTargetProperties = properties.get( renderTarget );

					if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

						// We need to make sure to rebind the framebuffer.
						state.bindFramebuffer( _gl.FRAMEBUFFER, null );
						useDefaultFramebuffer = false;

					} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

						textures.setupRenderTarget( renderTarget );

					} else if ( renderTargetProperties.__hasExternalTextures ) {

						// Color and depth texture must be rebound in order for the swapchain to update.
						textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

					}

					const texture = renderTarget.texture;

					if ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

						isRenderTarget3D = true;

					}

					const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

					if ( renderTarget.isWebGLCubeRenderTarget ) {

						framebuffer = __webglFramebuffer[ activeCubeFace ];
						isCube = true;

					} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

						framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

					} else {

						framebuffer = __webglFramebuffer;

					}

					_currentViewport.copy( renderTarget.viewport );
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

				} else {

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
					_currentScissorTest = _scissorTest;

				}

				const framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

					state.drawBuffers( renderTarget, framebuffer );

				}

				state.viewport( _currentViewport );
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				if ( isCube ) {

					const textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

				} else if ( isRenderTarget3D ) {

					const textureProperties = properties.get( renderTarget.texture );
					const layer = activeCubeFace || 0;
					_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

				}

				_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

			};

			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

				if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;

				}

				let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

					framebuffer = framebuffer[ activeCubeFaceIndex ];

				}

				if ( framebuffer ) {

					state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					try {

						const texture = renderTarget.texture;
						const textureFormat = texture.format;
						const textureType = texture.type;

						if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;

						}

						const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

						if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! halfFloatSupportedByExt ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;

						}

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} finally {

						// restore framebuffer of current render target if necessary

						const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
						state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					}

				}

			};

			this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

				const levelScale = Math.pow( 2, - level );
				const width = Math.floor( texture.image.width * levelScale );
				const height = Math.floor( texture.image.height * levelScale );

				textures.setTexture2D( texture, 0 );

				_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );

				state.unbindTexture();

			};

			this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

				const width = srcTexture.image.width;
				const height = srcTexture.image.height;
				const glFormat = utils.convert( dstTexture.format );
				const glType = utils.convert( dstTexture.type );

				textures.setTexture2D( dstTexture, 0 );

				// As another texture upload may have changed pixelStorei
				// parameters, make sure they are correct for the dstTexture
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

				if ( srcTexture.isDataTexture ) {

					_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

				} else {

					if ( srcTexture.isCompressedTexture ) {

						_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

					} else {

						_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

					}

				}

				// Generate mipmaps only when copying level 0
				if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

				state.unbindTexture();

			};

			this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

				if ( _this.isWebGL1Renderer ) {

					console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
					return;

				}

				const width = sourceBox.max.x - sourceBox.min.x + 1;
				const height = sourceBox.max.y - sourceBox.min.y + 1;
				const depth = sourceBox.max.z - sourceBox.min.z + 1;
				const glFormat = utils.convert( dstTexture.format );
				const glType = utils.convert( dstTexture.type );
				let glTarget;

				if ( dstTexture.isData3DTexture ) {

					textures.setTexture3D( dstTexture, 0 );
					glTarget = _gl.TEXTURE_3D;

				} else if ( dstTexture.isDataArrayTexture ) {

					textures.setTexture2DArray( dstTexture, 0 );
					glTarget = _gl.TEXTURE_2D_ARRAY;

				} else {

					console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
					return;

				}

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

				const unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
				const unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
				const unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
				const unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
				const unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

				const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );
				_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );
				_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );

				if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

					_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

				} else {

					if ( srcTexture.isCompressedArrayTexture ) {

						console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
						_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

					} else {

						_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

					}

				}

				_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );
				_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );
				_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );
				_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );
				_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );

				// Generate mipmaps only when copying level 0
				if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

				state.unbindTexture();

			};

			this.initTexture = function ( texture ) {

				if ( texture.isCubeTexture ) {

					textures.setTextureCube( texture, 0 );

				} else if ( texture.isData3DTexture ) {

					textures.setTexture3D( texture, 0 );

				} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

					textures.setTexture2DArray( texture, 0 );

				} else {

					textures.setTexture2D( texture, 0 );

				}

				state.unbindTexture();

			};

			this.resetState = function () {

				_currentActiveCubeFace = 0;
				_currentActiveMipmapLevel = 0;
				_currentRenderTarget = null;

				state.reset();
				bindingStates.reset();

			};

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		get coordinateSystem() {

			return WebGLCoordinateSystem;

		}

		get physicallyCorrectLights() { // @deprecated, r150

			console.warn( 'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.' );
			return ! this.useLegacyLights;

		}

		set physicallyCorrectLights( value ) { // @deprecated, r150

			console.warn( 'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.' );
			this.useLegacyLights = ! value;

		}

		get outputEncoding() { // @deprecated, r152

			console.warn( 'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.' );
			return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;

		}

		set outputEncoding( encoding ) { // @deprecated, r152

			console.warn( 'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.' );
			this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;

		}

	}

	class WebGL1Renderer extends WebGLRenderer {}

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	class FogExp2 {

		constructor( color, density = 0.00025 ) {

			this.isFogExp2 = true;

			this.name = '';

			this.color = new Color( color );
			this.density = density;

		}

		clone() {

			return new FogExp2( this.color, this.density );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	}

	class Fog {

		constructor( color, near = 1, far = 1000 ) {

			this.isFog = true;

			this.name = '';

			this.color = new Color( color );

			this.near = near;
			this.far = far;

		}

		clone() {

			return new Fog( this.color, this.near, this.far );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		}

	}

	class Scene extends Object3D {

		constructor() {

			super();

			this.isScene = true;

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.backgroundBlurriness = 0;
			this.backgroundIntensity = 1;

			this.overrideMaterial = null;

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			this.backgroundBlurriness = source.backgroundBlurriness;
			this.backgroundIntensity = source.backgroundIntensity;

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
			if ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;
			if ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;

			return data;

		}

	}

	class InterleavedBuffer {

		constructor( array, stride ) {

			this.isInterleavedBuffer = true;

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

			this.uuid = generateUUID();

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( let i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		set( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		}

		clone( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			const ib = new this.constructor( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		toJSON( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	}

	const _vector$5 = /*@__PURE__*/ new Vector3();

	class InterleavedBufferAttribute {

		constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

			this.isInterleavedBufferAttribute = true;

			this.name = '';

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized;

		}

		get count() {

			return this.data.count;

		}

		get array() {

			return this.data.array;

		}

		set needsUpdate( value ) {

			this.data.needsUpdate = value;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$5.fromBufferAttribute( this, i );

				_vector$5.applyMatrix4( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$5.fromBufferAttribute( this, i );

				_vector$5.applyNormalMatrix( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$5.fromBufferAttribute( this, i );

				_vector$5.transformDirection( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		}

		setX( index, x ) {

			if ( this.normalized ) x = normalize( x, this.array );

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		}

		setY( index, y ) {

			if ( this.normalized ) y = normalize( y, this.array );

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		}

		setZ( index, z ) {

			if ( this.normalized ) z = normalize( z, this.array );

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		}

		setW( index, w ) {

			if ( this.normalized ) w = normalize( w, this.array );

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		}

		getX( index ) {

			let x = this.data.array[ index * this.data.stride + this.offset ];

			if ( this.normalized ) x = denormalize( x, this.array );

			return x;

		}

		getY( index ) {

			let y = this.data.array[ index * this.data.stride + this.offset + 1 ];

			if ( this.normalized ) y = denormalize( y, this.array );

			return y;

		}

		getZ( index ) {

			let z = this.data.array[ index * this.data.stride + this.offset + 2 ];

			if ( this.normalized ) z = denormalize( z, this.array );

			return z;

		}

		getW( index ) {

			let w = this.data.array[ index * this.data.stride + this.offset + 3 ];

			if ( this.normalized ) w = denormalize( w, this.array );

			return w;

		}

		setXY( index, x, y ) {

			index = index * this.data.stride + this.offset;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );

			}

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );

			}

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			if ( this.normalized ) {

				x = normalize( x, this.array );
				y = normalize( y, this.array );
				z = normalize( z, this.array );
				w = normalize( w, this.array );

			}

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

		clone( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		}

		toJSON( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// de-interleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interleaved attribute

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	}

	class SpriteMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isSpriteMaterial = true;

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.rotation = 0;

			this.sizeAttenuation = true;

			this.transparent = true;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.rotation = source.rotation;

			this.sizeAttenuation = source.sizeAttenuation;

			this.fog = source.fog;

			return this;

		}

	}

	let _geometry;

	const _intersectPoint = /*@__PURE__*/ new Vector3();
	const _worldScale = /*@__PURE__*/ new Vector3();
	const _mvPosition = /*@__PURE__*/ new Vector3();

	const _alignedPosition = /*@__PURE__*/ new Vector2();
	const _rotatedPosition = /*@__PURE__*/ new Vector2();
	const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

	const _vA = /*@__PURE__*/ new Vector3();
	const _vB = /*@__PURE__*/ new Vector3();
	const _vC = /*@__PURE__*/ new Vector3();

	const _uvA = /*@__PURE__*/ new Vector2();
	const _uvB = /*@__PURE__*/ new Vector2();
	const _uvC = /*@__PURE__*/ new Vector2();

	class Sprite extends Object3D {

		constructor( material ) {

			super();

			this.isSprite = true;

			this.type = 'Sprite';

			if ( _geometry === undefined ) {

				_geometry = new BufferGeometry();

				const float32Array = new Float32Array( [
					- 0.5, - 0.5, 0, 0, 0,
					0.5, - 0.5, 0, 1, 0,
					0.5, 0.5, 0, 1, 1,
					- 0.5, 0.5, 0, 0, 1
				] );

				const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

				_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
				_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
				_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

			}

			this.geometry = _geometry;
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

			this.center = new Vector2( 0.5, 0.5 );

		}

		raycast( raycaster, intersects ) {

			if ( raycaster.camera === null ) {

				console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

			}

			_worldScale.setFromMatrixScale( this.matrixWorld );

			_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
			this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

			_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

			if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

				_worldScale.multiplyScalar( - _mvPosition.z );

			}

			const rotation = this.material.rotation;
			let sin, cos;

			if ( rotation !== 0 ) {

				cos = Math.cos( rotation );
				sin = Math.sin( rotation );

			}

			const center = this.center;

			transformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			transformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			transformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

			_uvA.set( 0, 0 );
			_uvB.set( 1, 0 );
			_uvC.set( 1, 1 );

			// check first triangle
			let intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );

			if ( intersect === null ) {

				// check second triangle
				transformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
				_uvB.set( 0, 1 );

				intersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );
				if ( intersect === null ) {

					return;

				}

			}

			const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),
				face: null,
				object: this

			} );

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.center !== undefined ) this.center.copy( source.center );

			this.material = source.material;

			return this;

		}

	}

	function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

		// compute position in camera space
		_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

		// to check if rotation is not zero
		if ( sin !== undefined ) {

			_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
			_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

		} else {

			_rotatedPosition.copy( _alignedPosition );

		}


		vertexPosition.copy( mvPosition );
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y;

		// transform to world space
		vertexPosition.applyMatrix4( _viewWorldMatrix );

	}

	const _v1$2 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();

	class LOD extends Object3D {

		constructor() {

			super();

			this._currentLevel = 0;

			this.type = 'LOD';

			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true,
				}
			} );

			this.autoUpdate = true;

		}

		copy( source ) {

			super.copy( source, false );

			const levels = source.levels;

			for ( let i = 0, l = levels.length; i < l; i ++ ) {

				const level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance, level.hysteresis );

			}

			this.autoUpdate = source.autoUpdate;

			return this;

		}

		addLevel( object, distance = 0, hysteresis = 0 ) {

			distance = Math.abs( distance );

			const levels = this.levels;

			let l;

			for ( l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );

			this.add( object );

			return this;

		}

		getCurrentLevel() {

			return this._currentLevel;

		}



		getObjectForDistance( distance ) {

			const levels = this.levels;

			if ( levels.length > 0 ) {

				let i, l;

				for ( i = 1, l = levels.length; i < l; i ++ ) {

					let levelDistance = levels[ i ].distance;

					if ( levels[ i ].object.visible ) {

						levelDistance -= levelDistance * levels[ i ].hysteresis;

					}

					if ( distance < levelDistance ) {

						break;

					}

				}

				return levels[ i - 1 ].object;

			}

			return null;

		}

		raycast( raycaster, intersects ) {

			const levels = this.levels;

			if ( levels.length > 0 ) {

				_v1$2.setFromMatrixPosition( this.matrixWorld );

				const distance = raycaster.ray.origin.distanceTo( _v1$2 );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			}

		}

		update( camera ) {

			const levels = this.levels;

			if ( levels.length > 1 ) {

				_v1$2.setFromMatrixPosition( camera.matrixWorld );
				_v2$1.setFromMatrixPosition( this.matrixWorld );

				const distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;

				levels[ 0 ].object.visible = true;

				let i, l;

				for ( i = 1, l = levels.length; i < l; i ++ ) {

					let levelDistance = levels[ i ].distance;

					if ( levels[ i ].object.visible ) {

						levelDistance -= levelDistance * levels[ i ].hysteresis;

					}

					if ( distance >= levelDistance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				this._currentLevel = i - 1;

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.autoUpdate === false ) data.object.autoUpdate = false;

			data.object.levels = [];

			const levels = this.levels;

			for ( let i = 0, l = levels.length; i < l; i ++ ) {

				const level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance,
					hysteresis: level.hysteresis
				} );

			}

			return data;

		}

	}

	const _basePosition = /*@__PURE__*/ new Vector3();

	const _skinIndex = /*@__PURE__*/ new Vector4();
	const _skinWeight = /*@__PURE__*/ new Vector4();

	const _vector3 = /*@__PURE__*/ new Vector3();
	const _matrix4 = /*@__PURE__*/ new Matrix4();
	const _vertex = /*@__PURE__*/ new Vector3();

	const _sphere$3 = /*@__PURE__*/ new Sphere();
	const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
	const _ray$2 = /*@__PURE__*/ new Ray();

	class SkinnedMesh extends Mesh {

		constructor( geometry, material ) {

			super( geometry, material );

			this.isSkinnedMesh = true;

			this.type = 'SkinnedMesh';

			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();

			this.boundingBox = null;
			this.boundingSphere = null;

		}

		computeBoundingBox() {

			const geometry = this.geometry;

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.makeEmpty();

			const positionAttribute = geometry.getAttribute( 'position' );

			for ( let i = 0; i < positionAttribute.count; i ++ ) {

				_vertex.fromBufferAttribute( positionAttribute, i );
				this.applyBoneTransform( i, _vertex );
				this.boundingBox.expandByPoint( _vertex );

			}

		}

		computeBoundingSphere() {

			const geometry = this.geometry;

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.makeEmpty();

			const positionAttribute = geometry.getAttribute( 'position' );

			for ( let i = 0; i < positionAttribute.count; i ++ ) {

				_vertex.fromBufferAttribute( positionAttribute, i );
				this.applyBoneTransform( i, _vertex );
				this.boundingSphere.expandByPoint( _vertex );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.bindMode = source.bindMode;
			this.bindMatrix.copy( source.bindMatrix );
			this.bindMatrixInverse.copy( source.bindMatrixInverse );

			this.skeleton = source.skeleton;

			if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
			if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

			return this;

		}

		raycast( raycaster, intersects ) {

			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// test with bounding sphere in world space

			if ( this.boundingSphere === null ) this.computeBoundingSphere();

			_sphere$3.copy( this.boundingSphere );
			_sphere$3.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

			// convert ray to local space of skinned mesh

			_inverseMatrix$2.copy( matrixWorld ).invert();
			_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

			// test with bounding box in local space

			if ( this.boundingBox !== null ) {

				if ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;

			}

			// test for intersections with geometry

			this._computeIntersections( raycaster, intersects, _ray$2 );

		}

		getVertexPosition( index, target ) {

			super.getVertexPosition( index, target );

			this.applyBoneTransform( index, target );

			return target;

		}

		bind( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.copy( bindMatrix ).invert();

		}

		pose() {

			this.skeleton.pose();

		}

		normalizeSkinWeights() {

			const vector = new Vector4();

			const skinWeight = this.geometry.attributes.skinWeight;

			for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

				vector.fromBufferAttribute( skinWeight, i );

				const scale = 1.0 / vector.manhattanLength();

				if ( scale !== Infinity ) {

					vector.multiplyScalar( scale );

				} else {

					vector.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

			}

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.copy( this.matrixWorld ).invert();

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.copy( this.bindMatrix ).invert();

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		}

		applyBoneTransform( index, vector ) {

			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );

			vector.set( 0, 0, 0 );

			for ( let i = 0; i < 4; i ++ ) {

				const weight = _skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					const boneIndex = _skinIndex.getComponent( i );

					_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					vector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );

				}

			}

			return vector.applyMatrix4( this.bindMatrixInverse );

		}

		boneTransform( index, vector ) { // @deprecated, r151

			console.warn( 'THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.' );
			return this.applyBoneTransform( index, vector );

		}


	}

	class Bone extends Object3D {

		constructor() {

			super();

			this.isBone = true;

			this.type = 'Bone';

		}

	}

	class DataTexture extends Texture {

		constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

			this.isDataTexture = true;

			this.image = { data: data, width: width, height: height };

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	const _offsetMatrix = /*@__PURE__*/ new Matrix4();
	const _identityMatrix = /*@__PURE__*/ new Matrix4();

	class Skeleton {

		constructor( bones = [], boneInverses = [] ) {

			this.uuid = generateUUID();

			this.bones = bones.slice( 0 );
			this.boneInverses = boneInverses;
			this.boneMatrices = null;

			this.boneTexture = null;
			this.boneTextureSize = 0;

			this.init();

		}

		init() {

			const bones = this.bones;
			const boneInverses = this.boneInverses;

			this.boneMatrices = new Float32Array( bones.length * 16 );

			// calculate inverse bone matrices if necessary

			if ( boneInverses.length === 0 ) {

				this.calculateInverses();

			} else {

				// handle special case

				if ( bones.length !== boneInverses.length ) {

					console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

					this.boneInverses = [];

					for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		calculateInverses() {

			this.boneInverses.length = 0;

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.copy( this.bones[ i ].matrixWorld ).invert();

				}

				this.boneInverses.push( inverse );

			}

		}

		pose() {

			// recover the bind-time world matrices

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.copy( bone.parent.matrixWorld ).invert();
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		}

		update() {

			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture;

			// flatten bone matrices to array

			for ( let i = 0, il = bones.length; i < il; i ++ ) {

				// compute the offset between the current and the original transform

				const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
				_offsetMatrix.toArray( boneMatrices, i * 16 );

			}

			if ( boneTexture !== null ) {

				boneTexture.needsUpdate = true;

			}

		}

		clone() {

			return new Skeleton( this.bones, this.boneInverses );

		}

		computeBoneTexture() {

			// layout (1 matrix = 4 pixels)
			//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
			//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
			//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
			//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

			let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
			size = ceilPowerOfTwo( size );
			size = Math.max( size, 4 );

			const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
			boneMatrices.set( this.boneMatrices ); // copy current values

			const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
			boneTexture.needsUpdate = true;

			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;

			return this;

		}

		getBoneByName( name ) {

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

		dispose( ) {

			if ( this.boneTexture !== null ) {

				this.boneTexture.dispose();

				this.boneTexture = null;

			}

		}

		fromJSON( json, bones ) {

			this.uuid = json.uuid;

			for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

				const uuid = json.bones[ i ];
				let bone = bones[ uuid ];

				if ( bone === undefined ) {

					console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
					bone = new Bone();

				}

				this.bones.push( bone );
				this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

			}

			this.init();

			return this;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.6,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};

			data.uuid = this.uuid;

			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for ( let i = 0, l = bones.length; i < l; i ++ ) {

				const bone = bones[ i ];
				data.bones.push( bone.uuid );

				const boneInverse = boneInverses[ i ];
				data.boneInverses.push( boneInverse.toArray() );

			}

			return data;

		}

	}

	class InstancedBufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

			super( array, itemSize, normalized );

			this.isInstancedBufferAttribute = true;

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	}

	const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
	const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();

	const _instanceIntersects = [];

	const _box3 = /*@__PURE__*/ new Box3();
	const _identity = /*@__PURE__*/ new Matrix4();
	const _mesh = /*@__PURE__*/ new Mesh();
	const _sphere$2 = /*@__PURE__*/ new Sphere();

	class InstancedMesh extends Mesh {

		constructor( geometry, material, count ) {

			super( geometry, material );

			this.isInstancedMesh = true;

			this.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );
			this.instanceColor = null;

			this.count = count;

			this.boundingBox = null;
			this.boundingSphere = null;

			for ( let i = 0; i < count; i ++ ) {

				this.setMatrixAt( i, _identity );

			}

		}

		computeBoundingBox() {

			const geometry = this.geometry;
			const count = this.count;

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			this.boundingBox.makeEmpty();

			for ( let i = 0; i < count; i ++ ) {

				this.getMatrixAt( i, _instanceLocalMatrix );

				_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );

				this.boundingBox.union( _box3 );

			}

		}

		computeBoundingSphere() {

			const geometry = this.geometry;
			const count = this.count;

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			if ( geometry.boundingSphere === null ) {

				geometry.computeBoundingSphere();

			}

			this.boundingSphere.makeEmpty();

			for ( let i = 0; i < count; i ++ ) {

				this.getMatrixAt( i, _instanceLocalMatrix );

				_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );

				this.boundingSphere.union( _sphere$2 );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.instanceMatrix.copy( source.instanceMatrix );

			if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

			this.count = source.count;

			if ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();
			if ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();

			return this;

		}

		getColorAt( index, color ) {

			color.fromArray( this.instanceColor.array, index * 3 );

		}

		getMatrixAt( index, matrix ) {

			matrix.fromArray( this.instanceMatrix.array, index * 16 );

		}

		raycast( raycaster, intersects ) {

			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;

			_mesh.geometry = this.geometry;
			_mesh.material = this.material;

			if ( _mesh.material === undefined ) return;

			// test with bounding sphere first

			if ( this.boundingSphere === null ) this.computeBoundingSphere();

			_sphere$2.copy( this.boundingSphere );
			_sphere$2.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

			// now test each instance

			for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

				// calculate the world matrix for each instance

				this.getMatrixAt( instanceId, _instanceLocalMatrix );

				_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

				// the mesh represents this single instance

				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast( raycaster, _instanceIntersects );

				// process the result of raycast

				for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

					const intersect = _instanceIntersects[ i ];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push( intersect );

				}

				_instanceIntersects.length = 0;

			}

		}

		setColorAt( index, color ) {

			if ( this.instanceColor === null ) {

				this.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );

			}

			color.toArray( this.instanceColor.array, index * 3 );

		}

		setMatrixAt( index, matrix ) {

			matrix.toArray( this.instanceMatrix.array, index * 16 );

		}

		updateMorphTargets() {

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	class LineBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isLineBasicMaterial = true;

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			this.fog = source.fog;

			return this;

		}

	}

	const _start$1 = /*@__PURE__*/ new Vector3();
	const _end$1 = /*@__PURE__*/ new Vector3();
	const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _ray$1 = /*@__PURE__*/ new Ray();
	const _sphere$1 = /*@__PURE__*/ new Sphere();

	class Line extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

			super();

			this.isLine = true;

			this.type = 'Line';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		computeLineDistances() {

			const geometry = this.geometry;

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start$1.fromBufferAttribute( positionAttribute, i - 1 );
					_end$1.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

			return this;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );
			_sphere$1.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

			//

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

	}

	const _start = /*@__PURE__*/ new Vector3();
	const _end = /*@__PURE__*/ new Vector3();

	class LineSegments extends Line {

		constructor( geometry, material ) {

			super( geometry, material );

			this.isLineSegments = true;

			this.type = 'LineSegments';

		}

		computeLineDistances() {

			const geometry = this.geometry;

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start.fromBufferAttribute( positionAttribute, i );
					_end.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

			return this;

		}

	}

	class LineLoop extends Line {

		constructor( geometry, material ) {

			super( geometry, material );

			this.isLineLoop = true;

			this.type = 'LineLoop';

		}

	}

	class PointsMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isPointsMaterial = true;

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			this.fog = source.fog;

			return this;

		}

	}

	const _inverseMatrix = /*@__PURE__*/ new Matrix4();
	const _ray = /*@__PURE__*/ new Ray();
	const _sphere = /*@__PURE__*/ new Sphere();
	const _position$2 = /*@__PURE__*/ new Vector3();

	class Points extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

			super();

			this.isPoints = true;

			this.type = 'Points';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );
			_sphere.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i ++ ) {

					const a = index.getX( i );

					_position$2.fromBufferAttribute( positionAttribute, a );

					testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end; i < l; i ++ ) {

					_position$2.fromBufferAttribute( positionAttribute, i );

					testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

	}

	function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

		const rayPointDistanceSq = _ray.distanceSqToPoint( point );

		if ( rayPointDistanceSq < localThresholdSq ) {

			const intersectPoint = new Vector3();

			_ray.closestPointToPoint( point, intersectPoint );
			intersectPoint.applyMatrix4( matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				distanceToRay: Math.sqrt( rayPointDistanceSq ),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			} );

		}

	}

	class VideoTexture extends Texture {

		constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isVideoTexture = true;

			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

			this.generateMipmaps = false;

			const scope = this;

			function updateVideo() {

				scope.needsUpdate = true;
				video.requestVideoFrameCallback( updateVideo );

			}

			if ( 'requestVideoFrameCallback' in video ) {

				video.requestVideoFrameCallback( updateVideo );

			}

		}

		clone() {

			return new this.constructor( this.image ).copy( this );

		}

		update() {

			const video = this.image;
			const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

			if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	}

	class FramebufferTexture extends Texture {

		constructor( width, height ) {

			super( { width, height } );

			this.isFramebufferTexture = true;

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.generateMipmaps = false;

			this.needsUpdate = true;

		}

	}

	class CompressedTexture extends Texture {

		constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );

			this.isCompressedTexture = true;

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

	}

	class CompressedArrayTexture extends CompressedTexture {

		constructor( mipmaps, width, height, depth, format, type ) {

			super( mipmaps, width, height, format, type );

			this.isCompressedArrayTexture = true;
			this.image.depth = depth;
			this.wrapR = ClampToEdgeWrapping;

		}

	}

	class CanvasTexture extends Texture {

		constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isCanvasTexture = true;

			this.needsUpdate = true;

		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {

		constructor() {

			this.type = 'Curve';

			this.arcLengthDivisions = 200;

		}

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		}

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt( u, optionalTarget ) {

			const t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		}

		// Get sequence of points using getPoint( t )

		getPoints( divisions = 5 ) {

			const points = [];

			for ( let d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		}

		// Get sequence of points using getPointAt( u )

		getSpacedPoints( divisions = 5 ) {

			const points = [];

			for ( let d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		}

		// Get total curve arc length

		getLength() {

			const lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		}

		// Get list of cumulative segment lengths

		getLengths( divisions = this.arcLengthDivisions ) {

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			const cache = [];
			let current, last = this.getPoint( 0 );
			let sum = 0;

			cache.push( 0 );

			for ( let p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		}

		updateArcLengths() {

			this.needsUpdate = true;
			this.getLengths();

		}

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping( u, distance ) {

			const arcLengths = this.getLengths();

			let i = 0;
			const il = arcLengths.length;

			let targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			let low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			const lengthBefore = arcLengths[ i ];
			const lengthAfter = arcLengths[ i + 1 ];

			const segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			const t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		}

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent( t, optionalTarget ) {

			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			const pt1 = this.getPoint( t1 );
			const pt2 = this.getPoint( t2 );

			const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

			tangent.copy( pt2 ).sub( pt1 ).normalize();

			return tangent;

		}

		getTangentAt( u, optionalTarget ) {

			const t = this.getUtoTmapping( u );
			return this.getTangent( t, optionalTarget );

		}

		computeFrenetFrames( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			const normal = new Vector3();

			const tangents = [];
			const normals = [];
			const binormals = [];

			const vec = new Vector3();
			const mat = new Matrix4();

			// compute the tangent vectors for each segment on the curve

			for ( let i = 0; i <= segments; i ++ ) {

				const u = i / segments;

				tangents[ i ] = this.getTangentAt( u, new Vector3() );

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs( tangents[ 0 ].x );
			const ty = Math.abs( tangents[ 0 ].y );
			const tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( let i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					const theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				let theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( let i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.6,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		}

		fromJSON( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	}

	class EllipseCurve extends Curve {

		constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

			super();

			this.isEllipseCurve = true;

			this.type = 'EllipseCurve';

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation;

		}

		getPoint( t, optionalTarget ) {

			const point = optionalTarget || new Vector2();

			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos( angle );
			let y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				const cos = Math.cos( this.aRotation );
				const sin = Math.sin( this.aRotation );

				const tx = x - this.aX;
				const ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return point.set( x, y );

		}

		copy( source ) {

			super.copy( source );

			this.aX = source.aX;
			this.aY = source.aY;

			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;

			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;

			this.aClockwise = source.aClockwise;

			this.aRotation = source.aRotation;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.aX = this.aX;
			data.aY = this.aY;

			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;

			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;

			data.aClockwise = this.aClockwise;

			data.aRotation = this.aRotation;

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.aX = json.aX;
			this.aY = json.aY;

			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;

			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;

			this.aClockwise = json.aClockwise;

			this.aRotation = json.aRotation;

			return this;

		}

	}

	class ArcCurve extends EllipseCurve {

		constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			this.isArcCurve = true;

			this.type = 'ArcCurve';

		}

	}

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	const tmp = /*@__PURE__*/ new Vector3();
	const px = /*@__PURE__*/ new CubicPoly();
	const py = /*@__PURE__*/ new CubicPoly();
	const pz = /*@__PURE__*/ new CubicPoly();

	class CatmullRomCurve3 extends Curve {

		constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

			super();

			this.isCatmullRomCurve3 = true;

			this.type = 'CatmullRomCurve3';

			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const points = this.points;
			const l = points.length;

			const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
			let intPoint = Math.floor( p );
			let weight = p - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			const p1 = points[ intPoint % l ];
			const p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.curveType === 'catmullrom' ) {

				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

			}

			point.set(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.points = [];

			for ( let i = 0, l = source.points.length; i < l; i ++ ) {

				const point = source.points[ i ];

				this.points.push( point.clone() );

			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.points = [];

			for ( let i = 0, l = this.points.length; i < l; i ++ ) {

				const point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.points = [];

			for ( let i = 0, l = json.points.length; i < l; i ++ ) {

				const point = json.points[ i ];
				this.points.push( new Vector3().fromArray( point ) );

			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;

			return this;

		}

	}

	/**
	 * Bezier Curves formulas obtained from
	 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		const v0 = ( p2 - p0 ) * 0.5;
		const v1 = ( p3 - p1 ) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		const k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		const k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		const k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	class CubicBezierCurve extends Curve {

		constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

			super();

			this.isCubicBezierCurve = true;

			this.type = 'CubicBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		}

	}

	class CubicBezierCurve3 extends Curve {

		constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

			super();

			this.isCubicBezierCurve3 = true;

			this.type = 'CubicBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		}

	}

	class LineCurve extends Curve {

		constructor( v1 = new Vector2(), v2 = new Vector2() ) {

			super();

			this.isLineCurve = true;

			this.type = 'LineCurve';

			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		}

		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		}

		getTangent( t, optionalTarget = new Vector2() ) {

			return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

		}

		getTangentAt( u, optionalTarget ) {

			return this.getTangent( u, optionalTarget );

		}

		copy( source ) {

			super.copy( source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	class LineCurve3 extends Curve {

		constructor( v1 = new Vector3(), v2 = new Vector3() ) {

			super();

			this.isLineCurve3 = true;

			this.type = 'LineCurve3';

			this.v1 = v1;
			this.v2 = v2;

		}
		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		}
		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		}

		getTangent( t, optionalTarget = new Vector3() ) {

			return optionalTarget.subVectors( this.v2, this.v1 ).normalize();

		}

		getTangentAt( u, optionalTarget ) {

			return this.getTangent( u, optionalTarget );

		}

		copy( source ) {

			super.copy( source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}
		toJSON() {

			const data = super.toJSON();

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}
		fromJSON( json ) {

			super.fromJSON( json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	class QuadraticBezierCurve extends Curve {

		constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

			super();

			this.isQuadraticBezierCurve = true;

			this.type = 'QuadraticBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	class QuadraticBezierCurve3 extends Curve {

		constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

			super();

			this.isQuadraticBezierCurve3 = true;

			this.type = 'QuadraticBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	class SplineCurve extends Curve {

		constructor( points = [] ) {

			super();

			this.isSplineCurve = true;

			this.type = 'SplineCurve';

			this.points = points;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const points = this.points;
			const p = ( points.length - 1 ) * t;

			const intPoint = Math.floor( p );
			const weight = p - intPoint;

			const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			const p1 = points[ intPoint ];
			const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			point.set(
				CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
				CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.points = [];

			for ( let i = 0, l = source.points.length; i < l; i ++ ) {

				const point = source.points[ i ];

				this.points.push( point.clone() );

			}

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.points = [];

			for ( let i = 0, l = this.points.length; i < l; i ++ ) {

				const point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.points = [];

			for ( let i = 0, l = json.points.length; i < l; i ++ ) {

				const point = json.points[ i ];
				this.points.push( new Vector2().fromArray( point ) );

			}

			return this;

		}

	}

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {

		constructor() {

			super();

			this.type = 'CurvePath';

			this.curves = [];
			this.autoClose = false; // Automatically closes the path

		}

		add( curve ) {

			this.curves.push( curve );

		}

		closePath() {

			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[ 0 ].getPoint( 0 );
			const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		}

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint( t, optionalTarget ) {

			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					const diff = curveLengths[ i ] - d;
					const curve = this.curves[ i ];

					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u, optionalTarget );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		}

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength() {

			const lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		}

		// cacheLengths must be recalculated.
		updateArcLengths() {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		}

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths() {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			const lengths = [];
			let sums = 0;

			for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		}

		getSpacedPoints( divisions = 40 ) {

			const points = [];

			for ( let i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		}

		getPoints( divisions = 12 ) {

			const points = [];
			let last;

			for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

				const curve = curves[ i ];
				const resolution = curve.isEllipseCurve ? divisions * 2
					: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1
						: curve.isSplineCurve ? divisions * curve.points.length
							: divisions;

				const pts = curve.getPoints( resolution );

				for ( let j = 0; j < pts.length; j ++ ) {

					const point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		}

		copy( source ) {

			super.copy( source );

			this.curves = [];

			for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

				const curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

				const curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

				const curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	}

	class Path extends CurvePath {

		constructor( points ) {

			super();

			this.type = 'Path';

			this.currentPoint = new Vector2();

			if ( points ) {

				this.setFromPoints( points );

			}

		}

		setFromPoints( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( let i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

			return this;

		}

		moveTo( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			return this;

		}

		lineTo( x, y ) {

			const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

			return this;

		}

		quadraticCurveTo( aCPx, aCPy, aX, aY ) {

			const curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		}

		bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			const curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		}

		splineThru( pts /*Array of Vector*/ ) {

			const npts = [ this.currentPoint.clone() ].concat( pts );

			const curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

			return this;

		}

		arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

			return this;

		}

		absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			return this;

		}

		ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			return this;

		}

		absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			const lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

			return this;

		}

		copy( source ) {

			super.copy( source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.currentPoint = this.currentPoint.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	}

	class LatheGeometry extends BufferGeometry {

		constructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

			super();

			this.type = 'LatheGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			segments = Math.floor( segments );

			// clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp( phiLength, 0, Math.PI * 2 );

			// buffers

			const indices = [];
			const vertices = [];
			const uvs = [];
			const initNormals = [];
			const normals = [];

			// helper variables

			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2();
			const normal = new Vector3();
			const curNormal = new Vector3();
			const prevNormal = new Vector3();
			let dx = 0;
			let dy = 0;

			// pre-compute normals for initial "meridian"

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				switch ( j ) {

					case 0:				// special handling for 1st vertex on path

						dx = points[ j + 1 ].x - points[ j ].x;
						dy = points[ j + 1 ].y - points[ j ].y;

						normal.x = dy * 1.0;
						normal.y = - dx;
						normal.z = dy * 0.0;

						prevNormal.copy( normal );

						normal.normalize();

						initNormals.push( normal.x, normal.y, normal.z );

						break;

					case ( points.length - 1 ):	// special handling for last Vertex on path

						initNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );

						break;

					default:			// default handling for all vertices in between

						dx = points[ j + 1 ].x - points[ j ].x;
						dy = points[ j + 1 ].y - points[ j ].y;

						normal.x = dy * 1.0;
						normal.y = - dx;
						normal.z = dy * 0.0;

						curNormal.copy( normal );

						normal.x += prevNormal.x;
						normal.y += prevNormal.y;
						normal.z += prevNormal.z;

						normal.normalize();

						initNormals.push( normal.x, normal.y, normal.z );

						prevNormal.copy( curNormal );

				}

			}

			// generate vertices, uvs and normals

			for ( let i = 0; i <= segments; i ++ ) {

				const phi = phiStart + i * inverseSegments * phiLength;

				const sin = Math.sin( phi );
				const cos = Math.cos( phi );

				for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

					// vertex

					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;

					vertices.push( vertex.x, vertex.y, vertex.z );

					// uv

					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );

					uvs.push( uv.x, uv.y );

					// normal

					const x = initNormals[ 3 * j + 0 ] * sin;
					const y = initNormals[ 3 * j + 1 ];
					const z = initNormals[ 3 * j + 0 ] * cos;

					normals.push( x, y, z );

				}

			}

			// indices

			for ( let i = 0; i < segments; i ++ ) {

				for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

					const base = j + i * points.length;

					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1;

					// faces

					indices.push( a, b, d );
					indices.push( c, d, b );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );

		}

	}

	class CapsuleGeometry extends LatheGeometry {

		constructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {

			const path = new Path();
			path.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );
			path.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );

			super( path.getPoints( capSegments ), radialSegments );

			this.type = 'CapsuleGeometry';

			this.parameters = {
				radius: radius,
				height: length,
				capSegments: capSegments,
				radialSegments: radialSegments,
			};

		}

		static fromJSON( data ) {

			return new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );

		}

	}

	class CircleGeometry extends BufferGeometry {

		constructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			segments = Math.max( 3, segments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const vertex = new Vector3();
			const uv = new Vector2();

			// center point

			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );

			for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

				const segment = thetaStart + s / segments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uvs

				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// indices

			for ( let i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );

		}

	}

	class CylinderGeometry extends BufferGeometry {

		constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			const scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				const normal = new Vector3();
				const vertex = new Vector3();

				let groupCount = 0;

				// this will be used to calculate the normal
				const slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( let y = 0; y <= heightSegments; y ++ ) {

					const indexRow = [];

					const v = y / heightSegments;

					// calculate the radius of the current row

					const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( let x = 0; x <= radialSegments; x ++ ) {

						const u = x / radialSegments;

						const theta = u * thetaLength + thetaStart;

						const sinTheta = Math.sin( theta );
						const cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					for ( let y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						const a = indexArray[ y ][ x ];
						const b = indexArray[ y + 1 ][ x ];
						const c = indexArray[ y + 1 ][ x + 1 ];
						const d = indexArray[ y ][ x + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				const centerIndexStart = index;

				const uv = new Vector2();
				const vertex = new Vector3();

				let groupCount = 0;

				const radius = ( top === true ) ? radiusTop : radiusBottom;
				const sign = ( top === true ) ? 1 : - 1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( let x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				const centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;

					const cosTheta = Math.cos( theta );
					const sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

		}

	}

	class ConeGeometry extends CylinderGeometry {

		constructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		static fromJSON( data ) {

			return new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

		}

	}

	class PolyhedronGeometry extends BufferGeometry {

		constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

			super();

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			// default buffer data

			const vertexBuffer = [];
			const uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			applyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

			if ( detail === 0 ) {

				this.computeVertexNormals(); // flat normals

			} else {

				this.normalizeNormals(); // smooth normals

			}

			// helper functions

			function subdivide( detail ) {

				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();

				// iterate over all faces and apply a subdivision with the given detail value

				for ( let i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				const cols = detail + 1;

				// we use this multidimensional array as a data structure for creating the subdivision

				const v = [];

				// construct all of the vertices for this subdivision

				for ( let i = 0; i <= cols; i ++ ) {

					v[ i ] = [];

					const aj = a.clone().lerp( c, i / cols );
					const bj = b.clone().lerp( c, i / cols );

					const rows = cols - i;

					for ( let j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( let i = 0; i < cols; i ++ ) {

					for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						const k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function applyRadius( radius ) {

				const vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				const vertex = new Vector3();

				for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					const v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( let i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					const x0 = uvBuffer[ i + 0 ];
					const x1 = uvBuffer[ i + 2 ];
					const x2 = uvBuffer[ i + 4 ];

					const max = Math.max( x0, x1, x2 );
					const min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				const stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();

				const centroid = new Vector3();

				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					const azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] = uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const t = ( 1 + Math.sqrt( 5 ) ) / 2;
			const r = 1 / t;

			const vertices = [

				// (1, 1, 1)
				- 1, - 1, - 1,	- 1, - 1, 1,
				- 1, 1, - 1, - 1, 1, 1,
				1, - 1, - 1, 1, - 1, 1,
				1, 1, - 1, 1, 1, 1,

				// (0, 1/, )
				0, - r, - t, 0, - r, t,
				0, r, - t, 0, r, t,

				// (1/, , 0)
				- r, - t, 0, - r, t, 0,
				r, - t, 0, r, t, 0,

				// (, 0, 1/)
				- t, 0, - r, t, 0, - r,
				- t, 0, r, t, 0, r
			];

			const indices = [
				3, 11, 7, 	3, 7, 15, 	3, 15, 13,
				7, 19, 17, 	7, 17, 6, 	7, 6, 15,
				17, 4, 8, 	17, 8, 10, 	17, 10, 6,
				8, 0, 16, 	8, 16, 2, 	8, 2, 10,
				0, 12, 1, 	0, 1, 18, 	0, 18, 16,
				6, 10, 2, 	6, 2, 13, 	6, 13, 15,
				2, 16, 18, 	2, 18, 3, 	2, 3, 13,
				18, 1, 9, 	18, 9, 11, 	18, 11, 3,
				4, 14, 12, 	4, 12, 0, 	4, 0, 8,
				11, 9, 5, 	11, 5, 19, 	11, 19, 7,
				19, 5, 14, 	19, 14, 4, 	19, 4, 17,
				1, 12, 14, 	1, 14, 5, 	1, 5, 9
			];

			super( vertices, indices, radius, detail );

			this.type = 'DodecahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		static fromJSON( data ) {

			return new DodecahedronGeometry( data.radius, data.detail );

		}

	}

	const _v0 = /*@__PURE__*/ new Vector3();
	const _v1$1 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();
	const _triangle = /*@__PURE__*/ new Triangle();

	class EdgesGeometry extends BufferGeometry {

		constructor( geometry = null, thresholdAngle = 1 ) {

			super();

			this.type = 'EdgesGeometry';

			this.parameters = {
				geometry: geometry,
				thresholdAngle: thresholdAngle
			};

			if ( geometry !== null ) {

				const precisionPoints = 4;
				const precision = Math.pow( 10, precisionPoints );
				const thresholdDot = Math.cos( DEG2RAD * thresholdAngle );

				const indexAttr = geometry.getIndex();
				const positionAttr = geometry.getAttribute( 'position' );
				const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

				const indexArr = [ 0, 0, 0 ];
				const vertKeys = [ 'a', 'b', 'c' ];
				const hashes = new Array( 3 );

				const edgeData = {};
				const vertices = [];
				for ( let i = 0; i < indexCount; i += 3 ) {

					if ( indexAttr ) {

						indexArr[ 0 ] = indexAttr.getX( i );
						indexArr[ 1 ] = indexAttr.getX( i + 1 );
						indexArr[ 2 ] = indexAttr.getX( i + 2 );

					} else {

						indexArr[ 0 ] = i;
						indexArr[ 1 ] = i + 1;
						indexArr[ 2 ] = i + 2;

					}

					const { a, b, c } = _triangle;
					a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
					b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
					c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
					_triangle.getNormal( _normal );

					// create hashes for the edge from the vertices
					hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
					hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
					hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

					// skip degenerate triangles
					if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

						continue;

					}

					// iterate over every edge
					for ( let j = 0; j < 3; j ++ ) {

						// get the first and next vertex making up the edge
						const jNext = ( j + 1 ) % 3;
						const vecHash0 = hashes[ j ];
						const vecHash1 = hashes[ jNext ];
						const v0 = _triangle[ vertKeys[ j ] ];
						const v1 = _triangle[ vertKeys[ jNext ] ];

						const hash = `${ vecHash0 }_${ vecHash1 }`;
						const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

						if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

							// if we found a sibling edge add it into the vertex array if
							// it meets the angle threshold and delete the edge from the map.
							if ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

								vertices.push( v0.x, v0.y, v0.z );
								vertices.push( v1.x, v1.y, v1.z );

							}

							edgeData[ reverseHash ] = null;

						} else if ( ! ( hash in edgeData ) ) {

							// if we've already got an edge here then skip adding a new one
							edgeData[ hash ] = {

								index0: indexArr[ j ],
								index1: indexArr[ jNext ],
								normal: _normal.clone(),

							};

						}

					}

				}

				// iterate over all remaining, unmatched edges and add them to the vertex array
				for ( const key in edgeData ) {

					if ( edgeData[ key ] ) {

						const { index0, index1 } = edgeData[ key ];
						_v0.fromBufferAttribute( positionAttr, index0 );
						_v1$1.fromBufferAttribute( positionAttr, index1 );

						vertices.push( _v0.x, _v0.y, _v0.z );
						vertices.push( _v1$1.x, _v1$1.y, _v1$1.z );

					}

				}

				this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

	}

	class Shape extends Path {

		constructor( points ) {

			super( points );

			this.uuid = generateUUID();

			this.type = 'Shape';

			this.holes = [];

		}

		getPointsHoles( divisions ) {

			const holesPts = [];

			for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		}

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		}

		copy( source ) {

			super.copy( source );

			this.holes = [];

			for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

				const hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.uuid = this.uuid;
			data.holes = [];

			for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

				const hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

				const hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	}

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.4)
	 */

	const Earcut = {

		triangulate: function ( data, holeIndices, dim = 2 ) {

			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
			let outerNode = linkedList( data, 0, outerLen, dim, true );
			const triangles = [];

			if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

			let minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( let i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 32767 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList( data, start, end, dim, clockwise ) {

		let i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points
	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		let p = start,
			again;
		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order
		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		let stop = ear,
			prev, next;

		// iterate through ears, slicing them one by one
		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim | 0 );
				triangles.push( ear.i / dim | 0 );
				triangles.push( next.i / dim | 0 );

				removeNode( ear );

				// skipping the next vertex leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears
			if ( ear === stop ) {

				// try filtering points and slicing again
				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

					// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar( ear ) {

		const a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

		// triangle bbox; min & max are calculated like this for speed
		const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
			y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
			x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
			y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

		let p = c.next;
		while ( p !== a ) {

			if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
				pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		const a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

		// triangle bbox; min & max are calculated like this for speed
		const x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),
			y0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),
			x1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),
			y1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );

		// z-order range for the current triangle bbox;
		const minZ = zOrder( x0, y0, minX, minY, invSize ),
			maxZ = zOrder( x1, y1, minX, minY, invSize );

		let p = ear.prevZ,
			n = ear.nextZ;

		// look for points inside the triangle in both directions
		while ( p && p.z >= minZ && n && n.z <= maxZ ) {

			if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
				pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.prevZ;

			if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
				pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
			n = n.nextZ;

		}

		// look for remaining points in decreasing z-order
		while ( p && p.z >= minZ ) {

			if ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
				pointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.prevZ;

		}

		// look for remaining points in increasing z-order
		while ( n && n.z <= maxZ ) {

			if ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
				pointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;
			n = n.nextZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections( start, triangles, dim ) {

		let p = start;
		do {

			const a = p.prev,
				b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim | 0 );
				triangles.push( p.i / dim | 0 );
				triangles.push( b.i / dim | 0 );

				// remove two nodes involved
				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return filterPoints( p );

	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two
		let a = start;
		do {

			let b = a.next.next;
			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal
					let c = splitPolygon( a, b );

					// filter colinear points around the cuts
					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half
					earcutLinked( a, triangles, dim, minX, minY, invSize, 0 );
					earcutLinked( c, triangles, dim, minX, minY, invSize, 0 );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		const queue = [];
		let i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right
		for ( i = 0; i < queue.length; i ++ ) {

			outerNode = eliminateHole( queue[ i ], outerNode );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and link it
	function eliminateHole( hole, outerNode ) {

		const bridge = findHoleBridge( hole, outerNode );
		if ( ! bridge ) {

			return outerNode;

		}

		const bridgeReverse = splitPolygon( bridge, hole );

		// filter collinear points around the cuts
		filterPoints( bridgeReverse, bridgeReverse.next );
		return filterPoints( bridge, bridge.next );

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge( hole, outerNode ) {

		let p = outerNode,
			qx = - Infinity,
			m;

		const hx = hole.x, hy = hole.y;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
				if ( x <= hx && x > qx ) {

					qx = x;
					m = p.x < p.next.x ? p : p.next;
					if ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
			mx = m.x,
			my = m.y;
		let tanMin = Infinity, tan;

		p = m;

		do {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
					pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		} while ( p !== stop );

		return m;

	}

	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector( m, p ) {

		return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

	}

	// interlink polygon nodes in z-order
	function indexCurve( start, minX, minY, invSize ) {

		let p = start;
		do {

			if ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked( list ) {

		let i, p, q, e, tail, numMerges, pSize, qSize,
			inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;
				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range
		x = ( x - minX ) * invSize | 0;
		y = ( y - minY ) * invSize | 0;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring
	function getLeftmost( start ) {

		let p = start,
			leftmost = start;
		do {

			if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle
	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&
	           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&
	           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
	           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
	            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
	            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

	}

	// signed area of a triangle
	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal
	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect
	function intersects( p1, q1, p2, q2 ) {

		const o1 = sign( area( p1, q1, p2 ) );
		const o2 = sign( area( p1, q1, q2 ) );
		const o3 = sign( area( p2, q2, p1 ) );
		const o4 = sign( area( p2, q2, q1 ) );

		if ( o1 !== o2 && o3 !== o4 ) return true; // general case

		if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
		if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
		if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
		if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;

	}

	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment( p, q, r ) {

		return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

	}

	function sign( num ) {

		return num > 0 ? 1 : num < 0 ? - 1 : 0;

	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon( a, b ) {

		let p = a;
		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside( a, b ) {

		let p = a,
			inside = false;
		const px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;
		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
				inside = ! inside;
			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon( a, b ) {

		const a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode( i, x, y, last ) {

		const p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertex index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertex nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = 0;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		let sum = 0;
		for ( let i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	class ShapeUtils {

		// calculate area of the contour polygon

		static area( contour ) {

			const n = contour.length;
			let a = 0.0;

			for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		}

		static isClockWise( pts ) {

			return ShapeUtils.area( pts ) < 0;

		}

		static triangulateShape( contour, holes ) {

			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			const holeIndices = []; // array of hole indices
			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			let holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( let i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			const triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( let i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	}

	function removeDupEndPts( points ) {

		const l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( let i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *  bevelOffset: <float>, // how far from shape outline does bevel start
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */


	class ExtrudeGeometry extends BufferGeometry {

		constructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {

			super();

			this.type = 'ExtrudeGeometry';

			this.parameters = {
				shapes: shapes,
				options: options
			};

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			const scope = this;

			const verticesArray = [];
			const uvArray = [];

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];
				addShape( shape );

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

			this.computeVertexNormals();

			// functions

			function addShape( shape ) {

				const placeholder = [];

				// options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				const depth = options.depth !== undefined ? options.depth : 1;

				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

				const extrudePath = options.extrudePath;

				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

				//

				let extrudePts, extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if ( extrudePath ) {

					extrudePts = extrudePath.getSpacedPoints( steps );

					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion

					// SETUP TNB variables

					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames( steps, false );

					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();

				}

				// Safeguards if bevels are not enabled

				if ( ! bevelEnabled ) {

					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;

				}

				// Variables initialization

				const shapePoints = shape.extractPoints( curveSegments );

				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;

				const reverse = ! ShapeUtils.isClockWise( vertices );

				if ( reverse ) {

					vertices = vertices.reverse();

					// Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];

						if ( ShapeUtils.isClockWise( ahole ) ) {

							holes[ h ] = ahole.reverse();

						}

					}

				}


				const faces = ShapeUtils.triangulateShape( vertices, holes );

				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					vertices = vertices.concat( ahole );

				}


				function scalePt2( pt, vec, size ) {

					if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

					return pt.clone().addScaledVector( vec, size );

				}

				const vlen = vertices.length, flen = faces.length;


				// Find directions for point movement


				function getBevelVec( inPt, inPrev, inNext ) {

					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.

					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y;

					const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

					// check for collinear edges
					const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					if ( Math.abs( collinear0 ) > Number.EPSILON ) {

						// not collinear

						// length of vectors for normalizing

						const v_prev_len = Math.sqrt( v_prev_lensq );
						const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

						// shift adjacent points by unit vectors to the left

						const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
						const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

						const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
						const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

						// scaling factor for v_prev to intersection point

						const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
							( v_prev_x * v_next_y - v_prev_y * v_next_x );

						// vector from inPt to intersection point

						v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
						v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
						if ( v_trans_lensq <= 2 ) {

							return new Vector2( v_trans_x, v_trans_y );

						} else {

							shrink_by = Math.sqrt( v_trans_lensq / 2 );

						}

					} else {

						// handle special case of collinear edges

						let direction_eq = false; // assumes: opposite

						if ( v_prev_x > Number.EPSILON ) {

							if ( v_next_x > Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( v_prev_x < - Number.EPSILON ) {

								if ( v_next_x < - Number.EPSILON ) {

									direction_eq = true;

								}

							} else {

								if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

									direction_eq = true;

								}

							}

						}

						if ( direction_eq ) {

							// console.log("Warning: lines are a straight sequence");
							v_trans_x = - v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt( v_prev_lensq );

						} else {

							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt( v_prev_lensq / 2 );

						}

					}

					return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

				}


				const contourMovements = [];

				for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

				}

				const holesMovements = [];
				let oneHoleMovements, verticesMovements = contourMovements.concat();

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					oneHoleMovements = [];

					for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

						if ( j === il ) j = 0;
						if ( k === il ) k = 0;

						//  (j)---(i)---(k)
						oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

					}

					holesMovements.push( oneHoleMovements );
					verticesMovements = verticesMovements.concat( oneHoleMovements );

				}


				// Loop bevelSegments, 1 for the front, 1 for the back

				for ( let b = 0; b < bevelSegments; b ++ ) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

					// expand holes

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							v( vert.x, vert.y, - z );

						}

					}

				}

				const bs = bevelSize + bevelOffset;

				// Back facing vertices

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, 0 );

					} else {

						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

						normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

				// Add stepped vertices...
				// Including front facing vertices

				for ( let s = 1; s <= steps; s ++ ) {

					for ( let i = 0; i < vlen; i ++ ) {

						const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth / steps * s );

						} else {

							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

							normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
							binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

							position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

							v( position2.x, position2.y, position2.z );

						}

					}

				}


				// Add bevel segments planes

				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for ( let b = bevelSegments - 1; b >= 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
						v( vert.x, vert.y, depth + z );

					}

					// expand holes

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							if ( ! extrudeByPath ) {

								v( vert.x, vert.y, depth + z );

							} else {

								v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

							}

						}

					}

				}

				/* Faces */

				// Top and bottom faces

				buildLidFaces();

				// Sides faces

				buildSideFaces();


				/////  Internal functions

				function buildLidFaces() {

					const start = verticesArray.length / 3;

					if ( bevelEnabled ) {

						let layer = 0; // steps + 1
						let offset = vlen * layer;

						// Bottom faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer;

						// Top faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

						}

					} else {

						// Bottom faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 2 ], face[ 1 ], face[ 0 ] );

						}

						// Top faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

						}

					}

					scope.addGroup( start, verticesArray.length / 3 - start, 0 );

				}

				// Create faces for the z-sides of the shape

				function buildSideFaces() {

					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls( contour, layeroffset );
					layeroffset += contour.length;

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						sidewalls( ahole, layeroffset );

						//, true
						layeroffset += ahole.length;

					}


					scope.addGroup( start, verticesArray.length / 3 - start, 1 );


				}

				function sidewalls( contour, layeroffset ) {

					let i = contour.length;

					while ( -- i >= 0 ) {

						const j = i;
						let k = i - 1;
						if ( k < 0 ) k = contour.length - 1;

						//console.log('b', i,j, i-1, k,vertices.length);

						for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

							const slen1 = vlen * s;
							const slen2 = vlen * ( s + 1 );

							const a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2;

							f4( a, b, c, d );

						}

					}

				}

				function v( x, y, z ) {

					placeholder.push( x );
					placeholder.push( y );
					placeholder.push( z );

				}


				function f3( a, b, c ) {

					addVertex( a );
					addVertex( b );
					addVertex( c );

					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );

				}

				function f4( a, b, c, d ) {

					addVertex( a );
					addVertex( b );
					addVertex( d );

					addVertex( b );
					addVertex( c );
					addVertex( d );


					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 3 ] );

					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );
					addUV( uvs[ 3 ] );

				}

				function addVertex( index ) {

					verticesArray.push( placeholder[ index * 3 + 0 ] );
					verticesArray.push( placeholder[ index * 3 + 1 ] );
					verticesArray.push( placeholder[ index * 3 + 2 ] );

				}


				function addUV( vector2 ) {

					uvArray.push( vector2.x );
					uvArray.push( vector2.y );

				}

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			const shapes = this.parameters.shapes;
			const options = this.parameters.options;

			return toJSON$1( shapes, options, data );

		}

		static fromJSON( data, shapes ) {

			const geometryShapes = [];

			for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

				const shape = shapes[ data.shapes[ j ] ];

				geometryShapes.push( shape );

			}

			const extrudePath = data.options.extrudePath;

			if ( extrudePath !== undefined ) {

				data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

			}

			return new ExtrudeGeometry( geometryShapes, data.options );

		}

	}

	const WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			const a_x = vertices[ indexA * 3 ];
			const a_y = vertices[ indexA * 3 + 1 ];
			const b_x = vertices[ indexB * 3 ];
			const b_y = vertices[ indexB * 3 + 1 ];
			const c_x = vertices[ indexC * 3 ];
			const c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			const a_x = vertices[ indexA * 3 ];
			const a_y = vertices[ indexA * 3 + 1 ];
			const a_z = vertices[ indexA * 3 + 2 ];
			const b_x = vertices[ indexB * 3 ];
			const b_y = vertices[ indexB * 3 + 1 ];
			const b_z = vertices[ indexB * 3 + 2 ];
			const c_x = vertices[ indexC * 3 ];
			const c_y = vertices[ indexC * 3 + 1 ];
			const c_z = vertices[ indexC * 3 + 2 ];
			const d_x = vertices[ indexD * 3 ];
			const d_y = vertices[ indexD * 3 + 1 ];
			const d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}

	};

	function toJSON$1( shapes, options, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		data.options = Object.assign( {}, options );

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	class IcosahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const t = ( 1 + Math.sqrt( 5 ) ) / 2;

			const vertices = [
				- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
				0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
				t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
			];

			const indices = [
				0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
				1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
				3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
				4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
			];

			super( vertices, indices, radius, detail );

			this.type = 'IcosahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		static fromJSON( data ) {

			return new IcosahedronGeometry( data.radius, data.detail );

		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const vertices = [
				1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
				0, - 1, 0, 	0, 0, 1,	0, 0, - 1
			];

			const indices = [
				0, 2, 4,	0, 4, 3,	0, 3, 5,
				0, 5, 2,	1, 2, 5,	1, 5, 3,
				1, 3, 4,	1, 4, 2
			];

			super( vertices, indices, radius, detail );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		static fromJSON( data ) {

			return new OctahedronGeometry( data.radius, data.detail );

		}

	}

	class RingGeometry extends BufferGeometry {

		constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			thetaSegments = Math.max( 3, thetaSegments );
			phiSegments = Math.max( 1, phiSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// some helper variables

			let radius = innerRadius;
			const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			const vertex = new Vector3();
			const uv = new Vector2();

			// generate vertices, normals and uvs

			for ( let j = 0; j <= phiSegments; j ++ ) {

				for ( let i = 0; i <= thetaSegments; i ++ ) {

					// values are generate from the inside of the ring to the outside

					const segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex

					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, 0, 1 );

					// uv

					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;

					uvs.push( uv.x, uv.y );

				}

				// increase the radius for next row of vertices

				radius += radiusStep;

			}

			// indices

			for ( let j = 0; j < phiSegments; j ++ ) {

				const thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( let i = 0; i < thetaSegments; i ++ ) {

					const segment = i + thetaSegmentLevel;

					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

		}

	}

	class ShapeGeometry extends BufferGeometry {

		constructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {

			super();

			this.type = 'ShapeGeometry';

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let groupStart = 0;
			let groupCount = 0;

			// allow single and array values for "shapes" parameter

			if ( Array.isArray( shapes ) === false ) {

				addShape( shapes );

			} else {

				for ( let i = 0; i < shapes.length; i ++ ) {

					addShape( shapes[ i ] );

					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


			// helper functions

			function addShape( shape ) {

				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints( curveSegments );

				let shapeVertices = points.shape;
				const shapeHoles = points.holes;

				// check direction of vertices

				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

					shapeVertices = shapeVertices.reverse();

				}

				for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

					const shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

				const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

				// join vertices of inner and outer paths to a single array

				for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

					const shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );

				}

				// vertices, normals, uvs

				for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

					const vertex = shapeVertices[ i ];

					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs

				}

				// indices

				for ( let i = 0, l = faces.length; i < l; i ++ ) {

					const face = faces[ i ];

					const a = face[ 0 ] + indexOffset;
					const b = face[ 1 ] + indexOffset;
					const c = face[ 2 ] + indexOffset;

					indices.push( a, b, c );
					groupCount += 3;

				}

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			const shapes = this.parameters.shapes;

			return toJSON( shapes, data );

		}

		static fromJSON( data, shapes ) {

			const geometryShapes = [];

			for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

				const shape = shapes[ data.shapes[ j ] ];

				geometryShapes.push( shape );

			}

			return new ShapeGeometry( geometryShapes, data.curveSegments );

		}

	}

	function toJSON( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	class SphereGeometry extends BufferGeometry {

		constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

			super();

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			let index = 0;
			const grid = [];

			const vertex = new Vector3();
			const normal = new Vector3();

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// generate vertices, normals and uvs

			for ( let iy = 0; iy <= heightSegments; iy ++ ) {

				const verticesRow = [];

				const v = iy / heightSegments;

				// special case for the poles

				let uOffset = 0;

				if ( iy === 0 && thetaStart === 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy === heightSegments && thetaEnd === Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( let ix = 0; ix <= widthSegments; ix ++ ) {

					const u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( let iy = 0; iy < heightSegments; iy ++ ) {

				for ( let ix = 0; ix < widthSegments; ix ++ ) {

					const a = grid[ iy ][ ix + 1 ];
					const b = grid[ iy ][ ix ];
					const c = grid[ iy + 1 ][ ix ];
					const d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const vertices = [
				1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
			];

			const indices = [
				2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
			];

			super( vertices, indices, radius, detail );

			this.type = 'TetrahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		static fromJSON( data ) {

			return new TetrahedronGeometry( data.radius, data.detail );

		}

	}

	class TorusGeometry extends BufferGeometry {

		constructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {

			super();

			this.type = 'TorusGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			radialSegments = Math.floor( radialSegments );
			tubularSegments = Math.floor( tubularSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3();

			// generate vertices, normals and uvs

			for ( let j = 0; j <= radialSegments; j ++ ) {

				for ( let i = 0; i <= tubularSegments; i ++ ) {

					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2;

					// vertex

					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
					normal.subVectors( vertex, center ).normalize();

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );

				}

			}

			// generate indices

			for ( let j = 1; j <= radialSegments; j ++ ) {

				for ( let i = 1; i <= tubularSegments; i ++ ) {

					// indices

					const a = ( tubularSegments + 1 ) * j + i - 1;
					const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					const d = ( tubularSegments + 1 ) * j + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

		}

	}

	class TorusKnotGeometry extends BufferGeometry {

		constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

			super();

			this.type = 'TorusKnotGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			tubularSegments = Math.floor( tubularSegments );
			radialSegments = Math.floor( radialSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const vertex = new Vector3();
			const normal = new Vector3();

			const P1 = new Vector3();
			const P2 = new Vector3();

			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3();

			// generate vertices, normals and uvs

			for ( let i = 0; i <= tubularSegments; ++ i ) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segment

				const u = i / tubularSegments * p * Math.PI * 2;

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

				// calculate orthonormal basis

				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );

				// normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for ( let j = 0; j <= radialSegments; ++ j ) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					const v = j / radialSegments * Math.PI * 2;
					const cx = - tube * Math.cos( v );
					const cy = tube * Math.sin( v );

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors( vertex, P1 ).normalize();

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );

				}

			}

			// generate indices

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					// indices

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve( u, p, q, radius, position ) {

				const cu = Math.cos( u );
				const su = Math.sin( u );
				const quOverP = q / p * u;
				const cs = Math.cos( quOverP );

				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		static fromJSON( data ) {

			return new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );

		}

	}

	class TubeGeometry extends BufferGeometry {

		constructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

			super();

			this.type = 'TubeGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			const frames = path.computeFrenetFrames( tubularSegments, closed );

			// expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;

			// helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3();

			// buffer

			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = [];

			// create buffer data

			generateBufferData();

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// functions

			function generateBufferData() {

				for ( let i = 0; i < tubularSegments; i ++ ) {

					generateSegment( i );

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment( ( closed === false ) ? tubularSegments : 0 );

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs();

				// finally create faces

				generateIndices();

			}

			function generateSegment( i ) {

				// we use getPointAt to sample evenly distributed points from the given path

				P = path.getPointAt( i / tubularSegments, P );

				// retrieve corresponding normal and binormal

				const N = frames.normals[ i ];
				const B = frames.binormals[ i ];

				// generate normals and vertices for the current segment

				for ( let j = 0; j <= radialSegments; j ++ ) {

					const v = j / radialSegments * Math.PI * 2;

					const sin = Math.sin( v );
					const cos = - Math.cos( v );

					// normal

					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();

					normals.push( normal.x, normal.y, normal.z );

					// vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;

					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			function generateIndices() {

				for ( let j = 1; j <= tubularSegments; j ++ ) {

					for ( let i = 1; i <= radialSegments; i ++ ) {

						const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						const b = ( radialSegments + 1 ) * j + ( i - 1 );
						const c = ( radialSegments + 1 ) * j + i;
						const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

					}

				}

			}

			function generateUVs() {

				for ( let i = 0; i <= tubularSegments; i ++ ) {

					for ( let j = 0; j <= radialSegments; j ++ ) {

						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;

						uvs.push( uv.x, uv.y );

					}

				}

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.path = this.parameters.path.toJSON();

			return data;

		}

		static fromJSON( data ) {

			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(
				new Curves[ data.path.type ]().fromJSON( data.path ),
				data.tubularSegments,
				data.radius,
				data.radialSegments,
				data.closed
			);

		}

	}

	class WireframeGeometry extends BufferGeometry {

		constructor( geometry = null ) {

			super();

			this.type = 'WireframeGeometry';

			this.parameters = {
				geometry: geometry
			};

			if ( geometry !== null ) {

				// buffer

				const vertices = [];
				const edges = new Set();

				// helper variables

				const start = new Vector3();
				const end = new Vector3();

				if ( geometry.index !== null ) {

					// indexed BufferGeometry

					const position = geometry.attributes.position;
					const indices = geometry.index;
					let groups = geometry.groups;

					if ( groups.length === 0 ) {

						groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

					}

					// create a data structure that contains all edges without duplicates

					for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

						const group = groups[ o ];

						const groupStart = group.start;
						const groupCount = group.count;

						for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

							for ( let j = 0; j < 3; j ++ ) {

								const index1 = indices.getX( i + j );
								const index2 = indices.getX( i + ( j + 1 ) % 3 );

								start.fromBufferAttribute( position, index1 );
								end.fromBufferAttribute( position, index2 );

								if ( isUniqueEdge( start, end, edges ) === true ) {

									vertices.push( start.x, start.y, start.z );
									vertices.push( end.x, end.y, end.z );

								}

							}

						}

					}

				} else {

					// non-indexed BufferGeometry

					const position = geometry.attributes.position;

					for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

						for ( let j = 0; j < 3; j ++ ) {

							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

							const index1 = 3 * i + j;
							const index2 = 3 * i + ( ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

				// build geometry

				this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

			}

		}

		copy( source ) {

			super.copy( source );

			this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

	}

	function isUniqueEdge( start, end, edges ) {

		const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
		const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

		if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

			return false;

		} else {

			edges.add( hash1 );
			edges.add( hash2 );
			return true;

		}

	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		CapsuleGeometry: CapsuleGeometry,
		CircleGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		PlaneGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TorusGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	class ShadowMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isShadowMaterial = true;

			this.type = 'ShadowMaterial';

			this.color = new Color( 0x000000 );
			this.transparent = true;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.fog = source.fog;

			return this;

		}

	}

	class RawShaderMaterial extends ShaderMaterial {

		constructor( parameters ) {

			super( parameters );

			this.isRawShaderMaterial = true;

			this.type = 'RawShaderMaterial';

		}

	}

	class MeshStandardMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshStandardMaterial = true;

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 1.0;
			this.metalness = 0.0;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.roughnessMap = null;

			this.metalnessMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshPhysicalMaterial extends MeshStandardMaterial {

		constructor( parameters ) {

			super();

			this.isMeshPhysicalMaterial = true;

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.type = 'MeshPhysicalMaterial';

			this.anisotropyRotation = 0;
			this.anisotropyMap = null;

			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2( 1, 1 );
			this.clearcoatNormalMap = null;

			this.ior = 1.5;

			Object.defineProperty( this, 'reflectivity', {
				get: function () {

					return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

				},
				set: function ( reflectivity ) {

					this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

				}
			} );

			this.iridescenceMap = null;
			this.iridescenceIOR = 1.3;
			this.iridescenceThicknessRange = [ 100, 400 ];
			this.iridescenceThicknessMap = null;

			this.sheenColor = new Color( 0x000000 );
			this.sheenColorMap = null;
			this.sheenRoughness = 1.0;
			this.sheenRoughnessMap = null;

			this.transmissionMap = null;

			this.thickness = 0;
			this.thicknessMap = null;
			this.attenuationDistance = Infinity;
			this.attenuationColor = new Color( 1, 1, 1 );

			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularColor = new Color( 1, 1, 1 );
			this.specularColorMap = null;

			this._anisotropy = 0;
			this._clearcoat = 0;
			this._iridescence = 0;
			this._sheen = 0.0;
			this._transmission = 0;

			this.setValues( parameters );

		}

		get anisotropy() {

			return this._anisotropy;

		}

		set anisotropy( value ) {

			if ( this._anisotropy > 0 !== value > 0 ) {

				this.version ++;

			}

			this._anisotropy = value;

		}

		get clearcoat() {

			return this._clearcoat;

		}

		set clearcoat( value ) {

			if ( this._clearcoat > 0 !== value > 0 ) {

				this.version ++;

			}

			this._clearcoat = value;

		}

		get iridescence() {

			return this._iridescence;

		}

		set iridescence( value ) {

			if ( this._iridescence > 0 !== value > 0 ) {

				this.version ++;

			}

			this._iridescence = value;

		}

		get sheen() {

			return this._sheen;

		}

		set sheen( value ) {

			if ( this._sheen > 0 !== value > 0 ) {

				this.version ++;

			}

			this._sheen = value;

		}

		get transmission() {

			return this._transmission;

		}

		set transmission( value ) {

			if ( this._transmission > 0 !== value > 0 ) {

				this.version ++;

			}

			this._transmission = value;

		}

		copy( source ) {

			super.copy( source );

			this.defines = {

				'STANDARD': '',
				'PHYSICAL': ''

			};

			this.anisotropy = source.anisotropy;
			this.anisotropyRotation = source.anisotropyRotation;
			this.anisotropyMap = source.anisotropyMap;

			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

			this.ior = source.ior;

			this.iridescence = source.iridescence;
			this.iridescenceMap = source.iridescenceMap;
			this.iridescenceIOR = source.iridescenceIOR;
			this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
			this.iridescenceThicknessMap = source.iridescenceThicknessMap;

			this.sheen = source.sheen;
			this.sheenColor.copy( source.sheenColor );
			this.sheenColorMap = source.sheenColorMap;
			this.sheenRoughness = source.sheenRoughness;
			this.sheenRoughnessMap = source.sheenRoughnessMap;

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;

			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationColor.copy( source.attenuationColor );

			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularColor.copy( source.specularColor );
			this.specularColorMap = source.specularColorMap;

			return this;

		}

	}

	class MeshPhongMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshPhongMaterial = true;

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshToonMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshToonMaterial = true;

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;
			this.gradientMap = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshNormalMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshNormalMaterial = true;

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	class MeshLambertMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshLambertMaterial = true;

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshMatcapMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshMatcapMaterial = true;

			this.defines = { 'MATCAP': '' };

			this.type = 'MeshMatcapMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.matcap = null;

			this.map = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.defines = { 'MATCAP': '' };

			this.color.copy( source.color );

			this.matcap = source.matcap;

			this.map = source.map;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	class LineDashedMaterial extends LineBasicMaterial {

		constructor( parameters ) {

			super();

			this.isLineDashedMaterial = true;

			this.type = 'LineDashedMaterial';

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		}

	}

	// same as Array.prototype.slice, but also works on typed arrays
	function arraySlice( array, from, to ) {

		if ( isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	}

	// converts an array to a specific type
	function convertArray( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	}

	function isTypedArray( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	}

	// returns an array by which times and values can be sorted
	function getKeyframeOrder( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	}

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	function sortedArray( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	}

	// function for parsing AOS keyframe formats
	function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	}

	function subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = convertArray( times, track.times.constructor );
			track.values = convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	}

	function makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

	const AnimationUtils = {
		arraySlice: arraySlice,
		convertArray: convertArray,
		isTypedArray: isTypedArray,
		getKeyframeOrder: getKeyframeOrder,
		sortedArray: sortedArray,
		flattenJSON: flattenJSON,
		subclip: subclip,
		makeClipAdditive: makeClipAdditive
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */

	class Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;

			this.resultBuffer = resultBuffer !== undefined ?
				resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;

			this.settings = null;
			this.DefaultSettings_ = {};

		}

		evaluate( t ) {

			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					let right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( let giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.copySampleValue_( i1 - 1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							const t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( let giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.copySampleValue_( 0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						const mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.copySampleValue_( 0 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.copySampleValue_( i1 - 1 );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		}

		getSettings_() {

			return this.settings || this.DefaultSettings_;

		}

		copySampleValue_( index ) {

			// copies a sample value to the result buffer

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		}

		// Template methods for derived classes:

		interpolate_( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		}

		intervalChanged_( /* i1, t0, t1 */ ) {

			// empty

		}

	}

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

			this._weightPrev = - 0;
			this._offsetPrev = - 0;
			this._weightNext = - 0;
			this._offsetNext = - 0;

			this.DefaultSettings_ = {

				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding

			};

		}

		intervalChanged_( i1, t0, t1 ) {

			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			const halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		}

		interpolate_( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			const sP = - wP * ppp + 2 * wP * pp - wP * p;
			const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	}

	class LinearInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		interpolate_( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		interpolate_( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	}

	class KeyframeTrack {

		constructor( name, times, values, interpolation ) {

			if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
			if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

			this.name = name;

			this.times = convertArray( times, this.TimeBufferType );
			this.values = convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

		}

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		static toJSON( track ) {

			const trackType = track.constructor;

			let json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== this.toJSON ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': convertArray( track.times, Array ),
					'values': convertArray( track.values, Array )

				};

				const interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		}

		InterpolantFactoryMethodDiscrete( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		InterpolantFactoryMethodLinear( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		InterpolantFactoryMethodSmooth( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		setInterpolation( interpolation ) {

			let factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				const message = 'unsupported interpolation for ' +
					this.ValueTypeName + ' keyframe track named ' + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return this;

			}

			this.createInterpolant = factoryMethod;

			return this;

		}

		getInterpolation() {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		}

		getValueSize() {

			return this.values.length / this.times.length;

		}

		// move all keyframes either forwards or backwards in time
		shift( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				const times = this.times;

				for ( let i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		}

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale( timeScale ) {

			if ( timeScale !== 1.0 ) {

				const times = this.times;

				for ( let i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		}

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim( startTime, endTime ) {

			const times = this.times,
				nKeys = times.length;

			let from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) {

					to = Math.max( to, 1 );
					from = to - 1;

				}

				const stride = this.getValueSize();
				this.times = arraySlice( times, from, to );
				this.values = arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		}

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate() {

			let valid = true;

			const valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			const times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			let prevTime = null;

			for ( let i = 0; i !== nKeys; i ++ ) {

				const currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( isTypedArray( values ) ) {

					for ( let i = 0, n = values.length; i !== n; ++ i ) {

						const value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		}

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize() {

			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = arraySlice( this.times ),
				values = arraySlice( this.values ),
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				lastIndex = times.length - 1;

			let writeIndex = 1;

			for ( let i = 1; i < lastIndex; ++ i ) {

				let keep = false;

				const time = times[ i ];
				const timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						const offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( let j = 0; j !== stride; ++ j ) {

							const value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						const readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( let j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = arraySlice( times, 0, writeIndex );
				this.values = arraySlice( values, 0, writeIndex * stride );

			} else {

				this.times = times;
				this.values = values;

			}

			return this;

		}

		clone() {

			const times = arraySlice( this.times, 0 );
			const values = arraySlice( this.values, 0 );

			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack( this.name, times, values );

			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;

			return track;

		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */
	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of keyframe values that represent color.
	 */
	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color';

	/**
	 * A Track of numeric keyframe values.
	 */
	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number';

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {

		constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		interpolate_( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				alpha = ( t - t0 ) / ( t1 - t0 );

			let offset = i1 * stride;

			for ( let end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */
	class QuaternionKeyframeTrack extends KeyframeTrack {

		InterpolantFactoryMethodLinear( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
	// ValueBufferType is inherited
	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */
	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */
	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

	class AnimationClip {

		constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;

			this.uuid = generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

		}


		static parse( json ) {

			const tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

			}

			const clip = new this( json.name, json.duration, tracks, json.blendMode );
			clip.uuid = json.uuid;

			return clip;

		}

		static toJSON( clip ) {

			const tracks = [],
				clipTracks = clip.tracks;

			const json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode

			};

			for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		}

		static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for ( let i = 0; i < numMorphTargets; i ++ ) {

				let times = [];
				let values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				const order = getKeyframeOrder( times );
				times = sortedArray( times, 1, order );
				values = sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new this( name, - 1, tracks );

		}

		static findByName( objectOrClipArray, name ) {

			let clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( let i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		}

		static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

			const animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			const pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

				const morphTarget = morphTargets[ i ];
				const parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					const name = parts[ 1 ];

					let animationMorphTargets = animationToMorphTargets[ name ];

					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			const clips = [];

			for ( const name in animationToMorphTargets ) {

				clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		}

		// parse the animation.hierarchy format
		static parseAnimation( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					const times = [];
					const values = [];

					flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			const tracks = [];

			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode;

			// automatic length determination in AnimationClip.
			let duration = animation.length || - 1;

			const hierarchyTracks = animation.hierarchy || [];

			for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

				const animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					const morphTargetNames = {};

					let k;

					for ( k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( const morphTargetName in morphTargetNames ) {

						const times = [];
						const values = [];

						for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							const animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * fps;

				} else {

					// ...assume skeletal animation

					const boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			const clip = new this( clipName, duration, tracks, blendMode );

			return clip;

		}

		resetDuration() {

			const tracks = this.tracks;
			let duration = 0;

			for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

				const track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

			return this;

		}

		trim() {

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		}

		validate() {

			let valid = true;

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				valid = valid && this.tracks[ i ].validate();

			}

			return valid;

		}

		optimize() {

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

		clone() {

			const tracks = [];

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				tracks.push( this.tracks[ i ].clone() );

			}

			return new this.constructor( this.name, this.duration, tracks, this.blendMode );

		}

		toJSON() {

			return this.constructor.toJSON( this );

		}

	}

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		const trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			const times = [], values = [];

			flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	const Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	class LoadingManager {

		constructor( onLoad, onProgress, onError ) {

			const scope = this;

			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = [];

			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

			this.resolveURL = function ( url ) {

				if ( urlModifier ) {

					return urlModifier( url );

				}

				return url;

			};

			this.setURLModifier = function ( transform ) {

				urlModifier = transform;

				return this;

			};

			this.addHandler = function ( regex, loader ) {

				handlers.push( regex, loader );

				return this;

			};

			this.removeHandler = function ( regex ) {

				const index = handlers.indexOf( regex );

				if ( index !== - 1 ) {

					handlers.splice( index, 2 );

				}

				return this;

			};

			this.getHandler = function ( file ) {

				for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

					const regex = handlers[ i ];
					const loader = handlers[ i + 1 ];

					if ( regex.global ) regex.lastIndex = 0; // see #17920

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			};

		}

	}

	const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

	class Loader {

		constructor( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};

		}

		load( /* url, onLoad, onProgress, onError */ ) {}

		loadAsync( url, onProgress ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		}

		parse( /* data */ ) {}

		setCrossOrigin( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		}

		setWithCredentials( value ) {

			this.withCredentials = value;
			return this;

		}

		setPath( path ) {

			this.path = path;
			return this;

		}

		setResourcePath( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		}

		setRequestHeader( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	}

	Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';

	const loading = {};

	class HttpError extends Error {

		constructor( message, response ) {

			super( message );
			this.response = response;

		}

	}

	class FileLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				this.manager.itemStart( url );

				setTimeout( () => {

					if ( onLoad ) onLoad( cached );

					this.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Initialise array for duplicate requests
			loading[ url ] = [];

			loading[ url ].push( {
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError,
			} );

			// create request
			const req = new Request( url, {
				headers: new Headers( this.requestHeader ),
				credentials: this.withCredentials ? 'include' : 'same-origin',
				// An abort controller could be added within a future PR
			} );

			// record states ( avoid data race )
			const mimeType = this.mimeType;
			const responseType = this.responseType;

			// start the fetch
			fetch( req )
				.then( response => {

					if ( response.status === 200 || response.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( response.status === 0 ) {

							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						}

						// Workaround: Checking if response.body === undefined for Alipay browser #23548

						if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

							return response;

						}

						const callbacks = loading[ url ];
						const reader = response.body.getReader();

						// Nginx needs X-File-Size check
						// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
						const contentLength = response.headers.get( 'Content-Length' ) || response.headers.get( 'X-File-Size' );
						const total = contentLength ? parseInt( contentLength ) : 0;
						const lengthComputable = total !== 0;
						let loaded = 0;

						// periodically read data into the new stream tracking while download progress
						const stream = new ReadableStream( {
							start( controller ) {

								readData();

								function readData() {

									reader.read().then( ( { done, value } ) => {

										if ( done ) {

											controller.close();

										} else {

											loaded += value.byteLength;

											const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
											for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

												const callback = callbacks[ i ];
												if ( callback.onProgress ) callback.onProgress( event );

											}

											controller.enqueue( value );
											readData();

										}

									} );

								}

							}

						} );

						return new Response( stream );

					} else {

						throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

					}

				} )
				.then( response => {

					switch ( responseType ) {

						case 'arraybuffer':

							return response.arrayBuffer();

						case 'blob':

							return response.blob();

						case 'document':

							return response.text()
								.then( text => {

									const parser = new DOMParser();
									return parser.parseFromString( text, mimeType );

								} );

						case 'json':

							return response.json();

						default:

							if ( mimeType === undefined ) {

								return response.text();

							} else {

								// sniff encoding
								const re = /charset="?([^;"\s]*)"?/i;
								const exec = re.exec( mimeType );
								const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
								const decoder = new TextDecoder( label );
								return response.arrayBuffer().then( ab => decoder.decode( ab ) );

							}

					}

				} )
				.then( data => {

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, data );

					const callbacks = loading[ url ];
					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( data );

					}

				} )
				.catch( err => {

					// Abort errors and other errors are handled the same

					const callbacks = loading[ url ];

					if ( callbacks === undefined ) {

						// When onLoad was called and url was deleted in `loading`
						this.manager.itemError( url );
						throw err;

					}

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( err );

					}

					this.manager.itemError( url );

				} )
				.finally( () => {

					this.manager.itemEnd( url );

				} );

			this.manager.itemStart( url );

		}

		setResponseType( value ) {

			this.responseType = value;
			return this;

		}

		setMimeType( value ) {

			this.mimeType = value;
			return this;

		}

	}

	class AnimationLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				try {

					onLoad( scope.parse( JSON.parse( text ) ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

		parse( json ) {

			const animations = [];

			for ( let i = 0; i < json.length; i ++ ) {

				const clip = AnimationClip.parse( json[ i ] );

				animations.push( clip );

			}

			return animations;

		}

	}

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class CompressedTextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const images = [];

			const texture = new CompressedTexture();

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( scope.withCredentials );

			let loaded = 0;

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					const texDatas = scope.parse( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				for ( let i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					const texDatas = scope.parse( buffer, true );

					if ( texDatas.isCubemap ) {

						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( let f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

						texture.image = images;

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		}

	}

	class ImageLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const image = createElementNS( 'img' );

			function onImageLoad() {

				removeEventListeners();

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				removeEventListeners();

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			function removeEventListeners() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.slice( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	}

	class CubeTextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( urls, onLoad, onProgress, onError ) {

			const texture = new CubeTexture();
			texture.colorSpace = SRGBColorSpace;

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			let loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( let i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		}

	}

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class DataTextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const texture = new DataTexture();

			const loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setPath( this.path );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( buffer ) {

				const texData = scope.parse( buffer );

				if ( ! texData ) return;

				if ( texData.image !== undefined ) {

					texture.image = texData.image;

				} else if ( texData.data !== undefined ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if ( texData.colorSpace !== undefined ) {

					texture.colorSpace = texData.colorSpace;

				} else if ( texData.encoding !== undefined ) { // @deprecated, r152

					texture.encoding = texData.encoding;

				}

				if ( texData.flipY !== undefined ) {

					texture.flipY = texData.flipY;

				}

				if ( texData.format !== undefined ) {

					texture.format = texData.format;

				}

				if ( texData.type !== undefined ) {

					texture.type = texData.type;

				}

				if ( texData.mipmaps !== undefined ) {

					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...

				}

				if ( texData.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				if ( texData.generateMipmaps !== undefined ) {

					texture.generateMipmaps = texData.generateMipmaps;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	}

	class TextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const texture = new Texture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	}

	class Light extends Object3D {

		constructor( color, intensity = 1 ) {

			super();

			this.isLight = true;

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity;

		}

		dispose() {

			// Empty here in base class; some subclasses override.

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	}

	class HemisphereLight extends Light {

		constructor( skyColor, groundColor, intensity ) {

			super( skyColor, intensity );

			this.isHemisphereLight = true;

			this.type = 'HemisphereLight';

			this.position.copy( Object3D.DEFAULT_UP );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	}

	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	const _lookTarget$1 = /*@__PURE__*/ new Vector3();

	class LightShadow {

		constructor( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();

			this.autoUpdate = true;
			this.needsUpdate = false;

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		getViewportCount() {

			return this._viewportCount;

		}

		getFrustum() {

			return this._frustum;

		}

		updateMatrices( light ) {

			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld$1 );

			_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _lookTarget$1 );
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( _projScreenMatrix$1 );

		}

		getViewport( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		}

		getFrameExtents() {

			return this._frameExtents;

		}

		dispose() {

			if ( this.map ) {

				this.map.dispose();

			}

			if ( this.mapPass ) {

				this.mapPass.dispose();

			}

		}

		copy( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	}

	class SpotLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

			this.isSpotLightShadow = true;

			this.focus = 1;

		}

		updateMatrices( light ) {

			const camera = this.camera;

			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

			super.updateMatrices( light );

		}

		copy( source ) {

			super.copy( source );

			this.focus = source.focus;

			return this;

		}

	}

	class SpotLight extends Light {

		constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {

			super( color, intensity );

			this.isSpotLight = true;

			this.type = 'SpotLight';

			this.position.copy( Object3D.DEFAULT_UP );
			this.updateMatrix();

			this.target = new Object3D();

			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay;

			this.map = null;

			this.shadow = new SpotLightShadow();

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
			return this.intensity * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / Math.PI;

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();

	class PointLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			this.isPointLightShadow = true;

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

		}

		updateMatrices( light, viewportIndex = 0 ) {

			const camera = this.camera;
			const shadowMatrix = this.matrix;

			const far = light.distance || camera.far;

			if ( far !== camera.far ) {

				camera.far = far;
				camera.updateProjectionMatrix();

			}

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld );

			_lookTarget.copy( camera.position );
			_lookTarget.add( this._cubeDirections[ viewportIndex ] );
			camera.up.copy( this._cubeUps[ viewportIndex ] );
			camera.lookAt( _lookTarget );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix );

		}

	}

	class PointLight extends Light {

		constructor( color, intensity, distance = 0, decay = 2 ) {

			super( color, intensity );

			this.isPointLight = true;

			this.type = 'PointLight';

			this.distance = distance;
			this.decay = decay;

			this.shadow = new PointLightShadow();

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in candela)
			// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
			return this.intensity * 4 * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in candela) from the desired luminous power (in lumens)
			this.intensity = power / ( 4 * Math.PI );

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	class DirectionalLightShadow extends LightShadow {

		constructor() {

			super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

			this.isDirectionalLightShadow = true;

		}

	}

	class DirectionalLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.isDirectionalLight = true;

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DEFAULT_UP );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source ) {

			super.copy( source );

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();

			return this;

		}

	}

	class AmbientLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.isAmbientLight = true;

			this.type = 'AmbientLight';

		}

	}

	class RectAreaLight extends Light {

		constructor( color, intensity, width = 10, height = 10 ) {

			super( color, intensity );

			this.isRectAreaLight = true;

			this.type = 'RectAreaLight';

			this.width = width;
			this.height = height;

		}

		get power() {

			// compute the light's luminous power (in lumens) from its intensity (in nits)
			return this.intensity * this.width * this.height * Math.PI;

		}

		set power( power ) {

			// set the light's intensity (in nits) from the desired luminous power (in lumens)
			this.intensity = power / ( this.width * this.height * Math.PI );

		}

		copy( source ) {

			super.copy( source );

			this.width = source.width;
			this.height = source.height;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	}

	/**
	 * Primary reference:
	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
	 */

	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {

		constructor() {

			this.isSphericalHarmonics3 = true;

			this.coefficients = [];

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients.push( new Vector3() );

			}

		}

		set( coefficients ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].copy( coefficients[ i ] );

			}

			return this;

		}

		zero() {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].set( 0, 0, 0 );

			}

			return this;

		}

		// get the radiance in the direction of the normal
		// target is a Vector3
		getAt( normal, target ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			const coeff = this.coefficients;

			// band 0
			target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

			// band 1
			target.addScaledVector( coeff[ 1 ], 0.488603 * y );
			target.addScaledVector( coeff[ 2 ], 0.488603 * z );
			target.addScaledVector( coeff[ 3 ], 0.488603 * x );

			// band 2
			target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
			target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
			target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
			target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
			target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

			return target;

		}

		// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		getIrradianceAt( normal, target ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			const coeff = this.coefficients;

			// band 0
			target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

			// band 1
			target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
			target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
			target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

			// band 2
			target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
			target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
			target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
			target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
			target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

			return target;

		}

		add( sh ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].add( sh.coefficients[ i ] );

			}

			return this;

		}

		addScaledSH( sh, s ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

			}

			return this;

		}

		scale( s ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].multiplyScalar( s );

			}

			return this;

		}

		lerp( sh, alpha ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

			}

			return this;

		}

		equals( sh ) {

			for ( let i = 0; i < 9; i ++ ) {

				if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

					return false;

				}

			}

			return true;

		}

		copy( sh ) {

			return this.set( sh.coefficients );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		fromArray( array, offset = 0 ) {

			const coefficients = this.coefficients;

			for ( let i = 0; i < 9; i ++ ) {

				coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const coefficients = this.coefficients;

			for ( let i = 0; i < 9; i ++ ) {

				coefficients[ i ].toArray( array, offset + ( i * 3 ) );

			}

			return array;

		}

		// evaluate the basis functions
		// shBasis is an Array[ 9 ]
		static getBasisAt( normal, shBasis ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			// band 0
			shBasis[ 0 ] = 0.282095;

			// band 1
			shBasis[ 1 ] = 0.488603 * y;
			shBasis[ 2 ] = 0.488603 * z;
			shBasis[ 3 ] = 0.488603 * x;

			// band 2
			shBasis[ 4 ] = 1.092548 * x * y;
			shBasis[ 5 ] = 1.092548 * y * z;
			shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
			shBasis[ 7 ] = 1.092548 * x * z;
			shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

		}

	}

	class LightProbe extends Light {

		constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

			super( undefined, intensity );

			this.isLightProbe = true;

			this.sh = sh;

		}

		copy( source ) {

			super.copy( source );

			this.sh.copy( source.sh );

			return this;

		}

		fromJSON( json ) {

			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
			this.sh.fromArray( json.sh );

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.sh = this.sh.toArray();

			return data;

		}

	}

	class MaterialLoader extends Loader {

		constructor( manager ) {

			super( manager );
			this.textures = {};

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.setRequestHeader( scope.requestHeader );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( text ) {

				try {

					onLoad( scope.parse( JSON.parse( text ) ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

		parse( json ) {

			const textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			const material = MaterialLoader.createMaterialFromType( json.type );

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.sheen !== undefined ) material.sheen = json.sheen;
			if ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );
			if ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;
			if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;
			if ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
			if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
			if ( json.iridescence !== undefined ) material.iridescence = json.iridescence;
			if ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;
			if ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
			if ( json.transmission !== undefined ) material.transmission = json.transmission;
			if ( json.thickness !== undefined ) material.thickness = json.thickness;
			if ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;
			if ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );
			if ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;
			if ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.combine !== undefined ) material.combine = json.combine;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

			if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
			if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
			if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
			if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
			if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
			if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
			if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
			if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;
			if ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;
			if ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;

			if ( json.visible !== undefined ) material.visible = json.visible;

			if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

			if ( json.userData !== undefined ) material.userData = json.userData;

			if ( json.vertexColors !== undefined ) {

				if ( typeof json.vertexColors === 'number' ) {

					material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

				} else {

					material.vertexColors = json.vertexColors;

				}

			}

			// Shader Material

			if ( json.uniforms !== undefined ) {

				for ( const name in json.uniforms ) {

					const uniform = json.uniforms[ name ];

					material.uniforms[ name ] = {};

					switch ( uniform.type ) {

						case 't':
							material.uniforms[ name ].value = getTexture( uniform.value );
							break;

						case 'c':
							material.uniforms[ name ].value = new Color().setHex( uniform.value );
							break;

						case 'v2':
							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
							break;

						case 'v3':
							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
							break;

						case 'v4':
							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
							break;

						case 'm3':
							material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
							break;

						case 'm4':
							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
							break;

						default:
							material.uniforms[ name ].value = uniform.value;

					}

				}

			}

			if ( json.defines !== undefined ) material.defines = json.defines;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;

			if ( json.extensions !== undefined ) {

				for ( const key in json.extensions ) {

					material.extensions[ key ] = json.extensions[ key ];

				}

			}

			if ( json.lights !== undefined ) material.lights = json.lights;
			if ( json.clipping !== undefined ) material.clipping = json.clipping;

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );
			if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

			if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {

				let normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
			if ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );
			if ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
			if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
			if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
			if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
			if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

			if ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );
			if ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );

			if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );
			if ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );

			if ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );

			if ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );
			if ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );

			return material;

		}

		setTextures( value ) {

			this.textures = value;
			return this;

		}

		static createMaterialFromType( type ) {

			const materialLib = {
				ShadowMaterial,
				SpriteMaterial,
				RawShaderMaterial,
				ShaderMaterial,
				PointsMaterial,
				MeshPhysicalMaterial,
				MeshStandardMaterial,
				MeshPhongMaterial,
				MeshToonMaterial,
				MeshNormalMaterial,
				MeshLambertMaterial,
				MeshDepthMaterial,
				MeshDistanceMaterial,
				MeshBasicMaterial,
				MeshMatcapMaterial,
				LineDashedMaterial,
				LineBasicMaterial,
				Material
			};

			return new materialLib[ type ]();

		}

	}

	class LoaderUtils {

		static decodeText( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			let s = '';

			for ( let i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			try {

				// merges multi-byte utf-8 characters.

				return decodeURIComponent( escape( s ) );

			} catch ( e ) { // see #16358

				return s;

			}

		}

		static extractUrlBase( url ) {

			const index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.slice( 0, index + 1 );

		}

		static resolveURL( url, path ) {

			// Invalid URL
			if ( typeof url !== 'string' || url === '' ) return '';

			// Host Relative URL
			if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

				path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

			}

			// Absolute URL http://,https://,//
			if ( /^(https?:)?\/\//i.test( url ) ) return url;

			// Data URI
			if ( /^data:.*,.*$/i.test( url ) ) return url;

			// Blob URL
			if ( /^blob:.*$/i.test( url ) ) return url;

			// Relative URL
			return path + url;

		}

	}

	class InstancedBufferGeometry extends BufferGeometry {

		constructor() {

			super();

			this.isInstancedBufferGeometry = true;

			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;

		}

		copy( source ) {

			super.copy( source );

			this.instanceCount = source.instanceCount;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	}

	class BufferGeometryLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.setRequestHeader( scope.requestHeader );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( text ) {

				try {

					onLoad( scope.parse( JSON.parse( text ) ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

		parse( json ) {

			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer( json, uuid ) {

				if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[ uuid ];

				const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

				const array = getTypedArray( interleavedBuffer.type, buffer );
				const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
				ib.uuid = interleavedBuffer.uuid;

				interleavedBufferMap[ uuid ] = ib;

				return ib;

			}

			function getArrayBuffer( json, uuid ) {

				if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[ uuid ];

				const ab = new Uint32Array( arrayBuffer ).buffer;

				arrayBufferMap[ uuid ] = ab;

				return ab;

			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

			const index = json.data.index;

			if ( index !== undefined ) {

				const typedArray = getTypedArray( index.type, index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			const attributes = json.data.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];
				let bufferAttribute;

				if ( attribute.isInterleavedBufferAttribute ) {

					const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
					bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

				} else {

					const typedArray = getTypedArray( attribute.type, attribute.array );
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

				}

				if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
				if ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );

				if ( attribute.updateRange !== undefined ) {

					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;

				}

				geometry.setAttribute( key, bufferAttribute );

			}

			const morphAttributes = json.data.morphAttributes;

			if ( morphAttributes ) {

				for ( const key in morphAttributes ) {

					const attributeArray = morphAttributes[ key ];

					const array = [];

					for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

						const attribute = attributeArray[ i ];
						let bufferAttribute;

						if ( attribute.isInterleavedBufferAttribute ) {

							const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
							bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

						} else {

							const typedArray = getTypedArray( attribute.type, attribute.array );
							bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

						}

						if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
						array.push( bufferAttribute );

					}

					geometry.morphAttributes[ key ] = array;

				}

			}

			const morphTargetsRelative = json.data.morphTargetsRelative;

			if ( morphTargetsRelative ) {

				geometry.morphTargetsRelative = true;

			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( let i = 0, n = groups.length; i !== n; ++ i ) {

					const group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			const boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				const center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			if ( json.name ) geometry.name = json.name;
			if ( json.userData ) geometry.userData = json.userData;

			return geometry;

		}

	}

	class ObjectLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
			this.resourcePath = this.resourcePath || path;

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				let json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				const metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					if ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\'t load ' + url ) );

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		}

		async loadAsync( url, onProgress ) {

			const scope = this;

			const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
			this.resourcePath = this.resourcePath || path;

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );

			const text = await loader.loadAsync( url, onProgress );

			const json = JSON.parse( text );

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				throw new Error( 'THREE.ObjectLoader: Can\'t load ' + url );

			}

			return await scope.parseAsync( json );

		}

		parse( json, onLoad ) {

			const animations = this.parseAnimations( json.animations );
			const shapes = this.parseShapes( json.shapes );
			const geometries = this.parseGeometries( json.geometries, shapes );

			const images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			const textures = this.parseTextures( json.textures, images );
			const materials = this.parseMaterials( json.materials, textures );

			const object = this.parseObject( json.object, geometries, materials, textures, animations );
			const skeletons = this.parseSkeletons( json.skeletons, object );

			this.bindSkeletons( object, skeletons );

			//

			if ( onLoad !== undefined ) {

				let hasImages = false;

				for ( const uuid in images ) {

					if ( images[ uuid ].data instanceof HTMLImageElement ) {

						hasImages = true;
						break;

					}

				}

				if ( hasImages === false ) onLoad( object );

			}

			return object;

		}

		async parseAsync( json ) {

			const animations = this.parseAnimations( json.animations );
			const shapes = this.parseShapes( json.shapes );
			const geometries = this.parseGeometries( json.geometries, shapes );

			const images = await this.parseImagesAsync( json.images );

			const textures = this.parseTextures( json.textures, images );
			const materials = this.parseMaterials( json.materials, textures );

			const object = this.parseObject( json.object, geometries, materials, textures, animations );
			const skeletons = this.parseSkeletons( json.skeletons, object );

			this.bindSkeletons( object, skeletons );

			return object;

		}

		parseShapes( json ) {

			const shapes = {};

			if ( json !== undefined ) {

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		}

		parseSkeletons( json, object ) {

			const skeletons = {};
			const bones = {};

			// generate bone lookup table

			object.traverse( function ( child ) {

				if ( child.isBone ) bones[ child.uuid ] = child;

			} );

			// create skeletons

			if ( json !== undefined ) {

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const skeleton = new Skeleton().fromJSON( json[ i ], bones );

					skeletons[ skeleton.uuid ] = skeleton;

				}

			}

			return skeletons;

		}

		parseGeometries( json, shapes ) {

			const geometries = {};

			if ( json !== undefined ) {

				const bufferGeometryLoader = new BufferGeometryLoader();

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					let geometry;
					const data = json[ i ];

					switch ( data.type ) {

						case 'BufferGeometry':
						case 'InstancedBufferGeometry':

							geometry = bufferGeometryLoader.parse( data );
							break;

						default:

							if ( data.type in Geometries ) {

								geometry = Geometries[ data.type ].fromJSON( data, shapes );

							} else {

								console.warn( `THREE.ObjectLoader: Unsupported geometry type "${ data.type }"` );

							}

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;
					if ( data.userData !== undefined ) geometry.userData = data.userData;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		}

		parseMaterials( json, textures ) {

			const cache = {}; // MultiMaterial
			const materials = {};

			if ( json !== undefined ) {

				const loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const data = json[ i ];

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

			return materials;

		}

		parseAnimations( json ) {

			const animations = {};

			if ( json !== undefined ) {

				for ( let i = 0; i < json.length; i ++ ) {

					const data = json[ i ];

					const clip = AnimationClip.parse( data );

					animations[ clip.uuid ] = clip;

				}

			}

			return animations;

		}

		parseImages( json, onLoad ) {

			const scope = this;
			const images = {};

			let loader;

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				} );

			}

			function deserializeImage( image ) {

				if ( typeof image === 'string' ) {

					const url = image;

					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

					return loadImage( path );

				} else {

					if ( image.data ) {

						return {
							data: getTypedArray( image.type, image.data ),
							width: image.width,
							height: image.height
						};

					} else {

						return null;

					}

				}

			}

			if ( json !== undefined && json.length > 0 ) {

				const manager = new LoadingManager( onLoad );

				loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( let i = 0, il = json.length; i < il; i ++ ) {

					const image = json[ i ];
					const url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						const imageArray = [];

						for ( let j = 0, jl = url.length; j < jl; j ++ ) {

							const currentUrl = url[ j ];

							const deserializedImage = deserializeImage( currentUrl );

							if ( deserializedImage !== null ) {

								if ( deserializedImage instanceof HTMLImageElement ) {

									imageArray.push( deserializedImage );

								} else {

									// special case: handle array of data textures for cube textures

									imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

								}

							}

						}

						images[ image.uuid ] = new Source( imageArray );

					} else {

						// load single image

						const deserializedImage = deserializeImage( image.url );
						images[ image.uuid ] = new Source( deserializedImage );


					}

				}

			}

			return images;

		}

		async parseImagesAsync( json ) {

			const scope = this;
			const images = {};

			let loader;

			async function deserializeImage( image ) {

				if ( typeof image === 'string' ) {

					const url = image;

					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

					return await loader.loadAsync( path );

				} else {

					if ( image.data ) {

						return {
							data: getTypedArray( image.type, image.data ),
							width: image.width,
							height: image.height
						};

					} else {

						return null;

					}

				}

			}

			if ( json !== undefined && json.length > 0 ) {

				loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( let i = 0, il = json.length; i < il; i ++ ) {

					const image = json[ i ];
					const url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						const imageArray = [];

						for ( let j = 0, jl = url.length; j < jl; j ++ ) {

							const currentUrl = url[ j ];

							const deserializedImage = await deserializeImage( currentUrl );

							if ( deserializedImage !== null ) {

								if ( deserializedImage instanceof HTMLImageElement ) {

									imageArray.push( deserializedImage );

								} else {

									// special case: handle array of data textures for cube textures

									imageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

								}

							}

						}

						images[ image.uuid ] = new Source( imageArray );

					} else {

						// load single image

						const deserializedImage = await deserializeImage( image.url );
						images[ image.uuid ] = new Source( deserializedImage );

					}

				}

			}

			return images;

		}

		parseTextures( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			const textures = {};

			if ( json !== undefined ) {

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					const source = images[ data.image ];
					const image = source.data;

					let texture;

					if ( Array.isArray( image ) ) {

						texture = new CubeTexture();

						if ( image.length === 6 ) texture.needsUpdate = true;

					} else {

						if ( image && image.data ) {

							texture = new DataTexture();

						} else {

							texture = new Texture();

						}

						if ( image ) texture.needsUpdate = true; // textures can have undefined image data

					}

					texture.source = source;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
					if ( data.channel !== undefined ) texture.channel = data.channel;

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.format !== undefined ) texture.format = data.format;
					if ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;
					if ( data.type !== undefined ) texture.type = data.type;
					if ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;
					if ( data.encoding !== undefined ) texture.encoding = data.encoding; // @deprecated, r152

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					if ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;
					if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
					if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;
					if ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;

					if ( data.userData !== undefined ) texture.userData = data.userData;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		}

		parseObject( data, geometries, materials, textures, animations ) {

			let object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					const array = [];

					for ( let i = 0, l = name.length; i < l; i ++ ) {

						const uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			function getTexture( uuid ) {

				if ( textures[ uuid ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined texture', uuid );

				}

				return textures[ uuid ];

			}

			let geometry, material;

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						} else {

							object.background = getTexture( data.background );

						}

					}

					if ( data.environment !== undefined ) {

						object.environment = getTexture( data.environment );

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					if ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;
					if ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'LightProbe':

					object = new LightProbe().fromJSON( data );

					break;

				case 'SkinnedMesh':

					geometry = getGeometry( data.geometry );
				 	material = getMaterial( data.material );

					object = new SkinnedMesh( geometry, material );

					if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
					if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
					if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

					break;

				case 'Mesh':

					geometry = getGeometry( data.geometry );
					material = getMaterial( data.material );

					object = new Mesh( geometry, material );

					break;

				case 'InstancedMesh':

					geometry = getGeometry( data.geometry );
					material = getMaterial( data.material );
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;
					const instanceColor = data.instanceColor;

					object = new InstancedMesh( geometry, material, count );
					object.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
					if ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				case 'Bone':

					object = new Bone();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;

			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );

				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.up !== undefined ) object.up.fromArray( data.up );

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;

			if ( data.children !== undefined ) {

				const children = data.children;

				for ( let i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );

				}

			}

			if ( data.animations !== undefined ) {

				const objectAnimations = data.animations;

				for ( let i = 0; i < objectAnimations.length; i ++ ) {

					const uuid = objectAnimations[ i ];

					object.animations.push( animations[ uuid ] );

				}

			}

			if ( data.type === 'LOD' ) {

				if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

				const levels = data.levels;

				for ( let l = 0; l < levels.length; l ++ ) {

					const level = levels[ l ];
					const child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance, level.hysteresis );

					}

				}

			}

			return object;

		}

		bindSkeletons( object, skeletons ) {

			if ( Object.keys( skeletons ).length === 0 ) return;

			object.traverse( function ( child ) {

				if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

					const skeleton = skeletons[ child.skeleton ];

					if ( skeleton === undefined ) {

						console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

					} else {

						child.bind( skeleton, child.bindMatrix );

					}

				}

			} );

		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping
	};

	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	class ImageBitmapLoader extends Loader {

		constructor( manager ) {

			super( manager );

			this.isImageBitmapLoader = true;

			if ( typeof createImageBitmap === 'undefined' ) {

				console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

			}

			if ( typeof fetch === 'undefined' ) {

				console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

			}

			this.options = { premultiplyAlpha: 'none' };

		}

		setOptions( options ) {

			this.options = options;

			return this;

		}

		load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const fetchOptions = {};
			fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;

			fetch( url, fetchOptions ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

			scope.manager.itemStart( url );

		}

	}

	let _context;

	class AudioContext {

		static getContext() {

			if ( _context === undefined ) {

				_context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return _context;

		}

		static setContext( value ) {

			_context = value;

		}

	}

	class AudioLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( buffer ) {

				try {

					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice( 0 );

					const context = AudioContext.getContext();
					context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

						onLoad( audioBuffer );

					}, handleError );

				} catch ( e ) {

					handleError( e );

				}

			}, onProgress, onError );

			function handleError( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}

	}

	class HemisphereLightProbe extends LightProbe {

		constructor( skyColor, groundColor, intensity = 1 ) {

			super( undefined, intensity );

			this.isHemisphereLightProbe = true;

			const color1 = new Color().set( skyColor );
			const color2 = new Color().set( groundColor );

			const sky = new Vector3( color1.r, color1.g, color1.b );
			const ground = new Vector3( color2.r, color2.g, color2.b );

			// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
			const c0 = Math.sqrt( Math.PI );
			const c1 = c0 * Math.sqrt( 0.75 );

			this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
			this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

		}

	}

	class AmbientLightProbe extends LightProbe {

		constructor( color, intensity = 1 ) {

			super( undefined, intensity );

			this.isAmbientLightProbe = true;

			const color1 = new Color().set( color );

			// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
			this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

		}

	}

	const _eyeRight = /*@__PURE__*/ new Matrix4();
	const _eyeLeft = /*@__PURE__*/ new Matrix4();
	const _projectionMatrix = /*@__PURE__*/ new Matrix4();

	class StereoCamera {

		constructor() {

			this.type = 'StereoCamera';

			this.aspect = 1;

			this.eyeSep = 0.064;

			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;

			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;

			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};

		}

		update( camera ) {

			const cache = this._cache;

			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
				cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
				cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if ( needsUpdate ) {

				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				_projectionMatrix.copy( camera.projectionMatrix );
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
				let xmin, xmax;

				// translate xOffset

				_eyeLeft.elements[ 12 ] = - eyeSepHalf;
				_eyeRight.elements[ 12 ] = eyeSepHalf;

				// for left eye

				xmin = - ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;

				_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( _projectionMatrix );

				// for right eye

				xmin = - ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;

				_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( _projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

		}

	}

	class Clock {

		constructor( autoStart = true ) {

			this.autoStart = autoStart;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		start() {

			this.startTime = now();

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		}

		stop() {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		}

		getElapsedTime() {

			this.getDelta();
			return this.elapsedTime;

		}

		getDelta() {

			let diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				const newTime = now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	}

	function now() {

		return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

	}

	const _position$1 = /*@__PURE__*/ new Vector3();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion();
	const _scale$1 = /*@__PURE__*/ new Vector3();
	const _orientation$1 = /*@__PURE__*/ new Vector3();

	class AudioListener extends Object3D {

		constructor() {

			super();

			this.type = 'AudioListener';

			this.context = AudioContext.getContext();

			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );

			this.filter = null;

			this.timeDelta = 0;

			// private

			this._clock = new Clock();

		}

		getInput() {

			return this.gain;

		}

		removeFilter() {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

			return this;

		}

		getFilter() {

			return this.filter;

		}

		setFilter( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

			return this;

		}

		getMasterVolume() {

			return this.gain.gain.value;

		}

		setMasterVolume( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			const listener = this.context.listener;
			const up = this.up;

			this.timeDelta = this._clock.getDelta();

			this.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );

			_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );

			if ( listener.positionX ) {

				// code path for Chrome (see #14393)

				const endTime = this.context.currentTime + this.timeDelta;

				listener.positionX.linearRampToValueAtTime( _position$1.x, endTime );
				listener.positionY.linearRampToValueAtTime( _position$1.y, endTime );
				listener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );
				listener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );
				listener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );
				listener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );
				listener.upX.linearRampToValueAtTime( up.x, endTime );
				listener.upY.linearRampToValueAtTime( up.y, endTime );
				listener.upZ.linearRampToValueAtTime( up.z, endTime );

			} else {

				listener.setPosition( _position$1.x, _position$1.y, _position$1.z );
				listener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );

			}

		}

	}

	class Audio extends Object3D {

		constructor( listener ) {

			super();

			this.type = 'Audio';

			this.listener = listener;
			this.context = listener.context;

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';

			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;

			this.filters = [];

		}

		getOutput() {

			return this.gain;

		}

		setNodeSource( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		}

		setMediaElementSource( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		}

		setMediaStreamSource( mediaStream ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource( mediaStream );
			this.connect();

			return this;

		}

		setBuffer( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		}

		play( delay = 0 ) {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._startedAt = this.context.currentTime + delay;

			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind( this );
			source.start( this._startedAt, this._progress + this.offset, this.duration );

			this.isPlaying = true;

			this.source = source;

			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );

			return this.connect();

		}

		pause() {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				// update current progress

				this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

				if ( this.loop === true ) {

					// ensure _progress does not exceed duration with looped audios

					this._progress = this._progress % ( this.duration || this.buffer.duration );

				}

				this.source.stop();
				this.source.onended = null;

				this.isPlaying = false;

			}

			return this;

		}

		stop() {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._progress = 0;

			if ( this.source !== null ) {

				this.source.stop();
				this.source.onended = null;

			}

			this.isPlaying = false;

			return this;

		}

		connect() {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			this._connected = true;

			return this;

		}

		disconnect() {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			this._connected = false;

			return this;

		}

		getFilters() {

			return this.filters;

		}

		setFilters( value ) {

			if ( ! value ) value = [];

			if ( this._connected === true ) {

				this.disconnect();
				this.filters = value.slice();
				this.connect();

			} else {

				this.filters = value.slice();

			}

			return this;

		}

		setDetune( value ) {

			this.detune = value;

			if ( this.source.detune === undefined ) return; // only set detune when available

			if ( this.isPlaying === true ) {

				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

			}

			return this;

		}

		getDetune() {

			return this.detune;

		}

		getFilter() {

			return this.getFilters()[ 0 ];

		}

		setFilter( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		}

		setPlaybackRate( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

			}

			return this;

		}

		getPlaybackRate() {

			return this.playbackRate;

		}

		onEnded() {

			this.isPlaying = false;

		}

		getLoop() {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		}

		setLoop( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		}

		setLoopStart( value ) {

			this.loopStart = value;

			return this;

		}

		setLoopEnd( value ) {

			this.loopEnd = value;

			return this;

		}

		getVolume() {

			return this.gain.gain.value;

		}

		setVolume( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	}

	const _position = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion();
	const _scale = /*@__PURE__*/ new Vector3();
	const _orientation = /*@__PURE__*/ new Vector3();

	class PositionalAudio extends Audio {

		constructor( listener ) {

			super( listener );

			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect( this.gain );

		}

		connect() {

			super.connect();

			this.panner.connect( this.gain );

		}

		disconnect() {

			super.disconnect();

			this.panner.disconnect( this.gain );

		}

		getOutput() {

			return this.panner;

		}

		getRefDistance() {

			return this.panner.refDistance;

		}

		setRefDistance( value ) {

			this.panner.refDistance = value;

			return this;

		}

		getRolloffFactor() {

			return this.panner.rolloffFactor;

		}

		setRolloffFactor( value ) {

			this.panner.rolloffFactor = value;

			return this;

		}

		getDistanceModel() {

			return this.panner.distanceModel;

		}

		setDistanceModel( value ) {

			this.panner.distanceModel = value;

			return this;

		}

		getMaxDistance() {

			return this.panner.maxDistance;

		}

		setMaxDistance( value ) {

			this.panner.maxDistance = value;

			return this;

		}

		setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

			this.matrixWorld.decompose( _position, _quaternion, _scale );

			_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );

			const panner = this.panner;

			if ( panner.positionX ) {

				// code path for Chrome and Firefox (see #14393)

				const endTime = this.context.currentTime + this.listener.timeDelta;

				panner.positionX.linearRampToValueAtTime( _position.x, endTime );
				panner.positionY.linearRampToValueAtTime( _position.y, endTime );
				panner.positionZ.linearRampToValueAtTime( _position.z, endTime );
				panner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );
				panner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );
				panner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );

			} else {

				panner.setPosition( _position.x, _position.y, _position.z );
				panner.setOrientation( _orientation.x, _orientation.y, _orientation.z );

			}

		}

	}

	class AudioAnalyser {

		constructor( audio, fftSize = 2048 ) {

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;

			this.data = new Uint8Array( this.analyser.frequencyBinCount );

			audio.getOutput().connect( this.analyser );

		}


		getFrequencyData() {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		}

		getAverageFrequency() {

			let value = 0;
			const data = this.getFrequencyData();

			for ( let i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	}

	class PropertyMixer {

		constructor( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			let mixFunction,
				mixFunctionAdditive,
				setIdentity;

			// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch ( typeName ) {

				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;

					this.buffer = new Float64Array( valueSize * 6 );
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select;

					// Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types
					mixFunctionAdditive = this._select;

					setIdentity = this._setAdditiveIdentityOther;

					this.buffer = new Array( valueSize * 5 );
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;

					this.buffer = new Float64Array( valueSize * 5 );

			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride;

			let currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( let i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				const mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		}

		// accumulate data in the 'incoming' region into 'add'
		accumulateAdditive( weight ) {

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = stride * this._addIndex;

			if ( this.cumulativeWeightAdditive === 0 ) {

				// add = identity

				this._setIdentity();

			}

			// add := add + incoming * weight

			this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
			this.cumulativeWeightAdditive += weight;

		}

		// apply the state of 'accu<i>' to the binding when accus differ
		apply( accuIndex ) {

			const stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,
				weightAdditive = this.cumulativeWeightAdditive,

				binding = this.binding;

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			if ( weightAdditive > 0 ) {

				// accuN := accuN + additive accuN

				this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

			}

			for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		}

		// remember the state of the bound property and copy it to both accus
		saveOriginalState() {

			const binding = this.binding;

			const buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * this._origIndex;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			// Add to identity for additive
			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

		}

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState() {

			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		}

		_setAdditiveIdentityNumeric() {

			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for ( let i = startIndex; i < endIndex; i ++ ) {

				this.buffer[ i ] = 0;

			}

		}

		_setAdditiveIdentityQuaternion() {

			this._setAdditiveIdentityNumeric();
			this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

		}

		_setAdditiveIdentityOther() {

			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for ( let i = 0; i < this.valueSize; i ++ ) {

				this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

			}

		}


		// mix functions

		_select( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( let i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		}

		_slerp( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		}

		_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

			const workOffset = this._workIndex * stride;

			// Store result in intermediate buffer offset
			Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

			// Slerp to the intermediate result
			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

		}

		_lerp( buffer, dstOffset, srcOffset, t, stride ) {

			const s = 1 - t;

			for ( let i = 0; i !== stride; ++ i ) {

				const j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

		_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

			for ( let i = 0; i !== stride; ++ i ) {

				const j = dstOffset + i;

				buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

			}

		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

	const _trackRe = new RegExp( ''
		+ '^'
		+ _directoryRe
		+ _nodeRe
		+ _objectRe
		+ _propertyRe
		+ '$'
	);

	const _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];

	class Composite {

		constructor( targetGroup, path, optionalParsedPath ) {

			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );

		}

		getValue( array, offset ) {

			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		}

		setValue( array, offset ) {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		}

		bind() {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		}

		unbind() {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	}

	// Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.
	class PropertyBinding {

		constructor( rootNode, path, parsedPath ) {

			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

			this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );

			this.rootNode = rootNode;

			// initial state of these methods that calls 'bind'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}


		static create( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		}

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		static sanitizeNodeName( name ) {

			return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

		}

		static parseTrackName( trackName ) {

			const matches = _trackRe.exec( trackName );

			if ( matches === null ) {

				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ],
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ], // required
				propertyIndex: matches[ 6 ]
			};

			const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

			if ( lastDot !== undefined && lastDot !== - 1 ) {

				const objectName = results.nodeName.substring( lastDot + 1 );

				// Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

					results.nodeName = results.nodeName.substring( 0, lastDot );
					results.objectName = objectName;

				}

			}

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

			}

			return results;

		}

		static findNode( root, nodeName ) {

			if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				const bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				const searchNodeSubtree = function ( children ) {

					for ( let i = 0; i < children.length; i ++ ) {

						const childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						const result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				const subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

		// these are used to "bind" a nonexistent property
		_getValue_unavailable() {}
		_setValue_unavailable() {}

		// Getters

		_getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.targetObject[ this.propertyName ];

		}

		_getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		}

		_getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		}

		_getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

		// Direct

		_setValue_direct( buffer, offset ) {

			this.targetObject[ this.propertyName ] = buffer[ offset ];

		}

		_setValue_direct_setNeedsUpdate( buffer, offset ) {

			this.targetObject[ this.propertyName ] = buffer[ offset ];
			this.targetObject.needsUpdate = true;

		}

		_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

			this.targetObject[ this.propertyName ] = buffer[ offset ];
			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		// EntireArray

		_setValue_array( buffer, offset ) {

			const dest = this.resolvedProperty;

			for ( let i = 0, n = dest.length; i !== n; ++ i ) {

				dest[ i ] = buffer[ offset ++ ];

			}

		}

		_setValue_array_setNeedsUpdate( buffer, offset ) {

			const dest = this.resolvedProperty;

			for ( let i = 0, n = dest.length; i !== n; ++ i ) {

				dest[ i ] = buffer[ offset ++ ];

			}

			this.targetObject.needsUpdate = true;

		}

		_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

			const dest = this.resolvedProperty;

			for ( let i = 0, n = dest.length; i !== n; ++ i ) {

				dest[ i ] = buffer[ offset ++ ];

			}

			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		// ArrayElement

		_setValue_arrayElement( buffer, offset ) {

			this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

		}

		_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

			this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
			this.targetObject.needsUpdate = true;

		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

			this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		// HasToFromArray

		_setValue_fromArray( buffer, offset ) {

			this.resolvedProperty.fromArray( buffer, offset );

		}

		_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

			this.resolvedProperty.fromArray( buffer, offset );
			this.targetObject.needsUpdate = true;

		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

			this.resolvedProperty.fromArray( buffer, offset );
			this.targetObject.matrixWorldNeedsUpdate = true;

		}

		_getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

		}

		_setValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		}

		// create getter / setter pair for a property in the scene graph
		bind() {

			let targetObject = this.node;
			const parsedPath = this.parsedPath;

			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				let objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( let i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					case 'map':

						if ( 'map' in targetObject ) {

							targetObject = targetObject.map;
							break;

						}

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.map ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );
							return;

						}

						targetObject = targetObject.material.map;
						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			const nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				const nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			let versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			let bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === 'morphTargetInfluences' ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		}

		unbind() {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	}

	PropertyBinding.Composite = Composite;

	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};

	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};

	PropertyBinding.prototype.GetterByBindingType = [

		PropertyBinding.prototype._getValue_direct,
		PropertyBinding.prototype._getValue_array,
		PropertyBinding.prototype._getValue_arrayElement,
		PropertyBinding.prototype._getValue_toArray,

	];

	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

		[
			// Direct
			PropertyBinding.prototype._setValue_direct,
			PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
			PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

		], [

			// EntireArray

			PropertyBinding.prototype._setValue_array,
			PropertyBinding.prototype._setValue_array_setNeedsUpdate,
			PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

		], [

			// ArrayElement
			PropertyBinding.prototype._setValue_arrayElement,
			PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
			PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

		], [

			// HasToFromArray
			PropertyBinding.prototype._setValue_fromArray,
			PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
			PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

		]

	];

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 */

	class AnimationObjectGroup {

		constructor() {

			this.isAnimationObjectGroup = true;

			this.uuid = generateUUID();

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );

			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				indices[ arguments[ i ].uuid ] = i;

			}

			this._paths = []; // inside: string
			this._parsedPaths = []; // inside: { we don't care, here }
			this._bindings = []; // inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			const scope = this;

			this.stats = {

				objects: {
					get total() {

						return scope._objects.length;

					},
					get inUse() {

						return this.total - scope.nCachedObjects_;

					}
				},
				get bindingsPerObject() {

					return scope._bindings.length;

				}

			};

		}

		add() {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;

			let knownObject = undefined,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_;

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				const object = arguments[ i ],
					uuid = object.uuid;
				let index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ];

						let binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		}

		remove() {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			let nCachedObjects = this.nCachedObjects_;

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				const object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					const lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		}

		// remove & forget
		uncache() {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			let nCachedObjects = this.nCachedObjects_,
				nObjects = objects.length;

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				const object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						const firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( let j = 0, m = nBindings; j !== m; ++ j ) {

							const bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						const lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						if ( lastIndex > 0 ) {

							indicesByUUID[ lastObject.uuid ] = index;

						}

						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( let j = 0, m = nBindings; j !== m; ++ j ) {

							const bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		}

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[ path ];
			const bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				const object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		}

		unsubscribe_( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			const indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				const paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	}

	class AnimationAction {

		constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;

			const tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for ( let i = 0; i !== nTracks; ++ i ) {

				const interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants; // bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null; // for the memory manager
			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = - 1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale
			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false;// keep feeding the last frame?

			this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true;// clips for start, loop and end

		}

		// State & Scheduling

		play() {

			this._mixer._activateAction( this );

			return this;

		}

		stop() {

			this._mixer._deactivateAction( this );

			return this.reset();

		}

		reset() {

			this.paused = false;
			this.enabled = true;

			this.time = 0; // restart clip
			this._loopCount = - 1;// forget previous loops
			this._startTime = null;// forget scheduling

			return this.stopFading().stopWarping();

		}

		isRunning() {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

		}

		// return true when play has been called
		isScheduled() {

			return this._mixer._isActiveAction( this );

		}

		startAt( time ) {

			this._startTime = time;

			return this;

		}

		setLoop( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		}

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		}

		// return the weight considering fading and .enabled
		getEffectiveWeight() {

			return this._effectiveWeight;

		}

		fadeIn( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		}

		fadeOut( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		}

		crossFadeFrom( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				const fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		}

		crossFadeTo( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		}

		stopFading() {

			const weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		}

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		}

		// return the time scale considering warping and .paused
		getEffectiveTimeScale() {

			return this._effectiveTimeScale;

		}

		setDuration( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		}

		syncWith( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		}

		halt( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		}

		warp( startTimeScale, endTimeScale, duration ) {

			const mixer = this._mixer,
				now = mixer.time,
				timeScale = this.timeScale;

			let interpolant = this._timeScaleInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		}

		stopWarping() {

			const timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		}

		// Object Accessors

		getMixer() {

			return this._mixer;

		}

		getClip() {

			return this._clip;

		}

		getRoot() {

			return this._localRoot || this._mixer._root;

		}

		// Interna

		_update( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			const startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				const timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					deltaTime = 0;

				} else {


					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;

				}

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			const clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			const weight = this._updateWeight( time );

			if ( weight > 0 ) {

				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch ( this.blendMode ) {

					case AdditiveAnimationBlendMode:

						for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

							interpolants[ j ].evaluate( clipTime );
							propertyMixers[ j ].accumulateAdditive( weight );

						}

						break;

					case NormalAnimationBlendMode:
					default:

						for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

							interpolants[ j ].evaluate( clipTime );
							propertyMixers[ j ].accumulate( accuIndex, weight );

						}

				}

			}

		}

		_updateWeight( time ) {

			let weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					const interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		}

		_updateTimeScale( time ) {

			let timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				const interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					const interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		}

		_updateTime( deltaTime ) {

			const duration = this._clip.duration;
			const loop = this.loop;

			let time = this.time + deltaTime;
			let loopCount = this._loopCount;

			const pingPong = ( loop === LoopPingPong );

			if ( deltaTime === 0 ) {

				if ( loopCount === - 1 ) return time;

				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

			}

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else {

						this.time = time;

						break handle_stop;

					}

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					const loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					const pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							const atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				} else {

					this.time = time;

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					return duration - time;

				}

			}

			return time;

		}

		_setEndings( atStart, atEnd, pingPong ) {

			const settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		}

		_scheduleFading( duration, weightNow, weightThen ) {

			const mixer = this._mixer, now = mixer.time;
			let interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;
			values[ 1 ] = weightThen;

			return this;

		}

	}

	const _controlInterpolantsResultBuffer = new Float32Array( 1 );


	class AnimationMixer extends EventDispatcher {

		constructor( root ) {

			super();

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;

		}

		_bindAction( action, prototypeAction ) {

			const root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName;

			let bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( let i = 0; i !== nTracks; ++ i ) {

				const track = tracks[ i ],
					trackName = track.name;

				let binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					++ binding.referenceCount;
					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					const path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		}

		_activateAction( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					const rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				const bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

					const binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		}

		_deactivateAction( action ) {

			if ( this._isActiveAction( action ) ) {

				const bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

					const binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		}

		// Memory manager

		_initMemoryManager() {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			const scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		}

		// Memory management for AnimationAction objects

		_isActiveAction( action ) {

			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		}

		_addInactiveAction( action, clipUuid, rootUuid ) {

			const actions = this._actions,
				actionsByClip = this._actionsByClip;

			let actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				const knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		}

		_removeInactiveAction( action ) {

			const actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			const clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			const actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		}

		_removeInactiveBindingsForAction( action ) {

			const bindings = action._propertyBindings;

			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		}

		_lendAction( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		}

		_takeBackAction( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		}

		// Memory management for PropertyMixer objects

		_addInactiveBinding( binding, rootUuid, trackName ) {

			const bindingsByRoot = this._bindingsByRootAndName,
				bindings = this._bindings;

			let bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		}

		_removeInactiveBinding( binding ) {

			const bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			if ( Object.keys( bindingByName ).length === 0 ) {

				delete bindingsByRoot[ rootUuid ];

			}

		}

		_lendBinding( binding ) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		}

		_takeBackBinding( binding ) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		}


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant() {

			const interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++;

			let interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, _controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		}

		_takeBackControlInterpolant( interpolant ) {

			const interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		}

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction( clip, optionalRoot, blendMode ) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid;

			let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

			const clipUuid = clipObject !== null ? clipObject.uuid : clip;

			const actionsForClip = this._actionsByClip[ clipUuid ];
			let prototypeAction = null;

			if ( blendMode === undefined ) {

				if ( clipObject !== null ) {

					blendMode = clipObject.blendMode;

				} else {

					blendMode = NormalAnimationBlendMode;

				}

			}

			if ( actionsForClip !== undefined ) {

				const existingAction = actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		}

		// get an existing action
		existingAction( clip, optionalRoot ) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		}

		// deactivates all previously scheduled actions
		stopAllAction() {

			const actions = this._actions,
				nActions = this._nActiveActions;

			for ( let i = nActions - 1; i >= 0; -- i ) {

				actions[ i ].stop();

			}

			return this;

		}

		// advance the time and update apply the animation
		update( deltaTime ) {

			deltaTime *= this.timeScale;

			const actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( let i = 0; i !== nActions; ++ i ) {

				const action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			const bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( let i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		}

		// Allows you to seek to a specific time in an animation.
		setTime( timeInSeconds ) {

			this.time = 0; // Zero out time attribute for AnimationMixer object;
			for ( let i = 0; i < this._actions.length; i ++ ) {

				this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

			}

			return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

		}

		// return this mixer's root target object
		getRoot() {

			return this._root;

		}

		// free all resources specific to a particular clip
		uncacheClip( clip ) {

			const actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				const actionsToRemove = actionsForClip.knownActions;

				for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					const action = actionsToRemove[ i ];

					this._deactivateAction( action );

					const cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		}

		// free all resources specific to a particular root target object
		uncacheRoot( root ) {

			const rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( const clipUuid in actionsByClip ) {

				const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			const bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( const trackName in bindingByName ) {

					const binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		}

		// remove a targeted clip from the cache
		uncacheAction( clip, optionalRoot ) {

			const action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	}

	class Uniform {

		constructor( value ) {

			this.value = value;

		}

		clone() {

			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

		}

	}

	let id = 0;

	class UniformsGroup extends EventDispatcher {

		constructor() {

			super();

			this.isUniformsGroup = true;

			Object.defineProperty( this, 'id', { value: id ++ } );

			this.name = '';

			this.usage = StaticDrawUsage;
			this.uniforms = [];

		}

		add( uniform ) {

			this.uniforms.push( uniform );

			return this;

		}

		remove( uniform ) {

			const index = this.uniforms.indexOf( uniform );

			if ( index !== - 1 ) this.uniforms.splice( index, 1 );

			return this;

		}

		setName( name ) {

			this.name = name;

			return this;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

			return this;

		}

		copy( source ) {

			this.name = source.name;
			this.usage = source.usage;

			const uniformsSource = source.uniforms;

			this.uniforms.length = 0;

			for ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {

				this.uniforms.push( uniformsSource[ i ].clone() );

			}

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {

		constructor( array, stride, meshPerAttribute = 1 ) {

			super( array, stride );

			this.isInstancedInterleavedBuffer = true;

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		clone( data ) {

			const ib = super.clone( data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		}

		toJSON( data ) {

			const json = super.toJSON( data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	}

	class GLBufferAttribute {

		constructor( buffer, type, itemSize, elementSize, count ) {

			this.isGLBufferAttribute = true;

			this.name = '';

			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;

			this.version = 0;

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setBuffer( buffer ) {

			this.buffer = buffer;

			return this;

		}

		setType( type, elementSize ) {

			this.type = type;
			this.elementSize = elementSize;

			return this;

		}

		setItemSize( itemSize ) {

			this.itemSize = itemSize;

			return this;

		}

		setCount( count ) {

			this.count = count;

			return this;

		}

	}

	class Raycaster {

		constructor( origin, direction, near = 0, far = Infinity ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();

			this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

		}

		set( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		}

		setFromCamera( coords, camera ) {

			if ( camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

			}

		}

		intersectObject( object, recursive = true, intersects = [] ) {

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		}

		intersectObjects( objects, recursive = true, intersects = [] ) {

			for ( let i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */


	class Spherical {

		constructor( radius = 1, phi = 0, theta = 0 ) {

			this.radius = radius;
			this.phi = phi; // polar angle
			this.theta = theta; // azimuthal angle

			return this;

		}

		set( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		}

		copy( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		}

		// restrict phi to be between EPS and PI-EPS
		makeSafe() {

			const EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */

	class Cylindrical {

		constructor( radius = 1, theta = 0, y = 0 ) {

			this.radius = radius; // distance from the origin to a point in the x-z plane
			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = y; // height above the x-z plane

			return this;

		}

		set( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		}

		copy( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + z * z );
			this.theta = Math.atan2( x, z );
			this.y = y;

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$4 = /*@__PURE__*/ new Vector2();

	class Box2 {

		constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

			this.isBox2 = true;

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		}

		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		}

		intersectsBox( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		}

		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			return this.clampPoint( point, _vector$4 ).distanceTo( point );

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	const _startP = /*@__PURE__*/ new Vector3();
	const _startEnd = /*@__PURE__*/ new Vector3();

	class Line3 {

		constructor( start = new Vector3(), end = new Vector3() ) {

			this.start = start;
			this.end = end;

		}

		set( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		}

		copy( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		}

		getCenter( target ) {

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		}

		delta( target ) {

			return target.subVectors( this.end, this.start );

		}

		distanceSq() {

			return this.start.distanceToSquared( this.end );

		}

		distance() {

			return this.start.distanceTo( this.end );

		}

		at( t, target ) {

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		closestPointToPointParameter( point, clampToLine ) {

			_startP.subVectors( point, this.start );
			_startEnd.subVectors( this.end, this.start );

			const startEnd2 = _startEnd.dot( _startEnd );
			const startEnd_startP = _startEnd.dot( _startP );

			let t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = clamp( t, 0, 1 );

			}

			return t;

		}

		closestPointToPoint( point, clampToLine, target ) {

			const t = this.closestPointToPointParameter( point, clampToLine );

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		applyMatrix4( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		}

		equals( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$3 = /*@__PURE__*/ new Vector3();

	class SpotLightHelper extends Object3D {

		constructor( light, color ) {

			super();

			this.light = light;

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			this.type = 'SpotLightHelper';

			const geometry = new BufferGeometry();

			const positions = [
				0, 0, 0, 	0, 0, 1,
				0, 0, 0, 	1, 0, 1,
				0, 0, 0,	- 1, 0, 1,
				0, 0, 0, 	0, 1, 1,
				0, 0, 0, 	0, - 1, 1
			];

			for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				const p1 = ( i / l ) * Math.PI * 2;
				const p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		dispose() {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		}

		update() {

			this.light.updateWorldMatrix( true, false );
			this.light.target.updateWorldMatrix( true, false );

			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( _vector$3 );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		}

	}

	const _vector$2 = /*@__PURE__*/ new Vector3();
	const _boneMatrix = /*@__PURE__*/ new Matrix4();
	const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


	class SkeletonHelper extends LineSegments {

		constructor( object ) {

			const bones = getBoneList( object );

			const geometry = new BufferGeometry();

			const vertices = [];
			const colors = [];

			const color1 = new Color( 0, 0, 1 );
			const color2 = new Color( 0, 1, 0 );

			for ( let i = 0; i < bones.length; i ++ ) {

				const bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );

				}

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

			super( geometry, material );

			this.isSkeletonHelper = true;

			this.type = 'SkeletonHelper';

			this.root = object;
			this.bones = bones;

			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;

		}

		updateMatrixWorld( force ) {

			const bones = this.bones;

			const geometry = this.geometry;
			const position = geometry.getAttribute( 'position' );

			_matrixWorldInv.copy( this.root.matrixWorld ).invert();

			for ( let i = 0, j = 0; i < bones.length; i ++ ) {

				const bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
					_vector$2.setFromMatrixPosition( _boneMatrix );
					position.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );

					_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
					_vector$2.setFromMatrixPosition( _boneMatrix );
					position.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			super.updateMatrixWorld( force );

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}


	function getBoneList( object ) {

		const boneList = [];

		if ( object.isBone === true ) {

			boneList.push( object );

		}

		for ( let i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	class PointLightHelper extends Mesh {

		constructor( light, sphereSize, color ) {

			const geometry = new SphereGeometry( sphereSize, 4, 2 );
			const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

			super( geometry, material );

			this.light = light;

			this.color = color;

			this.type = 'PointLightHelper';

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();


			/*
		// TODO: delete this comment?
		const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		const d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

		update() {

			this.light.updateWorldMatrix( true, false );

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				this.material.color.copy( this.light.color );

			}

			/*
			const d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		}

	}

	const _vector$1 = /*@__PURE__*/ new Vector3();
	const _color1 = /*@__PURE__*/ new Color();
	const _color2 = /*@__PURE__*/ new Color();

	class HemisphereLightHelper extends Object3D {

		constructor( light, size, color ) {

			super();

			this.light = light;

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			this.type = 'HemisphereLightHelper';

			const geometry = new OctahedronGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );

			this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
			if ( this.color === undefined ) this.material.vertexColors = true;

			const position = geometry.getAttribute( 'position' );
			const colors = new Float32Array( position.count * 3 );

			geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

			this.add( new Mesh( geometry, this.material ) );

			this.update();

		}

		dispose() {

			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();

		}

		update() {

			const mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				const colors = mesh.geometry.getAttribute( 'color' );

				_color1.copy( this.light.color );
				_color2.copy( this.light.groundColor );

				for ( let i = 0, l = colors.count; i < l; i ++ ) {

					const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			this.light.updateWorldMatrix( true, false );

			mesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		}

	}

	class GridHelper extends LineSegments {

		constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

			color1 = new Color( color1 );
			color2 = new Color( color2 );

			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;

			const vertices = [], colors = [];

			for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

				vertices.push( - halfSize, 0, k, halfSize, 0, k );
				vertices.push( k, 0, - halfSize, k, 0, halfSize );

				const color = i === center ? color1 : color2;

				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;

			}

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			super( geometry, material );

			this.type = 'GridHelper';

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}

	class PolarGridHelper extends LineSegments {

		constructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

			color1 = new Color( color1 );
			color2 = new Color( color2 );

			const vertices = [];
			const colors = [];

			// create the sectors

			if ( sectors > 1 ) {

				for ( let i = 0; i < sectors; i ++ ) {

					const v = ( i / sectors ) * ( Math.PI * 2 );

					const x = Math.sin( v ) * radius;
					const z = Math.cos( v ) * radius;

					vertices.push( 0, 0, 0 );
					vertices.push( x, 0, z );

					const color = ( i & 1 ) ? color1 : color2;

					colors.push( color.r, color.g, color.b );
					colors.push( color.r, color.g, color.b );

				}

			}

			// create the rings

			for ( let i = 0; i < rings; i ++ ) {

				const color = ( i & 1 ) ? color1 : color2;

				const r = radius - ( radius / rings * i );

				for ( let j = 0; j < divisions; j ++ ) {

					// first vertex

					let v = ( j / divisions ) * ( Math.PI * 2 );

					let x = Math.sin( v ) * r;
					let z = Math.cos( v ) * r;

					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );

					// second vertex

					v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;

					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );

				}

			}

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			super( geometry, material );

			this.type = 'PolarGridHelper';

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}

	const _v1 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();
	const _v3 = /*@__PURE__*/ new Vector3();

	class DirectionalLightHelper extends Object3D {

		constructor( light, size, color ) {

			super();

			this.light = light;

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.color = color;

			this.type = 'DirectionalLightHelper';

			if ( size === undefined ) size = 1;

			let geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [
				- size, size, 0,
				size, size, 0,
				size, - size, 0,
				- size, - size, 0,
				- size, size, 0
			], 3 ) );

			const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

			this.lightPlane = new Line( geometry, material );
			this.add( this.lightPlane );

			geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.targetLine = new Line( geometry, material );
			this.add( this.targetLine );

			this.update();

		}

		dispose() {

			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();

		}

		update() {

			this.light.updateWorldMatrix( true, false );
			this.light.target.updateWorldMatrix( true, false );

			_v1.setFromMatrixPosition( this.light.matrixWorld );
			_v2.setFromMatrixPosition( this.light.target.matrixWorld );
			_v3.subVectors( _v2, _v1 );

			this.lightPlane.lookAt( _v2 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( _v2 );
			this.targetLine.scale.z = _v3.length();

		}

	}

	const _vector = /*@__PURE__*/ new Vector3();
	const _camera = /*@__PURE__*/ new Camera();

	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
	 */

	class CameraHelper extends LineSegments {

		constructor( camera ) {

			const geometry = new BufferGeometry();
			const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

			const vertices = [];
			const colors = [];

			const pointMap = {};

			// near

			addLine( 'n1', 'n2' );
			addLine( 'n2', 'n4' );
			addLine( 'n4', 'n3' );
			addLine( 'n3', 'n1' );

			// far

			addLine( 'f1', 'f2' );
			addLine( 'f2', 'f4' );
			addLine( 'f4', 'f3' );
			addLine( 'f3', 'f1' );

			// sides

			addLine( 'n1', 'f1' );
			addLine( 'n2', 'f2' );
			addLine( 'n3', 'f3' );
			addLine( 'n4', 'f4' );

			// cone

			addLine( 'p', 'n1' );
			addLine( 'p', 'n2' );
			addLine( 'p', 'n3' );
			addLine( 'p', 'n4' );

			// up

			addLine( 'u1', 'u2' );
			addLine( 'u2', 'u3' );
			addLine( 'u3', 'u1' );

			// target

			addLine( 'c', 't' );
			addLine( 'p', 'c' );

			// cross

			addLine( 'cn1', 'cn2' );
			addLine( 'cn3', 'cn4' );

			addLine( 'cf1', 'cf2' );
			addLine( 'cf3', 'cf4' );

			function addLine( a, b ) {

				addPoint( a );
				addPoint( b );

			}

			function addPoint( id ) {

				vertices.push( 0, 0, 0 );
				colors.push( 0, 0, 0 );

				if ( pointMap[ id ] === undefined ) {

					pointMap[ id ] = [];

				}

				pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

			}

			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			super( geometry, material );

			this.type = 'CameraHelper';

			this.camera = camera;
			if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;

			this.pointMap = pointMap;

			this.update();

			// colors

			const colorFrustum = new Color( 0xffaa00 );
			const colorCone = new Color( 0xff0000 );
			const colorUp = new Color( 0x00aaff );
			const colorTarget = new Color( 0xffffff );
			const colorCross = new Color( 0x333333 );

			this.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );

		}

		setColors( frustum, cone, up, target, cross ) {

			const geometry = this.geometry;

			const colorAttribute = geometry.getAttribute( 'color' );

			// near

			colorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2
			colorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4
			colorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3
			colorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1

			// far

			colorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2
			colorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4
			colorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3
			colorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1

			// sides

			colorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1
			colorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2
			colorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3
			colorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4

			// cone

			colorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1
			colorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2
			colorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3
			colorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4

			// up

			colorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2
			colorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3
			colorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1

			// target

			colorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t
			colorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c

			// cross

			colorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2
			colorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4

			colorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2
			colorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4

			colorAttribute.needsUpdate = true;

		}

		update() {

			const geometry = this.geometry;
			const pointMap = this.pointMap;

			const w = 1, h = 1;

			// we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

			// center / target

			setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
			setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );

			// near

			setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
			setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
			setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
			setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );

			// far

			setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
			setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
			setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
			setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );

			// up

			setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
			setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
			setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
			setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );

			setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
			setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
			setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
			setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}


	function setPoint( point, pointMap, geometry, camera, x, y, z ) {

		_vector.set( x, y, z ).unproject( camera );

		const points = pointMap[ point ];

		if ( points !== undefined ) {

			const position = geometry.getAttribute( 'position' );

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				position.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );

			}

		}

	}

	const _box = /*@__PURE__*/ new Box3();

	class BoxHelper extends LineSegments {

		constructor( object, color = 0xffff00 ) {

			const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			const positions = new Float32Array( 8 * 3 );

			const geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

			super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			this.object = object;
			this.type = 'BoxHelper';

			this.matrixAutoUpdate = false;

			this.update();

		}

		update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				_box.setFromObject( this.object );

			}

			if ( _box.isEmpty() ) return;

			const min = _box.min;
			const max = _box.max;

			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position;
			const array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		}

		setFromObject( object ) {

			this.object = object;
			this.update();

			return this;

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.object = source.object;

			return this;

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}

	class Box3Helper extends LineSegments {

		constructor( box, color = 0xffff00 ) {

			const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

			const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

			const geometry = new BufferGeometry();

			geometry.setIndex( new BufferAttribute( indices, 1 ) );

			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

			super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			this.box = box;

			this.type = 'Box3Helper';

			this.geometry.computeBoundingSphere();

		}

		updateMatrixWorld( force ) {

			const box = this.box;

			if ( box.isEmpty() ) return;

			box.getCenter( this.position );

			box.getSize( this.scale );

			this.scale.multiplyScalar( 0.5 );

			super.updateMatrixWorld( force );

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}

	class PlaneHelper extends Line {

		constructor( plane, size = 1, hex = 0xffff00 ) {

			const color = hex;

			const positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
			geometry.computeBoundingSphere();

			super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			this.type = 'PlaneHelper';

			this.plane = plane;

			this.size = size;

			const positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

			const geometry2 = new BufferGeometry();
			geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
			geometry2.computeBoundingSphere();

			this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

		}

		updateMatrixWorld( force ) {

			this.position.set( 0, 0, 0 );

			this.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );

			this.lookAt( this.plane.normal );

			this.translateZ( - this.plane.constant );

			super.updateMatrixWorld( force );

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();

		}

	}

	const _axis = /*@__PURE__*/ new Vector3();
	let _lineGeometry, _coneGeometry;

	class ArrowHelper extends Object3D {

		// dir is assumed to be normalized

		constructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

			super();

			this.type = 'ArrowHelper';

			if ( _lineGeometry === undefined ) {

				_lineGeometry = new BufferGeometry();
				_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

				_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
				_coneGeometry.translate( 0, - 0.5, 0 );

			}

			this.position.copy( origin );

			this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

		setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				_axis.set( dir.z, 0, - dir.x ).normalize();

				const radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( _axis, radians );

			}

		}

		setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

			this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
			this.line.updateMatrix();

			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();

		}

		setColor( color ) {

			this.line.material.color.set( color );
			this.cone.material.color.set( color );

		}

		copy( source ) {

			super.copy( source, false );

			this.line.copy( source.line );
			this.cone.copy( source.cone );

			return this;

		}

		dispose() {

			this.line.geometry.dispose();
			this.line.material.dispose();
			this.cone.geometry.dispose();
			this.cone.material.dispose();

		}

	}

	class AxesHelper extends LineSegments {

		constructor( size = 1 ) {

			const vertices = [
				0, 0, 0,	size, 0, 0,
				0, 0, 0,	0, size, 0,
				0, 0, 0,	0, 0, size
			];

			const colors = [
				1, 0, 0,	1, 0.6, 0,
				0, 1, 0,	0.6, 1, 0,
				0, 0, 1,	0, 0.6, 1
			];

			const geometry = new BufferGeometry();
			geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

			const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

			super( geometry, material );

			this.type = 'AxesHelper';

		}

		setColors( xAxisColor, yAxisColor, zAxisColor ) {

			const color = new Color();
			const array = this.geometry.attributes.color.array;

			color.set( xAxisColor );
			color.toArray( array, 0 );
			color.toArray( array, 3 );

			color.set( yAxisColor );
			color.toArray( array, 6 );
			color.toArray( array, 9 );

			color.set( zAxisColor );
			color.toArray( array, 12 );
			color.toArray( array, 15 );

			this.geometry.attributes.color.needsUpdate = true;

			return this;

		}

		dispose() {

			this.geometry.dispose();
			this.material.dispose();

		}

	}

	class ShapePath {

		constructor() {

			this.type = 'ShapePath';

			this.color = new Color();

			this.subPaths = [];
			this.currentPath = null;

		}

		moveTo( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

			return this;

		}

		lineTo( x, y ) {

			this.currentPath.lineTo( x, y );

			return this;

		}

		quadraticCurveTo( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

			return this;

		}

		bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

			return this;

		}

		splineThru( pts ) {

			this.currentPath.splineThru( pts );

			return this;

		}

		toShapes( isCCW ) {

			function toShapesNoHoles( inSubpaths ) {

				const shapes = [];

				for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

					const tmpPath = inSubpaths[ i ];

					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				const polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				let inside = false;
				for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					let edgeLowPt = inPolygon[ p ];
					let edgeHighPt = inPolygon[ q ];

					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}

						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			const isClockWise = ShapeUtils.isClockWise;

			const subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			let solid, tmpPath, tmpShape;
			const shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				let ambiguous = false;
				let toChange = 0;

				for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					const sho = newShapeHoles[ sIdx ];

					for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						const ho = sho[ hIdx ];
						let hole_unassigned = true;

						for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange ++;

								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}

						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}

				if ( toChange > 0 && ambiguous === false ) {

					newShapeHoles = betterShapeHoles;

				}

			}

			let tmpHoles;

			for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	}

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
			revision: REVISION,
		} } ) );

	}

	if ( typeof window !== 'undefined' ) {

		if ( window.__THREE__ ) {

			console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

		} else {

			window.__THREE__ = REVISION;

		}

	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysCompare = AlwaysCompare;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationAction = AnimationAction;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasTexture = CanvasTexture;
	exports.CapsuleGeometry = CapsuleGeometry;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.ColorManagement = ColorManagement;
	exports.CompressedArrayTexture = CompressedArrayTexture;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.Data3DTexture = Data3DTexture;
	exports.DataArrayTexture = DataArrayTexture;
	exports.DataTexture = DataTexture;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DisplayP3ColorSpace = DisplayP3ColorSpace;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualCompare = EqualCompare;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FileLoader = FileLoader;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.FramebufferTexture = FramebufferTexture;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GreaterCompare = GreaterCompare;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualCompare = GreaterEqualCompare;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LessCompare = LessCompare;
	exports.LessDepth = LessDepth;
	exports.LessEqualCompare = LessEqualCompare;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LineSegments = LineSegments;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverCompare = NeverCompare;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColorSpace = NoColorSpace;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualCompare = NotEqualCompare;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
	exports.RED_RGTC1_Format = RED_RGTC1_Format;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingGeometry = RingGeometry;
	exports.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
	exports.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
	exports.SRGBColorSpace = SRGBColorSpace;
	exports.Scene = Scene;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Source = Source;
	exports.Sphere = Sphere;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeGeometry = TubeGeometry;
	exports.TwoPassDoubleSide = TwoPassDoubleSide;
	exports.UVMapping = UVMapping;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsGroup = UniformsGroup;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGL3DRenderTarget = WebGL3DRenderTarget;
	exports.WebGLArrayRenderTarget = WebGLArrayRenderTarget;
	exports.WebGLCoordinateSystem = WebGLCoordinateSystem;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WebGPUCoordinateSystem = WebGPUCoordinateSystem;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports._SRGBAFormat = _SRGBAFormat;
	exports.sRGBEncoding = sRGBEncoding;

}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWUuanMiLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25zdGFudHMuanMiLCIuLi9zcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanMiLCIuLi9zcmMvbWF0aC9NYXRoVXRpbHMuanMiLCIuLi9zcmMvbWF0aC9WZWN0b3IyLmpzIiwiLi4vc3JjL21hdGgvTWF0cml4My5qcyIsIi4uL3NyYy91dGlscy5qcyIsIi4uL3NyYy9tYXRoL0NvbG9yTWFuYWdlbWVudC5qcyIsIi4uL3NyYy9leHRyYXMvSW1hZ2VVdGlscy5qcyIsIi4uL3NyYy90ZXh0dXJlcy9Tb3VyY2UuanMiLCIuLi9zcmMvdGV4dHVyZXMvVGV4dHVyZS5qcyIsIi4uL3NyYy9tYXRoL1ZlY3RvcjQuanMiLCIuLi9zcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0LmpzIiwiLi4vc3JjL3RleHR1cmVzL0RhdGFBcnJheVRleHR1cmUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQuanMiLCIuLi9zcmMvdGV4dHVyZXMvRGF0YTNEVGV4dHVyZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvV2ViR0wzRFJlbmRlclRhcmdldC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMuanMiLCIuLi9zcmMvbWF0aC9RdWF0ZXJuaW9uLmpzIiwiLi4vc3JjL21hdGgvVmVjdG9yMy5qcyIsIi4uL3NyYy9tYXRoL0JveDMuanMiLCIuLi9zcmMvbWF0aC9TcGhlcmUuanMiLCIuLi9zcmMvbWF0aC9SYXkuanMiLCIuLi9zcmMvbWF0aC9NYXRyaXg0LmpzIiwiLi4vc3JjL21hdGgvRXVsZXIuanMiLCIuLi9zcmMvY29yZS9MYXllcnMuanMiLCIuLi9zcmMvY29yZS9PYmplY3QzRC5qcyIsIi4uL3NyYy9tYXRoL1RyaWFuZ2xlLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRoL0NvbG9yLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyIsIi4uL3NyYy9leHRyYXMvRGF0YVV0aWxzLmpzIiwiLi4vc3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzIiwiLi4vc3JjL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMiLCIuLi9zcmMvb2JqZWN0cy9NZXNoLmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kZWZhdWx0X3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanMiLCIuLi9zcmMvY2FtZXJhcy9DYW1lcmEuanMiLCIuLi9zcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qcyIsIi4uL3NyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanMiLCIuLi9zcmMvdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL1dlYkdMQ3ViZVJlbmRlclRhcmdldC5qcyIsIi4uL3NyYy9tYXRoL1BsYW5lLmpzIiwiLi4vc3JjL21hdGgvRnJ1c3R1bS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xBbmltYXRpb24uanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQXR0cmlidXRlcy5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1BsYW5lR2VvbWV0cnkuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFoYXNoX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FscGhhbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2luX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2lubm9ybWFsX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JzZGZzLmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvaXJpZGVzY2VuY2VfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NsaXBwaW5nX3BsYW5lc192ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbW1vbi5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2N1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRub3JtYWxfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2VtaXNzaXZlbWFwX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yc3BhY2VfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcnNwYWNlX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3BhcnNfYmVnaW4uZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c190b29uX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfZnJhZ21lbnRfYmVnaW4uZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfZnJhZ21lbnRfbWFwcy5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19mcmFnbWVudF9lbmQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBoY29sb3JfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF92ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxfZnJhZ21lbnRfYmVnaW4uZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ub3JtYWxfZnJhZ21lbnRfbWFwcy5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsX3BhcnNfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbm9ybWFsX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbi5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcy5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NsZWFyY29hdF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL29wYXF1ZV9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3BhY2tpbmcuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9wcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvcHJvamVjdF92ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXRoZXJpbmdfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXRoZXJpbmdfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3JvdWdobmVzc21hcF9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3JvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFza19wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubm9ybWFsX3ZlcnRleC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3RvbmVtYXBwaW5nX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3RyYW5zbWlzc2lvbl9mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3RyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfcGFyc19mcmFnbWVudC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXZfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL2JhY2tncm91bmQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvYmFja2dyb3VuZEN1YmUuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvY3ViZS5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi9kZXB0aC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi9kaXN0YW5jZVJHQkEuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvZXF1aXJlY3QuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvbGluZWRhc2hlZC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi9tZXNoYmFzaWMuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvbWVzaGxhbWJlcnQuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvbWVzaG1hdGNhcC5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi9tZXNobm9ybWFsLmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL21lc2hwaG9uZy5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi9tZXNocGh5c2ljYWwuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvbWVzaHRvb24uZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIvcG9pbnRzLmdsc2wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL3NoYWRvdy5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi9zcHJpdGUuZ2xzbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJMaWIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQmFja2dyb3VuZC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xCaW5kaW5nU3RhdGVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTENhcGFiaWxpdGllcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xDbGlwcGluZy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xDdWJlTWFwcy5qcyIsIi4uL3NyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qcyIsIi4uL3NyYy9leHRyYXMvUE1SRU1HZW5lcmF0b3IuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMQ3ViZVVWTWFwcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEdlb21ldHJpZXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEluZm8uanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMTW9ycGh0YXJnZXRzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTE9iamVjdHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMVW5pZm9ybXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZGVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZGVyQ2FjaGUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvcGVydGllcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xSZW5kZXJMaXN0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xMaWdodHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUmVuZGVyU3RhdGVzLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTWVzaERpc3RhbmNlTWF0ZXJpYWwuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL3ZzbS5nbHNsLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRvd01hcC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xUZXh0dXJlcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xVdGlscy5qcyIsIi4uL3NyYy9jYW1lcmFzL0FycmF5Q2FtZXJhLmpzIiwiLi4vc3JjL29iamVjdHMvR3JvdXAuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYnhyL1dlYlhSQ29udHJvbGxlci5qcyIsIi4uL3NyYy90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYnhyL1dlYlhSTWFuYWdlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xNYXRlcmlhbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMVW5pZm9ybXNHcm91cHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanMiLCIuLi9zcmMvcmVuZGVyZXJzL1dlYkdMMVJlbmRlcmVyLmpzIiwiLi4vc3JjL3NjZW5lcy9Gb2dFeHAyLmpzIiwiLi4vc3JjL3NjZW5lcy9Gb2cuanMiLCIuLi9zcmMvc2NlbmVzL1NjZW5lLmpzIiwiLi4vc3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanMiLCIuLi9zcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanMiLCIuLi9zcmMvb2JqZWN0cy9TcHJpdGUuanMiLCIuLi9zcmMvb2JqZWN0cy9MT0QuanMiLCIuLi9zcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qcyIsIi4uL3NyYy9vYmplY3RzL0JvbmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvRGF0YVRleHR1cmUuanMiLCIuLi9zcmMvb2JqZWN0cy9Ta2VsZXRvbi5qcyIsIi4uL3NyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9vYmplY3RzL0luc3RhbmNlZE1lc2guanMiLCIuLi9zcmMvbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzIiwiLi4vc3JjL29iamVjdHMvTGluZS5qcyIsIi4uL3NyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyIsIi4uL3NyYy9vYmplY3RzL0xpbmVMb29wLmpzIiwiLi4vc3JjL21hdGVyaWFscy9Qb2ludHNNYXRlcmlhbC5qcyIsIi4uL3NyYy9vYmplY3RzL1BvaW50cy5qcyIsIi4uL3NyYy90ZXh0dXJlcy9WaWRlb1RleHR1cmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvRnJhbWVidWZmZXJUZXh0dXJlLmpzIiwiLi4vc3JjL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzIiwiLi4vc3JjL3RleHR1cmVzL0NvbXByZXNzZWRBcnJheVRleHR1cmUuanMiLCIuLi9zcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qcyIsIi4uL3NyYy9leHRyYXMvY29yZS9DdXJ2ZS5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzIiwiLi4vc3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qcyIsIi4uL3NyYy9leHRyYXMvY29yZS9JbnRlcnBvbGF0aW9ucy5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlMy5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZS5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanMiLCIuLi9zcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qcyIsIi4uL3NyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzIiwiLi4vc3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qcyIsIi4uL3NyYy9leHRyYXMvY29yZS9QYXRoLmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0NhcHN1bGVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0NpcmNsZUdlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0NvbmVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1BvbHloZWRyb25HZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL0RvZGVjYWhlZHJvbkdlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvRWRnZXNHZW9tZXRyeS5qcyIsIi4uL3NyYy9leHRyYXMvY29yZS9TaGFwZS5qcyIsIi4uL3NyYy9leHRyYXMvRWFyY3V0LmpzIiwiLi4vc3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvRXh0cnVkZUdlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL09jdGFoZWRyb25HZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1JpbmdHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qcyIsIi4uL3NyYy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzIiwiLi4vc3JjL2dlb21ldHJpZXMvVG9ydXNLbm90R2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanMiLCIuLi9zcmMvZ2VvbWV0cmllcy9XaXJlZnJhbWVHZW9tZXRyeS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvU2hhZG93TWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL1Jhd1NoYWRlck1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoU3RhbmRhcmRNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTWVzaFBoeXNpY2FsTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hQaG9uZ01hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoVG9vbk1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9NZXNoTm9ybWFsTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL01lc2hNYXRjYXBNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvTGluZURhc2hlZE1hdGVyaWFsLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi9BbmltYXRpb25VdGlscy5qcyIsIi4uL3NyYy9tYXRoL0ludGVycG9sYW50LmpzIiwiLi4vc3JjL21hdGgvaW50ZXJwb2xhbnRzL0N1YmljSW50ZXJwb2xhbnQuanMiLCIuLi9zcmMvbWF0aC9pbnRlcnBvbGFudHMvTGluZWFySW50ZXJwb2xhbnQuanMiLCIuLi9zcmMvbWF0aC9pbnRlcnBvbGFudHMvRGlzY3JldGVJbnRlcnBvbGFudC5qcyIsIi4uL3NyYy9hbmltYXRpb24vS2V5ZnJhbWVUcmFjay5qcyIsIi4uL3NyYy9hbmltYXRpb24vdHJhY2tzL0Jvb2xlYW5LZXlmcmFtZVRyYWNrLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi90cmFja3MvQ29sb3JLZXlmcmFtZVRyYWNrLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi90cmFja3MvTnVtYmVyS2V5ZnJhbWVUcmFjay5qcyIsIi4uL3NyYy9tYXRoL2ludGVycG9sYW50cy9RdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQuanMiLCIuLi9zcmMvYW5pbWF0aW9uL3RyYWNrcy9RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5qcyIsIi4uL3NyYy9hbmltYXRpb24vdHJhY2tzL1N0cmluZ0tleWZyYW1lVHJhY2suanMiLCIuLi9zcmMvYW5pbWF0aW9uL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzIiwiLi4vc3JjL2FuaW1hdGlvbi9BbmltYXRpb25DbGlwLmpzIiwiLi4vc3JjL2xvYWRlcnMvQ2FjaGUuanMiLCIuLi9zcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qcyIsIi4uL3NyYy9sb2FkZXJzL0xvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL0ZpbGVMb2FkZXIuanMiLCIuLi9zcmMvbG9hZGVycy9BbmltYXRpb25Mb2FkZXIuanMiLCIuLi9zcmMvbG9hZGVycy9Db21wcmVzc2VkVGV4dHVyZUxvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL0ltYWdlTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvQ3ViZVRleHR1cmVMb2FkZXIuanMiLCIuLi9zcmMvbG9hZGVycy9EYXRhVGV4dHVyZUxvYWRlci5qcyIsIi4uL3NyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanMiLCIuLi9zcmMvbGlnaHRzL0xpZ2h0LmpzIiwiLi4vc3JjL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanMiLCIuLi9zcmMvbGlnaHRzL0xpZ2h0U2hhZG93LmpzIiwiLi4vc3JjL2xpZ2h0cy9TcG90TGlnaHRTaGFkb3cuanMiLCIuLi9zcmMvbGlnaHRzL1Nwb3RMaWdodC5qcyIsIi4uL3NyYy9saWdodHMvUG9pbnRMaWdodFNoYWRvdy5qcyIsIi4uL3NyYy9saWdodHMvUG9pbnRMaWdodC5qcyIsIi4uL3NyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodFNoYWRvdy5qcyIsIi4uL3NyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qcyIsIi4uL3NyYy9saWdodHMvQW1iaWVudExpZ2h0LmpzIiwiLi4vc3JjL2xpZ2h0cy9SZWN0QXJlYUxpZ2h0LmpzIiwiLi4vc3JjL21hdGgvU3BoZXJpY2FsSGFybW9uaWNzMy5qcyIsIi4uL3NyYy9saWdodHMvTGlnaHRQcm9iZS5qcyIsIi4uL3NyYy9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvTG9hZGVyVXRpbHMuanMiLCIuLi9zcmMvY29yZS9JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5qcyIsIi4uL3NyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvT2JqZWN0TG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvSW1hZ2VCaXRtYXBMb2FkZXIuanMiLCIuLi9zcmMvYXVkaW8vQXVkaW9Db250ZXh0LmpzIiwiLi4vc3JjL2xvYWRlcnMvQXVkaW9Mb2FkZXIuanMiLCIuLi9zcmMvbGlnaHRzL0hlbWlzcGhlcmVMaWdodFByb2JlLmpzIiwiLi4vc3JjL2xpZ2h0cy9BbWJpZW50TGlnaHRQcm9iZS5qcyIsIi4uL3NyYy9jYW1lcmFzL1N0ZXJlb0NhbWVyYS5qcyIsIi4uL3NyYy9jb3JlL0Nsb2NrLmpzIiwiLi4vc3JjL2F1ZGlvL0F1ZGlvTGlzdGVuZXIuanMiLCIuLi9zcmMvYXVkaW8vQXVkaW8uanMiLCIuLi9zcmMvYXVkaW8vUG9zaXRpb25hbEF1ZGlvLmpzIiwiLi4vc3JjL2F1ZGlvL0F1ZGlvQW5hbHlzZXIuanMiLCIuLi9zcmMvYW5pbWF0aW9uL1Byb3BlcnR5TWl4ZXIuanMiLCIuLi9zcmMvYW5pbWF0aW9uL1Byb3BlcnR5QmluZGluZy5qcyIsIi4uL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uT2JqZWN0R3JvdXAuanMiLCIuLi9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkFjdGlvbi5qcyIsIi4uL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uTWl4ZXIuanMiLCIuLi9zcmMvY29yZS9Vbmlmb3JtLmpzIiwiLi4vc3JjL2NvcmUvVW5pZm9ybXNHcm91cC5qcyIsIi4uL3NyYy9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzIiwiLi4vc3JjL2NvcmUvR0xCdWZmZXJBdHRyaWJ1dGUuanMiLCIuLi9zcmMvY29yZS9SYXljYXN0ZXIuanMiLCIuLi9zcmMvbWF0aC9TcGhlcmljYWwuanMiLCIuLi9zcmMvbWF0aC9DeWxpbmRyaWNhbC5qcyIsIi4uL3NyYy9tYXRoL0JveDIuanMiLCIuLi9zcmMvbWF0aC9MaW5lMy5qcyIsIi4uL3NyYy9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvUG9pbnRMaWdodEhlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL0dyaWRIZWxwZXIuanMiLCIuLi9zcmMvaGVscGVycy9Qb2xhckdyaWRIZWxwZXIuanMiLCIuLi9zcmMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQm94SGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQm94M0hlbHBlci5qcyIsIi4uL3NyYy9oZWxwZXJzL1BsYW5lSGVscGVyLmpzIiwiLi4vc3JjL2hlbHBlcnMvQXJyb3dIZWxwZXIuanMiLCIuLi9zcmMvaGVscGVycy9BeGVzSGVscGVyLmpzIiwiLi4vc3JjL2V4dHJhcy9jb3JlL1NoYXBlUGF0aC5qcyIsIi4uL3NyYy9UaHJlZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgUkVWSVNJT04gPSAnMTU1ZGV2JztcclxuXHJcbmV4cG9ydCBjb25zdCBNT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiwgUk9UQVRFOiAwLCBET0xMWTogMSwgUEFOOiAyIH07XHJcbmV4cG9ydCBjb25zdCBUT1VDSCA9IHsgUk9UQVRFOiAwLCBQQU46IDEsIERPTExZX1BBTjogMiwgRE9MTFlfUk9UQVRFOiAzIH07XHJcbmV4cG9ydCBjb25zdCBDdWxsRmFjZU5vbmUgPSAwO1xyXG5leHBvcnQgY29uc3QgQ3VsbEZhY2VCYWNrID0gMTtcclxuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnQgPSAyO1xyXG5leHBvcnQgY29uc3QgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xyXG5leHBvcnQgY29uc3QgQmFzaWNTaGFkb3dNYXAgPSAwO1xyXG5leHBvcnQgY29uc3QgUENGU2hhZG93TWFwID0gMTtcclxuZXhwb3J0IGNvbnN0IFBDRlNvZnRTaGFkb3dNYXAgPSAyO1xyXG5leHBvcnQgY29uc3QgVlNNU2hhZG93TWFwID0gMztcclxuZXhwb3J0IGNvbnN0IEZyb250U2lkZSA9IDA7XHJcbmV4cG9ydCBjb25zdCBCYWNrU2lkZSA9IDE7XHJcbmV4cG9ydCBjb25zdCBEb3VibGVTaWRlID0gMjtcclxuZXhwb3J0IGNvbnN0IFR3b1Bhc3NEb3VibGVTaWRlID0gMjsgLy8gcjE0OVxyXG5leHBvcnQgY29uc3QgTm9CbGVuZGluZyA9IDA7XHJcbmV4cG9ydCBjb25zdCBOb3JtYWxCbGVuZGluZyA9IDE7XHJcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcclxuZXhwb3J0IGNvbnN0IFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xyXG5leHBvcnQgY29uc3QgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XHJcbmV4cG9ydCBjb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XHJcbmV4cG9ydCBjb25zdCBBZGRFcXVhdGlvbiA9IDEwMDtcclxuZXhwb3J0IGNvbnN0IFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XHJcbmV4cG9ydCBjb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcclxuZXhwb3J0IGNvbnN0IE1pbkVxdWF0aW9uID0gMTAzO1xyXG5leHBvcnQgY29uc3QgTWF4RXF1YXRpb24gPSAxMDQ7XHJcbmV4cG9ydCBjb25zdCBaZXJvRmFjdG9yID0gMjAwO1xyXG5leHBvcnQgY29uc3QgT25lRmFjdG9yID0gMjAxO1xyXG5leHBvcnQgY29uc3QgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XHJcbmV4cG9ydCBjb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xyXG5leHBvcnQgY29uc3QgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcbmV4cG9ydCBjb25zdCBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xyXG5leHBvcnQgY29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5leHBvcnQgY29uc3QgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XHJcbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xyXG5leHBvcnQgY29uc3QgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcclxuZXhwb3J0IGNvbnN0IE5ldmVyRGVwdGggPSAwO1xyXG5leHBvcnQgY29uc3QgQWx3YXlzRGVwdGggPSAxO1xyXG5leHBvcnQgY29uc3QgTGVzc0RlcHRoID0gMjtcclxuZXhwb3J0IGNvbnN0IExlc3NFcXVhbERlcHRoID0gMztcclxuZXhwb3J0IGNvbnN0IEVxdWFsRGVwdGggPSA0O1xyXG5leHBvcnQgY29uc3QgR3JlYXRlckVxdWFsRGVwdGggPSA1O1xyXG5leHBvcnQgY29uc3QgR3JlYXRlckRlcHRoID0gNjtcclxuZXhwb3J0IGNvbnN0IE5vdEVxdWFsRGVwdGggPSA3O1xyXG5leHBvcnQgY29uc3QgTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xyXG5leHBvcnQgY29uc3QgTWl4T3BlcmF0aW9uID0gMTtcclxuZXhwb3J0IGNvbnN0IEFkZE9wZXJhdGlvbiA9IDI7XHJcbmV4cG9ydCBjb25zdCBOb1RvbmVNYXBwaW5nID0gMDtcclxuZXhwb3J0IGNvbnN0IExpbmVhclRvbmVNYXBwaW5nID0gMTtcclxuZXhwb3J0IGNvbnN0IFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xyXG5leHBvcnQgY29uc3QgQ2luZW9uVG9uZU1hcHBpbmcgPSAzO1xyXG5leHBvcnQgY29uc3QgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nID0gNDtcclxuZXhwb3J0IGNvbnN0IEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcclxuXHJcbmV4cG9ydCBjb25zdCBVVk1hcHBpbmcgPSAzMDA7XHJcbmV4cG9ydCBjb25zdCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XHJcbmV4cG9ydCBjb25zdCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XHJcbmV4cG9ydCBjb25zdCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcclxuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xyXG5leHBvcnQgY29uc3QgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDY7XHJcbmV4cG9ydCBjb25zdCBSZXBlYXRXcmFwcGluZyA9IDEwMDA7XHJcbmV4cG9ydCBjb25zdCBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcclxuZXhwb3J0IGNvbnN0IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xyXG5leHBvcnQgY29uc3QgTmVhcmVzdEZpbHRlciA9IDEwMDM7XHJcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyID0gMTAwNTtcclxuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xyXG5leHBvcnQgY29uc3QgTGluZWFyRmlsdGVyID0gMTAwNjtcclxuZXhwb3J0IGNvbnN0IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xyXG5leHBvcnQgY29uc3QgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XHJcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xyXG5leHBvcnQgY29uc3QgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcclxuZXhwb3J0IGNvbnN0IFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5leHBvcnQgY29uc3QgQnl0ZVR5cGUgPSAxMDEwO1xyXG5leHBvcnQgY29uc3QgU2hvcnRUeXBlID0gMTAxMTtcclxuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuZXhwb3J0IGNvbnN0IEludFR5cGUgPSAxMDEzO1xyXG5leHBvcnQgY29uc3QgVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcclxuZXhwb3J0IGNvbnN0IEZsb2F0VHlwZSA9IDEwMTU7XHJcbmV4cG9ydCBjb25zdCBIYWxmRmxvYXRUeXBlID0gMTAxNjtcclxuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTc7XHJcbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xyXG5leHBvcnQgY29uc3QgVW5zaWduZWRJbnQyNDhUeXBlID0gMTAyMDtcclxuZXhwb3J0IGNvbnN0IEFscGhhRm9ybWF0ID0gMTAyMTtcclxuZXhwb3J0IGNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xyXG5leHBvcnQgY29uc3QgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcclxuZXhwb3J0IGNvbnN0IEx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcclxuZXhwb3J0IGNvbnN0IERlcHRoRm9ybWF0ID0gMTAyNjtcclxuZXhwb3J0IGNvbnN0IERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XHJcbmV4cG9ydCBjb25zdCBSZWRGb3JtYXQgPSAxMDI4O1xyXG5leHBvcnQgY29uc3QgUmVkSW50ZWdlckZvcm1hdCA9IDEwMjk7XHJcbmV4cG9ydCBjb25zdCBSR0Zvcm1hdCA9IDEwMzA7XHJcbmV4cG9ydCBjb25zdCBSR0ludGVnZXJGb3JtYXQgPSAxMDMxO1xyXG5leHBvcnQgY29uc3QgUkdCQUludGVnZXJGb3JtYXQgPSAxMDMzO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XHJcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcclxuZXhwb3J0IGNvbnN0IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDMzNzc4O1xyXG5leHBvcnQgY29uc3QgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XHJcbmV4cG9ydCBjb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xyXG5leHBvcnQgY29uc3QgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAzNTg0MTtcclxuZXhwb3J0IGNvbnN0IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xyXG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XHJcbmV4cG9ydCBjb25zdCBSR0JfRVRDMV9Gb3JtYXQgPSAzNjE5NjtcclxuZXhwb3J0IGNvbnN0IFJHQl9FVEMyX0Zvcm1hdCA9IDM3NDkyO1xyXG5leHBvcnQgY29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5NjtcclxuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ180eDRfRm9ybWF0ID0gMzc4MDg7XHJcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xyXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcclxuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ182eDVfRm9ybWF0ID0gMzc4MTE7XHJcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xyXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcclxuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ184eDZfRm9ybWF0ID0gMzc4MTQ7XHJcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xyXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XHJcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgPSAzNzgxNztcclxuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xyXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xyXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCA9IDM3ODIwO1xyXG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xyXG5leHBvcnQgY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xyXG5leHBvcnQgY29uc3QgUkVEX1JHVEMxX0Zvcm1hdCA9IDM2MjgzO1xyXG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgPSAzNjI4NDtcclxuZXhwb3J0IGNvbnN0IFJFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NTtcclxuZXhwb3J0IGNvbnN0IFNJR05FRF9SRURfR1JFRU5fUkdUQzJfRm9ybWF0ID0gMzYyODY7XHJcbmV4cG9ydCBjb25zdCBMb29wT25jZSA9IDIyMDA7XHJcbmV4cG9ydCBjb25zdCBMb29wUmVwZWF0ID0gMjIwMTtcclxuZXhwb3J0IGNvbnN0IExvb3BQaW5nUG9uZyA9IDIyMDI7XHJcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcclxuZXhwb3J0IGNvbnN0IEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcclxuZXhwb3J0IGNvbnN0IEludGVycG9sYXRlU21vb3RoID0gMjMwMjtcclxuZXhwb3J0IGNvbnN0IFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xyXG5leHBvcnQgY29uc3QgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcclxuZXhwb3J0IGNvbnN0IFdyYXBBcm91bmRFbmRpbmcgPSAyNDAyO1xyXG5leHBvcnQgY29uc3QgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcclxuZXhwb3J0IGNvbnN0IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMTtcclxuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcclxuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XHJcbmV4cG9ydCBjb25zdCBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcclxuLyoqIEBkZXByZWNhdGVkIFVzZSBMaW5lYXJTUkdCQ29sb3JTcGFjZSBvciBOb0NvbG9yU3BhY2UgaW4gdGhyZWUuanMgcjE1MisuICovXHJcbmV4cG9ydCBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XHJcbi8qKiBAZGVwcmVjYXRlZCBVc2UgU1JHQkNvbG9yU3BhY2UgaW4gdGhyZWUuanMgcjE1MisuICovXHJcbmV4cG9ydCBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xyXG5leHBvcnQgY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xyXG5leHBvcnQgY29uc3QgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XHJcbmV4cG9ydCBjb25zdCBUYW5nZW50U3BhY2VOb3JtYWxNYXAgPSAwO1xyXG5leHBvcnQgY29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xyXG5cclxuLy8gQ29sb3Igc3BhY2Ugc3RyaW5nIGlkZW50aWZpZXJzLCBtYXRjaGluZyBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDQgYW5kIFdlYkdQVSBuYW1lcyB3aGVyZSBhdmFpbGFibGUuXHJcbmV4cG9ydCBjb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcclxuZXhwb3J0IGNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xyXG5leHBvcnQgY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInO1xyXG5leHBvcnQgY29uc3QgRGlzcGxheVAzQ29sb3JTcGFjZSA9ICdkaXNwbGF5LXAzJztcclxuXHJcbmV4cG9ydCBjb25zdCBaZXJvU3RlbmNpbE9wID0gMDtcclxuZXhwb3J0IGNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xyXG5leHBvcnQgY29uc3QgUmVwbGFjZVN0ZW5jaWxPcCA9IDc2ODE7XHJcbmV4cG9ydCBjb25zdCBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xyXG5leHBvcnQgY29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4MztcclxuZXhwb3J0IGNvbnN0IEluY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NTtcclxuZXhwb3J0IGNvbnN0IERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NjtcclxuZXhwb3J0IGNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XHJcblxyXG5leHBvcnQgY29uc3QgTmV2ZXJTdGVuY2lsRnVuYyA9IDUxMjtcclxuZXhwb3J0IGNvbnN0IExlc3NTdGVuY2lsRnVuYyA9IDUxMztcclxuZXhwb3J0IGNvbnN0IEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTQ7XHJcbmV4cG9ydCBjb25zdCBMZXNzRXF1YWxTdGVuY2lsRnVuYyA9IDUxNTtcclxuZXhwb3J0IGNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcclxuZXhwb3J0IGNvbnN0IE5vdEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTc7XHJcbmV4cG9ydCBjb25zdCBHcmVhdGVyRXF1YWxTdGVuY2lsRnVuYyA9IDUxODtcclxuZXhwb3J0IGNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xyXG5cclxuZXhwb3J0IGNvbnN0IE5ldmVyQ29tcGFyZSA9IDUxMjtcclxuZXhwb3J0IGNvbnN0IExlc3NDb21wYXJlID0gNTEzO1xyXG5leHBvcnQgY29uc3QgRXF1YWxDb21wYXJlID0gNTE0O1xyXG5leHBvcnQgY29uc3QgTGVzc0VxdWFsQ29tcGFyZSA9IDUxNTtcclxuZXhwb3J0IGNvbnN0IEdyZWF0ZXJDb21wYXJlID0gNTE2O1xyXG5leHBvcnQgY29uc3QgTm90RXF1YWxDb21wYXJlID0gNTE3O1xyXG5leHBvcnQgY29uc3QgR3JlYXRlckVxdWFsQ29tcGFyZSA9IDUxODtcclxuZXhwb3J0IGNvbnN0IEFsd2F5c0NvbXBhcmUgPSA1MTk7XHJcblxyXG5leHBvcnQgY29uc3QgU3RhdGljRHJhd1VzYWdlID0gMzUwNDQ7XHJcbmV4cG9ydCBjb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XHJcbmV4cG9ydCBjb25zdCBTdHJlYW1EcmF3VXNhZ2UgPSAzNTA0MDtcclxuZXhwb3J0IGNvbnN0IFN0YXRpY1JlYWRVc2FnZSA9IDM1MDQ1O1xyXG5leHBvcnQgY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xyXG5leHBvcnQgY29uc3QgU3RyZWFtUmVhZFVzYWdlID0gMzUwNDE7XHJcbmV4cG9ydCBjb25zdCBTdGF0aWNDb3B5VXNhZ2UgPSAzNTA0NjtcclxuZXhwb3J0IGNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcclxuZXhwb3J0IGNvbnN0IFN0cmVhbUNvcHlVc2FnZSA9IDM1MDQyO1xyXG5cclxuZXhwb3J0IGNvbnN0IEdMU0wxID0gJzEwMCc7XHJcbmV4cG9ydCBjb25zdCBHTFNMMyA9ICczMDAgZXMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IF9TUkdCQUZvcm1hdCA9IDEwMzU7IC8vIGZhbGxiYWNrIGZvciBXZWJHTCAxXHJcblxyXG5leHBvcnQgY29uc3QgV2ViR0xDb29yZGluYXRlU3lzdGVtID0gMjAwMDtcclxuZXhwb3J0IGNvbnN0IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gPSAyMDAxO1xyXG4iLCIvKipcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXHJcbiAqL1xyXG5cclxuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcclxuXHJcblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG5cclxuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGhhc0V2ZW50TGlzdGVuZXIoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuXHRcdHJldHVybiBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMTtcclxuXHJcblx0fVxyXG5cclxuXHRyZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRjb25zdCBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0Ly8gTWFrZSBhIGNvcHksIGluIGNhc2UgbGlzdGVuZXJzIGFyZSByZW1vdmVkIHdoaWxlIGl0ZXJhdGluZy5cclxuXHRcdFx0Y29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRldmVudC50YXJnZXQgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9O1xyXG4iLCJjb25zdCBfbHV0ID0gWyAnMDAnLCAnMDEnLCAnMDInLCAnMDMnLCAnMDQnLCAnMDUnLCAnMDYnLCAnMDcnLCAnMDgnLCAnMDknLCAnMGEnLCAnMGInLCAnMGMnLCAnMGQnLCAnMGUnLCAnMGYnLCAnMTAnLCAnMTEnLCAnMTInLCAnMTMnLCAnMTQnLCAnMTUnLCAnMTYnLCAnMTcnLCAnMTgnLCAnMTknLCAnMWEnLCAnMWInLCAnMWMnLCAnMWQnLCAnMWUnLCAnMWYnLCAnMjAnLCAnMjEnLCAnMjInLCAnMjMnLCAnMjQnLCAnMjUnLCAnMjYnLCAnMjcnLCAnMjgnLCAnMjknLCAnMmEnLCAnMmInLCAnMmMnLCAnMmQnLCAnMmUnLCAnMmYnLCAnMzAnLCAnMzEnLCAnMzInLCAnMzMnLCAnMzQnLCAnMzUnLCAnMzYnLCAnMzcnLCAnMzgnLCAnMzknLCAnM2EnLCAnM2InLCAnM2MnLCAnM2QnLCAnM2UnLCAnM2YnLCAnNDAnLCAnNDEnLCAnNDInLCAnNDMnLCAnNDQnLCAnNDUnLCAnNDYnLCAnNDcnLCAnNDgnLCAnNDknLCAnNGEnLCAnNGInLCAnNGMnLCAnNGQnLCAnNGUnLCAnNGYnLCAnNTAnLCAnNTEnLCAnNTInLCAnNTMnLCAnNTQnLCAnNTUnLCAnNTYnLCAnNTcnLCAnNTgnLCAnNTknLCAnNWEnLCAnNWInLCAnNWMnLCAnNWQnLCAnNWUnLCAnNWYnLCAnNjAnLCAnNjEnLCAnNjInLCAnNjMnLCAnNjQnLCAnNjUnLCAnNjYnLCAnNjcnLCAnNjgnLCAnNjknLCAnNmEnLCAnNmInLCAnNmMnLCAnNmQnLCAnNmUnLCAnNmYnLCAnNzAnLCAnNzEnLCAnNzInLCAnNzMnLCAnNzQnLCAnNzUnLCAnNzYnLCAnNzcnLCAnNzgnLCAnNzknLCAnN2EnLCAnN2InLCAnN2MnLCAnN2QnLCAnN2UnLCAnN2YnLCAnODAnLCAnODEnLCAnODInLCAnODMnLCAnODQnLCAnODUnLCAnODYnLCAnODcnLCAnODgnLCAnODknLCAnOGEnLCAnOGInLCAnOGMnLCAnOGQnLCAnOGUnLCAnOGYnLCAnOTAnLCAnOTEnLCAnOTInLCAnOTMnLCAnOTQnLCAnOTUnLCAnOTYnLCAnOTcnLCAnOTgnLCAnOTknLCAnOWEnLCAnOWInLCAnOWMnLCAnOWQnLCAnOWUnLCAnOWYnLCAnYTAnLCAnYTEnLCAnYTInLCAnYTMnLCAnYTQnLCAnYTUnLCAnYTYnLCAnYTcnLCAnYTgnLCAnYTknLCAnYWEnLCAnYWInLCAnYWMnLCAnYWQnLCAnYWUnLCAnYWYnLCAnYjAnLCAnYjEnLCAnYjInLCAnYjMnLCAnYjQnLCAnYjUnLCAnYjYnLCAnYjcnLCAnYjgnLCAnYjknLCAnYmEnLCAnYmInLCAnYmMnLCAnYmQnLCAnYmUnLCAnYmYnLCAnYzAnLCAnYzEnLCAnYzInLCAnYzMnLCAnYzQnLCAnYzUnLCAnYzYnLCAnYzcnLCAnYzgnLCAnYzknLCAnY2EnLCAnY2InLCAnY2MnLCAnY2QnLCAnY2UnLCAnY2YnLCAnZDAnLCAnZDEnLCAnZDInLCAnZDMnLCAnZDQnLCAnZDUnLCAnZDYnLCAnZDcnLCAnZDgnLCAnZDknLCAnZGEnLCAnZGInLCAnZGMnLCAnZGQnLCAnZGUnLCAnZGYnLCAnZTAnLCAnZTEnLCAnZTInLCAnZTMnLCAnZTQnLCAnZTUnLCAnZTYnLCAnZTcnLCAnZTgnLCAnZTknLCAnZWEnLCAnZWInLCAnZWMnLCAnZWQnLCAnZWUnLCAnZWYnLCAnZjAnLCAnZjEnLCAnZjInLCAnZjMnLCAnZjQnLCAnZjUnLCAnZjYnLCAnZjcnLCAnZjgnLCAnZjknLCAnZmEnLCAnZmInLCAnZmMnLCAnZmQnLCAnZmUnLCAnZmYnIF07XHJcblxyXG5sZXQgX3NlZWQgPSAxMjM0NTY3O1xyXG5cclxuXHJcbmNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwO1xyXG5jb25zdCBSQUQyREVHID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxyXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XHJcblxyXG5cdGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdGNvbnN0IHV1aWQgPSBfbHV0WyBkMCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcclxuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xyXG5cdFx0XHRfbHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBfbHV0WyBkMiA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDIgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXHJcblx0XHRcdF9sdXRbIGQzICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMjQgJiAweGZmIF07XHJcblxyXG5cdC8vIC50b0xvd2VyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cclxuXHRyZXR1cm4gdXVpZC50b0xvd2VyQ2FzZSgpO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcclxuXHJcblx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcclxuXHJcbn1cclxuXHJcbi8vIGNvbXB1dGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBtICUgblxyXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXHJcbmZ1bmN0aW9uIGV1Y2xpZGVhbk1vZHVsbyggbiwgbSApIHtcclxuXHJcblx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcclxuXHJcbn1cclxuXHJcbi8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcclxuXHJcblx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XHJcblxyXG59XHJcblxyXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xyXG5mdW5jdGlvbiBpbnZlcnNlTGVycCggeCwgeSwgdmFsdWUgKSB7XHJcblxyXG5cdGlmICggeCAhPT0geSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB2YWx1ZSAtIHggKSAvICggeSAtIHggKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cclxuZnVuY3Rpb24gbGVycCggeCwgeSwgdCApIHtcclxuXHJcblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcclxuXHJcbn1cclxuXHJcbi8vIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL1xyXG5mdW5jdGlvbiBkYW1wKCB4LCB5LCBsYW1iZGEsIGR0ICkge1xyXG5cclxuXHRyZXR1cm4gbGVycCggeCwgeSwgMSAtIE1hdGguZXhwKCAtIGxhbWJkYSAqIGR0ICkgKTtcclxuXHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci92Y3Nqbnl6N3g0XHJcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xyXG5cclxuXHRyZXR1cm4gbGVuZ3RoIC0gTWF0aC5hYnMoIGV1Y2xpZGVhbk1vZHVsbyggeCwgbGVuZ3RoICogMiApIC0gbGVuZ3RoICk7XHJcblxyXG59XHJcblxyXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuZnVuY3Rpb24gc21vb3Roc3RlcCggeCwgbWluLCBtYXggKSB7XHJcblxyXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XHJcblxyXG5cdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuXHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuXHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xyXG5cclxuXHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xyXG5cclxufVxyXG5cclxuLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XHJcblxyXG59XHJcblxyXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5mdW5jdGlvbiByYW5kRmxvYXQoIGxvdywgaGlnaCApIHtcclxuXHJcblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcclxuXHJcbn1cclxuXHJcbi8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcclxuZnVuY3Rpb24gcmFuZEZsb2F0U3ByZWFkKCByYW5nZSApIHtcclxuXHJcblx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XHJcblxyXG59XHJcblxyXG4vLyBEZXRlcm1pbmlzdGljIHBzZXVkby1yYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFsgMCwgMSBdXHJcbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcclxuXHJcblx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSBfc2VlZCA9IHM7XHJcblxyXG5cdC8vIE11bGJlcnJ5MzIgZ2VuZXJhdG9yXHJcblxyXG5cdGxldCB0ID0gX3NlZWQgKz0gMHg2RDJCNzlGNTtcclxuXHJcblx0dCA9IE1hdGguaW11bCggdCBeIHQgPj4+IDE1LCB0IHwgMSApO1xyXG5cclxuXHR0IF49IHQgKyBNYXRoLmltdWwoIHQgXiB0ID4+PiA3LCB0IHwgNjEgKTtcclxuXHJcblx0cmV0dXJuICggKCB0IF4gdCA+Pj4gMTQgKSA+Pj4gMCApIC8gNDI5NDk2NzI5NjtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZ1RvUmFkKCBkZWdyZWVzICkge1xyXG5cclxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiByYWRUb0RlZyggcmFkaWFucyApIHtcclxuXHJcblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKCB2YWx1ZSApIHtcclxuXHJcblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjZWlsUG93ZXJPZlR3byggdmFsdWUgKSB7XHJcblxyXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsb29yUG93ZXJPZlR3byggdmFsdWUgKSB7XHJcblxyXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCBxLCBhLCBiLCBjLCBvcmRlciApIHtcclxuXHJcblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXHJcblxyXG5cdC8vIHJvdGF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgYXhlcyBpbiB0aGUgb3JkZXIgc3BlY2lmaWVkIGJ5ICdvcmRlcidcclxuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXHJcblx0Ly8gYW5nbGVzIGFyZSBpbiByYWRpYW5zXHJcblxyXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xyXG5cdGNvbnN0IHNpbiA9IE1hdGguc2luO1xyXG5cclxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcclxuXHRjb25zdCBzMiA9IHNpbiggYiAvIDIgKTtcclxuXHJcblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XHJcblx0Y29uc3QgczEzID0gc2luKCAoIGEgKyBjICkgLyAyICk7XHJcblxyXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcclxuXHRjb25zdCBzMV8zID0gc2luKCAoIGEgLSBjICkgLyAyICk7XHJcblxyXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcclxuXHRjb25zdCBzM18xID0gc2luKCAoIGMgLSBhICkgLyAyICk7XHJcblxyXG5cdHN3aXRjaCAoIG9yZGVyICkge1xyXG5cclxuXHRcdGNhc2UgJ1hZWCc6XHJcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ1laWSc6XHJcblx0XHRcdHEuc2V0KCBzMiAqIHMxXzMsIGMyICogczEzLCBzMiAqIGMxXzMsIGMyICogYzEzICk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ1pYWic6XHJcblx0XHRcdHEuc2V0KCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBzMTMsIGMyICogYzEzICk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ1haWCc6XHJcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ1lYWSc6XHJcblx0XHRcdHEuc2V0KCBzMiAqIGMzXzEsIGMyICogczEzLCBzMiAqIHMzXzEsIGMyICogYzEzICk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ1pZWic6XHJcblx0XHRcdHEuc2V0KCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBzMTMsIGMyICogYzEzICk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcclxuXHJcblx0c3dpdGNoICggYXJyYXkuY29uc3RydWN0b3IgKSB7XHJcblxyXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cdFx0Y2FzZSBVaW50MzJBcnJheTpcclxuXHJcblx0XHRcdHJldHVybiB2YWx1ZSAvIDQyOTQ5NjcyOTUuMDtcclxuXHJcblx0XHRjYXNlIFVpbnQxNkFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlIC8gNjU1MzUuMDtcclxuXHJcblx0XHRjYXNlIFVpbnQ4QXJyYXk6XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcclxuXHJcblx0XHRjYXNlIEludDMyQXJyYXk6XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIHZhbHVlIC8gMjE0NzQ4MzY0Ny4wLCAtIDEuMCApO1xyXG5cclxuXHRcdGNhc2UgSW50MTZBcnJheTpcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLm1heCggdmFsdWUgLyAzMjc2Ny4wLCAtIDEuMCApO1xyXG5cclxuXHRcdGNhc2UgSW50OEFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplKCB2YWx1ZSwgYXJyYXkgKSB7XHJcblxyXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xyXG5cclxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdGNhc2UgVWludDMyQXJyYXk6XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiA0Mjk0OTY3Mjk1LjAgKTtcclxuXHJcblx0XHRjYXNlIFVpbnQxNkFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xyXG5cclxuXHRcdGNhc2UgVWludDhBcnJheTpcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDI1NS4wICk7XHJcblxyXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMjE0NzQ4MzY0Ny4wICk7XHJcblxyXG5cdFx0Y2FzZSBJbnQxNkFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xyXG5cclxuXHRcdGNhc2UgSW50OEFycmF5OlxyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMTI3LjAgKTtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IE1hdGhVdGlscyA9IHtcclxuXHRERUcyUkFEOiBERUcyUkFELFxyXG5cdFJBRDJERUc6IFJBRDJERUcsXHJcblx0Z2VuZXJhdGVVVUlEOiBnZW5lcmF0ZVVVSUQsXHJcblx0Y2xhbXA6IGNsYW1wLFxyXG5cdGV1Y2xpZGVhbk1vZHVsbzogZXVjbGlkZWFuTW9kdWxvLFxyXG5cdG1hcExpbmVhcjogbWFwTGluZWFyLFxyXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcclxuXHRsZXJwOiBsZXJwLFxyXG5cdGRhbXA6IGRhbXAsXHJcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxyXG5cdHNtb290aHN0ZXA6IHNtb290aHN0ZXAsXHJcblx0c21vb3RoZXJzdGVwOiBzbW9vdGhlcnN0ZXAsXHJcblx0cmFuZEludDogcmFuZEludCxcclxuXHRyYW5kRmxvYXQ6IHJhbmRGbG9hdCxcclxuXHRyYW5kRmxvYXRTcHJlYWQ6IHJhbmRGbG9hdFNwcmVhZCxcclxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcclxuXHRkZWdUb1JhZDogZGVnVG9SYWQsXHJcblx0cmFkVG9EZWc6IHJhZFRvRGVnLFxyXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxyXG5cdGNlaWxQb3dlck9mVHdvOiBjZWlsUG93ZXJPZlR3byxcclxuXHRmbG9vclBvd2VyT2ZUd286IGZsb29yUG93ZXJPZlR3byxcclxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxyXG5cdG5vcm1hbGl6ZTogbm9ybWFsaXplLFxyXG5cdGRlbm9ybWFsaXplOiBkZW5vcm1hbGl6ZVxyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuXHRERUcyUkFELFxyXG5cdFJBRDJERUcsXHJcblx0Z2VuZXJhdGVVVUlELFxyXG5cdGNsYW1wLFxyXG5cdGV1Y2xpZGVhbk1vZHVsbyxcclxuXHRtYXBMaW5lYXIsXHJcblx0aW52ZXJzZUxlcnAsXHJcblx0bGVycCxcclxuXHRkYW1wLFxyXG5cdHBpbmdwb25nLFxyXG5cdHNtb290aHN0ZXAsXHJcblx0c21vb3RoZXJzdGVwLFxyXG5cdHJhbmRJbnQsXHJcblx0cmFuZEZsb2F0LFxyXG5cdHJhbmRGbG9hdFNwcmVhZCxcclxuXHRzZWVkZWRSYW5kb20sXHJcblx0ZGVnVG9SYWQsXHJcblx0cmFkVG9EZWcsXHJcblx0aXNQb3dlck9mVHdvLFxyXG5cdGNlaWxQb3dlck9mVHdvLFxyXG5cdGZsb29yUG93ZXJPZlR3byxcclxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxyXG5cdG5vcm1hbGl6ZSxcclxuXHRkZW5vcm1hbGl6ZSxcclxuXHRNYXRoVXRpbHNcclxufTtcclxuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcclxuXHJcbmNsYXNzIFZlY3RvcjIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwICkge1xyXG5cclxuXHRcdFZlY3RvcjIucHJvdG90eXBlLmlzVmVjdG9yMiA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHdpZHRoKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLng7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgaGVpZ2h0KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCB4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHNjYWxhcjtcclxuXHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRYKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WSggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhZGQoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkU2NhbGFyKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkVmVjdG9ycyggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c3ViKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN1YlNjYWxhciggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5KCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGl2aWRlKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXgzKCBtICkge1xyXG5cclxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XHJcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXTtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1pbiggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1heCggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsYW1wKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueCApICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsb29yKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2VpbCgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyb3VuZCgpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdW5kVG9aZXJvKCkge1xyXG5cclxuXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bmVnYXRlKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZG90KCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3Jvc3MoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueSAtIHRoaXMueSAqIHYueDtcclxuXHJcblx0fVxyXG5cclxuXHRsZW5ndGhTcSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG5cclxuXHR9XHJcblxyXG5cdGxlbmd0aCgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRtYW5oYXR0YW5MZW5ndGgoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRub3JtYWxpemUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRhbmdsZSgpIHtcclxuXHJcblx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xyXG5cclxuXHRcdGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMiggLSB0aGlzLnksIC0gdGhpcy54ICkgKyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBhbmdsZTtcclxuXHJcblx0fVxyXG5cclxuXHRhbmdsZVRvKCB2ICkge1xyXG5cclxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcclxuXHJcblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIE1hdGguUEkgLyAyO1xyXG5cclxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXN0YW5jZVRvKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xyXG5cclxuXHRcdGNvbnN0IGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHJcblx0fVxyXG5cclxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGxlcnAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYxLnggKyAoIHYyLnggLSB2MS54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRlcXVhbHMoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyb3RhdGVBcm91bmQoIGNlbnRlciwgYW5nbGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0Y29uc3QgeCA9IHRoaXMueCAtIGNlbnRlci54O1xyXG5cdFx0Y29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xyXG5cclxuXHRcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcclxuXHRcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyYW5kb20oKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XHJcblxyXG5cdFx0eWllbGQgdGhpcy54O1xyXG5cdFx0eWllbGQgdGhpcy55O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBWZWN0b3IyIH07XHJcbiIsImNsYXNzIE1hdHJpeDMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcclxuXHJcblx0XHRNYXRyaXgzLnByb3RvdHlwZS5pc01hdHJpeDMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXHJcblxyXG5cdFx0XHQxLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0XTtcclxuXHJcblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBuMTEsIG4xMiwgbjEzLCBuMjEsIG4yMiwgbjIzLCBuMzEsIG4zMiwgbjMzICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xyXG5cdFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcclxuXHRcdHRlWyA2IF0gPSBuMTM7IHRlWyA3IF0gPSBuMjM7IHRlWyA4IF0gPSBuMzM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0aWRlbnRpdHkoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBtICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xyXG5cdFx0dGVbIDMgXSA9IG1lWyAzIF07IHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTtcclxuXHRcdHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTsgdGVbIDggXSA9IG1lWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXh0cmFjdEJhc2lzKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xyXG5cclxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAwICk7XHJcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMSApO1xyXG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tTWF0cml4NCggbSApIHtcclxuXHJcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxyXG5cdFx0XHRtZVsgMSBdLCBtZVsgNSBdLCBtZVsgOSBdLFxyXG5cdFx0XHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bXVsdGlwbHkoIG0gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHByZW11bHRpcGx5KCBtICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRtdWx0aXBseU1hdHJpY2VzKCBhLCBiICkge1xyXG5cclxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcclxuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRjb25zdCBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgMyBdLCBhMTMgPSBhZVsgNiBdO1xyXG5cdFx0Y29uc3QgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDQgXSwgYTIzID0gYWVbIDcgXTtcclxuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XHJcblxyXG5cdFx0Y29uc3QgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDMgXSwgYjEzID0gYmVbIDYgXTtcclxuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XHJcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNSBdLCBiMzMgPSBiZVsgOCBdO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XHJcblx0XHR0ZVsgMyBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyO1xyXG5cdFx0dGVbIDYgXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMztcclxuXHJcblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xyXG5cdFx0dGVbIDQgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjtcclxuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XHJcblxyXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTtcclxuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XHJcblx0XHR0ZVsgOCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xyXG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcclxuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGV0ZXJtaW5hbnQoKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGNvbnN0IGEgPSB0ZVsgMCBdLCBiID0gdGVbIDEgXSwgYyA9IHRlWyAyIF0sXHJcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXHJcblx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcclxuXHJcblx0fVxyXG5cclxuXHRpbnZlcnQoKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bjExID0gdGVbIDAgXSwgbjIxID0gdGVbIDEgXSwgbjMxID0gdGVbIDIgXSxcclxuXHRcdFx0bjEyID0gdGVbIDMgXSwgbjIyID0gdGVbIDQgXSwgbjMyID0gdGVbIDUgXSxcclxuXHRcdFx0bjEzID0gdGVbIDYgXSwgbjIzID0gdGVbIDcgXSwgbjMzID0gdGVbIDggXSxcclxuXHJcblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcclxuXHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxyXG5cdFx0XHR0MTMgPSBuMjMgKiBuMTIgLSBuMjIgKiBuMTMsXHJcblxyXG5cdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XHJcblxyXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcclxuXHJcblx0XHRjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xyXG5cclxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XHJcblx0XHR0ZVsgMSBdID0gKCBuMzEgKiBuMjMgLSBuMzMgKiBuMjEgKSAqIGRldEludjtcclxuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyAzIF0gPSB0MTIgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcclxuXHRcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcclxuXHRcdHRlWyA4IF0gPSAoIG4yMiAqIG4xMSAtIG4yMSAqIG4xMiApICogZGV0SW52O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zcG9zZSgpIHtcclxuXHJcblx0XHRsZXQgdG1wO1xyXG5cdFx0Y29uc3QgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dG1wID0gbVsgMSBdOyBtWyAxIF0gPSBtWyAzIF07IG1bIDMgXSA9IHRtcDtcclxuXHRcdHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XHJcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vcm1hbE1hdHJpeCggbWF0cml4NCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NCggbWF0cml4NCApLmludmVydCgpLnRyYW5zcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zcG9zZUludG9BcnJheSggciApIHtcclxuXHJcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRyWyAwIF0gPSBtWyAwIF07XHJcblx0XHRyWyAxIF0gPSBtWyAzIF07XHJcblx0XHRyWyAyIF0gPSBtWyA2IF07XHJcblx0XHRyWyAzIF0gPSBtWyAxIF07XHJcblx0XHRyWyA0IF0gPSBtWyA0IF07XHJcblx0XHRyWyA1IF0gPSBtWyA3IF07XHJcblx0XHRyWyA2IF0gPSBtWyAyIF07XHJcblx0XHRyWyA3IF0gPSBtWyA1IF07XHJcblx0XHRyWyA4IF0gPSBtWyA4IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xyXG5cclxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggcm90YXRpb24gKTtcclxuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcclxuXHRcdFx0LSBzeSAqIHMsIHN5ICogYywgLSBzeSAqICggLSBzICogY3ggKyBjICogY3kgKSArIGN5ICsgdHksXHJcblx0XHRcdDAsIDAsIDFcclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0c2NhbGUoIHN4LCBzeSApIHtcclxuXHJcblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVNjYWxlKCBzeCwgc3kgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZSggdGhldGEgKSB7XHJcblxyXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VSb3RhdGlvbiggLSB0aGV0YSApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dHJhbnNsYXRlKCB0eCwgdHkgKSB7XHJcblxyXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VUcmFuc2xhdGlvbiggdHgsIHR5ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBmb3IgMkQgVHJhbnNmb3Jtc1xyXG5cclxuXHRtYWtlVHJhbnNsYXRpb24oIHgsIHkgKSB7XHJcblxyXG5cdFx0aWYgKCB4LmlzVmVjdG9yMiApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0XHQxLCAwLCB4LngsXHJcblx0XHRcdFx0MCwgMSwgeC55LFxyXG5cdFx0XHRcdDAsIDAsIDFcclxuXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0XHQxLCAwLCB4LFxyXG5cdFx0XHRcdDAsIDEsIHksXHJcblx0XHRcdFx0MCwgMCwgMVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZVJvdGF0aW9uKCB0aGV0YSApIHtcclxuXHJcblx0XHQvLyBjb3VudGVyY2xvY2t3aXNlXHJcblxyXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xyXG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0YywgLSBzLCAwLFxyXG5cdFx0XHRzLCBjLCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtYWtlU2NhbGUoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHR4LCAwLCAwLFxyXG5cdFx0XHQwLCB5LCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRlcXVhbHMoIG1hdHJpeCApIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY29uc3QgX20zID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpO1xyXG5cclxuZXhwb3J0IHsgTWF0cml4MyB9O1xyXG4iLCJmdW5jdGlvbiBhcnJheU1pbiggYXJyYXkgKSB7XHJcblxyXG5cdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIEluZmluaXR5O1xyXG5cclxuXHRsZXQgbWluID0gYXJyYXlbIDAgXTtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5WyBpIF0gPCBtaW4gKSBtaW4gPSBhcnJheVsgaSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBtaW47XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheU1heCggYXJyYXkgKSB7XHJcblxyXG5cdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIC0gSW5maW5pdHk7XHJcblxyXG5cdGxldCBtYXggPSBhcnJheVsgMCBdO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xyXG5cclxuXHRcdGlmICggYXJyYXlbIGkgXSA+IG1heCApIG1heCA9IGFycmF5WyBpIF07XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1heDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoIGFycmF5ICkge1xyXG5cclxuXHQvLyBhc3N1bWVzIGxhcmdlciB2YWx1ZXMgdXN1YWxseSBvbiBsYXN0XHJcblxyXG5cdGZvciAoIGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLSBpICkge1xyXG5cclxuXHRcdGlmICggYXJyYXlbIGkgXSA+PSA2NTUzNSApIHJldHVybiB0cnVlOyAvLyBhY2NvdW50IGZvciBQUklNSVRJVkVfUkVTVEFSVF9GSVhFRF9JTkRFWCwgIzI0NTY1XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGZhbHNlO1xyXG5cclxufVxyXG5cclxuY29uc3QgVFlQRURfQVJSQVlTID0ge1xyXG5cdEludDhBcnJheTogSW50OEFycmF5LFxyXG5cdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXHJcblx0VWludDhDbGFtcGVkQXJyYXk6IFVpbnQ4Q2xhbXBlZEFycmF5LFxyXG5cdEludDE2QXJyYXk6IEludDE2QXJyYXksXHJcblx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxyXG5cdEludDMyQXJyYXk6IEludDMyQXJyYXksXHJcblx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxyXG5cdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxyXG5cdEZsb2F0NjRBcnJheTogRmxvYXQ2NEFycmF5XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRUeXBlZEFycmF5KCB0eXBlLCBidWZmZXIgKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVFlQRURfQVJSQVlTWyB0eXBlIF0oIGJ1ZmZlciApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKCBuYW1lICkge1xyXG5cclxuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIG5hbWUgKTtcclxuXHJcbn1cclxuXHJcbmNvbnN0IF9jYWNoZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gd2Fybk9uY2UoIG1lc3NhZ2UgKSB7XHJcblxyXG5cdGlmICggbWVzc2FnZSBpbiBfY2FjaGUgKSByZXR1cm47XHJcblxyXG5cdF9jYWNoZVsgbWVzc2FnZSBdID0gdHJ1ZTtcclxuXHJcblx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBhcnJheU1pbiwgYXJyYXlNYXgsIGFycmF5TmVlZHNVaW50MzIsIGdldFR5cGVkQXJyYXksIGNyZWF0ZUVsZW1lbnROUywgd2Fybk9uY2UgfTtcclxuIiwiaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UsIExpbmVhclNSR0JDb2xvclNwYWNlLCBEaXNwbGF5UDNDb2xvclNwYWNlLCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuL01hdHJpeDMuanMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFNSR0JUb0xpbmVhciggYyApIHtcclxuXHJcblx0cmV0dXJuICggYyA8IDAuMDQwNDUgKSA/IGMgKiAwLjA3NzM5OTM4MDggOiBNYXRoLnBvdyggYyAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgMi40ICk7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTGluZWFyVG9TUkdCKCBjICkge1xyXG5cclxuXHRyZXR1cm4gKCBjIDwgMC4wMDMxMzA4ICkgPyBjICogMTIuOTIgOiAxLjA1NSAqICggTWF0aC5wb3coIGMsIDAuNDE2NjYgKSApIC0gMC4wNTU7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogTWF0cmljZXMgY29udmVydGluZyBQMyA8LT4gUmVjLiA3MDkgcHJpbWFyaWVzLCB3aXRob3V0IGdhbXV0IG1hcHBpbmdcclxuICogb3IgY2xpcHBpbmcuIEJhc2VkIG9uIFczQyBzcGVjaWZpY2F0aW9ucyBmb3Igc1JHQiBhbmQgRGlzcGxheSBQMyxcclxuICogYW5kIElDQyBzcGVjaWZpY2F0aW9ucyBmb3IgdGhlIEQ1MCBjb25uZWN0aW9uIHNwYWNlLiBWYWx1ZXMgaW4vb3V0XHJcbiAqIGFyZSBfbGluZWFyXyBzUkdCIGFuZCBfbGluZWFyXyBEaXNwbGF5IFAzLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYm90aCBzUkdCIGFuZCBEaXNwbGF5IFAzIHVzZSB0aGUgc1JHQiB0cmFuc2ZlciBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZTpcclxuICogLSBodHRwOi8vd3d3LnJ1c3NlbGxjb3R0cmVsbC5jb20vcGhvdG8vbWF0cml4Q2FsY3VsYXRvci5odG1cclxuICovXHJcblxyXG5jb25zdCBMSU5FQVJfU1JHQl9UT19MSU5FQVJfRElTUExBWV9QMyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKS5mcm9tQXJyYXkoIFtcclxuXHQwLjgyMjQ2MjEsIDAuMDMzMTk0MSwgMC4wMTcwODI3LFxyXG5cdDAuMTc3NTM4MCwgMC45NjY4MDU4LCAwLjA3MjM5NzQsXHJcblx0LSAwLjAwMDAwMDEsIDAuMDAwMDAwMSwgMC45MTA1MTk5XHJcbl0gKTtcclxuXHJcbmNvbnN0IExJTkVBUl9ESVNQTEFZX1AzX1RPX0xJTkVBUl9TUkdCID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpLmZyb21BcnJheSggW1xyXG5cdDEuMjI0OTQwMSwgLSAwLjA0MjA1NjksIC0gMC4wMTk2Mzc2LFxyXG5cdC0gMC4yMjQ5NDA0LCAxLjA0MjA1NzEsIC0gMC4wNzg2MzYxLFxyXG5cdDAuMDAwMDAwMSwgMC4wMDAwMDAwLCAxLjA5ODI3MzVcclxuXSApO1xyXG5cclxuZnVuY3Rpb24gRGlzcGxheVAzVG9MaW5lYXJTUkdCKCBjb2xvciApIHtcclxuXHJcblx0Ly8gRGlzcGxheSBQMyB1c2VzIHRoZSBzUkdCIHRyYW5zZmVyIGZ1bmN0aW9uc1xyXG5cdHJldHVybiBjb2xvci5jb252ZXJ0U1JHQlRvTGluZWFyKCkuYXBwbHlNYXRyaXgzKCBMSU5FQVJfRElTUExBWV9QM19UT19MSU5FQVJfU1JHQiApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gTGluZWFyU1JHQlRvRGlzcGxheVAzKCBjb2xvciApIHtcclxuXHJcblx0Ly8gRGlzcGxheSBQMyB1c2VzIHRoZSBzUkdCIHRyYW5zZmVyIGZ1bmN0aW9uc1xyXG5cdHJldHVybiBjb2xvci5hcHBseU1hdHJpeDMoIExJTkVBUl9TUkdCX1RPX0xJTkVBUl9ESVNQTEFZX1AzICkuY29udmVydExpbmVhclRvU1JHQigpO1xyXG5cclxufVxyXG5cclxuLy8gQ29udmVyc2lvbnMgZnJvbSA8c291cmNlPiB0byBMaW5lYXItc1JHQiByZWZlcmVuY2Ugc3BhY2UuXHJcbmNvbnN0IFRPX0xJTkVBUiA9IHtcclxuXHRbIExpbmVhclNSR0JDb2xvclNwYWNlIF06ICggY29sb3IgKSA9PiBjb2xvcixcclxuXHRbIFNSR0JDb2xvclNwYWNlIF06ICggY29sb3IgKSA9PiBjb2xvci5jb252ZXJ0U1JHQlRvTGluZWFyKCksXHJcblx0WyBEaXNwbGF5UDNDb2xvclNwYWNlIF06IERpc3BsYXlQM1RvTGluZWFyU1JHQixcclxufTtcclxuXHJcbi8vIENvbnZlcnNpb25zIHRvIDx0YXJnZXQ+IGZyb20gTGluZWFyLXNSR0IgcmVmZXJlbmNlIHNwYWNlLlxyXG5jb25zdCBGUk9NX0xJTkVBUiA9IHtcclxuXHRbIExpbmVhclNSR0JDb2xvclNwYWNlIF06ICggY29sb3IgKSA9PiBjb2xvcixcclxuXHRbIFNSR0JDb2xvclNwYWNlIF06ICggY29sb3IgKSA9PiBjb2xvci5jb252ZXJ0TGluZWFyVG9TUkdCKCksXHJcblx0WyBEaXNwbGF5UDNDb2xvclNwYWNlIF06IExpbmVhclNSR0JUb0Rpc3BsYXlQMyxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBDb2xvck1hbmFnZW1lbnQgPSB7XHJcblxyXG5cdGVuYWJsZWQ6IHRydWUsXHJcblxyXG5cdGdldCBsZWdhY3lNb2RlKCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yTWFuYWdlbWVudDogLmxlZ2FjeU1vZGU9ZmFsc2UgcmVuYW1lZCB0byAuZW5hYmxlZD10cnVlIGluIHIxNTAuJyApO1xyXG5cclxuXHRcdHJldHVybiAhIHRoaXMuZW5hYmxlZDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IGxlZ2FjeU1vZGUoIGxlZ2FjeU1vZGUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3JNYW5hZ2VtZW50OiAubGVnYWN5TW9kZT1mYWxzZSByZW5hbWVkIHRvIC5lbmFibGVkPXRydWUgaW4gcjE1MC4nICk7XHJcblxyXG5cdFx0dGhpcy5lbmFibGVkID0gISBsZWdhY3lNb2RlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgd29ya2luZ0NvbG9yU3BhY2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuIExpbmVhclNSR0JDb2xvclNwYWNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgd29ya2luZ0NvbG9yU3BhY2UoIGNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3JNYW5hZ2VtZW50OiAud29ya2luZ0NvbG9yU3BhY2UgaXMgcmVhZG9ubHkuJyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0OiBmdW5jdGlvbiAoIGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlLCB0YXJnZXRDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSB8fCBzb3VyY2VDb2xvclNwYWNlID09PSB0YXJnZXRDb2xvclNwYWNlIHx8ICEgc291cmNlQ29sb3JTcGFjZSB8fCAhIHRhcmdldENvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gY29sb3I7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNvdXJjZVRvTGluZWFyID0gVE9fTElORUFSWyBzb3VyY2VDb2xvclNwYWNlIF07XHJcblx0XHRjb25zdCB0YXJnZXRGcm9tTGluZWFyID0gRlJPTV9MSU5FQVJbIHRhcmdldENvbG9yU3BhY2UgXTtcclxuXHJcblx0XHRpZiAoIHNvdXJjZVRvTGluZWFyID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0RnJvbUxpbmVhciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBgVW5zdXBwb3J0ZWQgY29sb3Igc3BhY2UgY29udmVyc2lvbiwgXCIkeyBzb3VyY2VDb2xvclNwYWNlIH1cIiB0byBcIiR7IHRhcmdldENvbG9yU3BhY2UgfVwiLmAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldEZyb21MaW5lYXIoIHNvdXJjZVRvTGluZWFyKCBjb2xvciApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24gKCBjb2xvciwgdGFyZ2V0Q29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0KCBjb2xvciwgdGhpcy53b3JraW5nQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b1dvcmtpbmdDb2xvclNwYWNlOiBmdW5jdGlvbiAoIGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnQoIGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlICk7XHJcblxyXG5cdH0sXHJcblxyXG59O1xyXG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50TlMgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcbmltcG9ydCB7IFNSR0JUb0xpbmVhciB9IGZyb20gJy4uL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcclxuXHJcbmxldCBfY2FudmFzO1xyXG5cclxuY2xhc3MgSW1hZ2VVdGlscyB7XHJcblxyXG5cdHN0YXRpYyBnZXREYXRhVVJMKCBpbWFnZSApIHtcclxuXHJcblx0XHRpZiAoIC9eZGF0YTovaS50ZXN0KCBpbWFnZS5zcmMgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBpbWFnZS5zcmM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ID09PSAndW5kZWZpbmVkJyApIHtcclxuXHJcblx0XHRcdHJldHVybiBpbWFnZS5zcmM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjYW52YXM7XHJcblxyXG5cdFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xyXG5cclxuXHRcdFx0Y2FudmFzID0gaW1hZ2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggX2NhbnZhcyA9PT0gdW5kZWZpbmVkICkgX2NhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcclxuXHJcblx0XHRcdF9jYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcclxuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG5cdFx0XHRjb25zdCBjb250ZXh0ID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhICkge1xyXG5cclxuXHRcdFx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2FudmFzID0gX2NhbnZhcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5nZXREYXRhVVJMOiBJbWFnZSBjb252ZXJ0ZWQgdG8ganBnIGZvciBwZXJmb3JtYW5jZSByZWFzb25zJywgaW1hZ2UgKTtcclxuXHJcblx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIHNSR0JUb0xpbmVhciggaW1hZ2UgKSB7XHJcblxyXG5cdFx0aWYgKCAoIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB8fFxyXG5cdFx0XHQoIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHx8XHJcblx0XHRcdCggdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XHJcblxyXG5cdFx0XHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcclxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcblx0XHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblx0XHRcdGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRkYXRhWyBpIF0gPSBTUkdCVG9MaW5lYXIoIGRhdGFbIGkgXSAvIDI1NSApICogMjU1O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlRGF0YSwgMCwgMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBpbWFnZS5kYXRhICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZGF0YSA9IGltYWdlLmRhdGEuc2xpY2UoIDAgKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSApIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhWyBpIF0gPSBNYXRoLmZsb29yKCBTUkdCVG9MaW5lYXIoIGRhdGFbIGkgXSAvIDI1NSApICogMjU1ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXNzdW1pbmcgZmxvYXRcclxuXHJcblx0XHRcdFx0XHRkYXRhWyBpIF0gPSBTUkdCVG9MaW5lYXIoIGRhdGFbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGRhdGE6IGRhdGEsXHJcblx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxyXG5cdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4nICk7XHJcblx0XHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEltYWdlVXRpbHMgfTtcclxuIiwiaW1wb3J0IHsgSW1hZ2VVdGlscyB9IGZyb20gJy4uL2V4dHJhcy9JbWFnZVV0aWxzLmpzJztcclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuXHJcbmxldCBzb3VyY2VJZCA9IDA7XHJcblxyXG5jbGFzcyBTb3VyY2Uge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZGF0YSA9IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy5pc1NvdXJjZSA9IHRydWU7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBzb3VyY2VJZCArKyB9ICk7XHJcblxyXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xyXG5cclxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS5pbWFnZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWV0YS5pbWFnZXNbIHRoaXMudXVpZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBvdXRwdXQgPSB7XHJcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcclxuXHRcdFx0dXJsOiAnJ1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xyXG5cclxuXHRcdGlmICggZGF0YSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGxldCB1cmw7XHJcblxyXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXHJcblxyXG5cdFx0XHRcdHVybCA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpIF0uaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVybC5wdXNoKCBzZXJpYWxpemVJbWFnZSggZGF0YVsgaSBdLmltYWdlICkgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dXJsLnB1c2goIHNlcmlhbGl6ZUltYWdlKCBkYXRhWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gdGV4dHVyZVxyXG5cclxuXHRcdFx0XHR1cmwgPSBzZXJpYWxpemVJbWFnZSggZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3V0cHV0LnVybCA9IHVybDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdG1ldGEuaW1hZ2VzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplSW1hZ2UoIGltYWdlICkge1xyXG5cclxuXHRpZiAoICggdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XHJcblx0XHQoIHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHx8XHJcblx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApICkge1xyXG5cclxuXHRcdC8vIGRlZmF1bHQgaW1hZ2VzXHJcblxyXG5cdFx0cmV0dXJuIEltYWdlVXRpbHMuZ2V0RGF0YVVSTCggaW1hZ2UgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIGltYWdlLmRhdGEgKSB7XHJcblxyXG5cdFx0XHQvLyBpbWFnZXMgb2YgRGF0YVRleHR1cmVcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZGF0YTogQXJyYXkuZnJvbSggaW1hZ2UuZGF0YSApLFxyXG5cdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcclxuXHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodCxcclxuXHRcdFx0XHR0eXBlOiBpbWFnZS5kYXRhLmNvbnN0cnVjdG9yLm5hbWVcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVGV4dHVyZTogVW5hYmxlIHRvIHNlcmlhbGl6ZSBUZXh0dXJlLicgKTtcclxuXHRcdFx0cmV0dXJuIHt9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgU291cmNlIH07XHJcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0IHtcclxuXHRNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxyXG5cdENsYW1wVG9FZGdlV3JhcHBpbmcsXHJcblx0UmVwZWF0V3JhcHBpbmcsXHJcblx0VW5zaWduZWRCeXRlVHlwZSxcclxuXHRSR0JBRm9ybWF0LFxyXG5cdExpbmVhck1pcG1hcExpbmVhckZpbHRlcixcclxuXHRMaW5lYXJGaWx0ZXIsXHJcblx0VVZNYXBwaW5nLFxyXG5cdHNSR0JFbmNvZGluZyxcclxuXHRTUkdCQ29sb3JTcGFjZSxcclxuXHROb0NvbG9yU3BhY2UsXHJcblx0TGluZWFyRW5jb2RpbmdcclxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uL21hdGgvTWF0cml4My5qcyc7XHJcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4vU291cmNlLmpzJztcclxuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcblxyXG5sZXQgdGV4dHVyZUlkID0gMDtcclxuXHJcbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggaW1hZ2UgPSBUZXh0dXJlLkRFRkFVTFRfSU1BR0UsIG1hcHBpbmcgPSBUZXh0dXJlLkRFRkFVTFRfTUFQUElORywgd3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nLCB3cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmcsIG1hZ0ZpbHRlciA9IExpbmVhckZpbHRlciwgbWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBmb3JtYXQgPSBSR0JBRm9ybWF0LCB0eXBlID0gVW5zaWduZWRCeXRlVHlwZSwgYW5pc290cm9weSA9IFRleHR1cmUuREVGQVVMVF9BTklTT1RST1BZLCBjb2xvclNwYWNlID0gTm9Db2xvclNwYWNlICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc1RleHR1cmUgPSB0cnVlO1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogdGV4dHVyZUlkICsrIH0gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UgPSBuZXcgU291cmNlKCBpbWFnZSApO1xyXG5cdFx0dGhpcy5taXBtYXBzID0gW107XHJcblxyXG5cdFx0dGhpcy5tYXBwaW5nID0gbWFwcGluZztcclxuXHRcdHRoaXMuY2hhbm5lbCA9IDA7XHJcblxyXG5cdFx0dGhpcy53cmFwUyA9IHdyYXBTO1xyXG5cdFx0dGhpcy53cmFwVCA9IHdyYXBUO1xyXG5cclxuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcclxuXHJcblx0XHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcclxuXHRcdHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBudWxsO1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHJcblx0XHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcblx0XHR0aGlzLnJlcGVhdCA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblx0XHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcclxuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5mbGlwWSA9IHRydWU7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7XHQvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBjb2xvclNwYWNlID09PSAnc3RyaW5nJyApIHtcclxuXHJcblx0XHRcdHRoaXMuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XHJcblxyXG5cdFx0fSBlbHNlIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNTJcclxuXHJcblx0XHRcdHdhcm5PbmNlKCAnVEhSRUUuVGV4dHVyZTogUHJvcGVydHkgLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IC5jb2xvclNwYWNlLicgKTtcclxuXHRcdFx0dGhpcy5jb2xvclNwYWNlID0gY29sb3JTcGFjZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBOb0NvbG9yU3BhY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0ge307XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHRcdHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gZmFsc2U7IC8vIGluZGljYXRlcyB3aGV0aGVyIGEgdGV4dHVyZSBiZWxvbmdzIHRvIGEgcmVuZGVyIHRhcmdldCBvciBub3RcclxuXHRcdHRoaXMubmVlZHNQTVJFTVVwZGF0ZSA9IGZhbHNlOyAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRleHR1cmUgc2hvdWxkIGJlIHByb2Nlc3NlZCBieSBQTVJFTUdlbmVyYXRvciBvciBub3QgKG9ubHkgcmVsZXZhbnQgZm9yIHJlbmRlciB0YXJnZXQgdGV4dHVyZXMpXHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGltYWdlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNvdXJjZS5kYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBpbWFnZSggdmFsdWUgPSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuc291cmNlLmRhdGEgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVNYXRyaXgoKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0oIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnksIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnksIHRoaXMucm90YXRpb24sIHRoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuXHRcdHRoaXMuc291cmNlID0gc291cmNlLnNvdXJjZTtcclxuXHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XHJcblxyXG5cdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XHJcblx0XHR0aGlzLmNoYW5uZWwgPSBzb3VyY2UuY2hhbm5lbDtcclxuXHJcblx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xyXG5cdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcclxuXHJcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XHJcblx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xyXG5cdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IHNvdXJjZS5pbnRlcm5hbEZvcm1hdDtcclxuXHRcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xyXG5cclxuXHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcclxuXHRcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcclxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcclxuXHRcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBzb3VyY2UuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XHJcblx0XHR0aGlzLmZsaXBZID0gc291cmNlLmZsaXBZO1xyXG5cdFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSBzb3VyY2UudW5wYWNrQWxpZ25tZW50O1xyXG5cdFx0dGhpcy5jb2xvclNwYWNlID0gc291cmNlLmNvbG9yU3BhY2U7XHJcblxyXG5cdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggbWV0YSApIHtcclxuXHJcblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcclxuXHJcblx0XHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG91dHB1dCA9IHtcclxuXHJcblx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0dmVyc2lvbjogNC42LFxyXG5cdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcclxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxyXG5cclxuXHRcdFx0aW1hZ2U6IHRoaXMuc291cmNlLnRvSlNPTiggbWV0YSApLnV1aWQsXHJcblxyXG5cdFx0XHRtYXBwaW5nOiB0aGlzLm1hcHBpbmcsXHJcblx0XHRcdGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcclxuXHJcblx0XHRcdHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXHJcblx0XHRcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXHJcblx0XHRcdGNlbnRlcjogWyB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55IF0sXHJcblx0XHRcdHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG5cclxuXHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXHJcblxyXG5cdFx0XHRmb3JtYXQ6IHRoaXMuZm9ybWF0LFxyXG5cdFx0XHRpbnRlcm5hbEZvcm1hdDogdGhpcy5pbnRlcm5hbEZvcm1hdCxcclxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxyXG5cdFx0XHRjb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsXHJcblxyXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxyXG5cdFx0XHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHksXHJcblxyXG5cdFx0XHRmbGlwWTogdGhpcy5mbGlwWSxcclxuXHJcblx0XHRcdGdlbmVyYXRlTWlwbWFwczogdGhpcy5nZW5lcmF0ZU1pcG1hcHMsXHJcblx0XHRcdHByZW11bHRpcGx5QWxwaGE6IHRoaXMucHJlbXVsdGlwbHlBbHBoYSxcclxuXHRcdFx0dW5wYWNrQWxpZ25tZW50OiB0aGlzLnVucGFja0FsaWdubWVudFxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBvdXRwdXQudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xyXG5cclxuXHRcdGlmICggISBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zZm9ybVV2KCB1diApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubWFwcGluZyAhPT0gVVZNYXBwaW5nICkgcmV0dXJuIHV2O1xyXG5cclxuXHRcdHV2LmFwcGx5TWF0cml4MyggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xyXG5cclxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIHRoaXMud3JhcFQgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di55ICkgJSAyICkgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5mbGlwWSApIHtcclxuXHJcblx0XHRcdHV2LnkgPSAxIC0gdXYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHV2O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMudmVyc2lvbiArKztcclxuXHRcdFx0dGhpcy5zb3VyY2UubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXQgZW5jb2RpbmcoKSB7IC8vIEBkZXByZWNhdGVkLCByMTUyXHJcblxyXG5cdFx0d2Fybk9uY2UoICdUSFJFRS5UZXh0dXJlOiBQcm9wZXJ0eSAuZW5jb2RpbmcgaGFzIGJlZW4gcmVwbGFjZWQgYnkgLmNvbG9yU3BhY2UuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgPyBzUkdCRW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgZW5jb2RpbmcoIGVuY29kaW5nICkgeyAvLyBAZGVwcmVjYXRlZCwgcjE1MlxyXG5cclxuXHRcdHdhcm5PbmNlKCAnVEhSRUUuVGV4dHVyZTogUHJvcGVydHkgLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IC5jb2xvclNwYWNlLicgKTtcclxuXHRcdHRoaXMuY29sb3JTcGFjZSA9IGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IE5vQ29sb3JTcGFjZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuVGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gbnVsbDtcclxuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBVVk1hcHBpbmc7XHJcblRleHR1cmUuREVGQVVMVF9BTklTT1RST1BZID0gMTtcclxuXHJcbmV4cG9ydCB7IFRleHR1cmUgfTtcclxuIiwiY2xhc3MgVmVjdG9yNCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcclxuXHJcblx0XHRWZWN0b3I0LnByb3RvdHlwZS5pc1ZlY3RvcjQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHdpZHRoKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLno7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnogPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgaGVpZ2h0KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnc7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy53ID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0U2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy55ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ID0gc2NhbGFyO1xyXG5cdFx0dGhpcy53ID0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFgoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRZKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WiggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFcoIHcgKSB7XHJcblxyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cdFx0dGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhZGQoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblx0XHR0aGlzLnogKz0gdi56O1xyXG5cdFx0dGhpcy53ICs9IHYudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhZGRTY2FsYXIoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHRcdHRoaXMueiArPSBzO1xyXG5cdFx0dGhpcy53ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkVmVjdG9ycyggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XHJcblx0XHR0aGlzLncgPSBhLncgKyBiLnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblx0XHR0aGlzLnogKz0gdi56ICogcztcclxuXHRcdHRoaXMudyArPSB2LncgKiBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN1YiggdiApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblx0XHR0aGlzLncgLT0gdi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN1YlNjYWxhciggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cdFx0dGhpcy56IC09IHM7XHJcblx0XHR0aGlzLncgLT0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcclxuXHRcdHRoaXMudyA9IGEudyAtIGIudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtdWx0aXBseSggdiApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gdi54O1xyXG5cdFx0dGhpcy55ICo9IHYueTtcclxuXHRcdHRoaXMueiAqPSB2Lno7XHJcblx0XHR0aGlzLncgKj0gdi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy53ICo9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XHJcblxyXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcclxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xyXG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XHJcblx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbiggcSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHRjb25zdCBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XHJcblxyXG5cdFx0aWYgKCBzIDwgMC4wMDAxICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMTtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gcS54IC8gcztcclxuXHRcdFx0dGhpcy55ID0gcS55IC8gcztcclxuXHRcdFx0dGhpcy56ID0gcS56IC8gcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0bGV0IGFuZ2xlLCB4LCB5LCB6OyAvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxyXG5cdFx0Y29uc3QgZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKSAmJlxyXG5cdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKSAmJlxyXG5cdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcclxuXHJcblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXHJcblx0XHRcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcclxuXHRcdFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xyXG5cclxuXHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yICkgJiZcclxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiZcclxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yICkgJiZcclxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xyXG5cclxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcclxuXHJcblx0XHRcdFx0dGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxyXG5cclxuXHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xyXG5cclxuXHRcdFx0Y29uc3QgeHggPSAoIG0xMSArIDEgKSAvIDI7XHJcblx0XHRcdGNvbnN0IHl5ID0gKCBtMjIgKyAxICkgLyAyO1xyXG5cdFx0XHRjb25zdCB6eiA9ICggbTMzICsgMSApIC8gMjtcclxuXHRcdFx0Y29uc3QgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcclxuXHRcdFx0Y29uc3QgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcclxuXHRcdFx0Y29uc3QgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcclxuXHJcblx0XHRcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXHJcblxyXG5cdFx0XHRcdGlmICggeHggPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHggPSBNYXRoLnNxcnQoIHh4ICk7XHJcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xyXG5cdFx0XHRcdFx0eiA9IHh6IC8geDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcclxuXHJcblx0XHRcdFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB5eSA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDA7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcclxuXHRcdFx0XHRcdHggPSB4eSAvIHk7XHJcblx0XHRcdFx0XHR6ID0geXogLyB5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXHJcblxyXG5cdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHogPSAwO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XHJcblx0XHRcdFx0XHR4ID0geHogLyB6O1xyXG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxyXG5cclxuXHRcdGxldCBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKSArXHJcblx0XHRcdCggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcclxuXHRcdFx0KCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xyXG5cclxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcclxuXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxyXG5cclxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bWluKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1heCggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjbGFtcCggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueSApICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnogKSApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy53ICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjbGFtcExlbmd0aCggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmbG9vcigpIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjZWlsKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cm91bmQoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cm91bmRUb1plcm8oKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bmVnYXRlKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdHRoaXMudyA9IC0gdGhpcy53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRvdCggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9XHJcblxyXG5cdGxlbmd0aFNxKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH1cclxuXHJcblx0bGVuZ3RoKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9XHJcblxyXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9XHJcblxyXG5cdG5vcm1hbGl6ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcclxuXHJcblx0fVxyXG5cclxuXHRsZXJwKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYxLnggKyAoIHYyLnggLSB2MS54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueiA9IHYxLnogKyAoIHYyLnogLSB2MS56ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMudyA9IHYxLncgKyAoIHYyLncgLSB2MS53ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRlcXVhbHMoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHRcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XHJcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xyXG5cdFx0dGhpcy53ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cmFuZG9tKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdHRoaXMudyA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XHJcblxyXG5cdFx0eWllbGQgdGhpcy54O1xyXG5cdFx0eWllbGQgdGhpcy55O1xyXG5cdFx0eWllbGQgdGhpcy56O1xyXG5cdFx0eWllbGQgdGhpcy53O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBWZWN0b3I0IH07XHJcbiIsImltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL1RleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIE5vQ29sb3JTcGFjZSwgU1JHQkNvbG9yU3BhY2UsIHNSR0JFbmNvZGluZyB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5pbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcuLi90ZXh0dXJlcy9Tb3VyY2UuanMnO1xyXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcclxuXHJcbi8qXHJcbiBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcclxuICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxyXG4gKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xyXG4qL1xyXG5jbGFzcyBXZWJHTFJlbmRlclRhcmdldCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIG9wdGlvbnMgPSB7fSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNXZWJHTFJlbmRlclRhcmdldCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR0aGlzLmRlcHRoID0gMTtcclxuXHJcblx0XHR0aGlzLnNjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdGNvbnN0IGltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBkZXB0aDogMSB9O1xyXG5cclxuXHRcdGlmICggb3B0aW9ucy5lbmNvZGluZyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gQGRlcHJlY2F0ZWQsIHIxNTJcclxuXHRcdFx0d2Fybk9uY2UoICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogb3B0aW9uLmVuY29kaW5nIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IG9wdGlvbi5jb2xvclNwYWNlLicgKTtcclxuXHRcdFx0b3B0aW9ucy5jb2xvclNwYWNlID0gb3B0aW9ucy5lbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBOb0NvbG9yU3BhY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBpbWFnZSwgb3B0aW9ucy5tYXBwaW5nLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5jb2xvclNwYWNlICk7XHJcblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgOiBmYWxzZTtcclxuXHRcdHRoaXMudGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQgOiBudWxsO1xyXG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcclxuXHJcblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XHJcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhUZXh0dXJlIDogbnVsbDtcclxuXHJcblx0XHR0aGlzLnNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2FtcGxlcyA6IDA7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0U2l6ZSggd2lkdGgsIGhlaWdodCwgZGVwdGggPSAxICkge1xyXG5cclxuXHRcdGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCB8fCB0aGlzLmRlcHRoICE9PSBkZXB0aCApIHtcclxuXHJcblx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcclxuXHJcblx0XHRcdHRoaXMudGV4dHVyZS5pbWFnZS53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHR0aGlzLnRleHR1cmUuaW1hZ2UuZGVwdGggPSBkZXB0aDtcclxuXHJcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dGhpcy5zY2lzc29yLnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcclxuXHRcdHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XHJcblxyXG5cdFx0dGhpcy5zY2lzc29yLmNvcHkoIHNvdXJjZS5zY2lzc29yICk7XHJcblx0XHR0aGlzLnNjaXNzb3JUZXN0ID0gc291cmNlLnNjaXNzb3JUZXN0O1xyXG5cclxuXHRcdHRoaXMudmlld3BvcnQuY29weSggc291cmNlLnZpZXdwb3J0ICk7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0gc291cmNlLnRleHR1cmUuY2xvbmUoKTtcclxuXHRcdHRoaXMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xyXG5cclxuXHRcdC8vIGVuc3VyZSBpbWFnZSBvYmplY3QgaXMgbm90IHNoYXJlZCwgc2VlICMyMDMyOFxyXG5cclxuXHRcdGNvbnN0IGltYWdlID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS50ZXh0dXJlLmltYWdlICk7XHJcblx0XHR0aGlzLnRleHR1cmUuc291cmNlID0gbmV3IFNvdXJjZSggaW1hZ2UgKTtcclxuXHJcblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xyXG5cdFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XHJcblxyXG5cdFx0aWYgKCBzb3VyY2UuZGVwdGhUZXh0dXJlICE9PSBudWxsICkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5zYW1wbGVzID0gc291cmNlLnNhbXBsZXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfTtcclxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IENsYW1wVG9FZGdlV3JhcHBpbmcsIE5lYXJlc3RGaWx0ZXIgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgRGF0YUFycmF5VGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCBudWxsICk7XHJcblxyXG5cdFx0dGhpcy5pc0RhdGFBcnJheVRleHR1cmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuaW1hZ2UgPSB7IGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoIH07XHJcblxyXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cclxuXHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IERhdGFBcnJheVRleHR1cmUgfTtcclxuIiwiaW1wb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL1dlYkdMUmVuZGVyVGFyZ2V0LmpzJztcclxuaW1wb3J0IHsgRGF0YUFycmF5VGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0RhdGFBcnJheVRleHR1cmUuanMnO1xyXG5cclxuY2xhc3MgV2ViR0xBcnJheVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0dGhpcy5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgRGF0YUFycmF5VGV4dHVyZSggbnVsbCwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgV2ViR0xBcnJheVJlbmRlclRhcmdldCB9O1xyXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi9UZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTmVhcmVzdEZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBEYXRhM0RUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBkYXRhID0gbnVsbCwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEgKSB7XHJcblxyXG5cdFx0Ly8gV2UncmUgZ29pbmcgdG8gYWRkIC5zZXRYWFgoKSBtZXRob2RzIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgbGF0ZXIuXHJcblx0XHQvLyBVc2VycyBjYW4gc3RpbGwgc2V0IGluIERhdGFUZXh0dXJlM0QgZGlyZWN0bHkuXHJcblx0XHQvL1xyXG5cdFx0Ly9cdGNvbnN0IHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUzRCggZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcclxuXHRcdC8vIFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7XHJcblx0XHQvL1xyXG5cdFx0Ly8gU2VlICMxNDgzOVxyXG5cclxuXHRcdHN1cGVyKCBudWxsICk7XHJcblxyXG5cdFx0dGhpcy5pc0RhdGEzRFRleHR1cmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuaW1hZ2UgPSB7IGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoIH07XHJcblxyXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cclxuXHRcdHRoaXMud3JhcFIgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IERhdGEzRFRleHR1cmUgfTtcclxuIiwiaW1wb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICcuL1dlYkdMUmVuZGVyVGFyZ2V0LmpzJztcclxuaW1wb3J0IHsgRGF0YTNEVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0RhdGEzRFRleHR1cmUuanMnO1xyXG5cclxuY2xhc3MgV2ViR0wzRFJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMUmVuZGVyVGFyZ2V0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZGVwdGggPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0dGhpcy5pc1dlYkdMM0RSZW5kZXJUYXJnZXQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUgPSBuZXcgRGF0YTNEVGV4dHVyZSggbnVsbCwgd2lkdGgsIGhlaWdodCwgZGVwdGggKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgV2ViR0wzRFJlbmRlclRhcmdldCB9O1xyXG4iLCJpbXBvcnQgeyBXZWJHTFJlbmRlclRhcmdldCB9IGZyb20gJy4vV2ViR0xSZW5kZXJUYXJnZXQuanMnO1xyXG5cclxuY2xhc3MgV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGNvdW50ID0gMSwgb3B0aW9ucyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XHJcblxyXG5cdFx0dGhpcy5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gdHJ1ZTtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlWyBpIF0gPSB0ZXh0dXJlLmNsb25lKCk7XHJcblx0XHRcdHRoaXMudGV4dHVyZVsgaSBdLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldFNpemUoIHdpZHRoLCBoZWlnaHQsIGRlcHRoID0gMSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdGhpcy5kZXB0aCAhPT0gZGVwdGggKSB7XHJcblxyXG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy50ZXh0dXJlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRleHR1cmVbIGkgXS5pbWFnZS53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRcdHRoaXMudGV4dHVyZVsgaSBdLmltYWdlLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdFx0XHR0aGlzLnRleHR1cmVbIGkgXS5pbWFnZS5kZXB0aCA9IGRlcHRoO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudmlld3BvcnQuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblx0XHR0aGlzLnNjaXNzb3Iuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cclxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XHJcblx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XHJcblx0XHR0aGlzLmRlcHRoID0gc291cmNlLmRlcHRoO1xyXG5cclxuXHRcdHRoaXMuc2Npc3Nvci5jb3B5KCBzb3VyY2Uuc2Npc3NvciApO1xyXG5cdFx0dGhpcy5zY2lzc29yVGVzdCA9IHNvdXJjZS5zY2lzc29yVGVzdDtcclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xyXG5cclxuXHRcdHRoaXMuZGVwdGhCdWZmZXIgPSBzb3VyY2UuZGVwdGhCdWZmZXI7XHJcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcclxuXHJcblx0XHRpZiAoIHNvdXJjZS5kZXB0aFRleHR1cmUgIT09IG51bGwgKSB0aGlzLmRlcHRoVGV4dHVyZSA9IHNvdXJjZS5kZXB0aFRleHR1cmUuY2xvbmUoKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUubGVuZ3RoID0gMDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gc291cmNlLnRleHR1cmUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnRleHR1cmVbIGkgXSA9IHNvdXJjZS50ZXh0dXJlWyBpIF0uY2xvbmUoKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlWyBpIF0uaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzIH07XHJcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XHJcblxyXG5jbGFzcyBRdWF0ZXJuaW9uIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxICkge1xyXG5cclxuXHRcdHRoaXMuaXNRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl94ID0geDtcclxuXHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0dGhpcy5feiA9IHo7XHJcblx0XHR0aGlzLl93ID0gdztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgc2xlcnBGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcclxuXHJcblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXHJcblxyXG5cdFx0bGV0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcclxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxyXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXHJcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcclxuXHJcblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXHJcblx0XHRcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcclxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxyXG5cdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XHJcblxyXG5cdFx0aWYgKCB0ID09PSAwICkge1xyXG5cclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MDtcclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHQgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgxO1xyXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkxO1xyXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHoxO1xyXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcxO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xyXG5cclxuXHRcdFx0bGV0IHMgPSAxIC0gdDtcclxuXHRcdFx0Y29uc3QgY29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcclxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxyXG5cdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XHJcblxyXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxyXG5cdFx0XHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxyXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcclxuXHJcblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XHJcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCB0RGlyID0gdCAqIGRpcjtcclxuXHJcblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xyXG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcclxuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XHJcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xyXG5cclxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxyXG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xyXG5cclxuXHRcdFx0XHR4MCAqPSBmO1xyXG5cdFx0XHRcdHkwICo9IGY7XHJcblx0XHRcdFx0ejAgKj0gZjtcclxuXHRcdFx0XHR3MCAqPSBmO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDA7XHJcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xyXG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSApIHtcclxuXHJcblx0XHRjb25zdCB4MCA9IHNyYzBbIHNyY09mZnNldDAgXTtcclxuXHRcdGNvbnN0IHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXTtcclxuXHRcdGNvbnN0IHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXTtcclxuXHRcdGNvbnN0IHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcclxuXHJcblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgXTtcclxuXHRcdGNvbnN0IHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXTtcclxuXHRcdGNvbnN0IHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXTtcclxuXHRcdGNvbnN0IHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcclxuXHJcblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDAgKiB3MSArIHcwICogeDEgKyB5MCAqIHoxIC0gejAgKiB5MTtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejAgKiB3MSArIHcwICogejEgKyB4MCAqIHkxIC0geTAgKiB4MTtcclxuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzAgKiB3MSAtIHgwICogeDEgLSB5MCAqIHkxIC0gejAgKiB6MTtcclxuXHJcblx0XHRyZXR1cm4gZHN0O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB4KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl94O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCB4KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3k7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHkoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgeigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fejtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgeiggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB3KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl93O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCB3KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl93ID0gdmFsdWU7XHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX3cgPSB3O1xyXG5cclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBxdWF0ZXJuaW9uICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XHJcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xyXG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcclxuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XHJcblxyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21FdWxlciggZXVsZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHRjb25zdCB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLl9vcmRlcjtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdGNvbnN0IGNvcyA9IE1hdGguY29zO1xyXG5cdFx0Y29uc3Qgc2luID0gTWF0aC5zaW47XHJcblxyXG5cdFx0Y29uc3QgYzEgPSBjb3MoIHggLyAyICk7XHJcblx0XHRjb25zdCBjMiA9IGNvcyggeSAvIDIgKTtcclxuXHRcdGNvbnN0IGMzID0gY29zKCB6IC8gMiApO1xyXG5cclxuXHRcdGNvbnN0IHMxID0gc2luKCB4IC8gMiApO1xyXG5cdFx0Y29uc3QgczIgPSBzaW4oIHkgLyAyICk7XHJcblx0XHRjb25zdCBzMyA9IHNpbiggeiAvIDIgKTtcclxuXHJcblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcclxuXHJcblx0XHRcdGNhc2UgJ1hZWic6XHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1lYWic6XHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1pYWSc6XHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1pZWCc6XHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1laWCc6XHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1haWSc6XHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0Y29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xyXG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XHJcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcclxuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcclxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXHJcblxyXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcclxuXHJcblx0XHRpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRsZXQgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xyXG5cclxuXHRcdGlmICggciA8IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0Ly8gdkZyb20gYW5kIHZUbyBwb2ludCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXHJcblxyXG5cdFx0XHRyID0gMDtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSAtIHZGcm9tLnk7XHJcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XHJcblx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblx0XHRcdFx0dGhpcy5fdyA9IHI7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0XHR0aGlzLl95ID0gLSB2RnJvbS56O1xyXG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xyXG5cdFx0XHRcdHRoaXMuX3cgPSByO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXHJcblxyXG5cdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xyXG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xyXG5cdFx0XHR0aGlzLl96ID0gdkZyb20ueCAqIHZUby55IC0gdkZyb20ueSAqIHZUby54O1xyXG5cdFx0XHR0aGlzLl93ID0gcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHJcblx0YW5nbGVUbyggcSApIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIE1hdGhVdGlscy5jbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVRvd2FyZHMoIHEsIHN0ZXAgKSB7XHJcblxyXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcclxuXHJcblx0XHRpZiAoIGFuZ2xlID09PSAwICkgcmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0Y29uc3QgdCA9IE1hdGgubWluKCAxLCBzdGVwIC8gYW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0aWRlbnRpdHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAxICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW52ZXJ0KCkge1xyXG5cclxuXHRcdC8vIHF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uanVnYXRlKCkge1xyXG5cclxuXHRcdHRoaXMuX3ggKj0gLSAxO1xyXG5cdFx0dGhpcy5feSAqPSAtIDE7XHJcblx0XHR0aGlzLl96ICo9IC0gMTtcclxuXHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZG90KCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcclxuXHJcblx0fVxyXG5cclxuXHRsZW5ndGhTcSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XHJcblxyXG5cdH1cclxuXHJcblx0bGVuZ3RoKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XHJcblxyXG5cdH1cclxuXHJcblx0bm9ybWFsaXplKCkge1xyXG5cclxuXHRcdGxldCBsID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIGwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0dGhpcy5feSA9IDA7XHJcblx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cdFx0XHR0aGlzLl93ID0gMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bCA9IDEgLyBsO1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xyXG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XHJcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcclxuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bXVsdGlwbHkoIHEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHByZW11bHRpcGx5KCBxICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xyXG5cclxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxyXG5cclxuXHRcdGNvbnN0IHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XHJcblx0XHRjb25zdCBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xyXG5cclxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XHJcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xyXG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcclxuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XHJcblxyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNsZXJwKCBxYiwgdCApIHtcclxuXHJcblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcclxuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0Y29uc3QgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xyXG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcclxuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XHJcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xyXG5cclxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IHc7XHJcblx0XHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0dGhpcy5feiA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc3FyU2luSGFsZlRoZXRhID0gMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhO1xyXG5cclxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcyA9IDEgLSB0O1xyXG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcclxuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XHJcblx0XHRcdHRoaXMuX3kgPSBzICogeSArIHQgKiB0aGlzLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xyXG5cdFx0Y29uc3QgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcclxuXHRcdGNvbnN0IHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzbGVycFF1YXRlcm5pb25zKCBxYSwgcWIsIHQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyYW5kb20oKSB7XHJcblxyXG5cdFx0Ly8gRGVyaXZlZCBmcm9tIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcclxuXHRcdC8vIE5vdGUsIHRoaXMgc291cmNlIHVzZXMgdywgeCwgeSwgeiBvcmRlcmluZyxcclxuXHRcdC8vIHNvIHdlIHN3YXAgdGhlIG9yZGVyIGJlbG93LlxyXG5cclxuXHRcdGNvbnN0IHUxID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdGNvbnN0IHNxcnQxdTEgPSBNYXRoLnNxcnQoIDEgLSB1MSApO1xyXG5cdFx0Y29uc3Qgc3FydHUxID0gTWF0aC5zcXJ0KCB1MSApO1xyXG5cclxuXHRcdGNvbnN0IHUyID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRcdGNvbnN0IHUzID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldChcclxuXHRcdFx0c3FydDF1MSAqIE1hdGguY29zKCB1MiApLFxyXG5cdFx0XHRzcXJ0dTEgKiBNYXRoLnNpbiggdTMgKSxcclxuXHRcdFx0c3FydHUxICogTWF0aC5jb3MoIHUzICksXHJcblx0XHRcdHNxcnQxdTEgKiBNYXRoLnNpbiggdTIgKSxcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZXF1YWxzKCBxdWF0ZXJuaW9uICkge1xyXG5cclxuXHRcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XHJcblx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XHJcblx0XHR0aGlzLl96ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XHJcblx0XHR0aGlzLl93ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRvQXJyYXkoKTtcclxuXHJcblx0fVxyXG5cclxuXHRfb25DaGFuZ2UoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XHJcblxyXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xyXG5cclxuXHRcdHlpZWxkIHRoaXMuX3g7XHJcblx0XHR5aWVsZCB0aGlzLl95O1xyXG5cdFx0eWllbGQgdGhpcy5fejtcclxuXHRcdHlpZWxkIHRoaXMuX3c7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFF1YXRlcm5pb24gfTtcclxuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcclxuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XHJcblxyXG5jbGFzcyBWZWN0b3IzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAgKSB7XHJcblxyXG5cdFx0VmVjdG9yMy5wcm90b3R5cGUuaXNWZWN0b3IzID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHRoaXMuejsgLy8gc3ByaXRlLnNjYWxlLnNldCh4LHkpXHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHNjYWxhcjtcclxuXHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHRcdHRoaXMueiA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRYKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WSggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFooIHogKSB7XHJcblxyXG5cdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENvbXBvbmVudCggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhZGQoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblx0XHR0aGlzLnogKz0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZFNjYWxhciggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gcztcclxuXHRcdHRoaXMueSArPSBzO1xyXG5cdFx0dGhpcy56ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkVmVjdG9ycyggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblx0XHR0aGlzLnogKz0gdi56ICogcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdWIoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN1YlNjYWxhciggcyApIHtcclxuXHJcblx0XHR0aGlzLnggLT0gcztcclxuXHRcdHRoaXMueSAtPSBzO1xyXG5cdFx0dGhpcy56IC09IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c3ViVmVjdG9ycyggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bXVsdGlwbHkoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHYueDtcclxuXHRcdHRoaXMueSAqPSB2Lnk7XHJcblx0XHR0aGlzLnogKj0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5VmVjdG9ycyggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKiBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlFdWxlciggZXVsZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXgzKCBtICkge1xyXG5cclxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XHJcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKCBtICkubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXg0KCBtICkge1xyXG5cclxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRjb25zdCB3ID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTtcclxuXHJcblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XHJcblx0XHR0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKSAqIHc7XHJcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcclxuXHJcblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0Y29uc3QgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcclxuXHJcblx0XHRjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcclxuXHRcdGNvbnN0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG5cdFx0Y29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XHJcblx0XHRjb25zdCBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcclxuXHJcblx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtIHF4ICsgaXkgKiAtIHF6IC0gaXogKiAtIHF5O1xyXG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcclxuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cHJvamVjdCggY2FtZXJhICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0fVxyXG5cclxuXHR1bnByb2plY3QoIGNhbWVyYSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdH1cclxuXHJcblx0dHJhbnNmb3JtRGlyZWN0aW9uKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxyXG5cclxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XHJcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpdmlkZSggdiApIHtcclxuXHJcblx0XHR0aGlzLnggLz0gdi54O1xyXG5cdFx0dGhpcy55IC89IHYueTtcclxuXHRcdHRoaXMueiAvPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRtaW4oIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1heCggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xhbXAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnggKSApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy55ICkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueiApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Zmxvb3IoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNlaWwoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdW5kKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyb3VuZFRvWmVybygpIHtcclxuXHJcblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bmVnYXRlKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRkb3QoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XHJcblxyXG5cdGxlbmd0aFNxKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XHJcblxyXG5cdH1cclxuXHJcblx0bGVuZ3RoKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xyXG5cclxuXHR9XHJcblxyXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xyXG5cclxuXHR9XHJcblxyXG5cdG5vcm1hbGl6ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcclxuXHJcblx0fVxyXG5cclxuXHRsZXJwKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy56ID0gdjEueiArICggdjIueiAtIHYxLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyb3NzKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdGhpcywgdiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyb3NzVmVjdG9ycyggYSwgYiApIHtcclxuXHJcblx0XHRjb25zdCBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0Y29uc3QgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcclxuXHJcblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcclxuXHRcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xyXG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xyXG5cclxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdi5sZW5ndGhTcSgpO1xyXG5cclxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29weSggdiApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XHJcblxyXG5cdFx0X3ZlY3Rvci5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlZmxlY3QoIG5vcm1hbCApIHtcclxuXHJcblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcclxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFuZ2xlVG8oIHYgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xyXG5cclxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XHJcblxyXG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlVG8oIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XHJcblxyXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcclxuXHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xyXG5cclxuXHR9XHJcblxyXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKSArIE1hdGguYWJzKCB0aGlzLnogLSB2LnogKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tU3BoZXJpY2FsKCBzICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMoIHMucmFkaXVzLCBzLnBoaSwgcy50aGV0YSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcclxuXHJcblx0XHRjb25zdCBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcGhpICkgKiByYWRpdXM7XHJcblxyXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcGhpICkgKiByYWRpdXM7XHJcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tQ3lsaW5kcmljYWwoIGMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCBjLnJhZGl1cywgYy50aGV0YSwgYy55ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCByYWRpdXMsIHRoZXRhLCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcclxuXHJcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAxMiBdO1xyXG5cdFx0dGhpcy55ID0gZVsgMTMgXTtcclxuXHRcdHRoaXMueiA9IGVbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbU1hdHJpeFNjYWxlKCBtICkge1xyXG5cclxuXHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XHJcblx0XHRjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0Y29uc3Qgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcclxuXHJcblx0XHR0aGlzLnggPSBzeDtcclxuXHRcdHRoaXMueSA9IHN5O1xyXG5cdFx0dGhpcy56ID0gc3o7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbU1hdHJpeENvbHVtbiggbSwgaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tTWF0cml4M0NvbHVtbiggbSwgaW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tRXVsZXIoIGUgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gZS5feDtcclxuXHRcdHRoaXMueSA9IGUuX3k7XHJcblx0XHR0aGlzLnogPSBlLl96O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21Db2xvciggYyApIHtcclxuXHJcblx0XHR0aGlzLnggPSBjLnI7XHJcblx0XHR0aGlzLnkgPSBjLmc7XHJcblx0XHR0aGlzLnogPSBjLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXF1YWxzKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xyXG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XHJcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyYW5kb20oKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcclxuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJhbmRvbURpcmVjdGlvbigpIHtcclxuXHJcblx0XHQvLyBEZXJpdmVkIGZyb20gaHR0cHM6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU3BoZXJlUG9pbnRQaWNraW5nLmh0bWxcclxuXHJcblx0XHRjb25zdCB1ID0gKCBNYXRoLnJhbmRvbSgpIC0gMC41ICkgKiAyO1xyXG5cdFx0Y29uc3QgdCA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuXHRcdGNvbnN0IGYgPSBNYXRoLnNxcnQoIDEgLSB1ICoqIDIgKTtcclxuXHJcblx0XHR0aGlzLnggPSBmICogTWF0aC5jb3MoIHQgKTtcclxuXHRcdHRoaXMueSA9IGYgKiBNYXRoLnNpbiggdCApO1xyXG5cdFx0dGhpcy56ID0gdTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcclxuXHJcblx0XHR5aWVsZCB0aGlzLng7XHJcblx0XHR5aWVsZCB0aGlzLnk7XHJcblx0XHR5aWVsZCB0aGlzLno7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuZXhwb3J0IHsgVmVjdG9yMyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuXHJcbmNsYXNzIEJveDMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWluID0gbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKSwgbWF4ID0gbmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKSApIHtcclxuXHJcblx0XHR0aGlzLmlzQm94MyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5taW4gPSBtaW47XHJcblx0XHR0aGlzLm1heCA9IG1heDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbUFycmF5KCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yLmZyb21BcnJheSggYXJyYXksIGkgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcclxuXHJcblx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5leHBhbmRCeU9iamVjdCggb2JqZWN0LCBwcmVjaXNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZUVtcHR5KCkge1xyXG5cclxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICsgSW5maW5pdHk7XHJcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGlzRW1wdHkoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2VudGVyKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTaXplKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGV4cGFuZEJ5UG9pbnQoIHBvaW50ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcclxuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRleHBhbmRCeVZlY3RvciggdmVjdG9yICkge1xyXG5cclxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGV4cGFuZEJ5U2NhbGFyKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xyXG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRleHBhbmRCeU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xyXG5cclxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuYm91bmRpbmdCb3ggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfYm94LmNvcHkoIG9iamVjdC5ib3VuZGluZ0JveCApO1xyXG5cdFx0XHRfYm94LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR0aGlzLnVuaW9uKCBfYm94ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHByZWNpc2UgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICkuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2JveC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xyXG5cdFx0XHRcdFx0X2JveC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudW5pb24oIF9ib3ggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5leHBhbmRCeU9iamVjdCggY2hpbGRyZW5bIGkgXSwgcHJlY2lzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdFx0cG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHxcclxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udGFpbnNCb3goIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcclxuXHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcclxuXHRcdFx0dGhpcy5taW4ueiA8PSBib3gubWluLnogJiYgYm94Lm1heC56IDw9IHRoaXMubWF4Lno7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UGFyYW1ldGVyKCBwb2ludCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc2V0KFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcclxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVyc2VjdHNCb3goIGJveCApIHtcclxuXHJcblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHRcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdFx0Ym94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XHJcblx0XHRcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cclxuXHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgX3ZlY3RvciApO1xyXG5cclxuXHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxyXG5cdFx0cmV0dXJuIF92ZWN0b3IuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXHJcblx0XHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cclxuXHJcblx0XHRsZXQgbWluLCBtYXg7XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1heC54O1xyXG5cdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xyXG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXHJcblx0XHR0aGlzLmdldENlbnRlciggX2NlbnRlciApO1xyXG5cdFx0X2V4dGVudHMuc3ViVmVjdG9ycyggdGhpcy5tYXgsIF9jZW50ZXIgKTtcclxuXHJcblx0XHQvLyB0cmFuc2xhdGUgdHJpYW5nbGUgdG8gYWFiYiBvcmlnaW5cclxuXHRcdF92MC5zdWJWZWN0b3JzKCB0cmlhbmdsZS5hLCBfY2VudGVyICk7XHJcblx0XHRfdjEuc3ViVmVjdG9ycyggdHJpYW5nbGUuYiwgX2NlbnRlciApO1xyXG5cdFx0X3YyLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmMsIF9jZW50ZXIgKTtcclxuXHJcblx0XHQvLyBjb21wdXRlIGVkZ2UgdmVjdG9ycyBmb3IgdHJpYW5nbGVcclxuXHRcdF9mMC5zdWJWZWN0b3JzKCBfdjEsIF92MCApO1xyXG5cdFx0X2YxLnN1YlZlY3RvcnMoIF92MiwgX3YxICk7XHJcblx0XHRfZjIuc3ViVmVjdG9ycyggX3YwLCBfdjIgKTtcclxuXHJcblx0XHQvLyB0ZXN0IGFnYWluc3QgYXhlcyB0aGF0IGFyZSBnaXZlbiBieSBjcm9zcyBwcm9kdWN0IGNvbWJpbmF0aW9ucyBvZiB0aGUgZWRnZXMgb2YgdGhlIHRyaWFuZ2xlIGFuZCB0aGUgZWRnZXMgb2YgdGhlIGFhYmJcclxuXHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXHJcblx0XHQvLyBheGlzX2lqID0gdV9pIHggZl9qICh1MCwgdTEsIHUyID0gZmFjZSBub3JtYWxzIG9mIGFhYmIgPSB4LHkseiBheGVzIHZlY3RvcnMgc2luY2UgYWFiYiBpcyBheGlzIGFsaWduZWQpXHJcblx0XHRsZXQgYXhlcyA9IFtcclxuXHRcdFx0MCwgLSBfZjAueiwgX2YwLnksIDAsIC0gX2YxLnosIF9mMS55LCAwLCAtIF9mMi56LCBfZjIueSxcclxuXHRcdFx0X2YwLnosIDAsIC0gX2YwLngsIF9mMS56LCAwLCAtIF9mMS54LCBfZjIueiwgMCwgLSBfZjIueCxcclxuXHRcdFx0LSBfZjAueSwgX2YwLngsIDAsIC0gX2YxLnksIF9mMS54LCAwLCAtIF9mMi55LCBfZjIueCwgMFxyXG5cdFx0XTtcclxuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB0ZXN0IDMgZmFjZSBub3JtYWxzIGZyb20gdGhlIGFhYmJcclxuXHRcdGF4ZXMgPSBbIDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEgXTtcclxuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxyXG5cdFx0Ly8gdXNlIGFscmVhZHkgZXhpc3RpbmcgdHJpYW5nbGUgZWRnZSB2ZWN0b3JzIGhlcmVcclxuXHRcdF90cmlhbmdsZU5vcm1hbC5jcm9zc1ZlY3RvcnMoIF9mMCwgX2YxICk7XHJcblx0XHRheGVzID0gWyBfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56IF07XHJcblxyXG5cdFx0cmV0dXJuIHNhdEZvckF4ZXMoIGF4ZXMsIF92MCwgX3YxLCBfdjIsIF9leHRlbnRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2xhbXBQb2ludCggcG9pbnQsIF92ZWN0b3IgKS5kaXN0YW5jZVRvKCBwb2ludCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEJvdW5kaW5nU3BoZXJlKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcclxuXHJcblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoIHRhcmdldC5jZW50ZXIgKTtcclxuXHJcblx0XHRcdHRhcmdldC5yYWRpdXMgPSB0aGlzLmdldFNpemUoIF92ZWN0b3IgKS5sZW5ndGgoKSAqIDAuNTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3QoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuXHRcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cclxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHVuaW9uKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcclxuXHJcblx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cclxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xyXG5cdFx0X3BvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxyXG5cdFx0X3BvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxyXG5cdFx0X3BvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxyXG5cdFx0X3BvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxyXG5cdFx0X3BvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxyXG5cdFx0X3BvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxyXG5cdFx0X3BvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxyXG5cdFx0X3BvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMVxyXG5cclxuXHRcdHRoaXMuc2V0RnJvbVBvaW50cyggX3BvaW50cyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGVxdWFscyggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY29uc3QgX3BvaW50cyA9IFtcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpXHJcbl07XHJcblxyXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcclxuXHJcbi8vIHRyaWFuZ2xlIGNlbnRlcmVkIHZlcnRpY2VzXHJcblxyXG5jb25zdCBfdjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuLy8gdHJpYW5nbGUgZWRnZSB2ZWN0b3JzXHJcblxyXG5jb25zdCBfZjAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9mMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX2YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX2NlbnRlciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX2V4dGVudHMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF90cmlhbmdsZU5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3Rlc3RBeGlzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuZnVuY3Rpb24gc2F0Rm9yQXhlcyggYXhlcywgdjAsIHYxLCB2MiwgZXh0ZW50cyApIHtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMyApIHtcclxuXHJcblx0XHRfdGVzdEF4aXMuZnJvbUFycmF5KCBheGVzLCBpICk7XHJcblx0XHQvLyBwcm9qZWN0IHRoZSBhYWJiIG9udG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xyXG5cdFx0Y29uc3QgciA9IGV4dGVudHMueCAqIE1hdGguYWJzKCBfdGVzdEF4aXMueCApICsgZXh0ZW50cy55ICogTWF0aC5hYnMoIF90ZXN0QXhpcy55ICkgKyBleHRlbnRzLnogKiBNYXRoLmFicyggX3Rlc3RBeGlzLnogKTtcclxuXHRcdC8vIHByb2plY3QgYWxsIDMgdmVydGljZXMgb2YgdGhlIHRyaWFuZ2xlIG9udG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xyXG5cdFx0Y29uc3QgcDAgPSB2MC5kb3QoIF90ZXN0QXhpcyApO1xyXG5cdFx0Y29uc3QgcDEgPSB2MS5kb3QoIF90ZXN0QXhpcyApO1xyXG5cdFx0Y29uc3QgcDIgPSB2Mi5kb3QoIF90ZXN0QXhpcyApO1xyXG5cdFx0Ly8gYWN0dWFsIHRlc3QsIGJhc2ljYWxseSBzZWUgaWYgZWl0aGVyIG9mIHRoZSBtb3N0IGV4dHJlbWUgb2YgdGhlIHRyaWFuZ2xlIHBvaW50cyBpbnRlcnNlY3RzIHJcclxuXHRcdGlmICggTWF0aC5tYXgoIC0gTWF0aC5tYXgoIHAwLCBwMSwgcDIgKSwgTWF0aC5taW4oIHAwLCBwMSwgcDIgKSApID4gciApIHtcclxuXHJcblx0XHRcdC8vIHBvaW50cyBvZiB0aGUgcHJvamVjdGVkIHRyaWFuZ2xlIGFyZSBvdXRzaWRlIHRoZSBwcm9qZWN0ZWQgaGFsZi1sZW5ndGggb2YgdGhlIGFhYmJcclxuXHRcdFx0Ly8gdGhlIGF4aXMgaXMgc2VwYXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEJveDMgfTtcclxuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4vQm94My5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcclxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfdjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jbGFzcyBTcGhlcmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLSAxICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XHJcblxyXG5cdFx0aWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9ib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGlzRW1wdHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yYWRpdXMgPCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZUVtcHR5KCkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLnNldCggMCwgMCwgMCApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSAtIDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcclxuXHJcblx0XHRjb25zdCByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsYW1wUG9pbnQoIHBvaW50LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdHRhcmdldC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0dGFyZ2V0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0dGFyZ2V0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRCb3VuZGluZ0JveCggdGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB7XHJcblxyXG5cdFx0XHQvLyBFbXB0eSBzcGhlcmUgcHJvZHVjZXMgZW1wdHkgYm91bmRpbmcgYm94XHJcblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XHJcblx0XHR0YXJnZXQuZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXhwYW5kQnlQb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcclxuXHJcblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IDA7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3YxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLmNlbnRlciApO1xyXG5cclxuXHRcdGNvbnN0IGxlbmd0aFNxID0gX3YxLmxlbmd0aFNxKCk7XHJcblxyXG5cdFx0aWYgKCBsZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBtaW5pbWFsIHNwaGVyZVxyXG5cclxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KCBsZW5ndGhTcSApO1xyXG5cclxuXHRcdFx0Y29uc3QgZGVsdGEgPSAoIGxlbmd0aCAtIHRoaXMucmFkaXVzICkgKiAwLjU7XHJcblxyXG5cdFx0XHR0aGlzLmNlbnRlci5hZGRTY2FsZWRWZWN0b3IoIF92MSwgZGVsdGEgLyBsZW5ndGggKTtcclxuXHJcblx0XHRcdHRoaXMucmFkaXVzICs9IGRlbHRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR1bmlvbiggc3BoZXJlICkge1xyXG5cclxuXHRcdGlmICggc3BoZXJlLmlzRW1wdHkoKSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb3B5KCBzcGhlcmUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuY2VudGVyLmVxdWFscyggc3BoZXJlLmNlbnRlciApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0IHRoaXMucmFkaXVzID0gTWF0aC5tYXgoIHRoaXMucmFkaXVzLCBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF92Mi5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xyXG5cclxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdjEuY29weSggc3BoZXJlLmNlbnRlciApLmFkZCggX3YyICkgKTtcclxuXHJcblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3YxLmNvcHkoIHNwaGVyZS5jZW50ZXIgKS5zdWIoIF92MiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGVxdWFscyggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTcGhlcmUgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcblxyXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfc2VnQ2VudGVyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfc2VnRGlyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfZGlmZiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNvbnN0IF9lZGdlMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX2VkZ2UyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfbm9ybWFsID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY2xhc3MgUmF5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG9yaWdpbiA9IG5ldyBWZWN0b3IzKCksIGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSApIHtcclxuXHJcblx0XHR0aGlzLm9yaWdpbiA9IG9yaWdpbjtcclxuXHRcdHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCByYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGF0KCB0LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLm9yaWdpbiApLmFkZFNjYWxlZFZlY3RvciggdGhpcy5kaXJlY3Rpb24sIHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRsb29rQXQoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggdiApLnN1YiggdGhpcy5vcmlnaW4gKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyZWNhc3QoIHQgKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgX3ZlY3RvciApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHR0YXJnZXQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgZGlyZWN0aW9uRGlzdGFuY2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGlyZWN0aW9uRGlzdGFuY2UgPSBfdmVjdG9yLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxyXG5cclxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfdmVjdG9yLmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgZGlyZWN0aW9uRGlzdGFuY2UgKTtcclxuXHJcblx0XHRyZXR1cm4gX3ZlY3Rvci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXN0YW5jZVNxVG9TZWdtZW50KCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcblx0XHQvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wbWpvbmlhay9HZW9tZXRyaWNUb29scy9ibG9iL21hc3Rlci9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZURpc3RSYXlTZWdtZW50LmhcclxuXHRcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XHJcblx0XHQvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxyXG5cdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcclxuXHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxyXG5cdFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxyXG5cclxuXHRcdF9zZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0X3NlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcclxuXHRcdF9kaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBfc2VnQ2VudGVyICk7XHJcblxyXG5cdFx0Y29uc3Qgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcclxuXHRcdGNvbnN0IGEwMSA9IC0gdGhpcy5kaXJlY3Rpb24uZG90KCBfc2VnRGlyICk7XHJcblx0XHRjb25zdCBiMCA9IF9kaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdGNvbnN0IGIxID0gLSBfZGlmZi5kb3QoIF9zZWdEaXIgKTtcclxuXHRcdGNvbnN0IGMgPSBfZGlmZi5sZW5ndGhTcSgpO1xyXG5cdFx0Y29uc3QgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcclxuXHRcdGxldCBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcclxuXHJcblx0XHRpZiAoIGRldCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRzMCA9IGEwMSAqIGIxIC0gYjA7XHJcblx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcclxuXHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xyXG5cclxuXHRcdFx0aWYgKCBzMCA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHMxID49IC0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDBcclxuXHRcdFx0XHRcdFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgaW52RGV0ID0gMSAvIGRldDtcclxuXHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xyXG5cdFx0XHRcdFx0XHRzMSAqPSBpbnZEZXQ7XHJcblx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAxXHJcblxyXG5cdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyByZWdpb24gNVxyXG5cclxuXHRcdFx0XHRcdHMxID0gLSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHMxIDw9IC0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHJlZ2lvbiA0XHJcblxyXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHJlZ2lvbiAzXHJcblxyXG5cdFx0XHRcdFx0czAgPSAwO1xyXG5cdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0c3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyByZWdpb24gMlxyXG5cclxuXHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XHJcblx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxyXG5cclxuXHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xyXG5cdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XHJcblx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xyXG5cclxuXHRcdFx0b3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMub3JpZ2luICkuYWRkU2NhbGVkVmVjdG9yKCB0aGlzLmRpcmVjdGlvbiwgczAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xyXG5cclxuXHRcdFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBfc2VnQ2VudGVyICkuYWRkU2NhbGVkVmVjdG9yKCBfc2VnRGlyLCBzMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3FyRGlzdDtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RTcGhlcmUoIHNwaGVyZSwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdF92ZWN0b3Iuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcclxuXHRcdGNvbnN0IHRjYSA9IF92ZWN0b3IuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0Y29uc3QgZDIgPSBfdmVjdG9yLmRvdCggX3ZlY3RvciApIC0gdGNhICogdGNhO1xyXG5cdFx0Y29uc3QgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Y29uc3QgdGhjID0gTWF0aC5zcXJ0KCByYWRpdXMyIC0gZDIgKTtcclxuXHJcblx0XHQvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxyXG5cdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7XHJcblxyXG5cdFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxyXG5cdFx0Y29uc3QgdDEgPSB0Y2EgKyB0aGM7XHJcblxyXG5cdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDEgaXMgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuXHRcdGlmICggdDEgPCAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XHJcblx0XHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXHJcblx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXHJcblx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcclxuXHRcdHJldHVybiB0aGlzLmF0KCB0MCwgdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcblx0XHRcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcclxuXHJcblx0XHRyZXR1cm4gdCA+PSAwID8gdCA6IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0UGxhbmUoIHBsYW5lLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdGlmICggdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdCwgdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XHJcblxyXG5cdFx0Y29uc3QgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByYXkgb3JpZ2luIGlzIGJlaGluZCB0aGUgcGxhbmUgKGFuZCBpcyBwb2ludGluZyBiZWhpbmQgaXQpXHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVyc2VjdEJveCggYm94LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0bGV0IHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xyXG5cclxuXHRcdGNvbnN0IGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcclxuXHRcdFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxyXG5cdFx0XHRpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0Y29uc3Qgb3JpZ2luID0gdGhpcy5vcmlnaW47XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cdFx0XHR0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XHJcblxyXG5cdFx0XHR0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cdFx0XHR0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgaXNOYU4oIHRtaW4gKSApIHRtaW4gPSB0eW1pbjtcclxuXHJcblx0XHRpZiAoIHR5bWF4IDwgdG1heCB8fCBpc05hTiggdG1heCApICkgdG1heCA9IHR5bWF4O1xyXG5cclxuXHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xyXG5cclxuXHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cdFx0XHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHR6bWluID0gKCBib3gubWF4LnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHRcdFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XHJcblxyXG5cdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcclxuXHJcblx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXHJcblxyXG5cdFx0aWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCBfdmVjdG9yICkgIT09IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0VHJpYW5nbGUoIGEsIGIsIGMsIGJhY2tmYWNlQ3VsbGluZywgdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxyXG5cclxuXHRcdC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Btam9uaWFrL0dlb21ldHJpY1Rvb2xzL2Jsb2IvbWFzdGVyL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlSW50clJheTNUcmlhbmdsZTMuaFxyXG5cclxuXHRcdF9lZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcblx0XHRfZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xyXG5cdFx0X25vcm1hbC5jcm9zc1ZlY3RvcnMoIF9lZGdlMSwgX2VkZ2UyICk7XHJcblxyXG5cdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXHJcblx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XHJcblx0XHQvLyAgIHxEb3QoRCxOKXwqYjEgPSBzaWduKERvdChELE4pKSpEb3QoRCxDcm9zcyhRLEUyKSlcclxuXHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxyXG5cdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcclxuXHRcdGxldCBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoIF9ub3JtYWwgKTtcclxuXHRcdGxldCBzaWduO1xyXG5cclxuXHRcdGlmICggRGROID4gMCApIHtcclxuXHJcblx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdHNpZ24gPSAxO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XHJcblxyXG5cdFx0XHRzaWduID0gLSAxO1xyXG5cdFx0XHREZE4gPSAtIERkTjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9kaWZmLnN1YlZlY3RvcnMoIHRoaXMub3JpZ2luLCBhICk7XHJcblx0XHRjb25zdCBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBfZWRnZTIuY3Jvc3NWZWN0b3JzKCBfZGlmZiwgX2VkZ2UyICkgKTtcclxuXHJcblx0XHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxyXG5cdFx0aWYgKCBEZFF4RTIgPCAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIF9lZGdlMS5jcm9zcyggX2RpZmYgKSApO1xyXG5cclxuXHRcdC8vIGIyIDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRpZiAoIERkRTF4USA8IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXHJcblx0XHRjb25zdCBRZE4gPSAtIHNpZ24gKiBfZGlmZi5kb3QoIF9ub3JtYWwgKTtcclxuXHJcblx0XHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXHJcblx0XHRpZiAoIFFkTiA8IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCB0YXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeDQgKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeDQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRlcXVhbHMoIHJheSApIHtcclxuXHJcblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBSYXkgfTtcclxuIiwiaW1wb3J0IHsgV2ViR0xDb29yZGluYXRlU3lzdGVtLCBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcblxyXG5jbGFzcyBNYXRyaXg0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHRNYXRyaXg0LnByb3RvdHlwZS5pc01hdHJpeDQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXHJcblxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0XTtcclxuXHJcblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XHJcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcclxuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcclxuXHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRpZGVudGl0eSgpIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDEsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIG0gKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xyXG5cdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XHJcblx0XHR0ZVsgOCBdID0gbWVbIDggXTsgdGVbIDkgXSA9IG1lWyA5IF07IHRlWyAxMCBdID0gbWVbIDEwIF07IHRlWyAxMSBdID0gbWVbIDExIF07XHJcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlQb3NpdGlvbiggbSApIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xyXG5cdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcclxuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbU1hdHJpeDMoIG0gKSB7XHJcblxyXG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSwgMCxcclxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSwgMCxcclxuXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXh0cmFjdEJhc2lzKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xyXG5cclxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcclxuXHRcdHlBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDEgKTtcclxuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtYWtlQmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXHJcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXHJcblx0XHRcdHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uKCBtICkge1xyXG5cclxuXHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRjb25zdCBzY2FsZVggPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcclxuXHRcdGNvbnN0IHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0Y29uc3Qgc2NhbGVaID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XHJcblx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcclxuXHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblxyXG5cdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcclxuXHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xyXG5cdFx0dGVbIDcgXSA9IDA7XHJcblxyXG5cdFx0dGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XHJcblx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcclxuXHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XHJcblx0XHR0ZVsgMTEgXSA9IDA7XHJcblxyXG5cdFx0dGVbIDEyIF0gPSAwO1xyXG5cdFx0dGVbIDEzIF0gPSAwO1xyXG5cdFx0dGVbIDE0IF0gPSAwO1xyXG5cdFx0dGVbIDE1IF0gPSAxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGNvbnN0IHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XHJcblx0XHRjb25zdCBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XHJcblx0XHRjb25zdCBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XHJcblxyXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XHJcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcclxuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xyXG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XHJcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBhICogZjtcclxuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xyXG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XHJcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcclxuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XHJcblx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcclxuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gLSBhICogZDtcclxuXHRcdFx0dGVbIDYgXSA9IGI7XHJcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xyXG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYyAqIGY7XHJcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcclxuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xyXG5cclxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcclxuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcclxuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGY7XHJcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcclxuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xyXG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdHRlWyA0IF0gPSAtIGY7XHJcblx0XHRcdHRlWyA4IF0gPSBkICogZTtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcclxuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XHJcblxyXG5cdFx0XHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XHJcblx0XHRcdHRlWyA2IF0gPSBiICogZTtcclxuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYm90dG9tIHJvd1xyXG5cdFx0dGVbIDMgXSA9IDA7XHJcblx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0dGVbIDEyIF0gPSAwO1xyXG5cdFx0dGVbIDEzIF0gPSAwO1xyXG5cdFx0dGVbIDE0IF0gPSAwO1xyXG5cdFx0dGVbIDE1IF0gPSAxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0aWYgKCBfei5sZW5ndGhTcSgpID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXHJcblxyXG5cdFx0XHRfei56ID0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3oubm9ybWFsaXplKCk7XHJcblx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xyXG5cclxuXHRcdGlmICggX3gubGVuZ3RoU3EoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggdXAueiApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRfei54ICs9IDAuMDAwMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF96LnogKz0gMC4wMDAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3oubm9ybWFsaXplKCk7XHJcblx0XHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF94Lm5vcm1hbGl6ZSgpO1xyXG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcclxuXHJcblx0XHR0ZVsgMCBdID0gX3gueDsgdGVbIDQgXSA9IF95Lng7IHRlWyA4IF0gPSBfei54O1xyXG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcclxuXHRcdHRlWyAyIF0gPSBfeC56OyB0ZVsgNiBdID0gX3kuejsgdGVbIDEwIF0gPSBfei56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG11bHRpcGx5KCBtICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRwcmVtdWx0aXBseSggbSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcclxuXHJcblx0XHRjb25zdCBhZSA9IGEuZWxlbWVudHM7XHJcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XHJcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcclxuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdGNvbnN0IGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcclxuXHJcblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcclxuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xyXG5cdFx0Y29uc3QgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xyXG5cclxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XHJcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xyXG5cdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcclxuXHRcdHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XHJcblx0XHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xyXG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcclxuXHRcdHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xyXG5cclxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XHJcblx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xyXG5cdFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XHJcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcclxuXHJcblx0XHR0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xyXG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcclxuXHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xyXG5cdFx0dGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bXVsdGlwbHlTY2FsYXIoIHMgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XHJcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xyXG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XHJcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRkZXRlcm1pbmFudCgpIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0Y29uc3QgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XHJcblx0XHRjb25zdCBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcclxuXHRcdGNvbnN0IG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcclxuXHRcdGNvbnN0IG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcclxuXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXHJcblxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0bjQxICogKFxyXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXHJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXHJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXHJcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXHJcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XHJcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XHJcblx0XHRcdCkgK1xyXG5cdFx0XHRuNDIgKiAoXHJcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcclxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcclxuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcclxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40MyAqIChcclxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxyXG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQ0ICogKFxyXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXHJcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXHJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXHJcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXHJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXHJcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXHJcblx0XHRcdClcclxuXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zcG9zZSgpIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRsZXQgdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcclxuXHJcblx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRQb3NpdGlvbiggeCwgeSwgeiApIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcclxuXHJcblx0XHRcdHRlWyAxMiBdID0geC54O1xyXG5cdFx0XHR0ZVsgMTMgXSA9IHgueTtcclxuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRlWyAxMiBdID0geDtcclxuXHRcdFx0dGVbIDEzIF0gPSB5O1xyXG5cdFx0XHR0ZVsgMTQgXSA9IHo7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGludmVydCgpIHtcclxuXHJcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcclxuXHJcblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sIG40MSA9IHRlWyAzIF0sXHJcblx0XHRcdG4xMiA9IHRlWyA0IF0sIG4yMiA9IHRlWyA1IF0sIG4zMiA9IHRlWyA2IF0sIG40MiA9IHRlWyA3IF0sXHJcblx0XHRcdG4xMyA9IHRlWyA4IF0sIG4yMyA9IHRlWyA5IF0sIG4zMyA9IHRlWyAxMCBdLCBuNDMgPSB0ZVsgMTEgXSxcclxuXHRcdFx0bjE0ID0gdGVbIDEyIF0sIG4yNCA9IHRlWyAxMyBdLCBuMzQgPSB0ZVsgMTQgXSwgbjQ0ID0gdGVbIDE1IF0sXHJcblxyXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXHJcblx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcclxuXHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxyXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XHJcblxyXG5cdFx0Y29uc3QgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xyXG5cclxuXHRcdGlmICggZGV0ID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcclxuXHJcblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xyXG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XHJcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XHJcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcclxuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xyXG5cclxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xyXG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNjYWxlKCB2ICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGNvbnN0IHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XHJcblxyXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcclxuXHRcdHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XHJcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcclxuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRjb25zdCBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuXHRcdGNvbnN0IHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xyXG5cdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdFx0MSwgMCwgMCwgeC54LFxyXG5cdFx0XHRcdDAsIDEsIDAsIHgueSxcclxuXHRcdFx0XHQwLCAwLCAxLCB4LnosXHJcblx0XHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRcdDEsIDAsIDAsIHgsXHJcblx0XHRcdFx0MCwgMSwgMCwgeSxcclxuXHRcdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1ha2VSb3RhdGlvblgoIHRoZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgYywgLSBzLCAwLFxyXG5cdFx0XHQwLCBzLCBjLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtYWtlUm90YXRpb25ZKCB0aGV0YSApIHtcclxuXHJcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHQgMCwgMSwgMCwgMCxcclxuXHRcdFx0LSBzLCAwLCBjLCAwLFxyXG5cdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZVJvdGF0aW9uWiggdGhldGEgKSB7XHJcblxyXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRjLCAtIHMsIDAsIDAsXHJcblx0XHRcdHMsIGMsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxyXG5cclxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdGNvbnN0IHQgPSAxIC0gYztcclxuXHRcdGNvbnN0IHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XHJcblx0XHRjb25zdCB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxyXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXHJcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZVNjYWxlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0eCwgMCwgMCwgMCxcclxuXHRcdFx0MCwgeSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgeiwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bWFrZVNoZWFyKCB4eSwgeHosIHl4LCB5eiwgengsIHp5ICkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgeXgsIHp4LCAwLFxyXG5cdFx0XHR4eSwgMSwgenksIDAsXHJcblx0XHRcdHh6LCB5eiwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRjb25zdCB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcclxuXHRcdGNvbnN0IHgyID0geCArIHgsXHR5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xyXG5cdFx0Y29uc3QgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6MjtcclxuXHRcdGNvbnN0IHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcblx0XHRjb25zdCB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xyXG5cclxuXHRcdGNvbnN0IHN4ID0gc2NhbGUueCwgc3kgPSBzY2FsZS55LCBzeiA9IHNjYWxlLno7XHJcblxyXG5cdFx0dGVbIDAgXSA9ICggMSAtICggeXkgKyB6eiApICkgKiBzeDtcclxuXHRcdHRlWyAxIF0gPSAoIHh5ICsgd3ogKSAqIHN4O1xyXG5cdFx0dGVbIDIgXSA9ICggeHogLSB3eSApICogc3g7XHJcblx0XHR0ZVsgMyBdID0gMDtcclxuXHJcblx0XHR0ZVsgNCBdID0gKCB4eSAtIHd6ICkgKiBzeTtcclxuXHRcdHRlWyA1IF0gPSAoIDEgLSAoIHh4ICsgenogKSApICogc3k7XHJcblx0XHR0ZVsgNiBdID0gKCB5eiArIHd4ICkgKiBzeTtcclxuXHRcdHRlWyA3IF0gPSAwO1xyXG5cclxuXHRcdHRlWyA4IF0gPSAoIHh6ICsgd3kgKSAqIHN6O1xyXG5cdFx0dGVbIDkgXSA9ICggeXogLSB3eCApICogc3o7XHJcblx0XHR0ZVsgMTAgXSA9ICggMSAtICggeHggKyB5eSApICkgKiBzejtcclxuXHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHR0ZVsgMTIgXSA9IHBvc2l0aW9uLng7XHJcblx0XHR0ZVsgMTMgXSA9IHBvc2l0aW9uLnk7XHJcblx0XHR0ZVsgMTQgXSA9IHBvc2l0aW9uLno7XHJcblx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdGxldCBzeCA9IF92MS5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdGNvbnN0IHN5ID0gX3YxLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xyXG5cdFx0Y29uc3Qgc3ogPSBfdjEuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xyXG5cclxuXHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXHJcblx0XHRjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XHJcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XHJcblxyXG5cdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xyXG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xyXG5cdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xyXG5cclxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XHJcblx0XHRfbTEuY29weSggdGhpcyApO1xyXG5cclxuXHRcdGNvbnN0IGludlNYID0gMSAvIHN4O1xyXG5cdFx0Y29uc3QgaW52U1kgPSAxIC8gc3k7XHJcblx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcclxuXHJcblx0XHRfbTEuZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuXHRcdF9tMS5lbGVtZW50c1sgMSBdICo9IGludlNYO1xyXG5cdFx0X20xLmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XHJcblxyXG5cdFx0X20xLmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcblx0XHRfbTEuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcclxuXHRcdF9tMS5lbGVtZW50c1sgNiBdICo9IGludlNZO1xyXG5cclxuXHRcdF9tMS5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG5cdFx0X20xLmVsZW1lbnRzWyA5IF0gKj0gaW52U1o7XHJcblx0XHRfbTEuZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XHJcblxyXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xyXG5cclxuXHRcdHNjYWxlLnggPSBzeDtcclxuXHRcdHNjYWxlLnkgPSBzeTtcclxuXHRcdHNjYWxlLnogPSBzejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHRjb25zdCB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdGNvbnN0IGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHJcblx0XHRsZXQgYywgZDtcclxuXHJcblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XHJcblx0XHRcdGQgPSAoIC0gMiAqIGZhciAqIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0XHRjID0gLSBmYXIgLyAoIGZhciAtIG5lYXIgKTtcclxuXHRcdFx0ZCA9ICggLSBmYXIgKiBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuTWF0cml4NC5tYWtlUGVyc3BlY3RpdmUoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhOyBcdHRlWyAxMiBdID0gMDtcclxuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjsgXHR0ZVsgMTMgXSA9IDA7XHJcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjOyBcdHRlWyAxNCBdID0gZDtcclxuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdGNvbnN0IGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cdFx0Y29uc3QgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdGNvbnN0IHggPSAoIHJpZ2h0ICsgbGVmdCApICogdztcclxuXHRcdGNvbnN0IHkgPSAoIHRvcCArIGJvdHRvbSApICogaDtcclxuXHJcblx0XHRsZXQgeiwgekludjtcclxuXHJcblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdHogPSAoIGZhciArIG5lYXIgKSAqIHA7XHJcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0XHR6ID0gbmVhciAqIHA7XHJcblx0XHRcdHpJbnYgPSAtIDEgKiBwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGVbIDAgXSA9IDIgKiB3O1x0dGVbIDQgXSA9IDA7XHRcdHRlWyA4IF0gPSAwOyBcdFx0dGVbIDEyIF0gPSAtIHg7XHJcblx0XHR0ZVsgMSBdID0gMDsgXHRcdHRlWyA1IF0gPSAyICogaDtcdHRlWyA5IF0gPSAwOyBcdFx0dGVbIDEzIF0gPSAtIHk7XHJcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcclxuXHRcdHRlWyAzIF0gPSAwOyBcdFx0dGVbIDcgXSA9IDA7XHRcdHRlWyAxMSBdID0gMDtcdFx0dGVbIDE1IF0gPSAxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGVxdWFscyggbWF0cml4ICkge1xyXG5cclxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcclxuXHJcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gPSB0ZVsgOSBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfemVybyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKTtcclxuY29uc3QgX29uZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcclxuY29uc3QgX3ggPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF95ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfeiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmV4cG9ydCB7IE1hdHJpeDQgfTtcclxuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vTWF0aFV0aWxzLmpzJztcclxuXHJcbmNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuY2xhc3MgRXVsZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIgPSBFdWxlci5ERUZBVUxUX09SREVSICkge1xyXG5cclxuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5feCA9IHg7XHJcblx0XHR0aGlzLl95ID0geTtcclxuXHRcdHRoaXMuX3ogPSB6O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgeCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgeCggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB5KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl95O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCB5KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHooKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHooIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgb3JkZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIHgsIHksIHosIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHg7XHJcblx0XHR0aGlzLl95ID0geTtcclxuXHRcdHRoaXMuX3ogPSB6O1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcclxuXHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIGV1bGVyICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcclxuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcclxuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcclxuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xyXG5cclxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUgKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHM7XHJcblx0XHRjb25zdCBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xyXG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcclxuXHRcdGNvbnN0IG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xyXG5cclxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xyXG5cclxuXHRcdFx0Y2FzZSAnWFlaJzpcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1lYWic6XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdaWFknOlxyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnWllYJzpcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcclxuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1laWCc6XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XHJcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdYWlknOlxyXG5cclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tUXVhdGVybmlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHRfbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVZlY3RvcjMoIHYsIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlb3JkZXIoIG5ld09yZGVyICkge1xyXG5cclxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cclxuXHJcblx0XHRfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZXF1YWxzKCBldWxlciApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUFycmF5KCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcclxuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xyXG5cdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XHJcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcclxuXHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH1cclxuXHJcblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxyXG5cclxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcclxuXHJcblx0XHR5aWVsZCB0aGlzLl94O1xyXG5cdFx0eWllbGQgdGhpcy5feTtcclxuXHRcdHlpZWxkIHRoaXMuX3o7XHJcblx0XHR5aWVsZCB0aGlzLl9vcmRlcjtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuRXVsZXIuREVGQVVMVF9PUkRFUiA9ICdYWVonO1xyXG5cclxuZXhwb3J0IHsgRXVsZXIgfTtcclxuIiwiY2xhc3MgTGF5ZXJzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBjaGFubmVsIHwgMCApID4+PiAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGVuYWJsZSggY2hhbm5lbCApIHtcclxuXHJcblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcclxuXHJcblx0fVxyXG5cclxuXHRlbmFibGVBbGwoKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrID0gMHhmZmZmZmZmZiB8IDA7XHJcblxyXG5cdH1cclxuXHJcblx0dG9nZ2xlKCBjaGFubmVsICkge1xyXG5cclxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc2FibGUoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzYWJsZUFsbCgpIHtcclxuXHJcblx0XHR0aGlzLm1hc2sgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdHRlc3QoIGxheWVycyApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGlzRW5hYmxlZCggY2hhbm5lbCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiAoIDEgPDwgY2hhbm5lbCB8IDAgKSApICE9PSAwO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgTGF5ZXJzIH07XHJcbiIsImltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9tYXRoL1F1YXRlcm5pb24uanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcclxuaW1wb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9MYXllcnMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuXHJcbmxldCBfb2JqZWN0M0RJZCA9IDA7XHJcblxyXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9xMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcclxuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfdGFyZ2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfc2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuY29uc3QgX3hBeGlzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xyXG5jb25zdCBfeUF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XHJcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcbmNvbnN0IF9hZGRlZEV2ZW50ID0geyB0eXBlOiAnYWRkZWQnIH07XHJcbmNvbnN0IF9yZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdyZW1vdmVkJyB9O1xyXG5cclxuY2xhc3MgT2JqZWN0M0QgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNPYmplY3QzRCA9IHRydWU7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfb2JqZWN0M0RJZCArKyB9ICk7XHJcblxyXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cdFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcclxuXHJcblx0XHR0aGlzLnBhcmVudCA9IG51bGw7XHJcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XHJcblxyXG5cdFx0dGhpcy51cCA9IE9iamVjdDNELkRFRkFVTFRfVVAuY2xvbmUoKTtcclxuXHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xyXG5cdFx0Y29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblx0XHRjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcclxuXHJcblx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xyXG5cclxuXHRcdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cm90YXRpb24uX29uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XHJcblx0XHRxdWF0ZXJuaW9uLl9vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuXHRcdFx0cG9zaXRpb246IHtcclxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0XHR2YWx1ZTogcG9zaXRpb25cclxuXHRcdFx0fSxcclxuXHRcdFx0cm90YXRpb246IHtcclxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cclxuXHRcdFx0fSxcclxuXHRcdFx0cXVhdGVybmlvbjoge1xyXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRcdHZhbHVlOiBxdWF0ZXJuaW9uXHJcblx0XHRcdH0sXHJcblx0XHRcdHNjYWxlOiB7XHJcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdFx0dmFsdWU6IHNjYWxlXHJcblx0XHRcdH0sXHJcblx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4NCgpXHJcblx0XHRcdH0sXHJcblx0XHRcdG5vcm1hbE1hdHJpeDoge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgTWF0cml4MygpXHJcblx0XHRcdH1cclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBPYmplY3QzRC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURTtcclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID0gT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfV09STERfQVVUT19VUERBVEU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXHJcblxyXG5cdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XHJcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xyXG5cclxuXHRcdHRoaXMuYW5pbWF0aW9ucyA9IFtdO1xyXG5cclxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRvbkJlZm9yZVJlbmRlciggLyogcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKi8gKSB7fVxyXG5cclxuXHRvbkFmdGVyUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqLyApIHt9XHJcblxyXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbU1hdHJpeCggbSApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyb3RhdGVPbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0X3ExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIHdvcmxkIHNwYWNlXHJcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cdFx0Ly8gbWV0aG9kIGFzc3VtZXMgbm8gcm90YXRlZCBwYXJlbnRcclxuXHJcblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIF9xMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggX3hBeGlzLCBhbmdsZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVkoIGFuZ2xlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggX3lBeGlzLCBhbmdsZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggX3pBeGlzLCBhbmdsZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxyXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRfdjEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XHJcblxyXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIF92MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3hBeGlzLCBkaXN0YW5jZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3lBeGlzLCBkaXN0YW5jZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZVooIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggX3pBeGlzLCBkaXN0YW5jZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGxvY2FsVG9Xb3JsZCggdmVjdG9yICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9va0F0KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXHJcblxyXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcclxuXHJcblx0XHRcdF90YXJnZXQuY29weSggeCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfdGFyZ2V0LnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdF9wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuaXNDYW1lcmEgfHwgdGhpcy5pc0xpZ2h0ICkge1xyXG5cclxuXHRcdFx0X20xLmxvb2tBdCggX3Bvc2l0aW9uLCBfdGFyZ2V0LCB0aGlzLnVwICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9tMS5sb29rQXQoIF90YXJnZXQsIF9wb3NpdGlvbiwgdGhpcy51cCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcclxuXHJcblx0XHRpZiAoIHBhcmVudCApIHtcclxuXHJcblx0XHRcdF9tMS5leHRyYWN0Um90YXRpb24oIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRfcTEuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBfcTEuaW52ZXJ0KCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0YWRkKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhblxcJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuJywgb2JqZWN0ICk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC4nLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cmVtb3ZlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX3JlbW92ZWRFdmVudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRyZW1vdmVGcm9tUGFyZW50KCkge1xyXG5cclxuXHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cGFyZW50LnJlbW92ZSggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjbGVhcigpIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IG9iamVjdCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIF9yZW1vdmVkRXZlbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRhdHRhY2goIG9iamVjdCApIHtcclxuXHJcblx0XHQvLyBhZGRzIG9iamVjdCBhcyBhIGNoaWxkIG9mIHRoaXMsIHdoaWxlIG1haW50YWluaW5nIHRoZSBvYmplY3QncyB3b3JsZCB0cmFuc2Zvcm1cclxuXHJcblx0XHQvLyBOb3RlOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHNjZW5lIGdyYXBocyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgbm9kZXMocylcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdF9tMS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdF9tMS5tdWx0aXBseSggb2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvYmplY3QuYXBwbHlNYXRyaXg0KCBfbTEgKTtcclxuXHJcblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XHJcblxyXG5cdFx0b2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE9iamVjdEJ5SWQoIGlkICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0T2JqZWN0QnlOYW1lKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xyXG5cdFx0XHRjb25zdCBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XHJcblxyXG5cdFx0bGV0IHJlc3VsdCA9IFtdO1xyXG5cclxuXHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJlc3VsdC5wdXNoKCB0aGlzICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2hpbGRSZXN1bHQgPSB0aGlzLmNoaWxkcmVuWyBpIF0uZ2V0T2JqZWN0c0J5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkUmVzdWx0Lmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIGNoaWxkUmVzdWx0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0V29ybGRQb3NpdGlvbiggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRXb3JsZFF1YXRlcm5pb24oIHRhcmdldCApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIHRhcmdldCwgX3NjYWxlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRXb3JsZFNjYWxlKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRXb3JsZERpcmVjdGlvbiggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIGVbIDggXSwgZVsgOSBdLCBlWyAxMCBdICkubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHJcblx0cmF5Y2FzdCggLyogcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICovICkge31cclxuXHJcblx0dHJhdmVyc2UoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XHJcblxyXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuXHJcblx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNhbGxiYWNrKCBwYXJlbnQgKTtcclxuXHJcblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTWF0cml4KCkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvcmNlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXHJcblxyXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjaGlsZCA9IGNoaWxkcmVuWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVdvcmxkTWF0cml4KCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApIHtcclxuXHJcblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZVBhcmVudHMgPT09IHRydWUgJiYgcGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRwYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUNoaWxkcmVuID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRjaGlsZC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oIG1ldGEgKSB7XHJcblxyXG5cdFx0Ly8gbWV0YSBpcyBhIHN0cmluZyB3aGVuIGNhbGxlZCBmcm9tIEpTT04uc3RyaW5naWZ5XHJcblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcclxuXHJcblx0XHRjb25zdCBvdXRwdXQgPSB7fTtcclxuXHJcblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxyXG5cdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcclxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXHJcblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcclxuXHRcdFx0bWV0YSA9IHtcclxuXHRcdFx0XHRnZW9tZXRyaWVzOiB7fSxcclxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxyXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcclxuXHRcdFx0XHRpbWFnZXM6IHt9LFxyXG5cdFx0XHRcdHNoYXBlczoge30sXHJcblx0XHRcdFx0c2tlbGV0b25zOiB7fSxcclxuXHRcdFx0XHRhbmltYXRpb25zOiB7fSxcclxuXHRcdFx0XHRub2Rlczoge31cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXHJcblx0XHRcdFx0dHlwZTogJ09iamVjdCcsXHJcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXHJcblxyXG5cdFx0Y29uc3Qgb2JqZWN0ID0ge307XHJcblxyXG5cdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XHJcblx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcclxuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xyXG5cdFx0aWYgKCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09IHRydWUgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XHJcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0aWYgKCB0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcclxuXHRcdGlmICggdGhpcy5yZW5kZXJPcmRlciAhPT0gMCApIG9iamVjdC5yZW5kZXJPcmRlciA9IHRoaXMucmVuZGVyT3JkZXI7XHJcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XHJcblxyXG5cdFx0b2JqZWN0LmxheWVycyA9IHRoaXMubGF5ZXJzLm1hc2s7XHJcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xyXG5cdFx0b2JqZWN0LnVwID0gdGhpcy51cC50b0FycmF5KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBvYmplY3Qgc3BlY2lmaWMgcHJvcGVydGllc1xyXG5cclxuXHRcdGlmICggdGhpcy5pc0luc3RhbmNlZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRvYmplY3QudHlwZSA9ICdJbnN0YW5jZWRNZXNoJztcclxuXHRcdFx0b2JqZWN0LmNvdW50ID0gdGhpcy5jb3VudDtcclxuXHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKTtcclxuXHRcdFx0aWYgKCB0aGlzLmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSBvYmplY3QuaW5zdGFuY2VDb2xvciA9IHRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID0gZWxlbWVudC50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBlbGVtZW50LnV1aWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5pc1NjZW5lICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJhY2tncm91bmQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuYmFja2dyb3VuZC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlICYmIHRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy5pc01lc2ggfHwgdGhpcy5pc0xpbmUgfHwgdGhpcy5pc1BvaW50cyApIHtcclxuXHJcblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgJiYgcGFyYW1ldGVycy5zaGFwZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XHJcblxyXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0c2VyaWFsaXplKCBtZXRhLnNoYXBlcywgc2hhcGUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2VyaWFsaXplKCBtZXRhLnNoYXBlcywgc2hhcGVzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xyXG5cdFx0XHRvYmplY3QuYmluZE1hdHJpeCA9IHRoaXMuYmluZE1hdHJpeC50b0FycmF5KCk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2VyaWFsaXplKCBtZXRhLnNrZWxldG9ucywgdGhpcy5za2VsZXRvbiApO1xyXG5cclxuXHRcdFx0XHRvYmplY3Quc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLnV1aWQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHV1aWRzID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gc2VyaWFsaXplKCBtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9ucy5wdXNoKCBzZXJpYWxpemUoIG1ldGEuYW5pbWF0aW9ucywgYW5pbWF0aW9uICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XHJcblx0XHRcdGNvbnN0IG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XHJcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cdFx0XHRjb25zdCBzaGFwZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNoYXBlcyApO1xyXG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNrZWxldG9ucyApO1xyXG5cdFx0XHRjb25zdCBhbmltYXRpb25zID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5hbmltYXRpb25zICk7XHJcblx0XHRcdGNvbnN0IG5vZGVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5ub2RlcyApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XHJcblx0XHRcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xyXG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcclxuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XHJcblx0XHRcdGlmICggc2hhcGVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuc2hhcGVzID0gc2hhcGVzO1xyXG5cdFx0XHRpZiAoIHNrZWxldG9ucy5sZW5ndGggPiAwICkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcclxuXHRcdFx0aWYgKCBhbmltYXRpb25zLmxlbmd0aCA+IDAgKSBvdXRwdXQuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XHJcblx0XHRcdGlmICggbm9kZXMubGVuZ3RoID4gMCApIG91dHB1dC5ub2RlcyA9IG5vZGVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcclxuXHRcdC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cclxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcclxuXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XHJcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcclxuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHNvdXJjZS5yb3RhdGlvbi5vcmRlcjtcclxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xyXG5cdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGRBdXRvVXBkYXRlO1xyXG5cclxuXHRcdHRoaXMubGF5ZXJzLm1hc2sgPSBzb3VyY2UubGF5ZXJzLm1hc2s7XHJcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcclxuXHRcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xyXG5cclxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xyXG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBzb3VyY2UuYW5pbWF0aW9ucztcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XHJcblxyXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xyXG5cdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5PYmplY3QzRC5ERUZBVUxUX1VQID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xyXG5PYmplY3QzRC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSA9IHRydWU7XHJcbk9iamVjdDNELkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFID0gdHJ1ZTtcclxuXHJcbmV4cG9ydCB7IE9iamVjdDNEIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3YzID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX3ZhYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZhYyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZiYyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZhcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZicCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZjcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmxldCB3YXJuZWRHZXRVViA9IGZhbHNlO1xyXG5cclxuY2xhc3MgVHJpYW5nbGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYSA9IG5ldyBWZWN0b3IzKCksIGIgPSBuZXcgVmVjdG9yMygpLCBjID0gbmV3IFZlY3RvcjMoKSApIHtcclxuXHJcblx0XHR0aGlzLmEgPSBhO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHRcdHRoaXMuYyA9IGM7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldE5vcm1hbCggYSwgYiwgYywgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHRhcmdldC5zdWJWZWN0b3JzKCBjLCBiICk7XHJcblx0XHRfdjAuc3ViVmVjdG9ycyggYSwgYiApO1xyXG5cdFx0dGFyZ2V0LmNyb3NzKCBfdjAgKTtcclxuXHJcblx0XHRjb25zdCB0YXJnZXRMZW5ndGhTcSA9IHRhcmdldC5sZW5ndGhTcSgpO1xyXG5cdFx0aWYgKCB0YXJnZXRMZW5ndGhTcSA+IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCB0YXJnZXRMZW5ndGhTcSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcclxuXHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxyXG5cdHN0YXRpYyBnZXRCYXJ5Y29vcmQoIHBvaW50LCBhLCBiLCBjLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0X3YwLnN1YlZlY3RvcnMoIGMsIGEgKTtcclxuXHRcdF92MS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcblx0XHRfdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcclxuXHJcblx0XHRjb25zdCBkb3QwMCA9IF92MC5kb3QoIF92MCApO1xyXG5cdFx0Y29uc3QgZG90MDEgPSBfdjAuZG90KCBfdjEgKTtcclxuXHRcdGNvbnN0IGRvdDAyID0gX3YwLmRvdCggX3YyICk7XHJcblx0XHRjb25zdCBkb3QxMSA9IF92MS5kb3QoIF92MSApO1xyXG5cdFx0Y29uc3QgZG90MTIgPSBfdjEuZG90KCBfdjIgKTtcclxuXHJcblx0XHRjb25zdCBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcclxuXHJcblx0XHQvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcclxuXHRcdGlmICggZGVub20gPT09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cclxuXHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCggLSAyLCAtIDEsIC0gMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcclxuXHRcdGNvbnN0IHUgPSAoIGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyICkgKiBpbnZEZW5vbTtcclxuXHRcdGNvbnN0IHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcblx0XHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxyXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcclxuXHJcblx0XHR0aGlzLmdldEJhcnljb29yZCggcG9pbnQsIGEsIGIsIGMsIF92MyApO1xyXG5cclxuXHRcdHJldHVybiAoIF92My54ID49IDAgKSAmJiAoIF92My55ID49IDAgKSAmJiAoICggX3YzLnggKyBfdjMueSApIDw9IDEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0VVYoIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKSB7IC8vIEBkZXByZWNhdGVkLCByMTUxXHJcblxyXG5cdFx0aWYgKCB3YXJuZWRHZXRVViA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UcmlhbmdsZS5nZXRVVigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbigpLicgKTtcclxuXHJcblx0XHRcdHdhcm5lZEdldFVWID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMsIHRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHRoaXMuZ2V0QmFyeWNvb3JkKCBwb2ludCwgcDEsIHAyLCBwMywgX3YzICk7XHJcblxyXG5cdFx0dGFyZ2V0LnNldFNjYWxhciggMCApO1xyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggdjEsIF92My54ICk7XHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCB2MiwgX3YzLnkgKTtcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHYzLCBfdjMueiApO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGlzRnJvbnRGYWNpbmcoIGEsIGIsIGMsIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHRfdjAuc3ViVmVjdG9ycyggYywgYiApO1xyXG5cdFx0X3YxLnN1YlZlY3RvcnMoIGEsIGIgKTtcclxuXHJcblx0XHQvLyBzdHJpY3RseSBmcm9udCBmYWNpbmdcclxuXHRcdHJldHVybiAoIF92MC5jcm9zcyggX3YxICkuZG90KCBkaXJlY3Rpb24gKSA8IDAgKSA/IHRydWUgOiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIGEgKTtcclxuXHRcdHRoaXMuYi5jb3B5KCBiICk7XHJcblx0XHR0aGlzLmMuY29weSggYyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKCBhdHRyaWJ1dGUsIGkwLCBpMSwgaTIgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaTAgKTtcclxuXHRcdHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkxICk7XHJcblx0XHR0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpMiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QXJlYSgpIHtcclxuXHJcblx0XHRfdjAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcclxuXHRcdF92MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cclxuXHRcdHJldHVybiBfdjAuY3Jvc3MoIF92MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE1pZHBvaW50KCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9ybWFsKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldE5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UGxhbmUoIHRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEJhcnljb29yZCggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gVHJpYW5nbGUuZ2V0QmFyeWNvb3JkKCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VVYoIHBvaW50LCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKSB7IC8vIEBkZXByZWNhdGVkLCByMTUxXHJcblxyXG5cdFx0aWYgKCB3YXJuZWRHZXRVViA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UcmlhbmdsZS5nZXRVVigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbigpLicgKTtcclxuXHJcblx0XHRcdHdhcm5lZEdldFVWID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdjEsIHYyLCB2MywgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdjEsIHYyLCB2MywgdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdH1cclxuXHJcblx0aXNGcm9udEZhY2luZyggZGlyZWN0aW9uICkge1xyXG5cclxuXHRcdHJldHVybiBUcmlhbmdsZS5pc0Zyb250RmFjaW5nKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBkaXJlY3Rpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzVHJpYW5nbGUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgYSA9IHRoaXMuYSwgYiA9IHRoaXMuYiwgYyA9IHRoaXMuYztcclxuXHRcdGxldCB2LCB3O1xyXG5cclxuXHRcdC8vIGFsZ29yaXRobSB0aGFua3MgdG8gUmVhbC1UaW1lIENvbGxpc2lvbiBEZXRlY3Rpb24gYnkgQ2hyaXN0ZXIgRXJpY3NvbixcclxuXHRcdC8vIHB1Ymxpc2hlZCBieSBNb3JnYW4gS2F1Zm1hbm4gUHVibGlzaGVycywgKGMpIDIwMDUgRWxzZXZpZXIgSW5jLixcclxuXHRcdC8vIHVuZGVyIHRoZSBhY2NvbXBhbnlpbmcgbGljZW5zZTsgc2VlIGNoYXB0ZXIgNS4xLjUgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxyXG5cdFx0Ly8gYmFzaWNhbGx5LCB3ZSdyZSBkaXN0aW5ndWlzaGluZyB3aGljaCBvZiB0aGUgdm9yb25vaSByZWdpb25zIG9mIHRoZSB0cmlhbmdsZVxyXG5cdFx0Ly8gdGhlIHBvaW50IGxpZXMgaW4gd2l0aCB0aGUgbWluaW11bSBhbW91bnQgb2YgcmVkdW5kYW50IGNvbXB1dGF0aW9uLlxyXG5cclxuXHRcdF92YWIuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0X3ZhYy5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRfdmFwLnN1YlZlY3RvcnMoIHAsIGEgKTtcclxuXHRcdGNvbnN0IGQxID0gX3ZhYi5kb3QoIF92YXAgKTtcclxuXHRcdGNvbnN0IGQyID0gX3ZhYy5kb3QoIF92YXAgKTtcclxuXHRcdGlmICggZDEgPD0gMCAmJiBkMiA8PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXHJcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfdmJwLnN1YlZlY3RvcnMoIHAsIGIgKTtcclxuXHRcdGNvbnN0IGQzID0gX3ZhYi5kb3QoIF92YnAgKTtcclxuXHRcdGNvbnN0IGQ0ID0gX3ZhYy5kb3QoIF92YnAgKTtcclxuXHRcdGlmICggZDMgPj0gMCAmJiBkNCA8PSBkMyApIHtcclxuXHJcblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQjsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLCAwKVxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdmMgPSBkMSAqIGQ0IC0gZDMgKiBkMjtcclxuXHRcdGlmICggdmMgPD0gMCAmJiBkMSA+PSAwICYmIGQzIDw9IDAgKSB7XHJcblxyXG5cdFx0XHR2ID0gZDEgLyAoIGQxIC0gZDMgKTtcclxuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQUI7IGJhcnljZW50cmljIGNvb3JkcyAoMS12LCB2LCAwKVxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKS5hZGRTY2FsZWRWZWN0b3IoIF92YWIsIHYgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3ZjcC5zdWJWZWN0b3JzKCBwLCBjICk7XHJcblx0XHRjb25zdCBkNSA9IF92YWIuZG90KCBfdmNwICk7XHJcblx0XHRjb25zdCBkNiA9IF92YWMuZG90KCBfdmNwICk7XHJcblx0XHRpZiAoIGQ2ID49IDAgJiYgZDUgPD0gZDYgKSB7XHJcblxyXG5cdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEM7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMCwgMSlcclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBjICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHZiID0gZDUgKiBkMiAtIGQxICogZDY7XHJcblx0XHRpZiAoIHZiIDw9IDAgJiYgZDIgPj0gMCAmJiBkNiA8PSAwICkge1xyXG5cclxuXHRcdFx0dyA9IGQyIC8gKCBkMiAtIGQ2ICk7XHJcblx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEFDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdywgMCwgdylcclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICkuYWRkU2NhbGVkVmVjdG9yKCBfdmFjLCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHZhID0gZDMgKiBkNiAtIGQ1ICogZDQ7XHJcblx0XHRpZiAoIHZhIDw9IDAgJiYgKCBkNCAtIGQzICkgPj0gMCAmJiAoIGQ1IC0gZDYgKSA+PSAwICkge1xyXG5cclxuXHRcdFx0X3ZiYy5zdWJWZWN0b3JzKCBjLCBiICk7XHJcblx0XHRcdHcgPSAoIGQ0IC0gZDMgKSAvICggKCBkNCAtIGQzICkgKyAoIGQ1IC0gZDYgKSApO1xyXG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBCQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLXcsIHcpXHJcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYiApLmFkZFNjYWxlZFZlY3RvciggX3ZiYywgdyApOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQ1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmYWNlIHJlZ2lvblxyXG5cdFx0Y29uc3QgZGVub20gPSAxIC8gKCB2YSArIHZiICsgdmMgKTtcclxuXHRcdC8vIHUgPSB2YSAqIGRlbm9tXHJcblx0XHR2ID0gdmIgKiBkZW5vbTtcclxuXHRcdHcgPSB2YyAqIGRlbm9tO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggX3ZhYiwgdiApLmFkZFNjYWxlZFZlY3RvciggX3ZhYywgdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGVxdWFscyggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBUcmlhbmdsZSB9O1xyXG4iLCJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuLi9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyc7XHJcbmltcG9ydCB7IEZyb250U2lkZSwgTm9ybWFsQmxlbmRpbmcsIExlc3NFcXVhbERlcHRoLCBBZGRFcXVhdGlvbiwgT25lTWludXNTcmNBbHBoYUZhY3RvciwgU3JjQWxwaGFGYWN0b3IsIEFsd2F5c1N0ZW5jaWxGdW5jLCBLZWVwU3RlbmNpbE9wIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuXHJcbmxldCBtYXRlcmlhbElkID0gMDtcclxuXHJcbmNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJZCArKyB9ICk7XHJcblxyXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cdFx0dGhpcy50eXBlID0gJ01hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XHJcblx0XHR0aGlzLnNpZGUgPSBGcm9udFNpZGU7XHJcblx0XHR0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMub3BhY2l0eSA9IDE7XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblx0XHR0aGlzLmFscGhhSGFzaCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3RvcjtcclxuXHRcdHRoaXMuYmxlbmREc3QgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XHJcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcclxuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xyXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnN0ZW5jaWxXcml0ZU1hc2sgPSAweGZmO1xyXG5cdFx0dGhpcy5zdGVuY2lsRnVuYyA9IEFsd2F5c1N0ZW5jaWxGdW5jO1xyXG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gMDtcclxuXHRcdHRoaXMuc3RlbmNpbEZ1bmNNYXNrID0gMHhmZjtcclxuXHRcdHRoaXMuc3RlbmNpbEZhaWwgPSBLZWVwU3RlbmNpbE9wO1xyXG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBLZWVwU3RlbmNpbE9wO1xyXG5cdFx0dGhpcy5zdGVuY2lsWlBhc3MgPSBLZWVwU3RlbmNpbE9wO1xyXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gbnVsbDtcclxuXHRcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IGZhbHNlO1xyXG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuc2hhZG93U2lkZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXHJcblxyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xyXG5cclxuXHRcdHRoaXMuZGl0aGVyaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5hbHBoYVRvQ292ZXJhZ2UgPSBmYWxzZTtcclxuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XHJcblx0XHR0aGlzLmZvcmNlU2luZ2xlUGFzcyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50b25lTWFwcGVkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0ge307XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcblx0XHR0aGlzLl9hbHBoYVRlc3QgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBhbHBoYVRlc3QoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2FscGhhVGVzdDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgYWxwaGFUZXN0KCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2FscGhhVGVzdCA+IDAgIT09IHZhbHVlID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWxwaGFUZXN0ID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0b25CdWlsZCggLyogc2hhZGVyb2JqZWN0LCByZW5kZXJlciAqLyApIHt9XHJcblxyXG5cdG9uQmVmb3JlUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG9iamVjdCwgZ3JvdXAgKi8gKSB7fVxyXG5cclxuXHRvbkJlZm9yZUNvbXBpbGUoIC8qIHNoYWRlcm9iamVjdCwgcmVuZGVyZXIgKi8gKSB7fVxyXG5cclxuXHRjdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub25CZWZvcmVDb21waWxlLnRvU3RyaW5nKCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0VmFsdWVzKCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZXMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdmFsdWVzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIGBUSFJFRS5NYXRlcmlhbDogcGFyYW1ldGVyICckeyBrZXkgfScgaGFzIHZhbHVlIG9mIHVuZGVmaW5lZC5gICk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggYFRIUkVFLk1hdGVyaWFsOiAnJHsga2V5IH0nIGlzIG5vdCBhIHByb3BlcnR5IG9mIFRIUkVFLiR7IHRoaXMudHlwZSB9LmAgKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yICkge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzVmVjdG9yMyApICYmICggbmV3VmFsdWUgJiYgbmV3VmFsdWUuaXNWZWN0b3IzICkgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xyXG5cclxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xyXG5cclxuXHRcdFx0bWV0YSA9IHtcclxuXHRcdFx0XHR0ZXh0dXJlczoge30sXHJcblx0XHRcdFx0aW1hZ2VzOiB7fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNixcclxuXHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXHJcblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XHJcblx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdGlmICggdGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xyXG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5tZXRhbG5lc3MgPSB0aGlzLm1ldGFsbmVzcztcclxuXHJcblx0XHRpZiAoIHRoaXMuc2hlZW4gIT09IHVuZGVmaW5lZCApIGRhdGEuc2hlZW4gPSB0aGlzLnNoZWVuO1xyXG5cdFx0aWYgKCB0aGlzLnNoZWVuQ29sb3IgJiYgdGhpcy5zaGVlbkNvbG9yLmlzQ29sb3IgKSBkYXRhLnNoZWVuQ29sb3IgPSB0aGlzLnNoZWVuQ29sb3IuZ2V0SGV4KCk7XHJcblx0XHRpZiAoIHRoaXMuc2hlZW5Sb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hlZW5Sb3VnaG5lc3MgPSB0aGlzLnNoZWVuUm91Z2huZXNzO1xyXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlICYmIHRoaXMuZW1pc3NpdmUuaXNDb2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xyXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICYmIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEgKSBkYXRhLmVtaXNzaXZlSW50ZW5zaXR5ID0gdGhpcy5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yICkgZGF0YS5zcGVjdWxhciA9IHRoaXMuc3BlY3VsYXIuZ2V0SGV4KCk7XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHkgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5O1xyXG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyQ29sb3IgJiYgdGhpcy5zcGVjdWxhckNvbG9yLmlzQ29sb3IgKSBkYXRhLnNwZWN1bGFyQ29sb3IgPSB0aGlzLnNwZWN1bGFyQ29sb3IuZ2V0SGV4KCk7XHJcblx0XHRpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xyXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdCAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhcmNvYXQgPSB0aGlzLmNsZWFyY29hdDtcclxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJjb2F0Um91Z2huZXNzID0gdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3M7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdE1hcCAmJiB0aGlzLmNsZWFyY29hdE1hcC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmNsZWFyY29hdE1hcCA9IHRoaXMuY2xlYXJjb2F0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgJiYgdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwICYmIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEuY2xlYXJjb2F0Tm9ybWFsTWFwID0gdGhpcy5jbGVhcmNvYXROb3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudG9BcnJheSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuaXJpZGVzY2VuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEuaXJpZGVzY2VuY2UgPSB0aGlzLmlyaWRlc2NlbmNlO1xyXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlSU9SICE9PSB1bmRlZmluZWQgKSBkYXRhLmlyaWRlc2NlbmNlSU9SID0gdGhpcy5pcmlkZXNjZW5jZUlPUjtcclxuXHRcdGlmICggdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICE9PSB1bmRlZmluZWQgKSBkYXRhLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlTWFwICYmIHRoaXMuaXJpZGVzY2VuY2VNYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5pcmlkZXNjZW5jZU1hcCA9IHRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICYmIHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIGRhdGEuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcclxuXHRcdGlmICggdGhpcy5hbmlzb3Ryb3B5Um90YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuYW5pc290cm9weVJvdGF0aW9uID0gdGhpcy5hbmlzb3Ryb3B5Um90YXRpb247XHJcblxyXG5cdFx0aWYgKCB0aGlzLmFuaXNvdHJvcHlNYXAgJiYgdGhpcy5hbmlzb3Ryb3B5TWFwLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEuYW5pc290cm9weU1hcCA9IHRoaXMuYW5pc290cm9weU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMubWFwICYmIHRoaXMubWFwLmlzVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdGlmICggdGhpcy5tYXRjYXAgJiYgdGhpcy5tYXRjYXAuaXNUZXh0dXJlICkgZGF0YS5tYXRjYXAgPSB0aGlzLm1hdGNhcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRpZiAoIHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5ID0gdGhpcy5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmFvTWFwICYmIHRoaXMuYW9NYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5hb01hcCA9IHRoaXMuYW9NYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5hb01hcEludGVuc2l0eSA9IHRoaXMuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5idW1wTWFwICYmIHRoaXMuYnVtcE1hcC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRcdGRhdGEubm9ybWFsTWFwVHlwZSA9IHRoaXMubm9ybWFsTWFwVHlwZTtcclxuXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuZGlzcGxhY2VtZW50TWFwICYmIHRoaXMuZGlzcGxhY2VtZW50TWFwLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUgKSBkYXRhLnJvdWdobmVzc01hcCA9IHRoaXMucm91Z2huZXNzTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMubWV0YWxuZXNzTWFwICYmIHRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSApIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRpZiAoIHRoaXMuZW1pc3NpdmVNYXAgJiYgdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUgKSBkYXRhLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyTWFwICYmIHRoaXMuc3BlY3VsYXJNYXAuaXNUZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdGlmICggdGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCAmJiB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXJDb2xvck1hcCAmJiB0aGlzLnNwZWN1bGFyQ29sb3JNYXAuaXNUZXh0dXJlICkgZGF0YS5zcGVjdWxhckNvbG9yTWFwID0gdGhpcy5zcGVjdWxhckNvbG9yTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVudk1hcCAmJiB0aGlzLmVudk1hcC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY29tYmluZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBkYXRhLmVudk1hcEludGVuc2l0eSA9IHRoaXMuZW52TWFwSW50ZW5zaXR5O1xyXG5cdFx0aWYgKCB0aGlzLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcclxuXHRcdGlmICggdGhpcy5yZWZyYWN0aW9uUmF0aW8gIT09IHVuZGVmaW5lZCApIGRhdGEucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0aWYgKCB0aGlzLmdyYWRpZW50TWFwICYmIHRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGF0YS5ncmFkaWVudE1hcCA9IHRoaXMuZ3JhZGllbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRyYW5zbWlzc2lvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS50cmFuc21pc3Npb24gPSB0aGlzLnRyYW5zbWlzc2lvbjtcclxuXHRcdGlmICggdGhpcy50cmFuc21pc3Npb25NYXAgJiYgdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlICkgZGF0YS50cmFuc21pc3Npb25NYXAgPSB0aGlzLnRyYW5zbWlzc2lvbk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLnRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS50aGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcztcclxuXHRcdGlmICggdGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS50aGlja25lc3NNYXAgPSB0aGlzLnRoaWNrbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0aWYgKCB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IEluZmluaXR5ICkgZGF0YS5hdHRlbnVhdGlvbkRpc3RhbmNlID0gdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlO1xyXG5cdFx0aWYgKCB0aGlzLmF0dGVudWF0aW9uQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEuYXR0ZW51YXRpb25Db2xvciA9IHRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xyXG5cdFx0aWYgKCB0aGlzLnNoYWRvd1NpZGUgIT09IG51bGwgKSBkYXRhLnNoYWRvd1NpZGUgPSB0aGlzLnNoYWRvd1NpZGU7XHJcblx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxuXHRcdGlmICggdGhpcy5ibGVuZGluZyAhPT0gTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcclxuXHRcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XHJcblx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdGRhdGEuZGVwdGhGdW5jID0gdGhpcy5kZXB0aEZ1bmM7XHJcblx0XHRkYXRhLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xyXG5cdFx0ZGF0YS5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xyXG5cdFx0ZGF0YS5jb2xvcldyaXRlID0gdGhpcy5jb2xvcldyaXRlO1xyXG5cclxuXHRcdGRhdGEuc3RlbmNpbFdyaXRlID0gdGhpcy5zdGVuY2lsV3JpdGU7XHJcblx0XHRkYXRhLnN0ZW5jaWxXcml0ZU1hc2sgPSB0aGlzLnN0ZW5jaWxXcml0ZU1hc2s7XHJcblx0XHRkYXRhLnN0ZW5jaWxGdW5jID0gdGhpcy5zdGVuY2lsRnVuYztcclxuXHRcdGRhdGEuc3RlbmNpbFJlZiA9IHRoaXMuc3RlbmNpbFJlZjtcclxuXHRcdGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XHJcblx0XHRkYXRhLnN0ZW5jaWxGYWlsID0gdGhpcy5zdGVuY2lsRmFpbDtcclxuXHRcdGRhdGEuc3RlbmNpbFpGYWlsID0gdGhpcy5zdGVuY2lsWkZhaWw7XHJcblx0XHRkYXRhLnN0ZW5jaWxaUGFzcyA9IHRoaXMuc3RlbmNpbFpQYXNzO1xyXG5cclxuXHRcdC8vIHJvdGF0aW9uIChTcHJpdGVNYXRlcmlhbClcclxuXHRcdGlmICggdGhpcy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICYmIHRoaXMucm90YXRpb24gIT09IDAgKSBkYXRhLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuXHJcblx0XHRpZiAoIHRoaXMucG9seWdvbk9mZnNldCA9PT0gdHJ1ZSApIGRhdGEucG9seWdvbk9mZnNldCA9IHRydWU7XHJcblx0XHRpZiAoIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciAhPT0gMCApIGRhdGEucG9seWdvbk9mZnNldEZhY3RvciA9IHRoaXMucG9seWdvbk9mZnNldEZhY3RvcjtcclxuXHRcdGlmICggdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgIT09IDAgKSBkYXRhLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzO1xyXG5cclxuXHRcdGlmICggdGhpcy5saW5ld2lkdGggIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxpbmV3aWR0aCAhPT0gMSApIGRhdGEubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XHJcblx0XHRpZiAoIHRoaXMuZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xyXG5cdFx0aWYgKCB0aGlzLmdhcFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZ2FwU2l6ZSA9IHRoaXMuZ2FwU2l6ZTtcclxuXHRcdGlmICggdGhpcy5zY2FsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSApIGRhdGEuZGl0aGVyaW5nID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XHJcblx0XHRpZiAoIHRoaXMuYWxwaGFIYXNoID09PSB0cnVlICkgZGF0YS5hbHBoYUhhc2ggPSB0aGlzLmFscGhhSGFzaDtcclxuXHRcdGlmICggdGhpcy5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWUgKSBkYXRhLmFscGhhVG9Db3ZlcmFnZSA9IHRoaXMuYWxwaGFUb0NvdmVyYWdlO1xyXG5cdFx0aWYgKCB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIGRhdGEucHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE7XHJcblx0XHRpZiAoIHRoaXMuZm9yY2VTaW5nbGVQYXNzID09PSB0cnVlICkgZGF0YS5mb3JjZVNpbmdsZVBhc3MgPSB0aGlzLmZvcmNlU2luZ2xlUGFzcztcclxuXHJcblx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZsYXRTaGFkaW5nID09PSB0cnVlICkgZGF0YS5mbGF0U2hhZGluZyA9IHRoaXMuZmxhdFNoYWRpbmc7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgZGF0YS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRvbmVNYXBwZWQgPT09IGZhbHNlICkgZGF0YS50b25lTWFwcGVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZvZyA9PT0gZmFsc2UgKSBkYXRhLmZvZyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMudXNlckRhdGEgKS5sZW5ndGggPiAwICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XHJcblxyXG5cdFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXHJcblxyXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcclxuXHRcdFx0XHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcclxuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcclxuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XHJcblx0XHR0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcclxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHR0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcclxuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XHJcblxyXG5cdFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcclxuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcclxuXHRcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xyXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XHJcblx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xyXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xyXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGVNYXNrID0gc291cmNlLnN0ZW5jaWxXcml0ZU1hc2s7XHJcblx0XHR0aGlzLnN0ZW5jaWxGdW5jID0gc291cmNlLnN0ZW5jaWxGdW5jO1xyXG5cdFx0dGhpcy5zdGVuY2lsUmVmID0gc291cmNlLnN0ZW5jaWxSZWY7XHJcblx0XHR0aGlzLnN0ZW5jaWxGdW5jTWFzayA9IHNvdXJjZS5zdGVuY2lsRnVuY01hc2s7XHJcblx0XHR0aGlzLnN0ZW5jaWxGYWlsID0gc291cmNlLnN0ZW5jaWxGYWlsO1xyXG5cdFx0dGhpcy5zdGVuY2lsWkZhaWwgPSBzb3VyY2Uuc3RlbmNpbFpGYWlsO1xyXG5cdFx0dGhpcy5zdGVuY2lsWlBhc3MgPSBzb3VyY2Uuc3RlbmNpbFpQYXNzO1xyXG5cdFx0dGhpcy5zdGVuY2lsV3JpdGUgPSBzb3VyY2Uuc3RlbmNpbFdyaXRlO1xyXG5cclxuXHRcdGNvbnN0IHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcztcclxuXHRcdGxldCBkc3RQbGFuZXMgPSBudWxsO1xyXG5cclxuXHRcdGlmICggc3JjUGxhbmVzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbiA9IHNyY1BsYW5lcy5sZW5ndGg7XHJcblx0XHRcdGRzdFBsYW5lcyA9IG5ldyBBcnJheSggbiApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRkc3RQbGFuZXNbIGkgXSA9IHNyY1BsYW5lc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBkc3RQbGFuZXM7XHJcblx0XHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcclxuXHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3dTaWRlID0gc291cmNlLnNoYWRvd1NpZGU7XHJcblxyXG5cdFx0dGhpcy5jb2xvcldyaXRlID0gc291cmNlLmNvbG9yV3JpdGU7XHJcblxyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xyXG5cclxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcblx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdFx0dGhpcy5kaXRoZXJpbmcgPSBzb3VyY2UuZGl0aGVyaW5nO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcclxuXHRcdHRoaXMuYWxwaGFIYXNoID0gc291cmNlLmFscGhhSGFzaDtcclxuXHRcdHRoaXMuYWxwaGFUb0NvdmVyYWdlID0gc291cmNlLmFscGhhVG9Db3ZlcmFnZTtcclxuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcclxuXHRcdHRoaXMuZm9yY2VTaW5nbGVQYXNzID0gc291cmNlLmZvcmNlU2luZ2xlUGFzcztcclxuXHJcblx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHJcblx0XHR0aGlzLnRvbmVNYXBwZWQgPSBzb3VyY2UudG9uZU1hcHBlZDtcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE1hdGVyaWFsIH07XHJcbiIsImltcG9ydCB7IGNsYW1wLCBldWNsaWRlYW5Nb2R1bG8sIGxlcnAgfSBmcm9tICcuL01hdGhVdGlscy5qcyc7XHJcbmltcG9ydCB7IENvbG9yTWFuYWdlbWVudCwgU1JHQlRvTGluZWFyLCBMaW5lYXJUb1NSR0IgfSBmcm9tICcuL0NvbG9yTWFuYWdlbWVudC5qcyc7XHJcbmltcG9ydCB7IFNSR0JDb2xvclNwYWNlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmNvbnN0IF9jb2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXHJcblx0J2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxyXG5cdCdicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcclxuXHQnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4QixcclxuXHQnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcclxuXHQnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxyXG5cdCdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXHJcblx0J2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXHJcblx0J2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXHJcblx0J2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxyXG5cdCdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXHJcblx0J2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcclxuXHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcclxuXHQnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxyXG5cdCdsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcclxuXHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXHJcblx0J21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXHJcblx0J25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcclxuXHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcclxuXHQncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWJlY2NhcHVycGxlJzogMHg2NjMzOTksICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxyXG5cdCdyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxyXG5cdCdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxyXG5cdCdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXHJcblx0J3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcclxuXHJcbmNvbnN0IF9oc2xBID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XHJcbmNvbnN0IF9oc2xCID0geyBoOiAwLCBzOiAwLCBsOiAwIH07XHJcblxyXG5mdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xyXG5cclxuXHRpZiAoIHQgPCAwICkgdCArPSAxO1xyXG5cdGlmICggdCA+IDEgKSB0IC09IDE7XHJcblx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG5cdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XHJcblx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xyXG5cdHJldHVybiBwO1xyXG5cclxufVxyXG5cclxuY2xhc3MgQ29sb3Ige1xyXG5cclxuXHRjb25zdHJ1Y3RvciggciwgZywgYiApIHtcclxuXHJcblx0XHR0aGlzLmlzQ29sb3IgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuciA9IDE7XHJcblx0XHR0aGlzLmcgPSAxO1xyXG5cdFx0dGhpcy5iID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXQoIHIsIGcsIGIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIHIsIGcsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWUgPSByO1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc0NvbG9yICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvcHkoIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldEhleCggdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0UkdCKCByLCBnLCBiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHNjYWxhcjtcclxuXHRcdHRoaXMuZyA9IHNjYWxhcjtcclxuXHRcdHRoaXMuYiA9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRIZXgoIGhleCwgY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xyXG5cclxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XHJcblx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XHJcblx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xyXG5cclxuXHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKCB0aGlzLCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0UkdCKCByLCBnLCBiLCBjb2xvclNwYWNlID0gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHJcblx0XHRDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSggdGhpcywgY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEhTTCggaCwgcywgbCwgY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcclxuXHJcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cdFx0aCA9IGV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xyXG5cdFx0cyA9IGNsYW1wKCBzLCAwLCAxICk7XHJcblx0XHRsID0gY2xhbXAoIGwsIDAsIDEgKTtcclxuXHJcblx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBwID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSAoIGwgKiBzICk7XHJcblx0XHRcdGNvbnN0IHEgPSAoIDIgKiBsICkgLSBwO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XHJcblx0XHRcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcclxuXHRcdFx0dGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKCB0aGlzLCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0U3R5bGUoIHN0eWxlLCBjb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcclxuXHJcblx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHBhcnNlRmxvYXQoIHN0cmluZyApIDwgMSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRsZXQgbTtcclxuXHJcblx0XHRpZiAoIG0gPSAvXihcXHcrKVxcKChbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIHJnYiAvIGhzbFxyXG5cclxuXHRcdFx0bGV0IGNvbG9yO1xyXG5cdFx0XHRjb25zdCBuYW1lID0gbVsgMSBdO1xyXG5cdFx0XHRjb25zdCBjb21wb25lbnRzID0gbVsgMiBdO1xyXG5cclxuXHRcdFx0c3dpdGNoICggbmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAncmdiJzpcclxuXHRcdFx0XHRjYXNlICdyZ2JhJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL15cXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFxcZCpcXC4/XFxkKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoXHJcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NSxcclxuXHRcdFx0XHRcdFx0XHRNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1LFxyXG5cdFx0XHRcdFx0XHRcdE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTUsXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL15cXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKig/OixcXHMqKFxcZCpcXC4/XFxkKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZ2IoMTAwJSwwJSwwJSkgcmdiYSgxMDAlLDAlLDAlLDAuNSlcclxuXHJcblx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNCBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRSR0IoXHJcblx0XHRcdFx0XHRcdFx0TWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMCxcclxuXHRcdFx0XHRcdFx0XHRNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwLFxyXG5cdFx0XHRcdFx0XHRcdE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDAsXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnaHNsJzpcclxuXHRcdFx0XHRjYXNlICdoc2xhJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL15cXHMqKFxcZCpcXC4/XFxkKylcXHMqLFxccyooXFxkKlxcLj9cXGQrKVxcJVxccyosXFxzKihcXGQqXFwuP1xcZCspXFwlXFxzKig/OixcXHMqKFxcZCpcXC4/XFxkKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA0IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldEhTTChcclxuXHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjAsXHJcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggY29sb3JbIDIgXSApIC8gMTAwLFxyXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGNvbG9yWyAzIF0gKSAvIDEwMCxcclxuXHRcdFx0XHRcdFx0XHRjb2xvclNwYWNlXHJcblx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yIG1vZGVsICcgKyBzdHlsZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mXFxkXSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdC8vIGhleCBjb2xvclxyXG5cclxuXHRcdFx0Y29uc3QgaGV4ID0gbVsgMSBdO1xyXG5cdFx0XHRjb25zdCBzaXplID0gaGV4Lmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggc2l6ZSA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0Ly8gI2ZmMFxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFJHQihcclxuXHRcdFx0XHRcdHBhcnNlSW50KCBoZXguY2hhckF0KCAwICksIDE2ICkgLyAxNSxcclxuXHRcdFx0XHRcdHBhcnNlSW50KCBoZXguY2hhckF0KCAxICksIDE2ICkgLyAxNSxcclxuXHRcdFx0XHRcdHBhcnNlSW50KCBoZXguY2hhckF0KCAyICksIDE2ICkgLyAxNSxcclxuXHRcdFx0XHRcdGNvbG9yU3BhY2VcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gI2ZmMDAwMFxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldEhleCggcGFyc2VJbnQoIGhleCwgMTYgKSwgY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEludmFsaWQgaGV4IGNvbG9yICcgKyBzdHlsZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHN0eWxlICYmIHN0eWxlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUoIHN0eWxlLCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldENvbG9yTmFtZSggc3R5bGUsIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcclxuXHJcblx0XHQvLyBjb2xvciBrZXl3b3Jkc1xyXG5cdFx0Y29uc3QgaGV4ID0gX2NvbG9yS2V5d29yZHNbIHN0eWxlLnRvTG93ZXJDYXNlKCkgXTtcclxuXHJcblx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gcmVkXHJcblx0XHRcdHRoaXMuc2V0SGV4KCBoZXgsIGNvbG9yU3BhY2UgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gdW5rbm93biBjb2xvclxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IucjtcclxuXHRcdHRoaXMuZyA9IGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlTUkdCVG9MaW5lYXIoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IFNSR0JUb0xpbmVhciggY29sb3IuciApO1xyXG5cdFx0dGhpcy5nID0gU1JHQlRvTGluZWFyKCBjb2xvci5nICk7XHJcblx0XHR0aGlzLmIgPSBTUkdCVG9MaW5lYXIoIGNvbG9yLmIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5TGluZWFyVG9TUkdCKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBMaW5lYXJUb1NSR0IoIGNvbG9yLnIgKTtcclxuXHRcdHRoaXMuZyA9IExpbmVhclRvU1JHQiggY29sb3IuZyApO1xyXG5cdFx0dGhpcy5iID0gTGluZWFyVG9TUkdCKCBjb2xvci5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udmVydFNSR0JUb0xpbmVhcigpIHtcclxuXHJcblx0XHR0aGlzLmNvcHlTUkdCVG9MaW5lYXIoIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb252ZXJ0TGluZWFyVG9TUkdCKCkge1xyXG5cclxuXHRcdHRoaXMuY29weUxpbmVhclRvU1JHQiggdGhpcyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhleCggY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdENvbG9yTWFuYWdlbWVudC5mcm9tV29ya2luZ0NvbG9yU3BhY2UoIF9jb2xvci5jb3B5KCB0aGlzICksIGNvbG9yU3BhY2UgKTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggY2xhbXAoIF9jb2xvci5yICogMjU1LCAwLCAyNTUgKSApICogNjU1MzYgKyBNYXRoLnJvdW5kKCBjbGFtcCggX2NvbG9yLmcgKiAyNTUsIDAsIDI1NSApICkgKiAyNTYgKyBNYXRoLnJvdW5kKCBjbGFtcCggX2NvbG9yLmIgKiAyNTUsIDAsIDI1NSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SGV4U3RyaW5nKCBjb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCggY29sb3JTcGFjZSApLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhTTCggdGFyZ2V0LCBjb2xvclNwYWNlID0gQ29sb3JNYW5hZ2VtZW50LndvcmtpbmdDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXHJcblxyXG5cdFx0Q29sb3JNYW5hZ2VtZW50LmZyb21Xb3JraW5nQ29sb3JTcGFjZSggX2NvbG9yLmNvcHkoIHRoaXMgKSwgY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdGNvbnN0IHIgPSBfY29sb3IuciwgZyA9IF9jb2xvci5nLCBiID0gX2NvbG9yLmI7XHJcblxyXG5cdFx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XHJcblxyXG5cdFx0bGV0IGh1ZSwgc2F0dXJhdGlvbjtcclxuXHRcdGNvbnN0IGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XHJcblxyXG5cdFx0aWYgKCBtaW4gPT09IG1heCApIHtcclxuXHJcblx0XHRcdGh1ZSA9IDA7XHJcblx0XHRcdHNhdHVyYXRpb24gPSAwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBkZWx0YSA9IG1heCAtIG1pbjtcclxuXHJcblx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1heCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhcmdldC5oID0gaHVlO1xyXG5cdFx0dGFyZ2V0LnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0dGFyZ2V0LmwgPSBsaWdodG5lc3M7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRSR0IoIHRhcmdldCwgY29sb3JTcGFjZSA9IENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKCBfY29sb3IuY29weSggdGhpcyApLCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0dGFyZ2V0LnIgPSBfY29sb3IucjtcclxuXHRcdHRhcmdldC5nID0gX2NvbG9yLmc7XHJcblx0XHR0YXJnZXQuYiA9IF9jb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U3R5bGUoIGNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKCBfY29sb3IuY29weSggdGhpcyApLCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0Y29uc3QgciA9IF9jb2xvci5yLCBnID0gX2NvbG9yLmcsIGIgPSBfY29sb3IuYjtcclxuXHJcblx0XHRpZiAoIGNvbG9yU3BhY2UgIT09IFNSR0JDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdFx0Ly8gUmVxdWlyZXMgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCA0IChodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTQvKS5cclxuXHRcdFx0cmV0dXJuIGBjb2xvcigkeyBjb2xvclNwYWNlIH0gJHsgci50b0ZpeGVkKCAzICkgfSAkeyBnLnRvRml4ZWQoIDMgKSB9ICR7IGIudG9GaXhlZCggMyApIH0pYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGByZ2IoJHsgTWF0aC5yb3VuZCggciAqIDI1NSApIH0sJHsgTWF0aC5yb3VuZCggZyAqIDI1NSApIH0sJHsgTWF0aC5yb3VuZCggYiAqIDI1NSApIH0pYDtcclxuXHJcblx0fVxyXG5cclxuXHRvZmZzZXRIU0woIGgsIHMsIGwgKSB7XHJcblxyXG5cdFx0dGhpcy5nZXRIU0woIF9oc2xBICk7XHJcblxyXG5cdFx0X2hzbEEuaCArPSBoOyBfaHNsQS5zICs9IHM7IF9oc2xBLmwgKz0gbDtcclxuXHJcblx0XHR0aGlzLnNldEhTTCggX2hzbEEuaCwgX2hzbEEucywgX2hzbEEubCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZCggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKz0gY29sb3IuZztcclxuXHRcdHRoaXMuYiArPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZENvbG9ycyggY29sb3IxLCBjb2xvcjIgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcclxuXHRcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XHJcblx0XHR0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZFNjYWxhciggcyApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gcztcclxuXHRcdHRoaXMuZyArPSBzO1xyXG5cdFx0dGhpcy5iICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c3ViKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLm1heCggMCwgdGhpcy5yIC0gY29sb3IuciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5tYXgoIDAsIHRoaXMuZyAtIGNvbG9yLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bXVsdGlwbHkoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBjb2xvci5yO1xyXG5cdFx0dGhpcy5nICo9IGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgKj0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcclxuXHJcblx0XHR0aGlzLnIgKj0gcztcclxuXHRcdHRoaXMuZyAqPSBzO1xyXG5cdFx0dGhpcy5iICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bGVycCggY29sb3IsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XHJcblx0XHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRsZXJwQ29sb3JzKCBjb2xvcjEsIGNvbG9yMiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IxLnIgKyAoIGNvbG9yMi5yIC0gY29sb3IxLnIgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyAoIGNvbG9yMi5nIC0gY29sb3IxLmcgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyAoIGNvbG9yMi5iIC0gY29sb3IxLmIgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGxlcnBIU0woIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLmdldEhTTCggX2hzbEEgKTtcclxuXHRcdGNvbG9yLmdldEhTTCggX2hzbEIgKTtcclxuXHJcblx0XHRjb25zdCBoID0gbGVycCggX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEgKTtcclxuXHRcdGNvbnN0IHMgPSBsZXJwKCBfaHNsQS5zLCBfaHNsQi5zLCBhbHBoYSApO1xyXG5cdFx0Y29uc3QgbCA9IGxlcnAoIF9oc2xBLmwsIF9oc2xCLmwsIGFscGhhICk7XHJcblxyXG5cdFx0dGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tVmVjdG9yMyggdiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSB2Lng7XHJcblx0XHR0aGlzLmcgPSB2Lnk7XHJcblx0XHR0aGlzLmIgPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXgzKCBtICkge1xyXG5cclxuXHRcdGNvbnN0IHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XHJcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnIgPSBlWyAwIF0gKiByICsgZVsgMyBdICogZyArIGVbIDYgXSAqIGI7XHJcblx0XHR0aGlzLmcgPSBlWyAxIF0gKiByICsgZVsgNCBdICogZyArIGVbIDcgXSAqIGI7XHJcblx0XHR0aGlzLmIgPSBlWyAyIF0gKiByICsgZVsgNSBdICogZyArIGVbIDggXSAqIGI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXF1YWxzKCBjICkge1xyXG5cclxuXHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XHJcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XHJcblx0XHR0aGlzLmcgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHRcdHRoaXMuYiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRIZXgoKTtcclxuXHJcblx0fVxyXG5cclxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcclxuXHJcblx0XHR5aWVsZCB0aGlzLnI7XHJcblx0XHR5aWVsZCB0aGlzLmc7XHJcblx0XHR5aWVsZCB0aGlzLmI7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IF9jb2xvciA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCk7XHJcblxyXG5Db2xvci5OQU1FUyA9IF9jb2xvcktleXdvcmRzO1xyXG5cclxuZXhwb3J0IHsgQ29sb3IgfTtcclxuIiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgTXVsdGlwbHlPcGVyYXRpb24gfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgTWVzaEJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hCYXNpY01hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXHJcblxyXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XHJcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0XHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcclxuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xyXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE1lc2hCYXNpY01hdGVyaWFsIH07XHJcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5cclxuLy8gRmFzdCBIYWxmIEZsb2F0IENvbnZlcnNpb25zLCBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXHJcblxyXG5jb25zdCBfdGFibGVzID0gLypAX19QVVJFX18qLyBfZ2VuZXJhdGVUYWJsZXMoKTtcclxuXHJcbmZ1bmN0aW9uIF9nZW5lcmF0ZVRhYmxlcygpIHtcclxuXHJcblx0Ly8gZmxvYXQzMiB0byBmbG9hdDE2IGhlbHBlcnNcclxuXHJcblx0Y29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCA0ICk7XHJcblx0Y29uc3QgZmxvYXRWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XHJcblx0Y29uc3QgdWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XHJcblxyXG5cdGNvbnN0IGJhc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNTEyICk7XHJcblx0Y29uc3Qgc2hpZnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggNTEyICk7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IDI1NjsgKysgaSApIHtcclxuXHJcblx0XHRjb25zdCBlID0gaSAtIDEyNztcclxuXHJcblx0XHQvLyB2ZXJ5IHNtYWxsIG51bWJlciAoMCwgLTApXHJcblxyXG5cdFx0aWYgKCBlIDwgLSAyNyApIHtcclxuXHJcblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHgwMDAwO1xyXG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHg4MDAwO1xyXG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAyNDtcclxuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcclxuXHJcblx0XHRcdC8vIHNtYWxsIG51bWJlciAoZGVub3JtKVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGUgPCAtIDE0ICkge1xyXG5cclxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDA0MDAgPj4gKCAtIGUgLSAxNCApO1xyXG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gKCAweDA0MDAgPj4gKCAtIGUgLSAxNCApICkgfCAweDgwMDA7XHJcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IC0gZSAtIDE7XHJcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gLSBlIC0gMTtcclxuXHJcblx0XHRcdC8vIG5vcm1hbCBudW1iZXJcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBlIDw9IDE1ICkge1xyXG5cclxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAoIGUgKyAxNSApIDw8IDEwO1xyXG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gKCAoIGUgKyAxNSApIDw8IDEwICkgfCAweDgwMDA7XHJcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDEzO1xyXG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xyXG5cclxuXHRcdFx0Ly8gbGFyZ2UgbnVtYmVyIChJbmZpbml0eSwgLUluZmluaXR5KVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGUgPCAxMjggKSB7XHJcblxyXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4N2MwMDtcclxuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcclxuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMjQ7XHJcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMjQ7XHJcblxyXG5cdFx0XHQvLyBzdGF5IChOYU4sIEluZmluaXR5LCAtSW5maW5pdHkpXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xyXG5cdFx0XHRiYXNlVGFibGVbIGkgfCAweDEwMCBdID0gMHhmYzAwO1xyXG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAxMztcclxuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAxMztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZmxvYXQxNiB0byBmbG9hdDMyIGhlbHBlcnNcclxuXHJcblx0Y29uc3QgbWFudGlzc2FUYWJsZSA9IG5ldyBVaW50MzJBcnJheSggMjA0OCApO1xyXG5cdGNvbnN0IGV4cG9uZW50VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XHJcblx0Y29uc3Qgb2Zmc2V0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDEwMjQ7ICsrIGkgKSB7XHJcblxyXG5cdFx0bGV0IG0gPSBpIDw8IDEzOyAvLyB6ZXJvIHBhZCBtYW50aXNzYSBiaXRzXHJcblx0XHRsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcclxuXHJcblx0XHQvLyBub3JtYWxpemVkXHJcblx0XHR3aGlsZSAoICggbSAmIDB4MDA4MDAwMDAgKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdG0gPDw9IDE7XHJcblx0XHRcdGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG0gJj0gfiAweDAwODAwMDAwOyAvLyBjbGVhciBsZWFkaW5nIDEgYml0XHJcblx0XHRlICs9IDB4Mzg4MDAwMDA7IC8vIGFkanVzdCBiaWFzXHJcblxyXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gbSB8IGU7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggbGV0IGkgPSAxMDI0OyBpIDwgMjA0ODsgKysgaSApIHtcclxuXHJcblx0XHRtYW50aXNzYVRhYmxlWyBpIF0gPSAweDM4MDAwMDAwICsgKCAoIGkgLSAxMDI0ICkgPDwgMTMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCAzMTsgKysgaSApIHtcclxuXHJcblx0XHRleHBvbmVudFRhYmxlWyBpIF0gPSBpIDw8IDIzO1xyXG5cclxuXHR9XHJcblxyXG5cdGV4cG9uZW50VGFibGVbIDMxIF0gPSAweDQ3ODAwMDAwO1xyXG5cdGV4cG9uZW50VGFibGVbIDMyIF0gPSAweDgwMDAwMDAwO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDMzOyBpIDwgNjM7ICsrIGkgKSB7XHJcblxyXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gMHg4MDAwMDAwMCArICggKCBpIC0gMzIgKSA8PCAyMyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGV4cG9uZW50VGFibGVbIDYzIF0gPSAweGM3ODAwMDAwO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDE7IGkgPCA2NDsgKysgaSApIHtcclxuXHJcblx0XHRpZiAoIGkgIT09IDMyICkge1xyXG5cclxuXHRcdFx0b2Zmc2V0VGFibGVbIGkgXSA9IDEwMjQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRmbG9hdFZpZXc6IGZsb2F0VmlldyxcclxuXHRcdHVpbnQzMlZpZXc6IHVpbnQzMlZpZXcsXHJcblx0XHRiYXNlVGFibGU6IGJhc2VUYWJsZSxcclxuXHRcdHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXHJcblx0XHRtYW50aXNzYVRhYmxlOiBtYW50aXNzYVRhYmxlLFxyXG5cdFx0ZXhwb25lbnRUYWJsZTogZXhwb25lbnRUYWJsZSxcclxuXHRcdG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZVxyXG5cdH07XHJcblxyXG59XHJcblxyXG4vLyBmbG9hdDMyIHRvIGZsb2F0MTZcclxuXHJcbmZ1bmN0aW9uIHRvSGFsZkZsb2F0KCB2YWwgKSB7XHJcblxyXG5cdGlmICggTWF0aC5hYnMoIHZhbCApID4gNjU1MDQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicgKTtcclxuXHJcblx0dmFsID0gY2xhbXAoIHZhbCwgLSA2NTUwNCwgNjU1MDQgKTtcclxuXHJcblx0X3RhYmxlcy5mbG9hdFZpZXdbIDAgXSA9IHZhbDtcclxuXHRjb25zdCBmID0gX3RhYmxlcy51aW50MzJWaWV3WyAwIF07XHJcblx0Y29uc3QgZSA9ICggZiA+PiAyMyApICYgMHgxZmY7XHJcblx0cmV0dXJuIF90YWJsZXMuYmFzZVRhYmxlWyBlIF0gKyAoICggZiAmIDB4MDA3ZmZmZmYgKSA+PiBfdGFibGVzLnNoaWZ0VGFibGVbIGUgXSApO1xyXG5cclxufVxyXG5cclxuLy8gZmxvYXQxNiB0byBmbG9hdDMyXHJcblxyXG5mdW5jdGlvbiBmcm9tSGFsZkZsb2F0KCB2YWwgKSB7XHJcblxyXG5cdGNvbnN0IG0gPSB2YWwgPj4gMTA7XHJcblx0X3RhYmxlcy51aW50MzJWaWV3WyAwIF0gPSBfdGFibGVzLm1hbnRpc3NhVGFibGVbIF90YWJsZXMub2Zmc2V0VGFibGVbIG0gXSArICggdmFsICYgMHgzZmYgKSBdICsgX3RhYmxlcy5leHBvbmVudFRhYmxlWyBtIF07XHJcblx0cmV0dXJuIF90YWJsZXMuZmxvYXRWaWV3WyAwIF07XHJcblxyXG59XHJcblxyXG5jb25zdCBEYXRhVXRpbHMgPSB7XHJcblx0dG9IYWxmRmxvYXQ6IHRvSGFsZkZsb2F0LFxyXG5cdGZyb21IYWxmRmxvYXQ6IGZyb21IYWxmRmxvYXQsXHJcbn07XHJcblxyXG5leHBvcnQge1xyXG5cdHRvSGFsZkZsb2F0LFxyXG5cdGZyb21IYWxmRmxvYXQsXHJcblx0RGF0YVV0aWxzXHJcbn07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgZGVub3JtYWxpemUsIG5vcm1hbGl6ZSB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuaW1wb3J0IHsgU3RhdGljRHJhd1VzYWdlLCBGbG9hdFR5cGUgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBmcm9tSGFsZkZsb2F0LCB0b0hhbGZGbG9hdCB9IGZyb20gJy4uL2V4dHJhcy9EYXRhVXRpbHMuanMnO1xyXG5cclxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcblxyXG5jbGFzcyBCdWZmZXJBdHRyaWJ1dGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmlzQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XHJcblx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcclxuXHRcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XHJcblxyXG5cdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcclxuXHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cdFx0dGhpcy5ncHVUeXBlID0gRmxvYXRUeXBlO1xyXG5cclxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0b25VcGxvYWRDYWxsYmFjaygpIHt9XHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRVc2FnZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcclxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcclxuXHRcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XHJcblx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xyXG5cdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XHJcblxyXG5cdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcclxuXHRcdHRoaXMuZ3B1VHlwZSA9IHNvdXJjZS5ncHVUeXBlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weUFycmF5KCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLml0ZW1TaXplID09PSAyICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcclxuXHRcdFx0XHRfdmVjdG9yMi5hcHBseU1hdHJpeDMoIG0gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXRYWSggaSwgX3ZlY3RvcjIueCwgX3ZlY3RvcjIueSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XHJcblx0XHRcdFx0X3ZlY3Rvci5hcHBseU1hdHJpeDMoIG0gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXg0KCBtICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XHJcblxyXG5cdFx0XHRfdmVjdG9yLmFwcGx5TWF0cml4NCggbSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcclxuXHJcblx0XHRcdF92ZWN0b3IuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xyXG5cclxuXHRcdFx0X3ZlY3Rvci50cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCggdmFsdWUsIG9mZnNldCA9IDAgKSB7XHJcblxyXG5cdFx0Ly8gTWF0Y2hpbmcgQnVmZmVyQXR0cmlidXRlIGNvbnN0cnVjdG9yLCBkbyBub3Qgbm9ybWFsaXplIHRoZSBhcnJheS5cclxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0WCggaW5kZXggKSB7XHJcblxyXG5cdFx0bGV0IHggPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB4O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFgoIGluZGV4LCB4ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRZKCBpbmRleCApIHtcclxuXHJcblx0XHRsZXQgeSA9IHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBkZW5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB5O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFkoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0WiggaW5kZXggKSB7XHJcblxyXG5cdFx0bGV0IHogPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gejtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRaKCBpbmRleCwgeiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFcoIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB3ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IGRlbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHc7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0VyggaW5kZXgsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRYWSggaW5kZXgsIHgsIHkgKSB7XHJcblxyXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcclxuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WFlaKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XHJcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XHJcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcclxuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5LCB0aGlzLml0ZW1TaXplICkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0ge1xyXG5cdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcclxuXHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxyXG5cdFx0XHRhcnJheTogQXJyYXkuZnJvbSggdGhpcy5hcnJheSApLFxyXG5cdFx0XHRub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xyXG5cdFx0aWYgKCB0aGlzLnVzYWdlICE9PSBTdGF0aWNEcmF3VXNhZ2UgKSBkYXRhLnVzYWdlID0gdGhpcy51c2FnZTtcclxuXHRcdGlmICggdGhpcy51cGRhdGVSYW5nZS5vZmZzZXQgIT09IDAgfHwgdGhpcy51cGRhdGVSYW5nZS5jb3VudCAhPT0gLSAxICkgZGF0YS51cGRhdGVSYW5nZSA9IHRoaXMudXBkYXRlUmFuZ2U7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5jbGFzcyBJbnQ4QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRzdXBlciggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdHN1cGVyKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRzdXBlciggbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRzdXBlciggbmV3IEludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0XHR0aGlzLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0WCggaW5kZXggKSB7XHJcblxyXG5cdFx0bGV0IHggPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WCggaW5kZXgsIHggKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB0b0hhbGZGbG9hdCggeCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFkoIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB5ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4geTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRZKCBpbmRleCwgeSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFooIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB6ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gejtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRaKCBpbmRleCwgeiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFcoIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB3ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gZGVub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRXKCBpbmRleCwgdyApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcclxuXHJcblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0gdG9IYWxmRmxvYXQoIHggKTtcclxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XHJcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcclxuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XHJcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHRvSGFsZkZsb2F0KCB6ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WFlaVyggaW5kZXgsIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcclxuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XHJcblx0XHRcdHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB0b0hhbGZGbG9hdCggeiApO1xyXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdHN1cGVyKCBuZXcgRmxvYXQ2NEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuZXhwb3J0IHtcclxuXHRGbG9hdDY0QnVmZmVyQXR0cmlidXRlLFxyXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXHJcblx0RmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRVaW50MzJCdWZmZXJBdHRyaWJ1dGUsXHJcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUsXHJcblx0VWludDE2QnVmZmVyQXR0cmlidXRlLFxyXG5cdEludDE2QnVmZmVyQXR0cmlidXRlLFxyXG5cdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZSxcclxuXHRJbnQ4QnVmZmVyQXR0cmlidXRlLFxyXG5cdEJ1ZmZlckF0dHJpYnV0ZVxyXG59O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuL09iamVjdDNELmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBhcnJheU5lZWRzVWludDMyIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xyXG5cclxubGV0IF9pZCA9IDA7XHJcblxyXG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF9vYmogPSAvKkBfX1BVUkVfXyovIG5ldyBPYmplY3QzRCgpO1xyXG5jb25zdCBfb2Zmc2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfYm94ID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xyXG5jb25zdCBfYm94TW9ycGhUYXJnZXRzID0gLypAX19QVVJFX18qLyBuZXcgQm94MygpO1xyXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY2xhc3MgQnVmZmVyR2VvbWV0cnkgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNCdWZmZXJHZW9tZXRyeSA9IHRydWU7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBfaWQgKysgfSApO1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xyXG5cclxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbmRleCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRJbmRleCggaW5kZXggKSB7XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xyXG5cclxuXHRcdFx0dGhpcy5pbmRleCA9IG5ldyAoIGFycmF5TmVlZHNVaW50MzIoIGluZGV4ICkgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgKSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRBdHRyaWJ1dGUoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlICkge1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0gYXR0cmlidXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlbGV0ZUF0dHJpYnV0ZSggbmFtZSApIHtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0aGFzQXR0cmlidXRlKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZEdyb3VwKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggPSAwICkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzLnB1c2goIHtcclxuXHJcblx0XHRcdHN0YXJ0OiBzdGFydCxcclxuXHRcdFx0Y291bnQ6IGNvdW50LFxyXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsZWFyR3JvdXBzKCkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RHJhd1JhbmdlKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcclxuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cG9zaXRpb24uYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0bm9ybWFsLmFwcGx5Tm9ybWFsTWF0cml4KCBub3JtYWxNYXRyaXggKTtcclxuXHJcblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRhbmdlbnQgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtcclxuXHJcblx0XHRpZiAoIHRhbmdlbnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRhbmdlbnQudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKTtcclxuXHJcblx0XHRcdHRhbmdlbnQubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XHJcblxyXG5cdFx0X20xLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVgoIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXHJcblxyXG5cdFx0X20xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVkoIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXHJcblxyXG5cdFx0X20xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXHJcblxyXG5cdFx0X20xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcclxuXHJcblx0XHRfbTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9tMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNjYWxlKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XHJcblxyXG5cdFx0X20xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xyXG5cclxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRsb29rQXQoIHZlY3RvciApIHtcclxuXHJcblx0XHRfb2JqLmxvb2tBdCggdmVjdG9yICk7XHJcblxyXG5cdFx0X29iai51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX29iai5tYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjZW50ZXIoKSB7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlciggX29mZnNldCApLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHRoaXMudHJhbnNsYXRlKCBfb2Zmc2V0LngsIF9vZmZzZXQueSwgX29mZnNldC56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHRwb3NpdGlvbi5wdXNoKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nQm94KCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0dMQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBib3guIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMgKTtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0KFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxyXG5cclxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcclxuXHRcdFx0XHRcdF9ib3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIHRoaXMuYm91bmRpbmdCb3gubWluLCBfYm94Lm1pbiApO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gubWF4ICk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF9ib3gubWluICk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5tYXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgc3BoZXJlLiBBbHRlcm5hdGl2ZWx5IHNldCBcIm1lc2guZnJ1c3R1bUN1bGxlZFwiIHRvIFwiZmFsc2VcIi4nLCB0aGlzICk7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldCggbmV3IFZlY3RvcjMoKSwgSW5maW5pdHkgKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxyXG5cclxuXHRcdFx0Y29uc3QgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XHJcblxyXG5cdFx0XHRfYm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxyXG5cclxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcclxuXHRcdFx0XHRcdF9ib3hNb3JwaFRhcmdldHMuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIF9ib3gubWluLCBfYm94TW9ycGhUYXJnZXRzLm1pbiApO1xyXG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggX2JveC5tYXgsIF9ib3hNb3JwaFRhcmdldHMubWF4ICk7XHJcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF9ib3hNb3JwaFRhcmdldHMubWluICk7XHJcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX2JveE1vcnBoVGFyZ2V0cy5tYXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9ib3guZ2V0Q2VudGVyKCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuXHRcdFx0Ly8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxyXG5cclxuXHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XHJcblxyXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcclxuXHJcblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XHJcblx0XHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG1vcnBoQXR0cmlidXRlLmNvdW50OyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBqICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfb2Zmc2V0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBqICk7XHJcblx0XHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGQoIF9vZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb21wdXRlVGFuZ2VudHMoKSB7XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxyXG5cdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXHJcblxyXG5cdFx0aWYgKCBpbmRleCA9PT0gbnVsbCB8fFxyXG5cdFx0XHQgYXR0cmlidXRlcy5wb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdCBhdHRyaWJ1dGVzLnV2ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSBpbmRleC5hcnJheTtcclxuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblx0XHRjb25zdCBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblx0XHRjb25zdCB1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xyXG5cclxuXHRcdGNvbnN0IG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXNBdHRyaWJ1dGUoICd0YW5nZW50JyApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndGFuZ2VudCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIDQgKiBuVmVydGljZXMgKSwgNCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRhbmdlbnRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoICd0YW5nZW50JyApLmFycmF5O1xyXG5cclxuXHRcdGNvbnN0IHRhbjEgPSBbXSwgdGFuMiA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSArKyApIHtcclxuXHJcblx0XHRcdHRhbjFbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHRhbjJbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHZBID0gbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0dkIgPSBuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHR2QyA9IG5ldyBWZWN0b3IzKCksXHJcblxyXG5cdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxyXG5cdFx0XHR1dkIgPSBuZXcgVmVjdG9yMigpLFxyXG5cdFx0XHR1dkMgPSBuZXcgVmVjdG9yMigpLFxyXG5cclxuXHRcdFx0c2RpciA9IG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdHRkaXIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XHJcblx0XHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xyXG5cdFx0XHR2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcclxuXHJcblx0XHRcdHV2QS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKTtcclxuXHRcdFx0dXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xyXG5cdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XHJcblxyXG5cdFx0XHR2Qi5zdWIoIHZBICk7XHJcblx0XHRcdHZDLnN1YiggdkEgKTtcclxuXHJcblx0XHRcdHV2Qi5zdWIoIHV2QSApO1xyXG5cdFx0XHR1dkMuc3ViKCB1dkEgKTtcclxuXHJcblx0XHRcdGNvbnN0IHIgPSAxLjAgLyAoIHV2Qi54ICogdXZDLnkgLSB1dkMueCAqIHV2Qi55ICk7XHJcblxyXG5cdFx0XHQvLyBzaWxlbnRseSBpZ25vcmUgZGVnZW5lcmF0ZSB1diB0cmlhbmdsZXMgaGF2aW5nIGNvaW5jaWRlbnQgb3IgY29saW5lYXIgdmVydGljZXNcclxuXHJcblx0XHRcdGlmICggISBpc0Zpbml0ZSggciApICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0c2Rpci5jb3B5KCB2QiApLm11bHRpcGx5U2NhbGFyKCB1dkMueSApLmFkZFNjYWxlZFZlY3RvciggdkMsIC0gdXZCLnkgKS5tdWx0aXBseVNjYWxhciggciApO1xyXG5cdFx0XHR0ZGlyLmNvcHkoIHZDICkubXVsdGlwbHlTY2FsYXIoIHV2Qi54ICkuYWRkU2NhbGVkVmVjdG9yKCB2QiwgLSB1dkMueCApLm11bHRpcGx5U2NhbGFyKCByICk7XHJcblxyXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XHJcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xyXG5cclxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xyXG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xyXG5cclxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGdyb3VwcyA9IFsge1xyXG5cdFx0XHRcdHN0YXJ0OiAwLFxyXG5cdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxyXG5cdFx0XHR9IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcclxuXHRcdFx0Y29uc3QgY291bnQgPSBncm91cC5jb3VudDtcclxuXHJcblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKFxyXG5cdFx0XHRcdFx0aW5kaWNlc1sgaiArIDAgXSxcclxuXHRcdFx0XHRcdGluZGljZXNbIGogKyAxIF0sXHJcblx0XHRcdFx0XHRpbmRpY2VzWyBqICsgMiBdXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKSwgdG1wMiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBuID0gbmV3IFZlY3RvcjMoKSwgbjIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcclxuXHJcblx0XHRcdG4uZnJvbUFycmF5KCBub3JtYWxzLCB2ICogMyApO1xyXG5cdFx0XHRuMi5jb3B5KCBuICk7XHJcblxyXG5cdFx0XHRjb25zdCB0ID0gdGFuMVsgdiBdO1xyXG5cclxuXHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcclxuXHJcblx0XHRcdHRtcC5jb3B5KCB0ICk7XHJcblx0XHRcdHRtcC5zdWIoIG4ubXVsdGlwbHlTY2FsYXIoIG4uZG90KCB0ICkgKSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcclxuXHJcblx0XHRcdHRtcDIuY3Jvc3NWZWN0b3JzKCBuMiwgdCApO1xyXG5cdFx0XHRjb25zdCB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xyXG5cdFx0XHRjb25zdCB3ID0gKCB0ZXN0IDwgMC4wICkgPyAtIDEuMCA6IDEuMDtcclxuXHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCBdID0gdG1wLng7XHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDEgXSA9IHRtcC55O1xyXG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAyIF0gPSB0bXAuejtcclxuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMyBdID0gdztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblxyXG5cdFx0XHRjb25zdCBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMCBdICk7XHJcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMSBdICk7XHJcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkge1xyXG5cclxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsZXQgbm9ybWFsQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICk7XHJcblxyXG5cdFx0XHRpZiAoIG5vcm1hbEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIDMgKSwgMyApO1xyXG5cdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbEF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGksIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgcEEgPSBuZXcgVmVjdG9yMygpLCBwQiA9IG5ldyBWZWN0b3IzKCksIHBDID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0Y29uc3QgbkEgPSBuZXcgVmVjdG9yMygpLCBuQiA9IG5ldyBWZWN0b3IzKCksIG5DID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0Y29uc3QgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gaW5kZXguY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHZBID0gaW5kZXguZ2V0WCggaSArIDAgKTtcclxuXHRcdFx0XHRcdGNvbnN0IHZCID0gaW5kZXguZ2V0WCggaSArIDEgKTtcclxuXHRcdFx0XHRcdGNvbnN0IHZDID0gaW5kZXguZ2V0WCggaSArIDIgKTtcclxuXHJcblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkEgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCB2QiApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIHZDICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5BLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkEgKTtcclxuXHRcdFx0XHRcdG5CLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkIgKTtcclxuXHRcdFx0XHRcdG5DLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkMgKTtcclxuXHJcblx0XHRcdFx0XHRuQS5hZGQoIGNiICk7XHJcblx0XHRcdFx0XHRuQi5hZGQoIGNiICk7XHJcblx0XHRcdFx0XHRuQy5hZGQoIGNiICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkEsIG5BLngsIG5BLnksIG5BLnogKTtcclxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZCLCBuQi54LCBuQi55LCBuQi56ICk7XHJcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QywgbkMueCwgbkMueSwgbkMueiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDAgKTtcclxuXHRcdFx0XHRcdHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICsgMSApO1xyXG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAyICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAwLCBjYi54LCBjYi55LCBjYi56ICk7XHJcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMSwgY2IueCwgY2IueSwgY2IueiApO1xyXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDIsIGNiLngsIGNiLnksIGNiLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XHJcblxyXG5cdFx0XHRub3JtYWxBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRub3JtYWxpemVOb3JtYWxzKCkge1xyXG5cclxuXHRcdGNvbnN0IG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBub3JtYWxzLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIGkgKTtcclxuXHJcblx0XHRcdF92ZWN0b3Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRub3JtYWxzLnNldFhZWiggaSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0b05vbkluZGV4ZWQoKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XHJcblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xyXG5cdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlLm5vcm1hbGl6ZWQ7XHJcblxyXG5cdFx0XHRjb25zdCBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcclxuXHJcblx0XHRcdGxldCBpbmRleCA9IDAsIGluZGV4MiA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHQvLyBhdHRyaWJ1dGVzXHJcblxyXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICk7XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXdBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbW9ycGggYXR0cmlidXRlc1xyXG5cclxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbW9ycGhBcnJheSA9IFtdO1xyXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVbIGkgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRpY2VzICk7XHJcblxyXG5cdFx0XHRcdG1vcnBoQXJyYXkucHVzaCggbmV3QXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBtb3JwaEFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xyXG5cclxuXHRcdC8vIGdyb3Vwc1xyXG5cclxuXHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5MjtcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHtcclxuXHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXHJcblx0XHRcdFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcclxuXHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMudXNlckRhdGEgKS5sZW5ndGggPiAwICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3Igc2ltcGxpY2l0eSB0aGUgY29kZSBhc3N1bWVzIGF0dHJpYnV0ZXMgYXJlIG5vdCBzaGFyZWQgYWNyb3NzIGdlb21ldHJpZXMsIHNlZSAjMTU4MTFcclxuXHJcblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XHJcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuXHRcdFx0XHRhcnJheTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5IClcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0gYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cdFx0bGV0IGhhc01vcnBoQXR0cmlidXRlcyA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhdHRyaWJ1dGVBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0YXJyYXkucHVzaCggYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYXJyYXkubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhBdHRyaWJ1dGVzWyBrZXkgXSA9IGFycmF5O1xyXG5cclxuXHRcdFx0XHRoYXNNb3JwaEF0dHJpYnV0ZXMgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGhhc01vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XHJcblx0XHRcdGRhdGEuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xyXG5cclxuXHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xyXG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcclxuXHRcdFx0XHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdC8vIHJlc2V0XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XHJcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHQvLyB1c2VkIGZvciBzdG9yaW5nIGNsb25lZCwgc2hhcmVkIGRhdGFcclxuXHJcblx0XHRjb25zdCBkYXRhID0ge307XHJcblxyXG5cdFx0Ly8gbmFtZVxyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuXHRcdC8vIGluZGV4XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSBzb3VyY2UuaW5kZXg7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCBkYXRhICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXR0cmlidXRlc1xyXG5cclxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoIGRhdGEgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb3JwaCBhdHRyaWJ1dGVzXHJcblxyXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFycmF5ID0gW107XHJcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0YXJyYXkucHVzaCggbW9ycGhBdHRyaWJ1dGVbIGkgXS5jbG9uZSggZGF0YSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7XHJcblxyXG5cdFx0Ly8gZ3JvdXBzXHJcblxyXG5cdFx0Y29uc3QgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBib3VuZGluZyBib3hcclxuXHJcblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJvdW5kaW5nIHNwaGVyZVxyXG5cclxuXHRcdGNvbnN0IGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZHJhdyByYW5nZVxyXG5cclxuXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcclxuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcclxuXHJcblx0XHQvLyB1c2VyIGRhdGFcclxuXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gc291cmNlLnVzZXJEYXRhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi4vbWF0aC9TcGhlcmUuanMnO1xyXG5pbXBvcnQgeyBSYXkgfSBmcm9tICcuLi9tYXRoL1JheS5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5pbXBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvVHJpYW5nbGUuanMnO1xyXG5pbXBvcnQgeyBCYWNrU2lkZSwgRnJvbnRTaWRlIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgTWVzaEJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5cclxuY29uc3QgX2ludmVyc2VNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF9yYXkgPSAvKkBfX1BVUkVfXyovIG5ldyBSYXkoKTtcclxuY29uc3QgX3NwaGVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNwaGVyZSgpO1xyXG5jb25zdCBfc3BoZXJlSGl0QXQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jb25zdCBfdkEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF92QiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZDID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX3RlbXBBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfbW9ycGhBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX3V2QSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcclxuY29uc3QgX3V2QiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcclxuY29uc3QgX3V2QyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcclxuXHJcbmNvbnN0IF9ub3JtYWxBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfbm9ybWFsQiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX25vcm1hbEMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY2xhc3MgTWVzaCBleHRlbmRzIE9iamVjdDNEIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCksIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCkgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzTWVzaCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2gnO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMuc2xpY2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1vcnBoVGFyZ2V0cygpIHtcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCBtb3JwaEF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRpZiAoIGtleXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXlzWyAwIF0gXTtcclxuXHJcblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XHJcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRWZXJ0ZXhQb3NpdGlvbiggaW5kZXgsIHRhcmdldCApIHtcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcclxuXHJcblx0XHR0YXJnZXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4ICk7XHJcblxyXG5cdFx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XHJcblxyXG5cdFx0aWYgKCBtb3JwaFBvc2l0aW9uICYmIG1vcnBoSW5mbHVlbmNlcyApIHtcclxuXHJcblx0XHRcdF9tb3JwaEEuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyBpIF07XHJcblx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaFBvc2l0aW9uWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdF90ZW1wQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSwgaW5kZXggKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcclxuXHJcblx0XHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvciggX3RlbXBBLCBpbmZsdWVuY2UgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfbW9ycGhBLmFkZFNjYWxlZFZlY3RvciggX3RlbXBBLnN1YiggdGFyZ2V0ICksIGluZmx1ZW5jZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0YXJnZXQuYWRkKCBfbW9ycGhBICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIHNwaGVyZSBpbiB3b3JsZCBzcGFjZVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHQvLyBjaGVjayBkaXN0YW5jZSBmcm9tIHJheSBvcmlnaW4gdG8gYm91bmRpbmcgc3BoZXJlXHJcblxyXG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkucmVjYXN0KCByYXljYXN0ZXIubmVhciApO1xyXG5cclxuXHRcdGlmICggX3NwaGVyZS5jb250YWluc1BvaW50KCBfcmF5Lm9yaWdpbiApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGlmICggX3JheS5pbnRlcnNlY3RTcGhlcmUoIF9zcGhlcmUsIF9zcGhlcmVIaXRBdCApID09PSBudWxsICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0aWYgKCBfcmF5Lm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggX3NwaGVyZUhpdEF0ICkgPiAoIHJheWNhc3Rlci5mYXIgLSByYXljYXN0ZXIubmVhciApICoqIDIgKSByZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbnZlcnQgcmF5IHRvIGxvY2FsIHNwYWNlIG9mIG1lc2hcclxuXHJcblx0XHRfaW52ZXJzZU1hdHJpeC5jb3B5KCBtYXRyaXhXb3JsZCApLmludmVydCgpO1xyXG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBfaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBib3ggaW4gbG9jYWwgc3BhY2VcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCBfcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB0ZXN0IGZvciBpbnRlcnNlY3Rpb25zIHdpdGggZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLl9jb21wdXRlSW50ZXJzZWN0aW9ucyggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBfcmF5ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2NvbXB1dGVJbnRlcnNlY3Rpb25zKCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJheUxvY2FsU3BhY2UgKSB7XHJcblxyXG5cdFx0bGV0IGludGVyc2VjdGlvbjtcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdGNvbnN0IHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcclxuXHRcdGNvbnN0IHV2MSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYxO1xyXG5cdFx0Y29uc3Qgbm9ybWFsID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XHJcblx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XHJcblxyXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgTWF0aC5taW4oICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApLCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICkgKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaiApO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBiID0gaW5kZXguZ2V0WCggaiArIDEgKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4LmdldFgoIGogKyAyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0dlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCBncm91cE1hdGVyaWFsLCByYXljYXN0ZXIsIHJheUxvY2FsU3BhY2UsIHV2LCB1djEsIG5vcm1hbCwgYSwgYiwgYyApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBqIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xyXG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4LmdldFgoIGkgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xyXG5cdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4LmdldFgoIGkgKyAyICk7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcclxuXHJcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCApO1xyXG5cdFx0XHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uLmNvdW50LCBNYXRoLm1pbiggKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICksICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKSApO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSBqO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBiID0gaiArIDE7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGMgPSBqICsgMjtcclxuXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIGdyb3VwTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGogLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBub24taW5kZXhlZCBidWZmZXIgc2VtYW50aWNzXHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoIDAsIGRyYXdSYW5nZS5zdGFydCApO1xyXG5cdFx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbi5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGk7XHJcblx0XHRcdFx0XHRjb25zdCBiID0gaSArIDE7XHJcblx0XHRcdFx0XHRjb25zdCBjID0gaSArIDI7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5TG9jYWxTcGFjZSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIG5vbi1pbmRleGVkIGJ1ZmZlciBzZW1hbnRpY3NcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQgKSB7XHJcblxyXG5cdGxldCBpbnRlcnNlY3Q7XHJcblxyXG5cdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XHJcblxyXG5cdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgKCBtYXRlcmlhbC5zaWRlID09PSBGcm9udFNpZGUgKSwgcG9pbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuXHRfaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBwb2ludCApO1xyXG5cdF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggX2ludGVyc2VjdGlvblBvaW50V29ybGQgKTtcclxuXHJcblx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0cG9pbnQ6IF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXHJcblx0XHRvYmplY3Q6IG9iamVjdFxyXG5cdH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0dlb21ldHJ5SW50ZXJzZWN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgdXYsIHV2MSwgbm9ybWFsLCBhLCBiLCBjICkge1xyXG5cclxuXHRvYmplY3QuZ2V0VmVydGV4UG9zaXRpb24oIGEsIF92QSApO1xyXG5cdG9iamVjdC5nZXRWZXJ0ZXhQb3NpdGlvbiggYiwgX3ZCICk7XHJcblx0b2JqZWN0LmdldFZlcnRleFBvc2l0aW9uKCBjLCBfdkMgKTtcclxuXHJcblx0Y29uc3QgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBfdkEsIF92QiwgX3ZDLCBfaW50ZXJzZWN0aW9uUG9pbnQgKTtcclxuXHJcblx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0aWYgKCB1diApIHtcclxuXHJcblx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGEgKTtcclxuXHRcdFx0X3V2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYiApO1xyXG5cdFx0XHRfdXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBjICk7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3Rpb24udXYgPSBUcmlhbmdsZS5nZXRJbnRlcnBvbGF0aW9uKCBfaW50ZXJzZWN0aW9uUG9pbnQsIF92QSwgX3ZCLCBfdkMsIF91dkEsIF91dkIsIF91dkMsIG5ldyBWZWN0b3IyKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1djEgKSB7XHJcblxyXG5cdFx0XHRfdXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYSApO1xyXG5cdFx0XHRfdXZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYiApO1xyXG5cdFx0XHRfdXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYyApO1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0aW9uLnV2MSA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSApO1xyXG5cdFx0XHRpbnRlcnNlY3Rpb24udXYyID0gaW50ZXJzZWN0aW9uLnV2MTsgLy8gQGRlcHJlY2F0ZWQsIHIxNTJcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBub3JtYWwgKSB7XHJcblxyXG5cdFx0XHRfbm9ybWFsQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGEgKTtcclxuXHRcdFx0X25vcm1hbEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBiICk7XHJcblx0XHRcdF9ub3JtYWxDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYyApO1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX25vcm1hbEEsIF9ub3JtYWxCLCBfbm9ybWFsQywgbmV3IFZlY3RvcjMoKSApO1xyXG5cclxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubm9ybWFsLmRvdCggcmF5LmRpcmVjdGlvbiApID4gMCApIHtcclxuXHJcblx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbC5tdWx0aXBseVNjYWxhciggLSAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGZhY2UgPSB7XHJcblx0XHRcdGE6IGEsXHJcblx0XHRcdGI6IGIsXHJcblx0XHRcdGM6IGMsXHJcblx0XHRcdG5vcm1hbDogbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0bWF0ZXJpYWxJbmRleDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHRUcmlhbmdsZS5nZXROb3JtYWwoIF92QSwgX3ZCLCBfdkMsIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBmYWNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBpbnRlcnNlY3Rpb247XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBNZXNoIH07XHJcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuY2xhc3MgQm94R2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIGRlcHRoID0gMSwgd2lkdGhTZWdtZW50cyA9IDEsIGhlaWdodFNlZ21lbnRzID0gMSwgZGVwdGhTZWdtZW50cyA9IDEgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0ZGVwdGg6IGRlcHRoLFxyXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdC8vIHNlZ21lbnRzXHJcblxyXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKTtcclxuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKTtcclxuXHRcdGRlcHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKCBkZXB0aFNlZ21lbnRzICk7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XHJcblx0XHRjb25zdCBub3JtYWxzID0gW107XHJcblx0XHRjb25zdCB1dnMgPSBbXTtcclxuXHJcblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXHJcblxyXG5cdFx0bGV0IG51bWJlck9mVmVydGljZXMgPSAwO1xyXG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xyXG5cclxuXHRcdC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XHJcblxyXG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxyXG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSApOyAvLyBueFxyXG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgMSwgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDIgKTsgLy8gcHlcclxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMyApOyAvLyBueVxyXG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQgKTsgLy8gcHpcclxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNSApOyAvLyBuelxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0XHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB3LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ3JpZFgsIGdyaWRZLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2VnbWVudFdpZHRoID0gd2lkdGggLyBncmlkWDtcclxuXHRcdFx0Y29uc3Qgc2VnbWVudEhlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xyXG5cclxuXHRcdFx0Y29uc3Qgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xyXG5cdFx0XHRjb25zdCBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcclxuXHRcdFx0Y29uc3QgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xyXG5cclxuXHRcdFx0Y29uc3QgZ3JpZFgxID0gZ3JpZFggKyAxO1xyXG5cdFx0XHRjb25zdCBncmlkWTEgPSBncmlkWSArIDE7XHJcblxyXG5cdFx0XHRsZXQgdmVydGV4Q291bnRlciA9IDA7XHJcblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcclxuXHJcblx0XHRcdGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHkgPSBpeSAqIHNlZ21lbnRIZWlnaHQgLSBoZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGl4ICogc2VnbWVudFdpZHRoIC0gd2lkdGhIYWxmO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XHJcblxyXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSB4ICogdWRpcjtcclxuXHRcdFx0XHRcdHZlY3RvclsgdiBdID0geSAqIHZkaXI7XHJcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoSGFsZjtcclxuXHJcblx0XHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIHZlcnRleCBidWZmZXJcclxuXHJcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3JbIHUgXSA9IDA7XHJcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IDA7XHJcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXHJcblxyXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXZzXHJcblxyXG5cdFx0XHRcdFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcclxuXHRcdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBjb3VudGVyc1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleENvdW50ZXIgKz0gMTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2VcclxuXHRcdFx0Ly8gMi4gYSBzaW5nbGUgc2VnbWVudCBjb25zaXN0cyBvZiB0d28gZmFjZXNcclxuXHRcdFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxyXG5cclxuXHRcdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcclxuXHRcdFx0XHRcdGNvbnN0IGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdFx0Y29uc3QgYyA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xyXG5cclxuXHRcdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBpbmNyZWFzZSBjb3VudGVyXHJcblxyXG5cdFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxyXG5cclxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIG1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xyXG5cclxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgQm94R2VvbWV0cnkoIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLmRlcHRoLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEuZGVwdGhTZWdtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBCb3hHZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBMaW5lYXJTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKipcclxuICogVW5pZm9ybSBVdGlsaXRpZXNcclxuICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVVbmlmb3Jtcyggc3JjICkge1xyXG5cclxuXHRjb25zdCBkc3QgPSB7fTtcclxuXHJcblx0Zm9yICggY29uc3QgdSBpbiBzcmMgKSB7XHJcblxyXG5cdFx0ZHN0WyB1IF0gPSB7fTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBwIGluIHNyY1sgdSBdICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcHJvcGVydHkgPSBzcmNbIHUgXVsgcCBdO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9wZXJ0eSAmJiAoIHByb3BlcnR5LmlzQ29sb3IgfHxcclxuXHRcdFx0XHRwcm9wZXJ0eS5pc01hdHJpeDMgfHwgcHJvcGVydHkuaXNNYXRyaXg0IHx8XHJcblx0XHRcdFx0cHJvcGVydHkuaXNWZWN0b3IyIHx8IHByb3BlcnR5LmlzVmVjdG9yMyB8fCBwcm9wZXJ0eS5pc1ZlY3RvcjQgfHxcclxuXHRcdFx0XHRwcm9wZXJ0eS5pc1RleHR1cmUgfHwgcHJvcGVydHkuaXNRdWF0ZXJuaW9uICkgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcHJvcGVydHkuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1VuaWZvcm1zVXRpbHM6IFRleHR1cmVzIG9mIHJlbmRlciB0YXJnZXRzIGNhbm5vdCBiZSBjbG9uZWQgdmlhIGNsb25lVW5pZm9ybXMoKSBvciBtZXJnZVVuaWZvcm1zKCkuJyApO1xyXG5cdFx0XHRcdFx0ZHN0WyB1IF1bIHAgXSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZHN0WyB1IF1bIHAgXSA9IHByb3BlcnR5LmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHByb3BlcnR5ICkgKSB7XHJcblxyXG5cdFx0XHRcdGRzdFsgdSBdWyBwIF0gPSBwcm9wZXJ0eS5zbGljZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZHN0WyB1IF1bIHAgXSA9IHByb3BlcnR5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZHN0O1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVW5pZm9ybXMoIHVuaWZvcm1zICkge1xyXG5cclxuXHRjb25zdCBtZXJnZWQgPSB7fTtcclxuXHJcblx0Zm9yICggbGV0IHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xyXG5cclxuXHRcdGNvbnN0IHRtcCA9IGNsb25lVW5pZm9ybXMoIHVuaWZvcm1zWyB1IF0gKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBwIGluIHRtcCApIHtcclxuXHJcblx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBtZXJnZWQ7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVVbmlmb3Jtc0dyb3Vwcyggc3JjICkge1xyXG5cclxuXHRjb25zdCBkc3QgPSBbXTtcclxuXHJcblx0Zm9yICggbGV0IHUgPSAwOyB1IDwgc3JjLmxlbmd0aDsgdSArKyApIHtcclxuXHJcblx0XHRkc3QucHVzaCggc3JjWyB1IF0uY2xvbmUoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBkc3Q7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5saXRVbmlmb3JtQ29sb3JTcGFjZSggcmVuZGVyZXIgKSB7XHJcblxyXG5cdGlmICggcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCkgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzOTM3I2lzc3VlY29tbWVudC0xMTExMDY3Mzk4XHJcblx0XHRyZXR1cm4gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gTGluZWFyU1JHQkNvbG9yU3BhY2U7XHJcblxyXG59XHJcblxyXG4vLyBMZWdhY3lcclxuXHJcbmNvbnN0IFVuaWZvcm1zVXRpbHMgPSB7IGNsb25lOiBjbG9uZVVuaWZvcm1zLCBtZXJnZTogbWVyZ2VVbmlmb3JtcyB9O1xyXG5cclxuZXhwb3J0IHsgVW5pZm9ybXNVdGlscyB9O1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG52b2lkIG1haW4oKSB7XHJcblx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xyXG59XHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbnZvaWQgbWFpbigpIHtcclxuXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcclxufVxyXG5gO1xyXG4iLCJpbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBjbG9uZVVuaWZvcm1zLCBjbG9uZVVuaWZvcm1zR3JvdXBzIH0gZnJvbSAnLi4vcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qcyc7XHJcblxyXG5pbXBvcnQgZGVmYXVsdF92ZXJ0ZXggZnJvbSAnLi4vcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdF92ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBkZWZhdWx0X2ZyYWdtZW50IGZyb20gJy4uL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcblxyXG5jbGFzcyBTaGFkZXJNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0ge307XHJcblx0XHR0aGlzLnVuaWZvcm1zID0ge307XHJcblx0XHR0aGlzLnVuaWZvcm1zR3JvdXBzID0gW107XHJcblxyXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBkZWZhdWx0X3ZlcnRleDtcclxuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBkZWZhdWx0X2ZyYWdtZW50O1xyXG5cclxuXHRcdHRoaXMubGluZXdpZHRoID0gMTtcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHRcdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xyXG5cdFx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcclxuXHJcblx0XHR0aGlzLmZvcmNlU2luZ2xlUGFzcyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge1xyXG5cdFx0XHRkZXJpdmF0aXZlczogZmFsc2UsIC8vIHNldCB0byB1c2UgZGVyaXZhdGl2ZXNcclxuXHRcdFx0ZnJhZ0RlcHRoOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBmcmFnbWVudCBkZXB0aCB2YWx1ZXNcclxuXHRcdFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xyXG5cdFx0XHRzaGFkZXJUZXh0dXJlTE9EOiBmYWxzZSAvLyBzZXQgdG8gdXNlIHNoYWRlciB0ZXh0dXJlIExPRFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcclxuXHRcdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cclxuXHRcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcclxuXHRcdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXHJcblx0XHRcdCd1dic6IFsgMCwgMCBdLFxyXG5cdFx0XHQndXYxJzogWyAwLCAwIF1cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy51bmlmb3Jtc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmdsc2xWZXJzaW9uID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xyXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMgPSBjbG9uZVVuaWZvcm1zKCBzb3VyY2UudW5pZm9ybXMgKTtcclxuXHRcdHRoaXMudW5pZm9ybXNHcm91cHMgPSBjbG9uZVVuaWZvcm1zR3JvdXBzKCBzb3VyY2UudW5pZm9ybXNHcm91cHMgKTtcclxuXHJcblx0XHR0aGlzLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLmRlZmluZXMgKTtcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cdFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xyXG5cdFx0dGhpcy5jbGlwcGluZyA9IHNvdXJjZS5jbGlwcGluZztcclxuXHJcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLmV4dGVuc2lvbnMgKTtcclxuXHJcblx0XHR0aGlzLmdsc2xWZXJzaW9uID0gc291cmNlLmdsc2xWZXJzaW9uO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggbWV0YSApIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XHJcblxyXG5cdFx0ZGF0YS5nbHNsVmVyc2lvbiA9IHRoaXMuZ2xzbFZlcnNpb247XHJcblx0XHRkYXRhLnVuaWZvcm1zID0ge307XHJcblxyXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiB0aGlzLnVuaWZvcm1zICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbIG5hbWUgXTtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcclxuXHRcdFx0XHRcdHR5cGU6ICd0JyxcclxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0pTT04oIG1ldGEgKS51dWlkXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIHZhbHVlLmlzQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcclxuXHRcdFx0XHRcdHR5cGU6ICdjJyxcclxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS5nZXRIZXgoKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc1ZlY3RvcjIgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcclxuXHRcdFx0XHRcdHR5cGU6ICd2MicsXHJcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIHZhbHVlLmlzVmVjdG9yMyApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xyXG5cdFx0XHRcdFx0dHlwZTogJ3YzJyxcclxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNWZWN0b3I0ICkge1xyXG5cclxuXHRcdFx0XHRkYXRhLnVuaWZvcm1zWyBuYW1lIF0gPSB7XHJcblx0XHRcdFx0XHR0eXBlOiAndjQnLFxyXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlLnRvQXJyYXkoKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc01hdHJpeDMgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEudW5pZm9ybXNbIG5hbWUgXSA9IHtcclxuXHRcdFx0XHRcdHR5cGU6ICdtMycsXHJcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWUudG9BcnJheSgpXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIHZhbHVlLmlzTWF0cml4NCApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xyXG5cdFx0XHRcdFx0dHlwZTogJ200JyxcclxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZS50b0FycmF5KClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZGF0YS51bmlmb3Jtc1sgbmFtZSBdID0ge1xyXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Ly8gbm90ZTogdGhlIGFycmF5IHZhcmlhbnRzIHYydiwgdjN2LCB2NHYsIG00diBhbmQgdHYgYXJlIG5vdCBzdXBwb3J0ZWQgc28gZmFyXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggT2JqZWN0LmtleXMoIHRoaXMuZGVmaW5lcyApLmxlbmd0aCA+IDAgKSBkYXRhLmRlZmluZXMgPSB0aGlzLmRlZmluZXM7XHJcblxyXG5cdFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuXHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdGRhdGEubGlnaHRzID0gdGhpcy5saWdodHM7XHJcblx0XHRkYXRhLmNsaXBwaW5nID0gdGhpcy5jbGlwcGluZztcclxuXHJcblx0XHRjb25zdCBleHRlbnNpb25zID0ge307XHJcblxyXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIHRoaXMuZXh0ZW5zaW9ucyApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5leHRlbnNpb25zWyBrZXkgXSA9PT0gdHJ1ZSApIGV4dGVuc2lvbnNbIGtleSBdID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggZXh0ZW5zaW9ucyApLmxlbmd0aCA+IDAgKSBkYXRhLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTaGFkZXJNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuXHJcbmNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzQ2FtZXJhID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XHJcblxyXG5cdFx0dGhpcy5jb29yZGluYXRlU3lzdGVtID0gc291cmNlLmNvb3JkaW5hdGVTeXN0ZW07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0V29ybGREaXJlY3Rpb24oIHRhcmdldCApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdGNvbnN0IGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc2V0KCAtIGVbIDggXSwgLSBlWyA5IF0sIC0gZVsgMTAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlV29ybGRNYXRyaXgoIHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuICkge1xyXG5cclxuXHRcdHN1cGVyLnVwZGF0ZVdvcmxkTWF0cml4KCB1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbiApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IENhbWVyYSB9O1xyXG4iLCJpbXBvcnQgeyBDYW1lcmEgfSBmcm9tICcuL0NhbWVyYS5qcyc7XHJcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcblxyXG5jbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYSBleHRlbmRzIENhbWVyYSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBmb3YgPSA1MCwgYXNwZWN0ID0gMSwgbmVhciA9IDAuMSwgZmFyID0gMjAwMCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcclxuXHJcblx0XHR0aGlzLmZvdiA9IGZvdjtcclxuXHRcdHRoaXMuem9vbSA9IDE7XHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcclxuXHRcdHRoaXMuZmFyID0gZmFyO1xyXG5cdFx0dGhpcy5mb2N1cyA9IDEwO1xyXG5cclxuXHRcdHRoaXMuYXNwZWN0ID0gYXNwZWN0O1xyXG5cdFx0dGhpcy52aWV3ID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmZpbG1HYXVnZSA9IDM1O1x0Ly8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXHJcblx0XHR0aGlzLmZpbG1PZmZzZXQgPSAwO1x0Ly8gaG9yaXpvbnRhbCBmaWxtIG9mZnNldCAoc2FtZSB1bml0IGFzIGdhdWdlKVxyXG5cclxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xyXG5cdFx0dGhpcy56b29tID0gc291cmNlLnpvb207XHJcblxyXG5cdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcblx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblx0XHR0aGlzLmZvY3VzID0gc291cmNlLmZvY3VzO1xyXG5cclxuXHRcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcclxuXHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xyXG5cclxuXHRcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcclxuXHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxyXG5cdCAqXHJcblx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXHJcblx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXHJcblx0ICpcclxuXHQgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cclxuXHQgKi9cclxuXHRzZXRGb2NhbExlbmd0aCggZm9jYWxMZW5ndGggKSB7XHJcblxyXG5cdFx0LyoqIHNlZSB7QGxpbmsgaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWx9ICovXHJcblx0XHRjb25zdCB2RXh0ZW50U2xvcGUgPSAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIGZvY2FsTGVuZ3RoO1xyXG5cclxuXHRcdHRoaXMuZm92ID0gTWF0aFV0aWxzLlJBRDJERUcgKiAyICogTWF0aC5hdGFuKCB2RXh0ZW50U2xvcGUgKTtcclxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZXMgdGhlIGZvY2FsIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IC5mb3YgYW5kIC5maWxtR2F1Z2UuXHJcblx0ICovXHJcblx0Z2V0Rm9jYWxMZW5ndGgoKSB7XHJcblxyXG5cdFx0Y29uc3QgdkV4dGVudFNsb3BlID0gTWF0aC50YW4oIE1hdGhVdGlscy5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKTtcclxuXHJcblx0XHRyZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyB2RXh0ZW50U2xvcGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RWZmZWN0aXZlRk9WKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoVXRpbHMuUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oXHJcblx0XHRcdE1hdGgudGFuKCBNYXRoVXRpbHMuREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20gKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGaWxtV2lkdGgoKSB7XHJcblxyXG5cdFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIHBvcnRyYWl0IGZvcm1hdCAoYXNwZWN0IDwgMSlcclxuXHRcdHJldHVybiB0aGlzLmZpbG1HYXVnZSAqIE1hdGgubWluKCB0aGlzLmFzcGVjdCwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEZpbG1IZWlnaHQoKSB7XHJcblxyXG5cdFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIGxhbmRzY2FwZSBmb3JtYXQgKGFzcGVjdCA+IDEpXHJcblx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCggdGhpcy5hc3BlY3QsIDEgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXHJcblx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cclxuXHQgKlxyXG5cdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXHJcblx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xyXG5cdCAqXHJcblx0ICogICArLS0tKy0tLSstLS0rXHJcblx0ICogICB8IEEgfCBCIHwgQyB8XHJcblx0ICogICArLS0tKy0tLSstLS0rXHJcblx0ICogICB8IEQgfCBFIHwgRiB8XHJcblx0ICogICArLS0tKy0tLSstLS0rXHJcblx0ICpcclxuXHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXHJcblx0ICpcclxuXHQgKiAgIGNvbnN0IHcgPSAxOTIwO1xyXG5cdCAqICAgY29uc3QgaCA9IDEwODA7XHJcblx0ICogICBjb25zdCBmdWxsV2lkdGggPSB3ICogMztcclxuXHQgKiAgIGNvbnN0IGZ1bGxIZWlnaHQgPSBoICogMjtcclxuXHQgKlxyXG5cdCAqICAgLS1BLS1cclxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xyXG5cdCAqICAgLS1CLS1cclxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xyXG5cdCAqICAgLS1DLS1cclxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xyXG5cdCAqICAgLS1ELS1cclxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xyXG5cdCAqICAgLS1FLS1cclxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xyXG5cdCAqICAgLS1GLS1cclxuXHQgKiAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xyXG5cdCAqXHJcblx0ICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxyXG5cdCAqL1xyXG5cdHNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHR0aGlzLmFzcGVjdCA9IGZ1bGxXaWR0aCAvIGZ1bGxIZWlnaHQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZpZXcgPSB7XHJcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdFx0XHRmdWxsV2lkdGg6IDEsXHJcblx0XHRcdFx0ZnVsbEhlaWdodDogMSxcclxuXHRcdFx0XHRvZmZzZXRYOiAwLFxyXG5cdFx0XHRcdG9mZnNldFk6IDAsXHJcblx0XHRcdFx0d2lkdGg6IDEsXHJcblx0XHRcdFx0aGVpZ2h0OiAxXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XHJcblx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XHJcblx0XHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XHJcblx0XHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XHJcblx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcclxuXHRcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xlYXJWaWV3T2Zmc2V0KCkge1xyXG5cclxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcclxuXHJcblx0XHRjb25zdCBuZWFyID0gdGhpcy5uZWFyO1xyXG5cdFx0bGV0IHRvcCA9IG5lYXIgKiBNYXRoLnRhbiggTWF0aFV0aWxzLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApIC8gdGhpcy56b29tO1xyXG5cdFx0bGV0IGhlaWdodCA9IDIgKiB0b3A7XHJcblx0XHRsZXQgd2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodDtcclxuXHRcdGxldCBsZWZ0ID0gLSAwLjUgKiB3aWR0aDtcclxuXHRcdGNvbnN0IHZpZXcgPSB0aGlzLnZpZXc7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgJiYgdGhpcy52aWV3LmVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBmdWxsV2lkdGggPSB2aWV3LmZ1bGxXaWR0aCxcclxuXHRcdFx0XHRmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xyXG5cclxuXHRcdFx0bGVmdCArPSB2aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcclxuXHRcdFx0dG9wIC09IHZpZXcub2Zmc2V0WSAqIGhlaWdodCAvIGZ1bGxIZWlnaHQ7XHJcblx0XHRcdHdpZHRoICo9IHZpZXcud2lkdGggLyBmdWxsV2lkdGg7XHJcblx0XHRcdGhlaWdodCAqPSB2aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNrZXcgPSB0aGlzLmZpbG1PZmZzZXQ7XHJcblx0XHRpZiAoIHNrZXcgIT09IDAgKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCwgdG9wIC0gaGVpZ2h0LCBuZWFyLCB0aGlzLmZhciwgdGhpcy5jb29yZGluYXRlU3lzdGVtICk7XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oIG1ldGEgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xyXG5cclxuXHRcdGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xyXG5cdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcclxuXHJcblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XHJcblx0XHRkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XHJcblxyXG5cdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xyXG5cclxuXHRcdGRhdGEub2JqZWN0LmZpbG1HYXVnZSA9IHRoaXMuZmlsbUdhdWdlO1xyXG5cdFx0ZGF0YS5vYmplY3QuZmlsbU9mZnNldCA9IHRoaXMuZmlsbU9mZnNldDtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfTtcclxuIiwiaW1wb3J0IHsgTm9Ub25lTWFwcGluZywgV2ViR0xDb29yZGluYXRlU3lzdGVtLCBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICcuL1BlcnNwZWN0aXZlQ2FtZXJhLmpzJztcclxuXHJcbmNvbnN0IGZvdiA9IC0gOTA7IC8vIG5lZ2F0aXZlIGZvdiBpcyBub3QgYW4gZXJyb3JcclxuY29uc3QgYXNwZWN0ID0gMTtcclxuXHJcbmNsYXNzIEN1YmVDYW1lcmEgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuZWFyLCBmYXIsIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcclxuXHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IG51bGw7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYVBYLmxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhTlggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYU5YLmxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhUFkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYVBZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYU5ZLmxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5ZICk7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhUFogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYVBaLmxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhTlogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYU5aLmxheWVycyA9IHRoaXMubGF5ZXJzO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQ29vcmRpbmF0ZVN5c3RlbSgpIHtcclxuXHJcblx0XHRjb25zdCBjb29yZGluYXRlU3lzdGVtID0gdGhpcy5jb29yZGluYXRlU3lzdGVtO1xyXG5cclxuXHRcdGNvbnN0IGNhbWVyYXMgPSB0aGlzLmNoaWxkcmVuLmNvbmNhdCgpO1xyXG5cclxuXHRcdGNvbnN0IFsgY2FtZXJhUFgsIGNhbWVyYU5YLCBjYW1lcmFQWSwgY2FtZXJhTlksIGNhbWVyYVBaLCBjYW1lcmFOWiBdID0gY2FtZXJhcztcclxuXHJcblx0XHRmb3IgKCBjb25zdCBjYW1lcmEgb2YgY2FtZXJhcyApIHRoaXMucmVtb3ZlKCBjYW1lcmEgKTtcclxuXHJcblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdGNhbWVyYVBYLnVwLnNldCggMCwgMSwgMCApO1xyXG5cdFx0XHRjYW1lcmFQWC5sb29rQXQoIDEsIDAsIDAgKTtcclxuXHJcblx0XHRcdGNhbWVyYU5YLnVwLnNldCggMCwgMSwgMCApO1xyXG5cdFx0XHRjYW1lcmFOWC5sb29rQXQoIC0gMSwgMCwgMCApO1xyXG5cclxuXHRcdFx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAtIDEgKTtcclxuXHRcdFx0Y2FtZXJhUFkubG9va0F0KCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHRjYW1lcmFOWS51cC5zZXQoIDAsIDAsIDEgKTtcclxuXHRcdFx0Y2FtZXJhTlkubG9va0F0KCAwLCAtIDEsIDAgKTtcclxuXHJcblx0XHRcdGNhbWVyYVBaLnVwLnNldCggMCwgMSwgMCApO1xyXG5cdFx0XHRjYW1lcmFQWi5sb29rQXQoIDAsIDAsIDEgKTtcclxuXHJcblx0XHRcdGNhbWVyYU5aLnVwLnNldCggMCwgMSwgMCApO1xyXG5cdFx0XHRjYW1lcmFOWi5sb29rQXQoIDAsIDAsIC0gMSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0XHRjYW1lcmFQWC51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdFx0XHRjYW1lcmFQWC5sb29rQXQoIC0gMSwgMCwgMCApO1xyXG5cclxuXHRcdFx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRcdFx0Y2FtZXJhTlgubG9va0F0KCAxLCAwLCAwICk7XHJcblxyXG5cdFx0XHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcclxuXHRcdFx0Y2FtZXJhUFkubG9va0F0KCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHRjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0gMSApO1xyXG5cdFx0XHRjYW1lcmFOWS5sb29rQXQoIDAsIC0gMSwgMCApO1xyXG5cclxuXHRcdFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRcdFx0Y2FtZXJhUFoubG9va0F0KCAwLCAwLCAxICk7XHJcblxyXG5cdFx0XHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdFx0XHRjYW1lcmFOWi5sb29rQXQoIDAsIDAsIC0gMSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5DdWJlQ2FtZXJhLnVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggY29uc3QgY2FtZXJhIG9mIGNhbWVyYXMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFkZCggY2FtZXJhICk7XHJcblxyXG5cdFx0XHRjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCByZW5kZXJlciwgc2NlbmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcclxuXHJcblx0XHRpZiAoIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSAhPT0gcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IHJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW07XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZUNvb3JkaW5hdGVTeXN0ZW0oKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgWyBjYW1lcmFQWCwgY2FtZXJhTlgsIGNhbWVyYVBZLCBjYW1lcmFOWSwgY2FtZXJhUFosIGNhbWVyYU5aIF0gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHJcblx0XHRjb25zdCBjdXJyZW50VG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcclxuXHRcdGNvbnN0IGN1cnJlbnRYckVuYWJsZWQgPSByZW5kZXJlci54ci5lbmFibGVkO1xyXG5cclxuXHRcdHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcclxuXHRcdHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDAgKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDEgKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDIgKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDMgKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQsIDQgKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCA1ICk7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggY3VycmVudFJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gY3VycmVudFRvbmVNYXBwaW5nO1xyXG5cdFx0cmVuZGVyZXIueHIuZW5hYmxlZCA9IGN1cnJlbnRYckVuYWJsZWQ7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUubmVlZHNQTVJFTVVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEN1YmVDYW1lcmEgfTtcclxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBDdWJlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0aW1hZ2VzID0gaW1hZ2VzICE9PSB1bmRlZmluZWQgPyBpbWFnZXMgOiBbXTtcclxuXHRcdG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xyXG5cclxuXHRcdHN1cGVyKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdHRoaXMuaXNDdWJlVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBpbWFnZXMoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaW1hZ2U7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IGltYWdlcyggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5pbWFnZSA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDdWJlVGV4dHVyZSB9O1xyXG4iLCJpbXBvcnQgeyBCYWNrU2lkZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIE5vQmxlbmRpbmcsIE5vQ29sb3JTcGFjZSwgU1JHQkNvbG9yU3BhY2UsIHNSR0JFbmNvZGluZyB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9vYmplY3RzL01lc2guanMnO1xyXG5pbXBvcnQgeyBCb3hHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9TaGFkZXJNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IGNsb25lVW5pZm9ybXMgfSBmcm9tICcuL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9XZWJHTFJlbmRlclRhcmdldC5qcyc7XHJcbmltcG9ydCB7IEN1YmVDYW1lcmEgfSBmcm9tICcuLi9jYW1lcmFzL0N1YmVDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBDdWJlVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcblxyXG5jbGFzcyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQgZXh0ZW5kcyBXZWJHTFJlbmRlclRhcmdldCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBzaXplID0gMSwgb3B0aW9ucyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCBzaXplLCBzaXplLCBvcHRpb25zICk7XHJcblxyXG5cdFx0dGhpcy5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9IHRydWU7XHJcblxyXG5cdFx0Y29uc3QgaW1hZ2UgPSB7IHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUsIGRlcHRoOiAxIH07XHJcblx0XHRjb25zdCBpbWFnZXMgPSBbIGltYWdlLCBpbWFnZSwgaW1hZ2UsIGltYWdlLCBpbWFnZSwgaW1hZ2UgXTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIEBkZXByZWNhdGVkLCByMTUyXHJcblx0XHRcdHdhcm5PbmNlKCAnVEhSRUUuV2ViR0xDdWJlUmVuZGVyVGFyZ2V0OiBvcHRpb24uZW5jb2RpbmcgaGFzIGJlZW4gcmVwbGFjZWQgYnkgb3B0aW9uLmNvbG9yU3BhY2UuJyApO1xyXG5cdFx0XHRvcHRpb25zLmNvbG9yU3BhY2UgPSBvcHRpb25zLmVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IE5vQ29sb3JTcGFjZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCBpbWFnZXMsIG9wdGlvbnMubWFwcGluZywgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdC8vIEJ5IGNvbnZlbnRpb24gLS0gbGlrZWx5IGJhc2VkIG9uIHRoZSBSZW5kZXJNYW4gc3BlYyBmcm9tIHRoZSAxOTkwJ3MgLS0gY3ViZSBtYXBzIGFyZSBzcGVjaWZpZWQgYnkgV2ViR0wgKGFuZCB0aHJlZS5qcylcclxuXHRcdC8vIGluIGEgY29vcmRpbmF0ZSBzeXN0ZW0gaW4gd2hpY2ggcG9zaXRpdmUteCBpcyB0byB0aGUgcmlnaHQgd2hlbiBsb29raW5nIHVwIHRoZSBwb3NpdGl2ZS16IGF4aXMgLS0gaW4gb3RoZXIgd29yZHMsXHJcblx0XHQvLyBpbiBhIGxlZnQtaGFuZGVkIGNvb3JkaW5hdGUgc3lzdGVtLiBCeSBjb250aW51aW5nIHRoaXMgY29udmVudGlvbiwgcHJlZXhpc3RpbmcgY3ViZSBtYXBzIGNvbnRpbnVlZCB0byByZW5kZXIgY29ycmVjdGx5LlxyXG5cclxuXHRcdC8vIHRocmVlLmpzIHVzZXMgYSByaWdodC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIFNvIGVudmlyb25tZW50IG1hcHMgdXNlZCBpbiB0aHJlZS5qcyBhcHBlYXIgdG8gaGF2ZSBweCBhbmQgbnggc3dhcHBlZFxyXG5cdFx0Ly8gYW5kIHRoZSBmbGFnIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBjb250cm9scyB0aGlzIGNvbnZlcnNpb24uIFRoZSBmbGlwIGlzIG5vdCByZXF1aXJlZCB3aGVuIHVzaW5nIFdlYkdMQ3ViZVJlbmRlclRhcmdldC50ZXh0dXJlXHJcblx0XHQvLyBhcyBhIGN1YmUgdGV4dHVyZSAodGhpcyBpcyBkZXRlY3RlZCB3aGVuIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBpcyBzZXQgdG8gdHJ1ZSBmb3IgY3ViZSB0ZXh0dXJlcykuXHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xyXG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IG9wdGlvbnMubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSggcmVuZGVyZXIsIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlLnR5cGU7XHJcblx0XHR0aGlzLnRleHR1cmUuY29sb3JTcGFjZSA9IHRleHR1cmUuY29sb3JTcGFjZTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7XHJcblx0XHR0aGlzLnRleHR1cmUubWFnRmlsdGVyID0gdGV4dHVyZS5tYWdGaWx0ZXI7XHJcblxyXG5cdFx0Y29uc3Qgc2hhZGVyID0ge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XHR0RXF1aXJlY3Q6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHZlcnRleFNoYWRlcjogLyogZ2xzbCAqL2BcclxuXHJcblx0XHRcdFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcclxuXHJcblx0XHRcdFx0dmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbm9ybWFsaXplKCAoIG1hdHJpeCAqIHZlYzQoIGRpciwgMC4wICkgKS54eXogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XHJcblxyXG5cdFx0XHRcdFx0dldvcmxkRGlyZWN0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdFx0XHRcdFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdGAsXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogLyogZ2xzbCAqL2BcclxuXHJcblx0XHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xyXG5cclxuXHRcdFx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xyXG5cclxuXHRcdFx0XHQjaW5jbHVkZSA8Y29tbW9uPlxyXG5cclxuXHRcdFx0XHR2b2lkIG1haW4oKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZERpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdHZlYzIgc2FtcGxlVVYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRgXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KCA1LCA1LCA1ICk7XHJcblxyXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcclxuXHJcblx0XHRcdG5hbWU6ICdDdWJlbWFwRnJvbUVxdWlyZWN0JyxcclxuXHJcblx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBzaGFkZXIudW5pZm9ybXMgKSxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxyXG5cdFx0XHRzaWRlOiBCYWNrU2lkZSxcclxuXHRcdFx0YmxlbmRpbmc6IE5vQmxlbmRpbmdcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0bWF0ZXJpYWwudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlID0gdGV4dHVyZTtcclxuXHJcblx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRNaW5GaWx0ZXIgPSB0ZXh0dXJlLm1pbkZpbHRlcjtcclxuXHJcblx0XHQvLyBBdm9pZCBibHVycmVkIHBvbGVzXHJcblx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcclxuXHJcblx0XHRjb25zdCBjYW1lcmEgPSBuZXcgQ3ViZUNhbWVyYSggMSwgMTAsIHRoaXMgKTtcclxuXHRcdGNhbWVyYS51cGRhdGUoIHJlbmRlcmVyLCBtZXNoICk7XHJcblxyXG5cdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBjdXJyZW50TWluRmlsdGVyO1xyXG5cclxuXHRcdG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0bWVzaC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xlYXIoIHJlbmRlcmVyLCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHRoaXMsIGkgKTtcclxuXHJcblx0XHRcdHJlbmRlcmVyLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMQ3ViZVJlbmRlclRhcmdldCB9O1xyXG4iLCJpbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi9NYXRyaXgzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XHJcblxyXG5jb25zdCBfdmVjdG9yMSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9ub3JtYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCk7XHJcblxyXG5jbGFzcyBQbGFuZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBub3JtYWwgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBjb25zdGFudCA9IDAgKSB7XHJcblxyXG5cdFx0dGhpcy5pc1BsYW5lID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0dGhpcy5ub3JtYWwgPSBub3JtYWw7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldENvbXBvbmVudHMoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tQ29wbGFuYXJQb2ludHMoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9ybWFsID0gX3ZlY3RvcjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCBfdmVjdG9yMi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHQvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xyXG5cclxuXHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHBsYW5lICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG5vcm1hbGl6ZSgpIHtcclxuXHJcblx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cclxuXHJcblx0XHRjb25zdCBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XHJcblx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG5lZ2F0ZSgpIHtcclxuXHJcblx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcclxuXHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzdGFuY2VUb1NwaGVyZSggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0fVxyXG5cclxuXHRwcm9qZWN0UG9pbnQoIHBvaW50LCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBwb2ludCApLmFkZFNjYWxlZFZlY3RvciggdGhpcy5ub3JtYWwsIC0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RMaW5lKCBsaW5lLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggX3ZlY3RvcjEgKTtcclxuXHJcblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHRoaXMubm9ybWFsLmRvdCggZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuXHRcdFx0aWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuXHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBsaW5lLnN0YXJ0ICkuYWRkU2NhbGVkVmVjdG9yKCBkaXJlY3Rpb24sIHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzTGluZSggbGluZSApIHtcclxuXHJcblx0XHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cclxuXHJcblx0XHRjb25zdCBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApO1xyXG5cdFx0Y29uc3QgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xyXG5cclxuXHRcdHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzUGxhbmUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5pbnRlcnNlY3RzUGxhbmUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3BsYW5hclBvaW50KCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgX25vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdGNvbnN0IHJlZmVyZW5jZVBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCBfdmVjdG9yMSApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0Y29uc3Qgbm9ybWFsID0gdGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHR0aGlzLmNvbnN0YW50ID0gLSByZWZlcmVuY2VQb2ludC5kb3QoIG5vcm1hbCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY29uc3RhbnQgLT0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRlcXVhbHMoIHBsYW5lICkge1xyXG5cclxuXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFBsYW5lIH07XHJcbiIsImltcG9ydCB7IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSwgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuL1NwaGVyZS5qcyc7XHJcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSAnLi9QbGFuZS5qcyc7XHJcblxyXG5jb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XHJcbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jbGFzcyBGcnVzdHVtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHAwID0gbmV3IFBsYW5lKCksIHAxID0gbmV3IFBsYW5lKCksIHAyID0gbmV3IFBsYW5lKCksIHAzID0gbmV3IFBsYW5lKCksIHA0ID0gbmV3IFBsYW5lKCksIHA1ID0gbmV3IFBsYW5lKCkgKSB7XHJcblxyXG5cdFx0dGhpcy5wbGFuZXMgPSBbIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XHJcblxyXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0cGxhbmVzWyAwIF0uY29weSggcDAgKTtcclxuXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XHJcblx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xyXG5cdFx0cGxhbmVzWyAzIF0uY29weSggcDMgKTtcclxuXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XHJcblx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIGZydXN0dW0gKSB7XHJcblxyXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIG0sIGNvb3JkaW5hdGVTeXN0ZW0gPSBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XHJcblx0XHRjb25zdCBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xyXG5cdFx0Y29uc3QgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcclxuXHRcdGNvbnN0IG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xyXG5cdFx0Y29uc3QgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xyXG5cclxuXHRcdHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0XHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTIsIG1lNiwgbWUxMCwgbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICcgKyBjb29yZGluYXRlU3lzdGVtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVyc2VjdHNPYmplY3QoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBvYmplY3QuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRfc3BoZXJlLmNvcHkoIG9iamVjdC5ib3VuZGluZ1NwaGVyZSApLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzU3ByaXRlKCBzcHJpdGUgKSB7XHJcblxyXG5cdFx0X3NwaGVyZS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XHJcblx0XHRfc3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcclxuXHRcdF9zcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cdFx0Y29uc3QgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcclxuXHRcdGNvbnN0IG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XHJcblxyXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHBsYW5lID0gcGxhbmVzWyBpIF07XHJcblxyXG5cdFx0XHQvLyBjb3JuZXIgYXQgbWF4IGRpc3RhbmNlXHJcblxyXG5cdFx0XHRfdmVjdG9yLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XHJcblx0XHRcdF92ZWN0b3IueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcclxuXHRcdFx0X3ZlY3Rvci56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xyXG5cclxuXHRcdFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIF92ZWN0b3IgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBGcnVzdHVtIH07XHJcbiIsImZ1bmN0aW9uIFdlYkdMQW5pbWF0aW9uKCkge1xyXG5cclxuXHRsZXQgY29udGV4dCA9IG51bGw7XHJcblx0bGV0IGlzQW5pbWF0aW5nID0gZmFsc2U7XHJcblx0bGV0IGFuaW1hdGlvbkxvb3AgPSBudWxsO1xyXG5cdGxldCByZXF1ZXN0SWQgPSBudWxsO1xyXG5cclxuXHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lLCBmcmFtZSApIHtcclxuXHJcblx0XHRhbmltYXRpb25Mb29wKCB0aW1lLCBmcmFtZSApO1xyXG5cclxuXHRcdHJlcXVlc3RJZCA9IGNvbnRleHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBvbkFuaW1hdGlvbkZyYW1lICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHRzdGFydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCBpc0FuaW1hdGluZyA9PT0gdHJ1ZSApIHJldHVybjtcclxuXHRcdFx0aWYgKCBhbmltYXRpb25Mb29wID09PSBudWxsICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0cmVxdWVzdElkID0gY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIG9uQW5pbWF0aW9uRnJhbWUgKTtcclxuXHJcblx0XHRcdGlzQW5pbWF0aW5nID0gdHJ1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnRleHQuY2FuY2VsQW5pbWF0aW9uRnJhbWUoIHJlcXVlc3RJZCApO1xyXG5cclxuXHRcdFx0aXNBbmltYXRpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRhbmltYXRpb25Mb29wID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRDb250ZXh0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y29udGV4dCA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMQW5pbWF0aW9uIH07XHJcbiIsImZ1bmN0aW9uIFdlYkdMQXR0cmlidXRlcyggZ2wsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XHJcblxyXG5cdGNvbnN0IGJ1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdGNvbnN0IHVzYWdlID0gYXR0cmlidXRlLnVzYWdlO1xyXG5cclxuXHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgYXJyYXksIHVzYWdlICk7XHJcblxyXG5cdFx0YXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcclxuXHJcblx0XHRsZXQgdHlwZTtcclxuXHJcblx0XHRpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0Zsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaXNXZWJHTDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dHlwZSA9IGdsLkhBTEZfRkxPQVQ7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVc2FnZSBvZiBGbG9hdDE2QnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIFdlYkdMMi4nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gZ2wuU0hPUlQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IGdsLklOVDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5CWVRFO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICcgKyBhcnJheSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRidWZmZXI6IGJ1ZmZlcixcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0Ynl0ZXNQZXJFbGVtZW50OiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuXHRcdFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb25cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlQnVmZmVyKCBidWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdGNvbnN0IHVwZGF0ZVJhbmdlID0gYXR0cmlidXRlLnVwZGF0ZVJhbmdlO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggdXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXHJcblxyXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBhcnJheSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGlzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuXHRcdFx0XHRcdGFycmF5LCB1cGRhdGVSYW5nZS5vZmZzZXQsIHVwZGF0ZVJhbmdlLmNvdW50ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuXHRcdFx0XHRcdGFycmF5LnN1YmFycmF5KCB1cGRhdGVSYW5nZS5vZmZzZXQsIHVwZGF0ZVJhbmdlLm9mZnNldCArIHVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZVJhbmdlLmNvdW50ID0gLSAxOyAvLyByZXNldCByYW5nZVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRhdHRyaWJ1dGUub25VcGxvYWRDYWxsYmFjaygpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIGdldCggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcclxuXHJcblx0XHRyZXR1cm4gYnVmZmVycy5nZXQoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gYnVmZmVycy5nZXQoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGlmICggZGF0YSApIHtcclxuXHJcblx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggZGF0YS5idWZmZXIgKTtcclxuXHJcblx0XHRcdGJ1ZmZlcnMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNhY2hlZCA9IGJ1ZmZlcnMuZ2V0KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdGlmICggISBjYWNoZWQgfHwgY2FjaGVkLnZlcnNpb24gPCBhdHRyaWJ1dGUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdFx0YnVmZmVycy5zZXQoIGF0dHJpYnV0ZSwge1xyXG5cdFx0XHRcdFx0YnVmZmVyOiBhdHRyaWJ1dGUuYnVmZmVyLFxyXG5cdFx0XHRcdFx0dHlwZTogYXR0cmlidXRlLnR5cGUsXHJcblx0XHRcdFx0XHRieXRlc1BlckVsZW1lbnQ6IGF0dHJpYnV0ZS5lbGVtZW50U2l6ZSxcclxuXHRcdFx0XHRcdHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IGJ1ZmZlcnMuZ2V0KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJ1ZmZlcnMuc2V0KCBhdHRyaWJ1dGUsIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlLCBidWZmZXJUeXBlICkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBkYXRhLnZlcnNpb24gPCBhdHRyaWJ1dGUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHVwZGF0ZUJ1ZmZlciggZGF0YS5idWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApO1xyXG5cclxuXHRcdFx0ZGF0YS52ZXJzaW9uID0gYXR0cmlidXRlLnZlcnNpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblxyXG5cdFx0Z2V0OiBnZXQsXHJcblx0XHRyZW1vdmU6IHJlbW92ZSxcclxuXHRcdHVwZGF0ZTogdXBkYXRlXHJcblxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xBdHRyaWJ1dGVzIH07XHJcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcblxyXG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCB3aWR0aFNlZ21lbnRzID0gMSwgaGVpZ2h0U2VnbWVudHMgPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XHJcblx0XHRjb25zdCBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XHJcblxyXG5cdFx0Y29uc3QgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICk7XHJcblx0XHRjb25zdCBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICk7XHJcblxyXG5cdFx0Y29uc3QgZ3JpZFgxID0gZ3JpZFggKyAxO1xyXG5cdFx0Y29uc3QgZ3JpZFkxID0gZ3JpZFkgKyAxO1xyXG5cclxuXHRcdGNvbnN0IHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xyXG5cdFx0Y29uc3Qgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XHJcblx0XHRjb25zdCBub3JtYWxzID0gW107XHJcblx0XHRjb25zdCB1dnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgLSB5LCAwICk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xyXG5cclxuXHRcdFx0XHR1dnMucHVzaCggaXggLyBncmlkWCApO1xyXG5cdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYSA9IGl4ICsgZ3JpZFgxICogaXk7XHJcblx0XHRcdFx0Y29uc3QgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0XHRjb25zdCBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0Y29uc3QgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBsYW5lR2VvbWV0cnkoIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgUGxhbmVHZW9tZXRyeSB9O1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0FMUEhBSEFTSFxyXG5cclxuXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgZ2V0QWxwaGFIYXNoVGhyZXNob2xkKCB2UG9zaXRpb24gKSApIGRpc2NhcmQ7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9BTFBIQUhBU0hcclxuXHJcblx0LyoqXHJcblx0ICogU2VlOiBodHRwczovL2Nhc3VhbC1lZmZlY3RzLmNvbS9yZXNlYXJjaC9XeW1hbjIwMTdIYXNoZWQvaW5kZXguaHRtbFxyXG5cdCAqL1xyXG5cclxuXHRjb25zdCBmbG9hdCBBTFBIQV9IQVNIX1NDQUxFID0gMC4wNTsgLy8gRGVyaXZlZCBmcm9tIHRyaWFscyBvbmx5LCBhbmQgbWF5IGJlIGNoYW5nZWQuXHJcblxyXG5cdGZsb2F0IGhhc2gyRCggdmVjMiB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gZnJhY3QoIDEuMGU0ICogc2luKCAxNy4wICogdmFsdWUueCArIDAuMSAqIHZhbHVlLnkgKSAqICggMC4xICsgYWJzKCBzaW4oIDEzLjAgKiB2YWx1ZS55ICsgdmFsdWUueCApICkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsb2F0IGhhc2gzRCggdmVjMyB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gaGFzaDJEKCB2ZWMyKCBoYXNoMkQoIHZhbHVlLnh5ICksIHZhbHVlLnogKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsb2F0IGdldEFscGhhSGFzaFRocmVzaG9sZCggdmVjMyBwb3NpdGlvbiApIHtcclxuXHJcblx0XHQvLyBGaW5kIHRoZSBkaXNjcmV0aXplZCBkZXJpdmF0aXZlcyBvZiBvdXIgY29vcmRpbmF0ZXNcclxuXHRcdGZsb2F0IG1heERlcml2ID0gbWF4KFxyXG5cdFx0XHRsZW5ndGgoIGRGZHgoIHBvc2l0aW9uLnh5eiApICksXHJcblx0XHRcdGxlbmd0aCggZEZkeSggcG9zaXRpb24ueHl6ICkgKVxyXG5cdFx0KTtcclxuXHRcdGZsb2F0IHBpeFNjYWxlID0gMS4wIC8gKCBBTFBIQV9IQVNIX1NDQUxFICogbWF4RGVyaXYgKTtcclxuXHJcblx0XHQvLyBGaW5kIHR3byBuZWFyZXN0IGxvZy1kaXNjcmV0aXplZCBub2lzZSBzY2FsZXNcclxuXHRcdHZlYzIgcGl4U2NhbGVzID0gdmVjMihcclxuXHRcdFx0ZXhwMiggZmxvb3IoIGxvZzIoIHBpeFNjYWxlICkgKSApLFxyXG5cdFx0XHRleHAyKCBjZWlsKCBsb2cyKCBwaXhTY2FsZSApICkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBDb21wdXRlIGFscGhhIHRocmVzaG9sZHMgYXQgb3VyIHR3byBub2lzZSBzY2FsZXNcclxuXHRcdHZlYzIgYWxwaGEgPSB2ZWMyKFxyXG5cdFx0XHRoYXNoM0QoIGZsb29yKCBwaXhTY2FsZXMueCAqIHBvc2l0aW9uLnh5eiApICksXHJcblx0XHRcdGhhc2gzRCggZmxvb3IoIHBpeFNjYWxlcy55ICogcG9zaXRpb24ueHl6ICkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBGYWN0b3IgdG8gaW50ZXJwb2xhdGUgbGVycCB3aXRoXHJcblx0XHRmbG9hdCBsZXJwRmFjdG9yID0gZnJhY3QoIGxvZzIoIHBpeFNjYWxlICkgKTtcclxuXHJcblx0XHQvLyBJbnRlcnBvbGF0ZSBhbHBoYSB0aHJlc2hvbGQgZnJvbSBub2lzZSBhdCB0d28gc2NhbGVzXHJcblx0XHRmbG9hdCB4ID0gKCAxLjAgLSBsZXJwRmFjdG9yICkgKiBhbHBoYS54ICsgbGVycEZhY3RvciAqIGFscGhhLnk7XHJcblxyXG5cdFx0Ly8gUGFzcyBpbnRvIENERiB0byBjb21wdXRlIHVuaWZvcm1seSBkaXN0cmliIHRocmVzaG9sZFxyXG5cdFx0ZmxvYXQgYSA9IG1pbiggbGVycEZhY3RvciwgMS4wIC0gbGVycEZhY3RvciApO1xyXG5cdFx0dmVjMyBjYXNlcyA9IHZlYzMoXHJcblx0XHRcdHggKiB4IC8gKCAyLjAgKiBhICogKCAxLjAgLSBhICkgKSxcclxuXHRcdFx0KCB4IC0gMC41ICogYSApIC8gKCAxLjAgLSBhICksXHJcblx0XHRcdDEuMCAtICggKCAxLjAgLSB4ICkgKiAoIDEuMCAtIHggKSAvICggMi4wICogYSAqICggMS4wIC0gYSApICkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBGaW5kIG91ciBmaW5hbCwgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIGFscGhhIHRocmVzaG9sZCAozrHPhClcclxuXHRcdGZsb2F0IHRocmVzaG9sZCA9ICggeCA8ICggMS4wIC0gYSApIClcclxuXHRcdFx0PyAoICggeCA8IGEgKSA/IGNhc2VzLnggOiBjYXNlcy55IClcclxuXHRcdFx0OiBjYXNlcy56O1xyXG5cclxuXHRcdC8vIEF2b2lkcyDOsc+EID09IDAuIENvdWxkIGFsc28gZG8gzrHPhCA9MS3Osc+EXHJcblx0XHRyZXR1cm4gY2xhbXAoIHRocmVzaG9sZCAsIDEuMGUtNiwgMS4wICk7XHJcblxyXG5cdH1cclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0FMUEhBTUFQXHJcblxyXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZBbHBoYU1hcFV2ICkuZztcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0FMUEhBTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfQUxQSEFURVNUXHJcblxyXG5cdGlmICggZGlmZnVzZUNvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfQUxQSEFURVNUXHJcblx0dW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0FPTUFQXHJcblxyXG5cdC8vIHJlYWRzIGNoYW5uZWwgUiwgY29tcGF0aWJsZSB3aXRoIGEgY29tYmluZWQgT2NjbHVzaW9uUm91Z2huZXNzTWV0YWxsaWMgKFJHQikgdGV4dHVyZVxyXG5cdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZBb01hcFV2ICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xyXG5cclxuXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEIClcclxuXHJcblx0XHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9BT01BUFxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcclxuXHR1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xyXG5cclxuI2lmZGVmIFVTRV9BTFBIQUhBU0hcclxuXHJcblx0dlBvc2l0aW9uID0gdmVjMyggcG9zaXRpb24gKTtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xyXG5cclxuI2lmZGVmIFVTRV9UQU5HRU5UXHJcblxyXG5cdHZlYzMgb2JqZWN0VGFuZ2VudCA9IHZlYzMoIHRhbmdlbnQueHl6ICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuXHJcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICovICkge1xyXG5cclxuXHQvLyBnZW9tZXRyeSB0ZXJtIGlzIChuIGRvdCBsKShuIGRvdCB2KSAvIDQobiBkb3QgbCkobiBkb3QgdilcclxuXHRyZXR1cm4gMC4yNTtcclxuXHJcbn1cclxuXHJcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcclxuXHJcblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XHJcblxyXG59XHJcblxyXG52ZWMzIEJSREZfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MgKSB7XHJcblxyXG5cdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XHJcblxyXG5cdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcclxuXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xyXG5cclxuXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIDEuMCwgZG90VkggKTtcclxuXHJcblx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggLyogZG90TkwsIGRvdE5WICovICk7XHJcblxyXG5cdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcclxuXHJcblx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XHJcblxyXG59IC8vIHZhbGlkYXRlZFxyXG5cclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcclxuXHJcblx0Ly8gWFlaIHRvIGxpbmVhci1zUkdCIGNvbG9yIHNwYWNlXHJcblx0Y29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MyhcclxuXHRcdCAzLjI0MDQ1NDIsIC0wLjk2OTI2NjAsICAwLjA1NTY0MzQsXHJcblx0XHQtMS41MzcxMzg1LCAgMS44NzYwMTA4LCAtMC4yMDQwMjU5LFxyXG5cdFx0LTAuNDk4NTMxNCwgIDAuMDQxNTU2MCwgIDEuMDU3MjI1MlxyXG5cdCk7XHJcblxyXG5cdC8vIEFzc3VtZSBhaXIgaW50ZXJmYWNlIGZvciB0b3BcclxuXHQvLyBOb3RlOiBXZSBkb24ndCBoYW5kbGUgdGhlIGNhc2UgZnJlc25lbDAgPT0gMVxyXG5cdHZlYzMgRnJlc25lbDBUb0lvciggdmVjMyBmcmVzbmVsMCApIHtcclxuXHJcblx0XHR2ZWMzIHNxcnRGMCA9IHNxcnQoIGZyZXNuZWwwICk7XHJcblx0XHRyZXR1cm4gKCB2ZWMzKCAxLjAgKSArIHNxcnRGMCApIC8gKCB2ZWMzKCAxLjAgKSAtIHNxcnRGMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIENvbnZlcnNpb24gRk8vSU9SXHJcblx0dmVjMyBJb3JUb0ZyZXNuZWwwKCB2ZWMzIHRyYW5zbWl0dGVkSW9yLCBmbG9hdCBpbmNpZGVudElvciApIHtcclxuXHJcblx0XHRyZXR1cm4gcG93MiggKCB0cmFuc21pdHRlZElvciAtIHZlYzMoIGluY2lkZW50SW9yICkgKSAvICggdHJhbnNtaXR0ZWRJb3IgKyB2ZWMzKCBpbmNpZGVudElvciApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBpb3IgaXMgYSB2YWx1ZSBiZXR3ZWVuIDEuMCBhbmQgMy4wLiAxLjAgaXMgYWlyIGludGVyZmFjZVxyXG5cdGZsb2F0IElvclRvRnJlc25lbDAoIGZsb2F0IHRyYW5zbWl0dGVkSW9yLCBmbG9hdCBpbmNpZGVudElvciApIHtcclxuXHJcblx0XHRyZXR1cm4gcG93MiggKCB0cmFuc21pdHRlZElvciAtIGluY2lkZW50SW9yICkgLyAoIHRyYW5zbWl0dGVkSW9yICsgaW5jaWRlbnRJb3IgKSk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gRnJlc25lbCBlcXVhdGlvbnMgZm9yIGRpZWxlY3RyaWMvZGllbGVjdHJpYyBpbnRlcmZhY2VzLlxyXG5cdC8vIFJlZjogaHR0cHM6Ly9iZWxjb3VyLmdpdGh1Yi5pby9ibG9nL3Jlc2VhcmNoLzIwMTcvMDUvMDEvYnJkZi10aGluLWZpbG0uaHRtbFxyXG5cdC8vIEV2YWx1YXRpb24gWFlaIHNlbnNpdGl2aXR5IGN1cnZlcyBpbiBGb3VyaWVyIHNwYWNlXHJcblx0dmVjMyBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0IE9QRCwgdmVjMyBzaGlmdCApIHtcclxuXHJcblx0XHRmbG9hdCBwaGFzZSA9IDIuMCAqIFBJICogT1BEICogMS4wZS05O1xyXG5cdFx0dmVjMyB2YWwgPSB2ZWMzKCA1LjQ4NTZlLTEzLCA0LjQyMDFlLTEzLCA1LjI0ODFlLTEzICk7XHJcblx0XHR2ZWMzIHBvcyA9IHZlYzMoIDEuNjgxMGUrMDYsIDEuNzk1M2UrMDYsIDIuMjA4NGUrMDYgKTtcclxuXHRcdHZlYzMgdmFyID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApO1xyXG5cclxuXHRcdHZlYzMgeHl6ID0gdmFsICogc3FydCggMi4wICogUEkgKiB2YXIgKSAqIGNvcyggcG9zICogcGhhc2UgKyBzaGlmdCApICogZXhwKCAtIHBvdzIoIHBoYXNlICkgKiB2YXIgKTtcclxuXHRcdHh5ei54ICs9IDkuNzQ3MGUtMTQgKiBzcXJ0KCAyLjAgKiBQSSAqIDQuNTI4MmUrMDkgKSAqIGNvcyggMi4yMzk5ZSswNiAqIHBoYXNlICsgc2hpZnRbIDAgXSApICogZXhwKCAtIDQuNTI4MmUrMDkgKiBwb3cyKCBwaGFzZSApICk7XHJcblx0XHR4eXogLz0gMS4wNjg1ZS03O1xyXG5cclxuXHRcdHZlYzMgcmdiID0gWFlaX1RPX1JFQzcwOSAqIHh5ejtcclxuXHRcdHJldHVybiByZ2I7XHJcblxyXG5cdH1cclxuXHJcblx0dmVjMyBldmFsSXJpZGVzY2VuY2UoIGZsb2F0IG91dHNpZGVJT1IsIGZsb2F0IGV0YTIsIGZsb2F0IGNvc1RoZXRhMSwgZmxvYXQgdGhpbkZpbG1UaGlja25lc3MsIHZlYzMgYmFzZUYwICkge1xyXG5cclxuXHRcdHZlYzMgSTtcclxuXHJcblx0XHQvLyBGb3JjZSBpcmlkZXNjZW5jZUlPUiAtPiBvdXRzaWRlSU9SIHdoZW4gdGhpbkZpbG1UaGlja25lc3MgLT4gMC4wXHJcblx0XHRmbG9hdCBpcmlkZXNjZW5jZUlPUiA9IG1peCggb3V0c2lkZUlPUiwgZXRhMiwgc21vb3Roc3RlcCggMC4wLCAwLjAzLCB0aGluRmlsbVRoaWNrbmVzcyApICk7XHJcblx0XHQvLyBFdmFsdWF0ZSB0aGUgY29zVGhldGEgb24gdGhlIGJhc2UgbGF5ZXIgKFNuZWxsIGxhdylcclxuXHRcdGZsb2F0IHNpblRoZXRhMlNxID0gcG93Miggb3V0c2lkZUlPUiAvIGlyaWRlc2NlbmNlSU9SICkgKiAoIDEuMCAtIHBvdzIoIGNvc1RoZXRhMSApICk7XHJcblxyXG5cdFx0Ly8gSGFuZGxlIFRJUjpcclxuXHRcdGZsb2F0IGNvc1RoZXRhMlNxID0gMS4wIC0gc2luVGhldGEyU3E7XHJcblx0XHRpZiAoIGNvc1RoZXRhMlNxIDwgMC4wICkge1xyXG5cclxuXHRcdFx0IHJldHVybiB2ZWMzKCAxLjAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZmxvYXQgY29zVGhldGEyID0gc3FydCggY29zVGhldGEyU3EgKTtcclxuXHJcblx0XHQvLyBGaXJzdCBpbnRlcmZhY2VcclxuXHRcdGZsb2F0IFIwID0gSW9yVG9GcmVzbmVsMCggaXJpZGVzY2VuY2VJT1IsIG91dHNpZGVJT1IgKTtcclxuXHRcdGZsb2F0IFIxMiA9IEZfU2NobGljayggUjAsIDEuMCwgY29zVGhldGExICk7XHJcblx0XHRmbG9hdCBSMjEgPSBSMTI7XHJcblx0XHRmbG9hdCBUMTIxID0gMS4wIC0gUjEyO1xyXG5cdFx0ZmxvYXQgcGhpMTIgPSAwLjA7XHJcblx0XHRpZiAoIGlyaWRlc2NlbmNlSU9SIDwgb3V0c2lkZUlPUiApIHBoaTEyID0gUEk7XHJcblx0XHRmbG9hdCBwaGkyMSA9IFBJIC0gcGhpMTI7XHJcblxyXG5cdFx0Ly8gU2Vjb25kIGludGVyZmFjZVxyXG5cdFx0dmVjMyBiYXNlSU9SID0gRnJlc25lbDBUb0lvciggY2xhbXAoIGJhc2VGMCwgMC4wLCAwLjk5OTkgKSApOyAvLyBndWFyZCBhZ2FpbnN0IDEuMFxyXG5cdFx0dmVjMyBSMSA9IElvclRvRnJlc25lbDAoIGJhc2VJT1IsIGlyaWRlc2NlbmNlSU9SICk7XHJcblx0XHR2ZWMzIFIyMyA9IEZfU2NobGljayggUjEsIDEuMCwgY29zVGhldGEyICk7XHJcblx0XHR2ZWMzIHBoaTIzID0gdmVjMyggMC4wICk7XHJcblx0XHRpZiAoIGJhc2VJT1JbIDAgXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbIDAgXSA9IFBJO1xyXG5cdFx0aWYgKCBiYXNlSU9SWyAxIF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWyAxIF0gPSBQSTtcclxuXHRcdGlmICggYmFzZUlPUlsgMiBdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sgMiBdID0gUEk7XHJcblxyXG5cdFx0Ly8gUGhhc2Ugc2hpZnRcclxuXHRcdGZsb2F0IE9QRCA9IDIuMCAqIGlyaWRlc2NlbmNlSU9SICogdGhpbkZpbG1UaGlja25lc3MgKiBjb3NUaGV0YTI7XHJcblx0XHR2ZWMzIHBoaSA9IHZlYzMoIHBoaTIxICkgKyBwaGkyMztcclxuXHJcblx0XHQvLyBDb21wb3VuZCB0ZXJtc1xyXG5cdFx0dmVjMyBSMTIzID0gY2xhbXAoIFIxMiAqIFIyMywgMWUtNSwgMC45OTk5ICk7XHJcblx0XHR2ZWMzIHIxMjMgPSBzcXJ0KCBSMTIzICk7XHJcblx0XHR2ZWMzIFJzID0gcG93MiggVDEyMSApICogUjIzIC8gKCB2ZWMzKCAxLjAgKSAtIFIxMjMgKTtcclxuXHJcblx0XHQvLyBSZWZsZWN0YW5jZSB0ZXJtIGZvciBtID0gMCAoREMgdGVybSBhbXBsaXR1ZGUpXHJcblx0XHR2ZWMzIEMwID0gUjEyICsgUnM7XHJcblx0XHRJID0gQzA7XHJcblxyXG5cdFx0Ly8gUmVmbGVjdGFuY2UgdGVybSBmb3IgbSA+IDAgKHBhaXJzIG9mIGRpcmFjcylcclxuXHRcdHZlYzMgQ20gPSBScyAtIFQxMjE7XHJcblx0XHRmb3IgKCBpbnQgbSA9IDE7IG0gPD0gMjsgKysgbSApIHtcclxuXHJcblx0XHRcdENtICo9IHIxMjM7XHJcblx0XHRcdHZlYzMgU20gPSAyLjAgKiBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0KCBtICkgKiBPUEQsIGZsb2F0KCBtICkgKiBwaGkgKTtcclxuXHRcdFx0SSArPSBDbSAqIFNtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTaW5jZSBvdXQgb2YgZ2FtdXQgY29sb3JzIG1pZ2h0IGJlIHByb2R1Y2VkLCBuZWdhdGl2ZSBjb2xvciB2YWx1ZXMgYXJlIGNsYW1wZWQgdG8gMC5cclxuXHRcdHJldHVybiBtYXgoIEksIHZlYzMoIDAuMCApICk7XHJcblxyXG5cdH1cclxuXHJcbiNlbmRpZlxyXG5cclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9CVU1QTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XHJcblx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XHJcblxyXG5cdC8vIEJ1bXAgTWFwcGluZyBVbnBhcmFtZXRyaXplZCBTdXJmYWNlcyBvbiB0aGUgR1BVIGJ5IE1vcnRlbiBTLiBNaWtrZWxzZW5cclxuXHQvLyBodHRwczovL21taWtrLmdpdGh1Yi5pby9wYXBlcnMzZC9tbV9zZmdyYWRfYnVtcC5wZGZcclxuXHJcblx0Ly8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXHJcblxyXG5cdHZlYzIgZEhkeHlfZndkKCkge1xyXG5cclxuXHRcdHZlYzIgZFNUZHggPSBkRmR4KCB2QnVtcE1hcFV2ICk7XHJcblx0XHR2ZWMyIGRTVGR5ID0gZEZkeSggdkJ1bXBNYXBVdiApO1xyXG5cclxuXHRcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdkJ1bXBNYXBVdiApLng7XHJcblx0XHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZCdW1wTWFwVXYgKyBkU1RkeCApLnggLSBIbGw7XHJcblx0XHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZCdW1wTWFwVXYgKyBkU1RkeSApLnggLSBIbGw7XHJcblxyXG5cdFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSwgZmxvYXQgZmFjZURpcmVjdGlvbiApIHtcclxuXHJcblx0XHR2ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3Bvcy54eXogKTtcclxuXHRcdHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zLnh5eiApO1xyXG5cdFx0dmVjMyB2TiA9IHN1cmZfbm9ybTsgLy8gbm9ybWFsaXplZFxyXG5cclxuXHRcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcclxuXHRcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcclxuXHJcblx0XHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApICogZmFjZURpcmVjdGlvbjtcclxuXHJcblx0XHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcclxuXHRcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcclxuXHJcblx0fVxyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxyXG5cclxuXHR2ZWM0IHBsYW5lO1xyXG5cclxuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XHJcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xyXG5cclxuXHRcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcclxuXHRcdGlmICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkO1xyXG5cclxuXHR9XHJcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcclxuXHJcblx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcclxuXHJcblx0XHRib29sIGNsaXBwZWQgPSB0cnVlO1xyXG5cclxuXHRcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcclxuXHRcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcclxuXHJcblx0XHRcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcclxuXHRcdFx0Y2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xyXG5cclxuXHRcdH1cclxuXHRcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXHJcblxyXG5cdFx0aWYgKCBjbGlwcGVkICkgZGlzY2FyZDtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXHJcblxyXG5cdHZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uO1xyXG5cclxuXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcclxuXHJcblx0dmFyeWluZyB2ZWMzIHZDbGlwUG9zaXRpb247XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXHJcblxyXG5cdHZDbGlwUG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxyXG5cclxuXHRkaWZmdXNlQ29sb3IgKj0gdkNvbG9yO1xyXG5cclxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcclxuXHJcblx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXHJcblxyXG5cdHZhcnlpbmcgdmVjNCB2Q29sb3I7XHJcblxyXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKVxyXG5cclxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxyXG5cclxuXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xyXG5cclxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SICkgfHwgZGVmaW5lZCggVVNFX0lOU1RBTkNJTkdfQ09MT1IgKVxyXG5cclxuXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxyXG5cclxuXHR2Q29sb3IgPSB2ZWM0KCAxLjAgKTtcclxuXHJcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9JTlNUQU5DSU5HX0NPTE9SIClcclxuXHJcblx0dkNvbG9yID0gdmVjMyggMS4wICk7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfQ09MT1JcclxuXHJcblx0dkNvbG9yICo9IGNvbG9yO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcclxuXHJcblx0dkNvbG9yLnh5eiAqPSBpbnN0YW5jZUNvbG9yLnh5ejtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzXHJcbiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MTc5NTg2XHJcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDg5NjZcclxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MTgzNzkwN1xyXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTQzMDkxODk1MzVcclxuI2RlZmluZSBFUFNJTE9OIDFlLTZcclxuXHJcbiNpZm5kZWYgc2F0dXJhdGVcclxuLy8gPHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQ+IG1heSBoYXZlIGRlZmluZWQgc2F0dXJhdGUoKSBhbHJlYWR5XHJcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxyXG4jZW5kaWZcclxuI2RlZmluZSB3aGl0ZUNvbXBsZW1lbnQoIGEgKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxyXG5cclxuZmxvYXQgcG93MiggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfVxyXG52ZWMzIHBvdzIoIGNvbnN0IGluIHZlYzMgeCApIHsgcmV0dXJuIHgqeDsgfVxyXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cclxuZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfVxyXG5mbG9hdCBtYXgzKCBjb25zdCBpbiB2ZWMzIHYgKSB7IHJldHVybiBtYXgoIG1heCggdi54LCB2LnkgKSwgdi56ICk7IH1cclxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KCB2LCB2ZWMzKCAwLjMzMzMzMzMgKSApOyB9XHJcblxyXG4vLyBleHBlY3RzIHZhbHVlcyBpbiB0aGUgcmFuZ2Ugb2YgWzAsMV14WzAsMV0sIHJldHVybnMgdmFsdWVzIGluIHRoZSBbMCwxXSByYW5nZS5cclxuLy8gZG8gbm90IGNvbGxhcHNlIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gcGVyOiBodHRwOi8vYnl0ZWJsYWNrc21pdGguY29tL2ltcHJvdmVtZW50cy10by10aGUtY2Fub25pY2FsLW9uZS1saW5lci1nbHNsLXJhbmQtZm9yLW9wZW5nbC1lcy0yLTAvXHJcbmhpZ2hwIGZsb2F0IHJhbmQoIGNvbnN0IGluIHZlYzIgdXYgKSB7XHJcblxyXG5cdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcclxuXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcclxuXHJcblx0cmV0dXJuIGZyYWN0KCBzaW4oIHNuICkgKiBjICk7XHJcblxyXG59XHJcblxyXG4jaWZkZWYgSElHSF9QUkVDSVNJT05cclxuXHRmbG9hdCBwcmVjaXNpb25TYWZlTGVuZ3RoKCB2ZWMzIHYgKSB7IHJldHVybiBsZW5ndGgoIHYgKTsgfVxyXG4jZWxzZVxyXG5cdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHtcclxuXHRcdGZsb2F0IG1heENvbXBvbmVudCA9IG1heDMoIGFicyggdiApICk7XHJcblx0XHRyZXR1cm4gbGVuZ3RoKCB2IC8gbWF4Q29tcG9uZW50ICkgKiBtYXhDb21wb25lbnQ7XHJcblx0fVxyXG4jZW5kaWZcclxuXHJcbnN0cnVjdCBJbmNpZGVudExpZ2h0IHtcclxuXHR2ZWMzIGNvbG9yO1xyXG5cdHZlYzMgZGlyZWN0aW9uO1xyXG5cdGJvb2wgdmlzaWJsZTtcclxufTtcclxuXHJcbnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7XHJcblx0dmVjMyBkaXJlY3REaWZmdXNlO1xyXG5cdHZlYzMgZGlyZWN0U3BlY3VsYXI7XHJcblx0dmVjMyBpbmRpcmVjdERpZmZ1c2U7XHJcblx0dmVjMyBpbmRpcmVjdFNwZWN1bGFyO1xyXG59O1xyXG5cclxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xyXG5cdHZlYzMgcG9zaXRpb247XHJcblx0dmVjMyBub3JtYWw7XHJcblx0dmVjMyB2aWV3RGlyO1xyXG4jaWZkZWYgVVNFX0NMRUFSQ09BVFxyXG5cdHZlYzMgY2xlYXJjb2F0Tm9ybWFsO1xyXG4jZW5kaWZcclxufTtcclxuXHJcbiNpZmRlZiBVU0VfQUxQSEFIQVNIXHJcblxyXG5cdHZhcnlpbmcgdmVjMyB2UG9zaXRpb247XHJcblxyXG4jZW5kaWZcclxuXHJcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XHJcblxyXG5cdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xyXG5cclxufVxyXG5cclxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XHJcblxyXG5cdC8vIGRpciBjYW4gYmUgZWl0aGVyIGEgZGlyZWN0aW9uIHZlY3RvciBvciBhIG5vcm1hbCB2ZWN0b3JcclxuXHQvLyB1cHBlci1sZWZ0IDN4MyBvZiBtYXRyaXggaXMgYXNzdW1lZCB0byBiZSBvcnRob2dvbmFsXHJcblxyXG5cdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xyXG5cclxufVxyXG5cclxubWF0MyB0cmFuc3Bvc2VNYXQzKCBjb25zdCBpbiBtYXQzIG0gKSB7XHJcblxyXG5cdG1hdDMgdG1wO1xyXG5cclxuXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcclxuXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcclxuXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcclxuXHJcblx0cmV0dXJuIHRtcDtcclxuXHJcbn1cclxuXHJcbmZsb2F0IGx1bWluYW5jZSggY29uc3QgaW4gdmVjMyByZ2IgKSB7XHJcblxyXG5cdC8vIGFzc3VtZXMgcmdiIGlzIGluIGxpbmVhciBjb2xvciBzcGFjZSB3aXRoIHNSR0IgcHJpbWFyaWVzIGFuZCBENjUgd2hpdGUgcG9pbnRcclxuXHJcblx0Y29uc3QgdmVjMyB3ZWlnaHRzID0gdmVjMyggMC4yMTI2NzI5LCAwLjcxNTE1MjIsIDAuMDcyMTc1MCApO1xyXG5cclxuXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCByZ2IgKTtcclxuXHJcbn1cclxuXHJcbmJvb2wgaXNQZXJzcGVjdGl2ZU1hdHJpeCggbWF0NCBtICkge1xyXG5cclxuXHRyZXR1cm4gbVsgMiBdWyAzIF0gPT0gLSAxLjA7XHJcblxyXG59XHJcblxyXG52ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkge1xyXG5cclxuXHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxyXG5cclxuXHRmbG9hdCB1ID0gYXRhbiggZGlyLnosIGRpci54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcclxuXHJcblx0ZmxvYXQgdiA9IGFzaW4oIGNsYW1wKCBkaXIueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xyXG5cclxuXHRyZXR1cm4gdmVjMiggdSwgdiApO1xyXG5cclxufVxyXG5cclxudmVjMyBCUkRGX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xyXG5cclxuXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGRpZmZ1c2VDb2xvcjtcclxuXHJcbn0gLy8gdmFsaWRhdGVkXHJcblxyXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcclxuXHJcblx0Ly8gT3JpZ2luYWwgYXBwcm94aW1hdGlvbiBieSBDaHJpc3RvcGhlIFNjaGxpY2sgJzk0XHJcblx0Ly8gZmxvYXQgZnJlc25lbCA9IHBvdyggMS4wIC0gZG90VkgsIDUuMCApO1xyXG5cclxuXHQvLyBPcHRpbWl6ZWQgdmFyaWFudCAocHJlc2VudGVkIGJ5IEVwaWMgYXQgU0lHR1JBUEggJzEzKVxyXG5cdC8vIGh0dHBzOi8vY2RuMi51bnJlYWxlbmdpbmUuY29tL1Jlc291cmNlcy9maWxlcy8yMDEzU2lnZ3JhcGhQcmVzZW50YXRpb25zTm90ZXMtMjY5MTU3MzgucGRmXHJcblx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLSA1LjU1NDczICogZG90VkggLSA2Ljk4MzE2ICkgKiBkb3RWSCApO1xyXG5cclxuXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xyXG5cclxufSAvLyB2YWxpZGF0ZWRcclxuXHJcbmZsb2F0IEZfU2NobGljayggY29uc3QgaW4gZmxvYXQgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgZG90VkggKSB7XHJcblxyXG5cdC8vIE9yaWdpbmFsIGFwcHJveGltYXRpb24gYnkgQ2hyaXN0b3BoZSBTY2hsaWNrICc5NFxyXG5cdC8vIGZsb2F0IGZyZXNuZWwgPSBwb3coIDEuMCAtIGRvdFZILCA1LjAgKTtcclxuXHJcblx0Ly8gT3B0aW1pemVkIHZhcmlhbnQgKHByZXNlbnRlZCBieSBFcGljIGF0IFNJR0dSQVBIICcxMylcclxuXHQvLyBodHRwczovL2NkbjIudW5yZWFsZW5naW5lLmNvbS9SZXNvdXJjZXMvZmlsZXMvMjAxM1NpZ2dyYXBoUHJlc2VudGF0aW9uc05vdGVzLTI2OTE1NzM4LnBkZlxyXG5cdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTtcclxuXHJcblx0cmV0dXJuIGYwICogKCAxLjAgLSBmcmVzbmVsICkgKyAoIGY5MCAqIGZyZXNuZWwgKTtcclxuXHJcbn0gLy8gdmFsaWRhdGVkXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXHJcblxyXG5cdCNkZWZpbmUgY3ViZVVWX21pbk1pcExldmVsIDQuMFxyXG5cdCNkZWZpbmUgY3ViZVVWX21pblRpbGVTaXplIDE2LjBcclxuXHJcblx0Ly8gVGhlc2Ugc2hhZGVyIGZ1bmN0aW9ucyBjb252ZXJ0IGJldHdlZW4gdGhlIFVWIGNvb3JkaW5hdGVzIG9mIGEgc2luZ2xlIGZhY2Ugb2ZcclxuXHQvLyBhIGN1YmVtYXAsIHRoZSAwLTUgaW50ZWdlciBpbmRleCBvZiBhIGN1YmUgZmFjZSwgYW5kIHRoZSBkaXJlY3Rpb24gdmVjdG9yIGZvclxyXG5cdC8vIHNhbXBsaW5nIGEgdGV4dHVyZUN1YmUgKG5vdCBnZW5lcmFsbHkgbm9ybWFsaXplZCApLlxyXG5cclxuXHRmbG9hdCBnZXRGYWNlKCB2ZWMzIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHR2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyggZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0ZmxvYXQgZmFjZSA9IC0gMS4wO1xyXG5cclxuXHRcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHtcclxuXHJcblx0XHRcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXHJcblxyXG5cdFx0XHRcdGZhY2UgPSBkaXJlY3Rpb24ueCA+IDAuMCA/IDAuMCA6IDMuMDtcclxuXHJcblx0XHRcdGVsc2VcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxyXG5cclxuXHRcdFx0XHRmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyLjAgOiA1LjA7XHJcblxyXG5cdFx0XHRlbHNlXHJcblxyXG5cdFx0XHRcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEuMCA6IDQuMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhY2U7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gUkggY29vcmRpbmF0ZSBzeXN0ZW07IFBNUkVNIGZhY2UtaW5kZXhpbmcgY29udmVudGlvblxyXG5cdHZlYzIgZ2V0VVYoIHZlYzMgZGlyZWN0aW9uLCBmbG9hdCBmYWNlICkge1xyXG5cclxuXHRcdHZlYzIgdXY7XHJcblxyXG5cdFx0aWYgKCBmYWNlID09IDAuMCApIHtcclxuXHJcblx0XHRcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7IC8vIHBvcyB4XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XHJcblxyXG5cdFx0XHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIC0gZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTsgLy8gcG9zIHlcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHtcclxuXHJcblx0XHRcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTsgLy8gcG9zIHpcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcclxuXHJcblx0XHRcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTsgLy8gbmVnIHhcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcclxuXHJcblx0XHRcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnogKSAvIGFicyggZGlyZWN0aW9uLnkgKTsgLy8gbmVnIHlcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dXYgPSB2ZWMyKCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnogKTsgLy8gbmVnIHpcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIDAuNSAqICggdXYgKyAxLjAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xyXG5cclxuXHRcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XHJcblxyXG5cdFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xyXG5cclxuXHRcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XHJcblxyXG5cdFx0aGlnaHAgdmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDsgLy8gIzI1MDcxXHJcblxyXG5cdFx0aWYgKCBmYWNlID4gMi4wICkge1xyXG5cclxuXHRcdFx0dXYueSArPSBmYWNlU2l6ZTtcclxuXHJcblx0XHRcdGZhY2UgLT0gMy4wO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR1di54ICs9IGZhY2UgKiBmYWNlU2l6ZTtcclxuXHJcblx0XHR1di54ICs9IGZpbHRlckludCAqIDMuMCAqIGN1YmVVVl9taW5UaWxlU2l6ZTtcclxuXHJcblx0XHR1di55ICs9IDQuMCAqICggZXhwMiggQ1VCRVVWX01BWF9NSVAgKSAtIGZhY2VTaXplICk7XHJcblxyXG5cdFx0dXYueCAqPSBDVUJFVVZfVEVYRUxfV0lEVEg7XHJcblx0XHR1di55ICo9IENVQkVVVl9URVhFTF9IRUlHSFQ7XHJcblxyXG5cdFx0I2lmZGVmIHRleHR1cmUyREdyYWRFWFRcclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7IC8vIGRpc2FibGUgYW5pc290cm9waWMgZmlsdGVyaW5nXHJcblxyXG5cdFx0I2Vsc2VcclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlMkQoIGVudk1hcCwgdXYgKS5yZ2I7XHJcblxyXG5cdFx0I2VuZGlmXHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVGhlc2UgZGVmaW5lcyBtdXN0IG1hdGNoIHdpdGggUE1SRU1HZW5lcmF0b3JcclxuXHJcblx0I2RlZmluZSBjdWJlVVZfcjAgMS4wXHJcblx0I2RlZmluZSBjdWJlVVZfdjAgMC4zMzlcclxuXHQjZGVmaW5lIGN1YmVVVl9tMCAtIDIuMFxyXG5cdCNkZWZpbmUgY3ViZVVWX3IxIDAuOFxyXG5cdCNkZWZpbmUgY3ViZVVWX3YxIDAuMjc2XHJcblx0I2RlZmluZSBjdWJlVVZfbTEgLSAxLjBcclxuXHQjZGVmaW5lIGN1YmVVVl9yNCAwLjRcclxuXHQjZGVmaW5lIGN1YmVVVl92NCAwLjA0NlxyXG5cdCNkZWZpbmUgY3ViZVVWX200IDIuMFxyXG5cdCNkZWZpbmUgY3ViZVVWX3I1IDAuMzA1XHJcblx0I2RlZmluZSBjdWJlVVZfdjUgMC4wMTZcclxuXHQjZGVmaW5lIGN1YmVVVl9tNSAzLjBcclxuXHQjZGVmaW5lIGN1YmVVVl9yNiAwLjIxXHJcblx0I2RlZmluZSBjdWJlVVZfdjYgMC4wMDM4XHJcblx0I2RlZmluZSBjdWJlVVZfbTYgNC4wXHJcblxyXG5cdGZsb2F0IHJvdWdobmVzc1RvTWlwKCBmbG9hdCByb3VnaG5lc3MgKSB7XHJcblxyXG5cdFx0ZmxvYXQgbWlwID0gMC4wO1xyXG5cclxuXHRcdGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yMSApIHtcclxuXHJcblx0XHRcdG1pcCA9ICggY3ViZVVWX3IwIC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tMSAtIGN1YmVVVl9tMCApIC8gKCBjdWJlVVZfcjAgLSBjdWJlVVZfcjEgKSArIGN1YmVVVl9tMDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gY3ViZVVWX3I0ICkge1xyXG5cclxuXHRcdFx0bWlwID0gKCBjdWJlVVZfcjEgLSByb3VnaG5lc3MgKSAqICggY3ViZVVWX200IC0gY3ViZVVWX20xICkgLyAoIGN1YmVVVl9yMSAtIGN1YmVVVl9yNCApICsgY3ViZVVWX20xO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSBjdWJlVVZfcjUgKSB7XHJcblxyXG5cdFx0XHRtaXAgPSAoIGN1YmVVVl9yNCAtIHJvdWdobmVzcyApICogKCBjdWJlVVZfbTUgLSBjdWJlVVZfbTQgKSAvICggY3ViZVVWX3I0IC0gY3ViZVVWX3I1ICkgKyBjdWJlVVZfbTQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IGN1YmVVVl9yNiApIHtcclxuXHJcblx0XHRcdG1pcCA9ICggY3ViZVVWX3I1IC0gcm91Z2huZXNzICkgKiAoIGN1YmVVVl9tNiAtIGN1YmVVVl9tNSApIC8gKCBjdWJlVVZfcjUgLSBjdWJlVVZfcjYgKSArIGN1YmVVVl9tNTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWlwID0gLSAyLjAgKiBsb2cyKCAxLjE2ICogcm91Z2huZXNzICk7IC8vIDEuMTYgPSAxLjc5XjAuMjVcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWlwO1xyXG5cclxuXHR9XHJcblxyXG5cdHZlYzQgdGV4dHVyZUN1YmVVViggc2FtcGxlcjJEIGVudk1hcCwgdmVjMyBzYW1wbGVEaXIsIGZsb2F0IHJvdWdobmVzcyApIHtcclxuXHJcblx0XHRmbG9hdCBtaXAgPSBjbGFtcCggcm91Z2huZXNzVG9NaXAoIHJvdWdobmVzcyApLCBjdWJlVVZfbTAsIENVQkVVVl9NQVhfTUlQICk7XHJcblxyXG5cdFx0ZmxvYXQgbWlwRiA9IGZyYWN0KCBtaXAgKTtcclxuXHJcblx0XHRmbG9hdCBtaXBJbnQgPSBmbG9vciggbWlwICk7XHJcblxyXG5cdFx0dmVjMyBjb2xvcjAgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCApO1xyXG5cclxuXHRcdGlmICggbWlwRiA9PSAwLjAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjNCggY29sb3IwLCAxLjAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHZlYzQoIG1peCggY29sb3IwLCBjb2xvcjEsIG1pcEYgKSwgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG9iamVjdE5vcm1hbDtcclxuXHJcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xyXG5cclxuXHQvLyB0aGlzIGlzIGluIGxpZXUgb2YgYSBwZXItaW5zdGFuY2Ugbm9ybWFsLW1hdHJpeFxyXG5cdC8vIHNoZWFyIHRyYW5zZm9ybXMgaW4gdGhlIGluc3RhbmNlIG1hdHJpeCBhcmUgbm90IHN1cHBvcnRlZFxyXG5cclxuXHRtYXQzIG0gPSBtYXQzKCBpbnN0YW5jZU1hdHJpeCApO1xyXG5cclxuXHR0cmFuc2Zvcm1lZE5vcm1hbCAvPSB2ZWMzKCBkb3QoIG1bIDAgXSwgbVsgMCBdICksIGRvdCggbVsgMSBdLCBtWyAxIF0gKSwgZG90KCBtWyAyIF0sIG1bIDIgXSApICk7XHJcblxyXG5cdHRyYW5zZm9ybWVkTm9ybWFsID0gbSAqIHRyYW5zZm9ybWVkTm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG50cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIHRyYW5zZm9ybWVkTm9ybWFsO1xyXG5cclxuI2lmZGVmIEZMSVBfU0lERURcclxuXHJcblx0dHJhbnNmb3JtZWROb3JtYWwgPSAtIHRyYW5zZm9ybWVkTm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgVVNFX1RBTkdFTlRcclxuXHJcblx0dmVjMyB0cmFuc2Zvcm1lZFRhbmdlbnQgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG9iamVjdFRhbmdlbnQsIDAuMCApICkueHl6O1xyXG5cclxuXHQjaWZkZWYgRkxJUF9TSURFRFxyXG5cclxuXHRcdHRyYW5zZm9ybWVkVGFuZ2VudCA9IC0gdHJhbnNmb3JtZWRUYW5nZW50O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XHJcblx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcclxuXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcclxuXHJcblx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHZEaXNwbGFjZW1lbnRNYXBVdiApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0VNSVNTSVZFTUFQXHJcblxyXG5cdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZFbWlzc2l2ZU1hcFV2ICk7XHJcblxyXG5cdHRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0VNSVNTSVZFTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbmdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG5cclxudmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcclxuXHRyZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbnZlYzQgTGluZWFyVG9zUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xyXG5cdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLmEgKTtcclxufVxyXG5cclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9FTlZNQVBcclxuXHJcblx0I2lmZGVmIEVOVl9XT1JMRFBPU1xyXG5cclxuXHRcdHZlYzMgY2FtZXJhVG9GcmFnO1xyXG5cclxuXHRcdGlmICggaXNPcnRob2dyYXBoaWMgKSB7XHJcblxyXG5cdFx0XHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVHJhbnNmb3JtaW5nIE5vcm1hbCBWZWN0b3JzIHdpdGggdGhlIEludmVyc2UgVHJhbnNmb3JtYXRpb25cclxuXHRcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxyXG5cclxuXHRcdFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCApO1xyXG5cclxuXHRcdCNlbHNlXHJcblxyXG5cdFx0XHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb0ZyYWcsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXHJcblxyXG5cdFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcclxuXHJcblx0XHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XHJcblxyXG5cdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxyXG5cclxuXHRcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xyXG5cclxuXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcclxuXHJcblx0XHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfRU5WTUFQXHJcblxyXG5cdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zaXR5O1xyXG5cdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcclxuXHJcblx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcclxuXHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1xyXG5cdCNlbHNlXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XHJcblx0I2VuZGlmXHJcblx0XHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0VOVk1BUFxyXG5cclxuXHR1bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcclxuXHJcblx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggTEFNQkVSVCApXHJcblxyXG5cdFx0I2RlZmluZSBFTlZfV09STERQT1NcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZmRlZiBFTlZfV09STERQT1NcclxuXHJcblx0XHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XHJcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcclxuXHQjZWxzZVxyXG5cdFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfRU5WTUFQXHJcblxyXG5cdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKVxyXG5cclxuXHRcdCNkZWZpbmUgRU5WX1dPUkxEUE9TXHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWZkZWYgRU5WX1dPUkxEUE9TXHJcblx0XHRcclxuXHRcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XHJcblx0XHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9FTlZNQVBcclxuXHJcblx0I2lmZGVmIEVOVl9XT1JMRFBPU1xyXG5cclxuXHRcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XHJcblxyXG5cdCNlbHNlXHJcblxyXG5cdFx0dmVjMyBjYW1lcmFUb1ZlcnRleDtcclxuXHJcblx0XHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xyXG5cclxuXHRcdFx0Y2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZlYzMoIC0gdmlld01hdHJpeFsgMCBdWyAyIF0sIC0gdmlld01hdHJpeFsgMSBdWyAyIF0sIC0gdmlld01hdHJpeFsgMiBdWyAyIF0gKSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxyXG5cclxuXHRcdFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcclxuXHJcblx0XHQjZWxzZVxyXG5cclxuXHRcdFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xyXG5cclxuXHRcdCNlbmRpZlxyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0ZPR1xyXG5cclxuXHR2Rm9nRGVwdGggPSAtIG12UG9zaXRpb24uejtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0ZPR1xyXG5cclxuXHR2YXJ5aW5nIGZsb2F0IHZGb2dEZXB0aDtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0ZPR1xyXG5cclxuXHQjaWZkZWYgRk9HX0VYUDJcclxuXHJcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSAxLjAgLSBleHAoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiB2Rm9nRGVwdGggKiB2Rm9nRGVwdGggKTtcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIHZGb2dEZXB0aCApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfRk9HXHJcblxyXG5cdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcclxuXHR2YXJ5aW5nIGZsb2F0IHZGb2dEZXB0aDtcclxuXHJcblx0I2lmZGVmIEZPR19FWFAyXHJcblxyXG5cdFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcclxuXHRcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG5cclxuI2lmZGVmIFVTRV9HUkFESUVOVE1BUFxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDtcclxuXHJcbiNlbmRpZlxyXG5cclxudmVjMyBnZXRHcmFkaWVudElycmFkaWFuY2UoIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uICkge1xyXG5cclxuXHQvLyBkb3ROTCB3aWxsIGJlIGZyb20gLTEuMCB0byAxLjBcclxuXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApO1xyXG5cdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XHJcblxyXG5cdCNpZmRlZiBVU0VfR1JBRElFTlRNQVBcclxuXHJcblx0XHRyZXR1cm4gdmVjMyggdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yICk7XHJcblxyXG5cdCNlbHNlXHJcblxyXG5cdFx0dmVjMiBmdyA9IGZ3aWR0aCggY29vcmQgKSAqIDAuNTtcclxuXHRcdHJldHVybiBtaXgoIHZlYzMoIDAuNyApLCB2ZWMzKCAxLjAgKSwgc21vb3Roc3RlcCggMC43IC0gZncueCwgMC43ICsgZncueCwgY29vcmQueCApICk7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0xJR0hUTUFQXHJcblxyXG5cdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7XHJcblx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfTElHSFRNQVBcclxuXHJcblx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XHJcblx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG5MYW1iZXJ0TWF0ZXJpYWwgbWF0ZXJpYWw7XHJcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XHJcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1xyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbnN0cnVjdCBMYW1iZXJ0TWF0ZXJpYWwge1xyXG5cclxuXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcclxuXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xyXG5cclxufTtcclxuXHJcbnZvaWQgUkVfRGlyZWN0X0xhbWJlcnQoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XHJcblxyXG5cdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xyXG5cdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XHJcblxyXG59XHJcblxyXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIExhbWJlcnRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcclxuXHJcbn1cclxuXHJcbiNkZWZpbmUgUkVfRGlyZWN0XHRcdFx0XHRSRV9EaXJlY3RfTGFtYmVydFxyXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVx0XHRSRV9JbmRpcmVjdERpZmZ1c2VfTGFtYmVydFxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG51bmlmb3JtIGJvb2wgcmVjZWl2ZVNoYWRvdztcclxudW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xyXG51bmlmb3JtIHZlYzMgbGlnaHRQcm9iZVsgOSBdO1xyXG5cclxuLy8gZ2V0IHRoZSBpcnJhZGlhbmNlIChyYWRpYW5jZSBjb252b2x2ZWQgd2l0aCBjb3NpbmUgbG9iZSkgYXQgdGhlIHBvaW50ICdub3JtYWwnIG9uIHRoZSB1bml0IHNwaGVyZVxyXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L3BhcGVycy9lbnZtYXAvZW52bWFwLnBkZlxyXG52ZWMzIHNoR2V0SXJyYWRpYW5jZUF0KCBpbiB2ZWMzIG5vcm1hbCwgaW4gdmVjMyBzaENvZWZmaWNpZW50c1sgOSBdICkge1xyXG5cclxuXHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXHJcblxyXG5cdGZsb2F0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XHJcblxyXG5cdC8vIGJhbmQgMFxyXG5cdHZlYzMgcmVzdWx0ID0gc2hDb2VmZmljaWVudHNbIDAgXSAqIDAuODg2MjI3O1xyXG5cclxuXHQvLyBiYW5kIDFcclxuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDEgXSAqIDIuMCAqIDAuNTExNjY0ICogeTtcclxuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDIgXSAqIDIuMCAqIDAuNTExNjY0ICogejtcclxuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDMgXSAqIDIuMCAqIDAuNTExNjY0ICogeDtcclxuXHJcblx0Ly8gYmFuZCAyXHJcblx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA0IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB5O1xyXG5cdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNSBdICogMi4wICogMC40MjkwNDMgKiB5ICogejtcclxuXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDYgXSAqICggMC43NDMxMjUgKiB6ICogeiAtIDAuMjQ3NzA4ICk7XHJcblx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA3IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHggKiB6O1xyXG5cdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgOCBdICogMC40MjkwNDMgKiAoIHggKiB4IC0geSAqIHkgKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn1cclxuXHJcbnZlYzMgZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbGlnaHRQcm9iZVsgOSBdLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcclxuXHJcblx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xyXG5cclxuXHR2ZWMzIGlycmFkaWFuY2UgPSBzaEdldElycmFkaWFuY2VBdCggd29ybGROb3JtYWwsIGxpZ2h0UHJvYmUgKTtcclxuXHJcblx0cmV0dXJuIGlycmFkaWFuY2U7XHJcblxyXG59XHJcblxyXG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XHJcblxyXG5cdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xyXG5cclxuXHRyZXR1cm4gaXJyYWRpYW5jZTtcclxuXHJcbn1cclxuXHJcbmZsb2F0IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xyXG5cclxuXHQjaWYgZGVmaW5lZCAoIExFR0FDWV9MSUdIVFMgKVxyXG5cclxuXHRcdGlmICggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgJiYgZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcclxuXHJcblx0XHRcdHJldHVybiBwb3coIHNhdHVyYXRlKCAtIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAxLjA7XHJcblxyXG5cdCNlbHNlXHJcblxyXG5cdFx0Ly8gYmFzZWQgdXBvbiBGcm9zdGJpdGUgMyBNb3ZpbmcgdG8gUGh5c2ljYWxseS1iYXNlZCBSZW5kZXJpbmdcclxuXHRcdC8vIHBhZ2UgMzIsIGVxdWF0aW9uIDI2OiBFW3dpbmRvdzFdXHJcblx0XHQvLyBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXHJcblx0XHRmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7XHJcblxyXG5cdFx0aWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCApIHtcclxuXHJcblx0XHRcdGRpc3RhbmNlRmFsbG9mZiAqPSBwb3cyKCBzYXR1cmF0ZSggMS4wIC0gcG93NCggbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICkgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbn1cclxuXHJcbmZsb2F0IGdldFNwb3RBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgY29uZUNvc2luZSwgY29uc3QgaW4gZmxvYXQgcGVudW1icmFDb3NpbmUsIGNvbnN0IGluIGZsb2F0IGFuZ2xlQ29zaW5lICkge1xyXG5cclxuXHRyZXR1cm4gc21vb3Roc3RlcCggY29uZUNvc2luZSwgcGVudW1icmFDb3NpbmUsIGFuZ2xlQ29zaW5lICk7XHJcblxyXG59XHJcblxyXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXHJcblxyXG5cdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcclxuXHRcdHZlYzMgZGlyZWN0aW9uO1xyXG5cdFx0dmVjMyBjb2xvcjtcclxuXHR9O1xyXG5cclxuXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XHJcblxyXG5cdHZvaWQgZ2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGNvbnN0IGluIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7XHJcblxyXG5cdFx0bGlnaHQuY29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0LmNvbG9yO1xyXG5cdFx0bGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XHJcblx0XHRsaWdodC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuI2VuZGlmXHJcblxyXG5cclxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXHJcblxyXG5cdHN0cnVjdCBQb2ludExpZ2h0IHtcclxuXHRcdHZlYzMgcG9zaXRpb247XHJcblx0XHR2ZWMzIGNvbG9yO1xyXG5cdFx0ZmxvYXQgZGlzdGFuY2U7XHJcblx0XHRmbG9hdCBkZWNheTtcclxuXHR9O1xyXG5cclxuXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcclxuXHJcblx0Ly8gbGlnaHQgaXMgYW4gb3V0IHBhcmFtZXRlciBhcyBoYXZpbmcgaXQgYXMgYSByZXR1cm4gdmFsdWUgY2F1c2VkIGNvbXBpbGVyIGVycm9ycyBvbiBzb21lIGRldmljZXNcclxuXHR2b2lkIGdldFBvaW50TGlnaHRJbmZvKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xyXG5cclxuXHRcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcclxuXHJcblx0XHRsaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcclxuXHJcblx0XHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XHJcblxyXG5cdFx0bGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xyXG5cdFx0bGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xyXG5cdFx0bGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcclxuXHJcblx0fVxyXG5cclxuI2VuZGlmXHJcblxyXG5cclxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcclxuXHJcblx0c3RydWN0IFNwb3RMaWdodCB7XHJcblx0XHR2ZWMzIHBvc2l0aW9uO1xyXG5cdFx0dmVjMyBkaXJlY3Rpb247XHJcblx0XHR2ZWMzIGNvbG9yO1xyXG5cdFx0ZmxvYXQgZGlzdGFuY2U7XHJcblx0XHRmbG9hdCBkZWNheTtcclxuXHRcdGZsb2F0IGNvbmVDb3M7XHJcblx0XHRmbG9hdCBwZW51bWJyYUNvcztcclxuXHR9O1xyXG5cclxuXHR1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTtcclxuXHJcblx0Ly8gbGlnaHQgaXMgYW4gb3V0IHBhcmFtZXRlciBhcyBoYXZpbmcgaXQgYXMgYSByZXR1cm4gdmFsdWUgY2F1c2VkIGNvbXBpbGVyIGVycm9ycyBvbiBzb21lIGRldmljZXNcclxuXHR2b2lkIGdldFNwb3RMaWdodEluZm8oIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xyXG5cclxuXHRcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xyXG5cclxuXHRcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xyXG5cclxuXHRcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBsaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24oIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XHJcblxyXG5cdFx0aWYgKCBzcG90QXR0ZW51YXRpb24gPiAwLjAgKSB7XHJcblxyXG5cdFx0XHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XHJcblxyXG5cdFx0XHRsaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvciAqIHNwb3RBdHRlbnVhdGlvbjtcclxuXHRcdFx0bGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgc3BvdExpZ2h0LmRpc3RhbmNlLCBzcG90TGlnaHQuZGVjYXkgKTtcclxuXHRcdFx0bGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTtcclxuXHRcdFx0bGlnaHQudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuI2VuZGlmXHJcblxyXG5cclxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxyXG5cclxuXHRzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7XHJcblx0XHR2ZWMzIGNvbG9yO1xyXG5cdFx0dmVjMyBwb3NpdGlvbjtcclxuXHRcdHZlYzMgaGFsZldpZHRoO1xyXG5cdFx0dmVjMyBoYWxmSGVpZ2h0O1xyXG5cdH07XHJcblxyXG5cdC8vIFByZS1jb21wdXRlZCB2YWx1ZXMgb2YgTGluZWFyVHJhbnNmb3JtZWRDb3NpbmUgYXBwcm94aW1hdGlvbiBvZiBCUkRGXHJcblx0Ly8gQlJERiBhcHByb3hpbWF0aW9uIFRleHR1cmUgaXMgNjR4NjRcclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNfMTsgLy8gUkdCQSBGbG9hdFxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y18yOyAvLyBSR0JBIEZsb2F0XHJcblxyXG5cdHVuaWZvcm0gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0c1sgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgXTtcclxuXHJcbiNlbmRpZlxyXG5cclxuXHJcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXHJcblxyXG5cdHN0cnVjdCBIZW1pc3BoZXJlTGlnaHQge1xyXG5cdFx0dmVjMyBkaXJlY3Rpb247XHJcblx0XHR2ZWMzIHNreUNvbG9yO1xyXG5cdFx0dmVjMyBncm91bmRDb2xvcjtcclxuXHR9O1xyXG5cclxuXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcclxuXHJcblx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcclxuXHJcblx0XHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XHJcblx0XHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xyXG5cclxuXHRcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGlycmFkaWFuY2U7XHJcblxyXG5cdH1cclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0VOVk1BUFxyXG5cclxuXHR2ZWMzIGdldElCTElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xyXG5cclxuXHRcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXHJcblxyXG5cdFx0XHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCB3b3JsZE5vcm1hbCwgMS4wICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gUEkgKiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0I2Vsc2VcclxuXHJcblx0XHRcdHJldHVybiB2ZWMzKCAwLjAgKTtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0fVxyXG5cclxuXHR2ZWMzIGdldElCTFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XHJcblxyXG5cdFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVfVVZcclxuXHJcblx0XHRcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC0gdmlld0Rpciwgbm9ybWFsICk7XHJcblxyXG5cdFx0XHQvLyBNaXhpbmcgdGhlIHJlZmxlY3Rpb24gd2l0aCB0aGUgbm9ybWFsIGlzIG1vcmUgYWNjdXJhdGUgYW5kIGtlZXBzIHJvdWdoIG9iamVjdHMgZnJvbSBnYXRoZXJpbmcgbGlnaHQgZnJvbSBiZWhpbmQgdGhlaXIgdGFuZ2VudCBwbGFuZS5cclxuXHRcdFx0cmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTtcclxuXHJcblx0XHRcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZsZWN0VmVjLCByb3VnaG5lc3MgKTtcclxuXHJcblx0XHRcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0I2Vsc2VcclxuXHJcblx0XHRcdHJldHVybiB2ZWMzKCAwLjAgKTtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0fVxyXG5cclxuXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlcclxuXHJcblx0XHR2ZWMzIGdldElCTEFuaXNvdHJvcHlSYWRpYW5jZSggY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiB2ZWMzIGJpdGFuZ2VudCwgY29uc3QgaW4gZmxvYXQgYW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXHJcblxyXG5cdFx0XHQgIC8vIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9maWxhbWVudC9GaWxhbWVudC5tZC5odG1sI2xpZ2h0aW5nL2ltYWdlYmFzZWRsaWdodHMvYW5pc290cm9weVxyXG5cdFx0XHRcdHZlYzMgYmVudE5vcm1hbCA9IGNyb3NzKCBiaXRhbmdlbnQsIHZpZXdEaXIgKTtcclxuXHRcdFx0XHRiZW50Tm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggYmVudE5vcm1hbCwgYml0YW5nZW50ICkgKTtcclxuXHRcdFx0XHRiZW50Tm9ybWFsID0gbm9ybWFsaXplKCBtaXgoIGJlbnROb3JtYWwsIG5vcm1hbCwgcG93MiggcG93MiggMS4wIC0gYW5pc290cm9weSAqICggMS4wIC0gcm91Z2huZXNzICkgKSApICkgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGdldElCTFJhZGlhbmNlKCB2aWV3RGlyLCBiZW50Tm9ybWFsLCByb3VnaG5lc3MgKTtcclxuXHJcblx0XHRcdCNlbHNlXHJcblxyXG5cdFx0XHRcdHJldHVybiB2ZWMzKCAwLjAgKTtcclxuXHJcblx0XHRcdCNlbmRpZlxyXG5cclxuXHRcdH1cclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuVG9vbk1hdGVyaWFsIG1hdGVyaWFsO1xyXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbnN0cnVjdCBUb29uTWF0ZXJpYWwge1xyXG5cclxuXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcclxuXHJcbn07XHJcblxyXG52b2lkIFJFX0RpcmVjdF9Ub29uKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xyXG5cclxuXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcclxuXHJcblx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcclxuXHJcbn1cclxuXHJcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX1Rvb24oIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gVG9vbk1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcclxuXHJcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xyXG5cclxufVxyXG5cclxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9Ub29uXHJcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXHRcdFJFX0luZGlyZWN0RGlmZnVzZV9Ub29uXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcclxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcclxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xyXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcclxubWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aCA9IHNwZWN1bGFyU3RyZW5ndGg7XHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xyXG5cclxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XHJcblxyXG5cdHZlYzMgZGlmZnVzZUNvbG9yO1xyXG5cdHZlYzMgc3BlY3VsYXJDb2xvcjtcclxuXHRmbG9hdCBzcGVjdWxhclNoaW5pbmVzcztcclxuXHRmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xyXG5cclxufTtcclxuXHJcbnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XHJcblxyXG5cdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xyXG5cdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX0JsaW5uUGhvbmcoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDtcclxuXHJcbn1cclxuXHJcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcclxuXHJcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xyXG5cclxufVxyXG5cclxuI2RlZmluZSBSRV9EaXJlY3RcdFx0XHRcdFJFX0RpcmVjdF9CbGlublBob25nXHJcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXHRcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcblBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7XHJcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xyXG5cclxudmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggZ2VvbWV0cnlOb3JtYWwgKSApLCBhYnMoIGRGZHkoIGdlb21ldHJ5Tm9ybWFsICkgKSApO1xyXG5mbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTtcclxuXHJcbm1hdGVyaWFsLnJvdWdobmVzcyA9IG1heCggcm91Z2huZXNzRmFjdG9yLCAwLjA1MjUgKTsvLyAwLjA1MjUgY29ycmVzcG9uZHMgdG8gdGhlIGJhc2UgbWlwIG9mIGEgMjU2IGN1YmVtYXAuXHJcbm1hdGVyaWFsLnJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcclxubWF0ZXJpYWwucm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5yb3VnaG5lc3MsIDEuMCApO1xyXG5cclxuI2lmZGVmIElPUlxyXG5cclxuXHRtYXRlcmlhbC5pb3IgPSBpb3I7XHJcblxyXG5cdCNpZmRlZiBVU0VfU1BFQ1VMQVJcclxuXHJcblx0XHRmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IHNwZWN1bGFySW50ZW5zaXR5O1xyXG5cdFx0dmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gc3BlY3VsYXJDb2xvcjtcclxuXHJcblx0XHQjaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQXHJcblxyXG5cdFx0XHRzcGVjdWxhckNvbG9yRmFjdG9yICo9IHRleHR1cmUyRCggc3BlY3VsYXJDb2xvck1hcCwgdlNwZWN1bGFyQ29sb3JNYXBVdiApLnJnYjtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0XHQjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUFxyXG5cclxuXHRcdFx0c3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgKj0gdGV4dHVyZTJEKCBzcGVjdWxhckludGVuc2l0eU1hcCwgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXYgKS5hO1xyXG5cclxuXHRcdCNlbmRpZlxyXG5cclxuXHRcdG1hdGVyaWFsLnNwZWN1bGFyRjkwID0gbWl4KCBzcGVjdWxhckludGVuc2l0eUZhY3RvciwgMS4wLCBtZXRhbG5lc3NGYWN0b3IgKTtcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHRmbG9hdCBzcGVjdWxhckludGVuc2l0eUZhY3RvciA9IDEuMDtcclxuXHRcdHZlYzMgc3BlY3VsYXJDb2xvckZhY3RvciA9IHZlYzMoIDEuMCApO1xyXG5cdFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCBtaW4oIHBvdzIoICggbWF0ZXJpYWwuaW9yIC0gMS4wICkgLyAoIG1hdGVyaWFsLmlvciArIDEuMCApICkgKiBzcGVjdWxhckNvbG9yRmFjdG9yLCB2ZWMzKCAxLjAgKSApICogc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IsIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xyXG5cclxuI2Vsc2VcclxuXHJcblx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcclxuXHRtYXRlcmlhbC5zcGVjdWxhckY5MCA9IDEuMDtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcclxuXHJcblx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gY2xlYXJjb2F0O1xyXG5cdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IGNsZWFyY29hdFJvdWdobmVzcztcclxuXHRtYXRlcmlhbC5jbGVhcmNvYXRGMCA9IHZlYzMoIDAuMDQgKTtcclxuXHRtYXRlcmlhbC5jbGVhcmNvYXRGOTAgPSAxLjA7XHJcblxyXG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXHJcblxyXG5cdFx0bWF0ZXJpYWwuY2xlYXJjb2F0ICo9IHRleHR1cmUyRCggY2xlYXJjb2F0TWFwLCB2Q2xlYXJjb2F0TWFwVXYgKS54O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXHJcblxyXG5cdFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICo9IHRleHR1cmUyRCggY2xlYXJjb2F0Um91Z2huZXNzTWFwLCB2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgKS55O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gc2F0dXJhdGUoIG1hdGVyaWFsLmNsZWFyY29hdCApOyAvLyBCdXJsZXkgY2xlYXJjb2F0IG1vZGVsXHJcblx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWF4KCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDAuMDUyNSApO1xyXG5cdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzcztcclxuXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcywgMS4wICk7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcclxuXHJcblx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSBpcmlkZXNjZW5jZTtcclxuXHRtYXRlcmlhbC5pcmlkZXNjZW5jZUlPUiA9IGlyaWRlc2NlbmNlSU9SO1xyXG5cclxuXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQXHJcblxyXG5cdFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgKj0gdGV4dHVyZTJEKCBpcmlkZXNjZW5jZU1hcCwgdklyaWRlc2NlbmNlTWFwVXYgKS5yO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcclxuXHJcblx0XHRtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IChpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gLSBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0pICogdGV4dHVyZTJEKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYgKS5nICsgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9TSEVFTlxyXG5cclxuXHRtYXRlcmlhbC5zaGVlbkNvbG9yID0gc2hlZW5Db2xvcjtcclxuXHJcblx0I2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxyXG5cclxuXHRcdG1hdGVyaWFsLnNoZWVuQ29sb3IgKj0gdGV4dHVyZTJEKCBzaGVlbkNvbG9yTWFwLCB2U2hlZW5Db2xvck1hcFV2ICkucmdiO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgPSBjbGFtcCggc2hlZW5Sb3VnaG5lc3MsIDAuMDcsIDEuMCApO1xyXG5cclxuXHQjaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUFxyXG5cclxuXHRcdG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICo9IHRleHR1cmUyRCggc2hlZW5Sb3VnaG5lc3NNYXAsIHZTaGVlblJvdWdobmVzc01hcFV2ICkuYTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfQU5JU09UUk9QWVxyXG5cclxuXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcclxuXHJcblx0XHRtYXQyIGFuaXNvdHJvcHlNYXQgPSBtYXQyKCBhbmlzb3Ryb3B5VmVjdG9yLngsIGFuaXNvdHJvcHlWZWN0b3IueSwgLSBhbmlzb3Ryb3B5VmVjdG9yLnksIGFuaXNvdHJvcHlWZWN0b3IueCApO1xyXG5cdFx0dmVjMyBhbmlzb3Ryb3B5UG9sYXIgPSB0ZXh0dXJlMkQoIGFuaXNvdHJvcHlNYXAsIHZBbmlzb3Ryb3B5TWFwVXYgKS5yZ2I7XHJcblx0XHR2ZWMyIGFuaXNvdHJvcHlWID0gYW5pc290cm9weU1hdCAqIG5vcm1hbGl6ZSggMi4wICogYW5pc290cm9weVBvbGFyLnJnIC0gdmVjMiggMS4wICkgKSAqIGFuaXNvdHJvcHlQb2xhci5iO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHZlYzIgYW5pc290cm9weVYgPSBhbmlzb3Ryb3B5VmVjdG9yO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0bWF0ZXJpYWwuYW5pc290cm9weSA9IGxlbmd0aCggYW5pc290cm9weVYgKTtcclxuXHRhbmlzb3Ryb3B5ViAvPSBtYXRlcmlhbC5hbmlzb3Ryb3B5O1xyXG5cdG1hdGVyaWFsLmFuaXNvdHJvcHkgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuYW5pc290cm9weSApO1xyXG5cclxuXHQvLyBSb3VnaG5lc3MgYWxvbmcgdGhlIGFuaXNvdHJvcHkgYml0YW5nZW50IGlzIHRoZSBtYXRlcmlhbCByb3VnaG5lc3MsIHdoaWxlIHRoZSB0YW5nZW50IHJvdWdobmVzcyBpbmNyZWFzZXMgd2l0aCBhbmlzb3Ryb3B5LlxyXG5cdG1hdGVyaWFsLmFscGhhVCA9IG1peCggcG93MiggbWF0ZXJpYWwucm91Z2huZXNzICksIDEuMCwgcG93MiggbWF0ZXJpYWwuYW5pc290cm9weSApICk7XHJcblxyXG5cdG1hdGVyaWFsLmFuaXNvdHJvcHlUID0gdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi54IC0gdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi55O1xyXG5cdG1hdGVyaWFsLmFuaXNvdHJvcHlCID0gdGJuWyAxIF0gKiBhbmlzb3Ryb3B5Vi54ICsgdGJuWyAwIF0gKiBhbmlzb3Ryb3B5Vi55O1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcblxyXG5zdHJ1Y3QgUGh5c2ljYWxNYXRlcmlhbCB7XHJcblxyXG5cdHZlYzMgZGlmZnVzZUNvbG9yO1xyXG5cdGZsb2F0IHJvdWdobmVzcztcclxuXHR2ZWMzIHNwZWN1bGFyQ29sb3I7XHJcblx0ZmxvYXQgc3BlY3VsYXJGOTA7XHJcblxyXG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXHJcblx0XHRmbG9hdCBjbGVhcmNvYXQ7XHJcblx0XHRmbG9hdCBjbGVhcmNvYXRSb3VnaG5lc3M7XHJcblx0XHR2ZWMzIGNsZWFyY29hdEYwO1xyXG5cdFx0ZmxvYXQgY2xlYXJjb2F0RjkwO1xyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWZkZWYgVVNFX0lSSURFU0NFTkNFXHJcblx0XHRmbG9hdCBpcmlkZXNjZW5jZTtcclxuXHRcdGZsb2F0IGlyaWRlc2NlbmNlSU9SO1xyXG5cdFx0ZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3M7XHJcblx0XHR2ZWMzIGlyaWRlc2NlbmNlRnJlc25lbDtcclxuXHRcdHZlYzMgaXJpZGVzY2VuY2VGMDtcclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9TSEVFTlxyXG5cdFx0dmVjMyBzaGVlbkNvbG9yO1xyXG5cdFx0ZmxvYXQgc2hlZW5Sb3VnaG5lc3M7XHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZmRlZiBJT1JcclxuXHRcdGZsb2F0IGlvcjtcclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05cclxuXHRcdGZsb2F0IHRyYW5zbWlzc2lvbjtcclxuXHRcdGZsb2F0IHRyYW5zbWlzc2lvbkFscGhhO1xyXG5cdFx0ZmxvYXQgdGhpY2tuZXNzO1xyXG5cdFx0ZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTtcclxuXHRcdHZlYzMgYXR0ZW51YXRpb25Db2xvcjtcclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9BTklTT1RST1BZXHJcblx0XHRmbG9hdCBhbmlzb3Ryb3B5O1xyXG5cdFx0ZmxvYXQgYWxwaGFUO1xyXG5cdFx0dmVjMyBhbmlzb3Ryb3B5VDtcclxuXHRcdHZlYzMgYW5pc290cm9weUI7XHJcblx0I2VuZGlmXHJcblxyXG59O1xyXG5cclxuLy8gdGVtcG9yYXJ5XHJcbnZlYzMgY2xlYXJjb2F0U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcclxudmVjMyBzaGVlblNwZWN1bGFyID0gdmVjMyggMC4wICk7XHJcblxyXG52ZWMzIFNjaGxpY2tfdG9fRjAoIGNvbnN0IGluIHZlYzMgZiwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcclxuICAgIGZsb2F0IHggPSBjbGFtcCggMS4wIC0gZG90VkgsIDAuMCwgMS4wICk7XHJcbiAgICBmbG9hdCB4MiA9IHggKiB4O1xyXG4gICAgZmxvYXQgeDUgPSBjbGFtcCggeCAqIHgyICogeDIsIDAuMCwgMC45OTk5ICk7XHJcblxyXG4gICAgcmV0dXJuICggZiAtIHZlYzMoIGY5MCApICogeDUgKSAvICggMS4wIC0geDUgKTtcclxufVxyXG5cclxuLy8gTW92aW5nIEZyb3N0Yml0ZSB0byBQaHlzaWNhbGx5IEJhc2VkIFJlbmRlcmluZyAzLjAgLSBwYWdlIDEyLCBsaXN0aW5nIDJcclxuLy8gaHR0cHM6Ly9zZWJsYWdhcmRlLmZpbGVzLndvcmRwcmVzcy5jb20vMjAxNS8wNy9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnJfdjMyLnBkZlxyXG5mbG9hdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XHJcblxyXG5cdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcclxuXHJcblx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xyXG5cdGZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcclxuXHJcblx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xyXG5cclxufVxyXG5cclxuLy8gTWljcm9mYWNldCBNb2RlbHMgZm9yIFJlZnJhY3Rpb24gdGhyb3VnaCBSb3VnaCBTdXJmYWNlcyAtIGVxdWF0aW9uICgzMylcclxuLy8gaHR0cDovL2dyYXBoaWNyYW50cy5ibG9nc3BvdC5jb20vMjAxMy8wOC9zcGVjdWxhci1icmRmLXJlZmVyZW5jZS5odG1sXHJcbi8vIGFscGhhIGlzIFwicm91Z2huZXNzIHNxdWFyZWRcIiBpbiBEaXNuZXnigJlzIHJlcGFyYW1ldGVyaXphdGlvblxyXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xyXG5cclxuXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XHJcblxyXG5cdGZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDsgLy8gYXZvaWQgYWxwaGEgPSAwIHdpdGggZG90TkggPSAxXHJcblxyXG5cdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xyXG5cclxufVxyXG5cclxuLy8gaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZpbGFtZW50L0ZpbGFtZW50Lm1kLmh0bWwjbWF0ZXJpYWxzeXN0ZW0vYW5pc290cm9waWNtb2RlbC9hbmlzb3Ryb3BpY3NwZWN1bGFyYnJkZlxyXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlcclxuXHJcblx0ZmxvYXQgVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljKCBjb25zdCBpbiBmbG9hdCBhbHBoYVQsIGNvbnN0IGluIGZsb2F0IGFscGhhQiwgY29uc3QgaW4gZmxvYXQgZG90VFYsIGNvbnN0IGluIGZsb2F0IGRvdEJWLCBjb25zdCBpbiBmbG9hdCBkb3RUTCwgY29uc3QgaW4gZmxvYXQgZG90QkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WLCBjb25zdCBpbiBmbG9hdCBkb3ROTCApIHtcclxuXHJcblx0XHRmbG9hdCBndiA9IGRvdE5MICogbGVuZ3RoKCB2ZWMzKCBhbHBoYVQgKiBkb3RUViwgYWxwaGFCICogZG90QlYsIGRvdE5WICkgKTtcclxuXHRcdGZsb2F0IGdsID0gZG90TlYgKiBsZW5ndGgoIHZlYzMoIGFscGhhVCAqIGRvdFRMLCBhbHBoYUIgKiBkb3RCTCwgZG90TkwgKSApO1xyXG5cdFx0ZmxvYXQgdiA9IDAuNSAvICggZ3YgKyBnbCApO1xyXG5cclxuXHRcdHJldHVybiBzYXR1cmF0ZSh2KTtcclxuXHJcblx0fVxyXG5cclxuXHRmbG9hdCBEX0dHWF9Bbmlzb3Ryb3BpYyggY29uc3QgaW4gZmxvYXQgYWxwaGFULCBjb25zdCBpbiBmbG9hdCBhbHBoYUIsIGNvbnN0IGluIGZsb2F0IGRvdE5ILCBjb25zdCBpbiBmbG9hdCBkb3RUSCwgY29uc3QgaW4gZmxvYXQgZG90QkggKSB7XHJcblxyXG5cdFx0ZmxvYXQgYTIgPSBhbHBoYVQgKiBhbHBoYUI7XHJcblx0XHRoaWdocCB2ZWMzIHYgPSB2ZWMzKCBhbHBoYUIgKiBkb3RUSCwgYWxwaGFUICogZG90QkgsIGEyICogZG90TkggKTtcclxuXHRcdGhpZ2hwIGZsb2F0IHYyID0gZG90KCB2LCB2ICk7XHJcblx0XHRmbG9hdCB3MiA9IGEyIC8gdjI7XHJcblxyXG5cdFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAqIHBvdzIgKCB3MiApO1xyXG5cclxuXHR9XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXHJcblxyXG5cdC8vIEdHWCBEaXN0cmlidXRpb24sIFNjaGxpY2sgRnJlc25lbCwgR0dYX1NtaXRoQ29ycmVsYXRlZCBWaXNpYmlsaXR5XHJcblx0dmVjMyBCUkRGX0dHWF9DbGVhcmNvYXQoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwpIHtcclxuXHJcblx0XHR2ZWMzIGYwID0gbWF0ZXJpYWwuY2xlYXJjb2F0RjA7XHJcblx0XHRmbG9hdCBmOTAgPSBtYXRlcmlhbC5jbGVhcmNvYXRGOTA7XHJcblx0XHRmbG9hdCByb3VnaG5lc3MgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3M7XHJcblxyXG5cdFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTsgLy8gVUU0J3Mgcm91Z2huZXNzXHJcblxyXG5cdFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcclxuXHJcblx0XHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xyXG5cdFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xyXG5cdFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xyXG5cdFx0ZmxvYXQgZG90VkggPSBzYXR1cmF0ZSggZG90KCB2aWV3RGlyLCBoYWxmRGlyICkgKTtcclxuXHJcblx0XHR2ZWMzIEYgPSBGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICk7XHJcblxyXG5cdFx0ZmxvYXQgViA9IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xyXG5cclxuXHRcdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XHJcblxyXG5cdFx0cmV0dXJuIEYgKiAoIFYgKiBEICk7XHJcblxyXG5cdH1cclxuXHJcbiNlbmRpZlxyXG5cclxudmVjMyBCUkRGX0dHWCggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCApIHtcclxuXHJcblx0dmVjMyBmMCA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3I7XHJcblx0ZmxvYXQgZjkwID0gbWF0ZXJpYWwuc3BlY3VsYXJGOTA7XHJcblx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzO1xyXG5cclxuXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApOyAvLyBVRTQncyByb3VnaG5lc3NcclxuXHJcblx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcclxuXHJcblx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcclxuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XHJcblx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xyXG5cdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XHJcblxyXG5cdHZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTtcclxuXHJcblx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxyXG5cclxuXHRcdEYgPSBtaXgoIEYsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZmRlZiBVU0VfQU5JU09UUk9QWVxyXG5cclxuXHRcdGZsb2F0IGRvdFRMID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgbGlnaHREaXIgKTtcclxuXHRcdGZsb2F0IGRvdFRWID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5VCwgdmlld0RpciApO1xyXG5cdFx0ZmxvYXQgZG90VEggPSBkb3QoIG1hdGVyaWFsLmFuaXNvdHJvcHlULCBoYWxmRGlyICk7XHJcblx0XHRmbG9hdCBkb3RCTCA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIGxpZ2h0RGlyICk7XHJcblx0XHRmbG9hdCBkb3RCViA9IGRvdCggbWF0ZXJpYWwuYW5pc290cm9weUIsIHZpZXdEaXIgKTtcclxuXHRcdGZsb2F0IGRvdEJIID0gZG90KCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgaGFsZkRpciApO1xyXG5cclxuXHRcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIG1hdGVyaWFsLmFscGhhVCwgYWxwaGEsIGRvdFRWLCBkb3RCViwgZG90VEwsIGRvdEJMLCBkb3ROViwgZG90TkwgKTtcclxuXHJcblx0XHRmbG9hdCBEID0gRF9HR1hfQW5pc290cm9waWMoIG1hdGVyaWFsLmFscGhhVCwgYWxwaGEsIGRvdE5ILCBkb3RUSCwgZG90QkggKTtcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XHJcblxyXG5cdFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdHJldHVybiBGICogKCBWICogRCApO1xyXG5cclxufVxyXG5cclxuLy8gUmVjdCBBcmVhIExpZ2h0XHJcblxyXG4vLyBSZWFsLVRpbWUgUG9seWdvbmFsLUxpZ2h0IFNoYWRpbmcgd2l0aCBMaW5lYXJseSBUcmFuc2Zvcm1lZCBDb3NpbmVzXHJcbi8vIGJ5IEVyaWMgSGVpdHosIEpvbmF0aGFuIER1cHV5LCBTdGVwaGVuIEhpbGwgYW5kIERhdmlkIE5ldWJlbHRcclxuLy8gY29kZTogaHR0cHM6Ly9naXRodWIuY29tL3NlbGZzaGFkb3cvbHRjX2NvZGUvXHJcblxyXG52ZWMyIExUQ19VdiggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcclxuXHJcblx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wO1xyXG5cdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xyXG5cdGNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XHJcblxyXG5cdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggTiwgViApICk7XHJcblxyXG5cdC8vIHRleHR1cmUgcGFyYW1ldGVyaXplZCBieSBzcXJ0KCBHR1ggYWxwaGEgKSBhbmQgc3FydCggMSAtIGNvcyggdGhldGEgKSApXHJcblx0dmVjMiB1diA9IHZlYzIoIHJvdWdobmVzcywgc3FydCggMS4wIC0gZG90TlYgKSApO1xyXG5cclxuXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XHJcblxyXG5cdHJldHVybiB1djtcclxuXHJcbn1cclxuXHJcbmZsb2F0IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyBmICkge1xyXG5cclxuXHQvLyBSZWFsLVRpbWUgQXJlYSBMaWdodGluZzogYSBKb3VybmV5IGZyb20gUmVzZWFyY2ggdG8gUHJvZHVjdGlvbiAocC4xMDIpXHJcblx0Ly8gQW4gYXBwcm94aW1hdGlvbiBvZiB0aGUgZm9ybSBmYWN0b3Igb2YgYSBob3Jpem9uLWNsaXBwZWQgcmVjdGFuZ2xlLlxyXG5cclxuXHRmbG9hdCBsID0gbGVuZ3RoKCBmICk7XHJcblxyXG5cdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcclxuXHJcbn1cclxuXHJcbnZlYzMgTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIHYxLCBjb25zdCBpbiB2ZWMzIHYyICkge1xyXG5cclxuXHRmbG9hdCB4ID0gZG90KCB2MSwgdjIgKTtcclxuXHJcblx0ZmxvYXQgeSA9IGFicyggeCApO1xyXG5cclxuXHQvLyByYXRpb25hbCBwb2x5bm9taWFsIGFwcHJveGltYXRpb24gdG8gdGhldGEgLyBzaW4oIHRoZXRhICkgLyAyUElcclxuXHRmbG9hdCBhID0gMC44NTQzOTg1ICsgKCAwLjQ5NjUxNTUgKyAwLjAxNDUyMDYgKiB5ICkgKiB5O1xyXG5cdGZsb2F0IGIgPSAzLjQxNzU5NDAgKyAoIDQuMTYxNjcyNCArIHkgKSAqIHk7XHJcblx0ZmxvYXQgdiA9IGEgLyBiO1xyXG5cclxuXHRmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICggeCA+IDAuMCApID8gdiA6IDAuNSAqIGludmVyc2VzcXJ0KCBtYXgoIDEuMCAtIHggKiB4LCAxZS03ICkgKSAtIHY7XHJcblxyXG5cdHJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTtcclxuXHJcbn1cclxuXHJcbnZlYzMgTFRDX0V2YWx1YXRlKCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gdmVjMyBQLCBjb25zdCBpbiBtYXQzIG1JbnYsIGNvbnN0IGluIHZlYzMgcmVjdENvb3Jkc1sgNCBdICkge1xyXG5cclxuXHQvLyBiYWlsIGlmIHBvaW50IGlzIG9uIGJhY2sgc2lkZSBvZiBwbGFuZSBvZiBsaWdodFxyXG5cdC8vIGFzc3VtZXMgY2N3IHdpbmRpbmcgb3JkZXIgb2YgbGlnaHQgdmVydGljZXNcclxuXHR2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdO1xyXG5cdHZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07XHJcblx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcclxuXHJcblx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcclxuXHJcblx0Ly8gY29uc3RydWN0IG9ydGhvbm9ybWFsIGJhc2lzIGFyb3VuZCBOXHJcblx0dmVjMyBUMSwgVDI7XHJcblx0VDEgPSBub3JtYWxpemUoIFYgLSBOICogZG90KCBWLCBOICkgKTtcclxuXHRUMiA9IC0gY3Jvc3MoIE4sIFQxICk7IC8vIG5lZ2F0ZWQgZnJvbSBwYXBlcjsgcG9zc2libHkgZHVlIHRvIGEgZGlmZmVyZW50IGhhbmRlZG5lc3Mgb2Ygd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW1cclxuXHJcblx0Ly8gY29tcHV0ZSB0cmFuc2Zvcm1cclxuXHRtYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApO1xyXG5cclxuXHQvLyB0cmFuc2Zvcm0gcmVjdFxyXG5cdHZlYzMgY29vcmRzWyA0IF07XHJcblx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcclxuXHRjb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApO1xyXG5cdGNvb3Jkc1sgMiBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAyIF0gLSBQICk7XHJcblx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcclxuXHJcblx0Ly8gcHJvamVjdCByZWN0IG9udG8gc3BoZXJlXHJcblx0Y29vcmRzWyAwIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMCBdICk7XHJcblx0Y29vcmRzWyAxIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMSBdICk7XHJcblx0Y29vcmRzWyAyIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMiBdICk7XHJcblx0Y29vcmRzWyAzIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMyBdICk7XHJcblxyXG5cdC8vIGNhbGN1bGF0ZSB2ZWN0b3IgZm9ybSBmYWN0b3JcclxuXHR2ZWMzIHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwLjAgKTtcclxuXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XHJcblx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApO1xyXG5cdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDIgXSwgY29vcmRzWyAzIF0gKTtcclxuXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XHJcblxyXG5cdC8vIGFkanVzdCBmb3IgaG9yaXpvbiBjbGlwcGluZ1xyXG5cdGZsb2F0IHJlc3VsdCA9IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggdmVjdG9yRm9ybUZhY3RvciApO1xyXG5cclxuLypcclxuXHQvLyBhbHRlcm5hdGUgbWV0aG9kIG9mIGFkanVzdGluZyBmb3IgaG9yaXpvbiBjbGlwcGluZyAoc2VlIHJlZmVyZWNlKVxyXG5cdC8vIHJlZmFjdG9yaW5nIHJlcXVpcmVkXHJcblx0ZmxvYXQgbGVuID0gbGVuZ3RoKCB2ZWN0b3JGb3JtRmFjdG9yICk7XHJcblx0ZmxvYXQgeiA9IHZlY3RvckZvcm1GYWN0b3IueiAvIGxlbjtcclxuXHJcblx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgPSA2NC4wO1xyXG5cdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xyXG5cdGNvbnN0IGZsb2F0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XHJcblxyXG5cdC8vIHRhYnVsYXRlZCBob3Jpem9uLWNsaXBwZWQgc3BoZXJlLCBhcHBhcmVudGx5Li4uXHJcblx0dmVjMiB1diA9IHZlYzIoIHogKiAwLjUgKyAwLjUsIGxlbiApO1xyXG5cdHV2ID0gdXYgKiBMVVRfU0NBTEUgKyBMVVRfQklBUztcclxuXHJcblx0ZmxvYXQgc2NhbGUgPSB0ZXh0dXJlMkQoIGx0Y18yLCB1diApLnc7XHJcblxyXG5cdGZsb2F0IHJlc3VsdCA9IGxlbiAqIHNjYWxlO1xyXG4qL1xyXG5cclxuXHRyZXR1cm4gdmVjMyggcmVzdWx0ICk7XHJcblxyXG59XHJcblxyXG4vLyBFbmQgUmVjdCBBcmVhIExpZ2h0XHJcblxyXG4jaWYgZGVmaW5lZCggVVNFX1NIRUVOIClcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZmlsYW1lbnQvYmxvYi9tYXN0ZXIvc2hhZGVycy9zcmMvYnJkZi5mc1xyXG5mbG9hdCBEX0NoYXJsaWUoIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgZG90TkggKSB7XHJcblxyXG5cdGZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7XHJcblxyXG5cdC8vIEVzdGV2ZXogYW5kIEt1bGxhIDIwMTcsIFwiUHJvZHVjdGlvbiBGcmllbmRseSBNaWNyb2ZhY2V0IFNoZWVuIEJSREZcIlxyXG5cdGZsb2F0IGludkFscGhhID0gMS4wIC8gYWxwaGE7XHJcblx0ZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IO1xyXG5cdGZsb2F0IHNpbjJoID0gbWF4KCAxLjAgLSBjb3MyaCwgMC4wMDc4MTI1ICk7IC8vIDJeKC0xNC8yKSwgc28gc2luMmheMiA+IDAgaW4gZnAxNlxyXG5cclxuXHRyZXR1cm4gKCAyLjAgKyBpbnZBbHBoYSApICogcG93KCBzaW4yaCwgaW52QWxwaGEgKiAwLjUgKSAvICggMi4wICogUEkgKTtcclxuXHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZmlsYW1lbnQvYmxvYi9tYXN0ZXIvc2hhZGVycy9zcmMvYnJkZi5mc1xyXG5mbG9hdCBWX05ldWJlbHQoIGZsb2F0IGRvdE5WLCBmbG9hdCBkb3ROTCApIHtcclxuXHJcblx0Ly8gTmV1YmVsdCBhbmQgUGV0dGluZW8gMjAxMywgXCJDcmFmdGluZyBhIE5leHQtZ2VuIE1hdGVyaWFsIFBpcGVsaW5lIGZvciBUaGUgT3JkZXI6IDE4ODZcIlxyXG5cdHJldHVybiBzYXR1cmF0ZSggMS4wIC8gKCA0LjAgKiAoIGRvdE5MICsgZG90TlYgLSBkb3ROTCAqIGRvdE5WICkgKSApO1xyXG5cclxufVxyXG5cclxudmVjMyBCUkRGX1NoZWVuKCBjb25zdCBpbiB2ZWMzIGxpZ2h0RGlyLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCB2ZWMzIHNoZWVuQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoZWVuUm91Z2huZXNzICkge1xyXG5cclxuXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xyXG5cclxuXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xyXG5cdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcclxuXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XHJcblxyXG5cdGZsb2F0IEQgPSBEX0NoYXJsaWUoIHNoZWVuUm91Z2huZXNzLCBkb3ROSCApO1xyXG5cdGZsb2F0IFYgPSBWX05ldWJlbHQoIGRvdE5WLCBkb3ROTCApO1xyXG5cclxuXHRyZXR1cm4gc2hlZW5Db2xvciAqICggRCAqIFYgKTtcclxuXHJcbn1cclxuXHJcbiNlbmRpZlxyXG5cclxuLy8gVGhpcyBpcyBhIGN1cnZlLWZpdCBhcHByb3htYXRpb24gdG8gdGhlIFwiQ2hhcmxpZSBzaGVlblwiIEJSREYgaW50ZWdyYXRlZCBvdmVyIHRoZSBoZW1pc3BoZXJlIGZyb20gXHJcbi8vIEVzdGV2ZXogYW5kIEt1bGxhIDIwMTcsIFwiUHJvZHVjdGlvbiBGcmllbmRseSBNaWNyb2ZhY2V0IFNoZWVuIEJSREZcIi4gVGhlIGFuYWx5c2lzIGNhbiBiZSBmb3VuZFxyXG4vLyBpbiB0aGUgU2hlZW4gc2VjdGlvbiBvZiBodHRwczovL2RyaXZlLmdvb2dsZS5jb20vZmlsZS9kLzFUMEQxVlN5UjRBbGxxSUpUUUFyYUVJempsYjVoNEZLSC92aWV3P3VzcD1zaGFyaW5nXHJcbmZsb2F0IElCTFNoZWVuQlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xyXG5cclxuXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgdmlld0RpciApICk7XHJcblxyXG5cdGZsb2F0IHIyID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xyXG5cclxuXHRmbG9hdCBhID0gcm91Z2huZXNzIDwgMC4yNSA/IC0zMzkuMiAqIHIyICsgMTYxLjQgKiByb3VnaG5lc3MgLSAyNS45IDogLTguNDggKiByMiArIDE0LjMgKiByb3VnaG5lc3MgLSA5Ljk1O1xyXG5cclxuXHRmbG9hdCBiID0gcm91Z2huZXNzIDwgMC4yNSA/IDQ0LjAgKiByMiAtIDIzLjcgKiByb3VnaG5lc3MgKyAzLjI2IDogMS45NyAqIHIyIC0gMy4yNyAqIHJvdWdobmVzcyArIDAuNzI7XHJcblxyXG5cdGZsb2F0IERHID0gZXhwKCBhICogZG90TlYgKyBiICkgKyAoIHJvdWdobmVzcyA8IDAuMjUgPyAwLjAgOiAwLjEgKiAoIHJvdWdobmVzcyAtIDAuMjUgKSApO1xyXG5cclxuXHRyZXR1cm4gc2F0dXJhdGUoIERHICogUkVDSVBST0NBTF9QSSApO1xyXG5cclxufVxyXG5cclxuLy8gQW5hbHl0aWNhbCBhcHByb3hpbWF0aW9uIG9mIHRoZSBERkcgTFVULCBvbmUgaGFsZiBvZiB0aGVcclxuLy8gc3BsaXQtc3VtIGFwcHJveGltYXRpb24gdXNlZCBpbiBpbmRpcmVjdCBzcGVjdWxhciBsaWdodGluZy5cclxuLy8gdmlhICdlbnZpcm9ubWVudEJSREYnIGZyb20gXCJQaHlzaWNhbGx5IEJhc2VkIFNoYWRpbmcgb24gTW9iaWxlXCJcclxuLy8gaHR0cHM6Ly93d3cudW5yZWFsZW5naW5lLmNvbS9ibG9nL3BoeXNpY2FsbHktYmFzZWQtc2hhZGluZy1vbi1tb2JpbGVcclxudmVjMiBERkdBcHByb3goIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcclxuXHJcblx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xyXG5cclxuXHRjb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTtcclxuXHJcblx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XHJcblxyXG5cdHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XHJcblxyXG5cdGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55O1xyXG5cclxuXHR2ZWMyIGZhYiA9IHZlYzIoIC0gMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7XHJcblxyXG5cdHJldHVybiBmYWI7XHJcblxyXG59XHJcblxyXG52ZWMzIEVudmlyb25tZW50QlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xyXG5cclxuXHR2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcclxuXHJcblx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBmYWIueCArIHNwZWN1bGFyRjkwICogZmFiLnk7XHJcblxyXG59XHJcblxyXG4vLyBGZGV6LUFnw7xlcmEncyBcIk11bHRpcGxlLVNjYXR0ZXJpbmcgTWljcm9mYWNldCBNb2RlbCBmb3IgUmVhbC1UaW1lIEltYWdlIEJhc2VkIExpZ2h0aW5nXCJcclxuLy8gQXBwcm94aW1hdGVzIG11bHRpc2NhdHRlcmluZyBpbiBvcmRlciB0byBwcmVzZXJ2ZSBlbmVyZ3kuXHJcbi8vIGh0dHA6Ly93d3cuamNndC5vcmcvcHVibGlzaGVkLzAwMDgvMDEvMDMvXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0Vcclxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IGlyaWRlc2NlbmNlLCBjb25zdCBpbiB2ZWMzIGlyaWRlc2NlbmNlRjAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHtcclxuI2Vsc2Vcclxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGlub3V0IHZlYzMgc2luZ2xlU2NhdHRlciwgaW5vdXQgdmVjMyBtdWx0aVNjYXR0ZXIgKSB7XHJcbiNlbmRpZlxyXG5cclxuXHR2ZWMyIGZhYiA9IERGR0FwcHJveCggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcclxuXHJcblx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxyXG5cclxuXHRcdHZlYzMgRnIgPSBtaXgoIHNwZWN1bGFyQ29sb3IsIGlyaWRlc2NlbmNlRjAsIGlyaWRlc2NlbmNlICk7XHJcblxyXG5cdCNlbHNlXHJcblxyXG5cdFx0dmVjMyBGciA9IHNwZWN1bGFyQ29sb3I7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHR2ZWMzIEZzc0VzcyA9IEZyICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55O1xyXG5cclxuXHRmbG9hdCBFc3MgPSBmYWIueCArIGZhYi55O1xyXG5cdGZsb2F0IEVtcyA9IDEuMCAtIEVzcztcclxuXHJcblx0dmVjMyBGYXZnID0gRnIgKyAoIDEuMCAtIEZyICkgKiAwLjA0NzYxOTsgLy8gMS8yMVxyXG5cdHZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApO1xyXG5cclxuXHRzaW5nbGVTY2F0dGVyICs9IEZzc0VzcztcclxuXHRtdWx0aVNjYXR0ZXIgKz0gRm1zICogRW1zO1xyXG5cclxufVxyXG5cclxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxyXG5cclxuXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcclxuXHJcblx0XHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcclxuXHRcdHZlYzMgdmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XHJcblx0XHR2ZWMzIHBvc2l0aW9uID0gZ2VvbWV0cnkucG9zaXRpb247XHJcblx0XHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcclxuXHRcdHZlYzMgaGFsZldpZHRoID0gcmVjdEFyZWFMaWdodC5oYWxmV2lkdGg7XHJcblx0XHR2ZWMzIGhhbGZIZWlnaHQgPSByZWN0QXJlYUxpZ2h0LmhhbGZIZWlnaHQ7XHJcblx0XHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xyXG5cdFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwucm91Z2huZXNzO1xyXG5cclxuXHRcdHZlYzMgcmVjdENvb3Jkc1sgNCBdO1xyXG5cdFx0cmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0OyAvLyBjb3VudGVyY2xvY2t3aXNlOyBsaWdodCBzaGluZXMgaW4gbG9jYWwgbmVnIHogZGlyZWN0aW9uXHJcblx0XHRyZWN0Q29vcmRzWyAxIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XHJcblx0XHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XHJcblx0XHRyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XHJcblxyXG5cdFx0dmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcclxuXHJcblx0XHR2ZWM0IHQxID0gdGV4dHVyZTJEKCBsdGNfMSwgdXYgKTtcclxuXHRcdHZlYzQgdDIgPSB0ZXh0dXJlMkQoIGx0Y18yLCB1diApO1xyXG5cclxuXHRcdG1hdDMgbUludiA9IG1hdDMoXHJcblx0XHRcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcclxuXHRcdFx0dmVjMyggICAgMCwgMSwgICAgMCApLFxyXG5cdFx0XHR2ZWMzKCB0MS56LCAwLCB0MS53IClcclxuXHRcdCk7XHJcblxyXG5cdFx0Ly8gTFRDIEZyZXNuZWwgQXBwcm94aW1hdGlvbiBieSBTdGVwaGVuIEhpbGxcclxuXHRcdC8vIGh0dHA6Ly9ibG9nLnNlbGZzaGFkb3cuY29tL3B1YmxpY2F0aW9ucy9zMjAxNi1hZHZhbmNlcy9zMjAxNl9sdGNfZnJlc25lbC5wZGZcclxuXHRcdHZlYzMgZnJlc25lbCA9ICggbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAqIHQyLnggKyAoIHZlYzMoIDEuMCApIC0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciApICogdDIueSApO1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGxpZ2h0Q29sb3IgKiBmcmVzbmVsICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtSW52LCByZWN0Q29vcmRzICk7XHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBsaWdodENvbG9yICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtYXQzKCAxLjAgKSwgcmVjdENvb3JkcyApO1xyXG5cclxuXHR9XHJcblxyXG4jZW5kaWZcclxuXHJcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcclxuXHJcblx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XHJcblxyXG5cdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XHJcblxyXG5cdCNpZmRlZiBVU0VfQ0xFQVJDT0FUXHJcblxyXG5cdFx0ZmxvYXQgZG90TkxjYyA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcclxuXHJcblx0XHR2ZWMzIGNjSXJyYWRpYW5jZSA9IGRvdE5MY2MgKiBkaXJlY3RMaWdodC5jb2xvcjtcclxuXHJcblx0XHRjbGVhcmNvYXRTcGVjdWxhciArPSBjY0lycmFkaWFuY2UgKiBCUkRGX0dHWF9DbGVhcmNvYXQoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbCApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9TSEVFTlxyXG5cclxuXHRcdHNoZWVuU3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU2hlZW4oIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zaGVlbkNvbG9yLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfR0dYKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwgKTtcclxuXHJcblx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcclxufVxyXG5cclxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcclxuXHJcbn1cclxuXHJcbnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyY29hdFJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCkge1xyXG5cclxuXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxyXG5cclxuXHRcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9TSEVFTlxyXG5cclxuXHRcdHNoZWVuU3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIG1hdGVyaWFsLnNoZWVuQ29sb3IgKiBJQkxTaGVlbkJSREYoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciwgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdC8vIEJvdGggaW5kaXJlY3Qgc3BlY3VsYXIgYW5kIGluZGlyZWN0IGRpZmZ1c2UgbGlnaHQgYWNjdW11bGF0ZSBoZXJlXHJcblxyXG5cdHZlYzMgc2luZ2xlU2NhdHRlcmluZyA9IHZlYzMoIDAuMCApO1xyXG5cdHZlYzMgbXVsdGlTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XHJcblx0dmVjMyBjb3NpbmVXZWlnaHRlZElycmFkaWFuY2UgPSBpcnJhZGlhbmNlICogUkVDSVBST0NBTF9QSTtcclxuXHJcblx0I2lmZGVmIFVTRV9JUklERVNDRU5DRVxyXG5cclxuXHRcdGNvbXB1dGVNdWx0aXNjYXR0ZXJpbmdJcmlkZXNjZW5jZSggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwucm91Z2huZXNzLCBzaW5nbGVTY2F0dGVyaW5nLCBtdWx0aVNjYXR0ZXJpbmcgKTtcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0dmVjMyB0b3RhbFNjYXR0ZXJpbmcgPSBzaW5nbGVTY2F0dGVyaW5nICsgbXVsdGlTY2F0dGVyaW5nO1xyXG5cdHZlYzMgZGlmZnVzZSA9IG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqICggMS4wIC0gbWF4KCBtYXgoIHRvdGFsU2NhdHRlcmluZy5yLCB0b3RhbFNjYXR0ZXJpbmcuZyApLCB0b3RhbFNjYXR0ZXJpbmcuYiApICk7XHJcblxyXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gcmFkaWFuY2UgKiBzaW5nbGVTY2F0dGVyaW5nO1xyXG5cdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gbXVsdGlTY2F0dGVyaW5nICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xyXG5cclxuXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gZGlmZnVzZSAqIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZTtcclxuXHJcbn1cclxuXHJcbiNkZWZpbmUgUkVfRGlyZWN0XHRcdFx0XHRSRV9EaXJlY3RfUGh5c2ljYWxcclxuI2RlZmluZSBSRV9EaXJlY3RfUmVjdEFyZWFcdFx0UkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsXHJcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXHRcdFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbFxyXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcdFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxyXG5cclxuLy8gcmVmOiBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXHJcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcclxuXHJcblx0cmV0dXJuIHNhdHVyYXRlKCBwb3coIGRvdE5WICsgYW1iaWVudE9jY2x1c2lvbiwgZXhwMiggLSAxNi4wICogcm91Z2huZXNzIC0gMS4wICkgKSAtIDEuMCArIGFtYmllbnRPY2NsdXNpb24gKTtcclxuXHJcbn1cclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuLyoqXHJcbiAqIFRoaXMgaXMgYSB0ZW1wbGF0ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGxpZ2h0IGEgbWF0ZXJpYWwsIGl0IHVzZXMgcGx1Z2dhYmxlXHJcbiAqIFJlbmRlckVxdWF0aW9ucyAoUkUpZm9yIHNwZWNpZmljIGxpZ2h0aW5nIHNjZW5hcmlvcy5cclxuICpcclxuICogSW5zdHJ1Y3Rpb25zIGZvciB1c2U6XHJcbiAqIC0gRW5zdXJlIHRoYXQgYm90aCBSRV9EaXJlY3QsIFJFX0luZGlyZWN0RGlmZnVzZSBhbmQgUkVfSW5kaXJlY3RTcGVjdWxhciBhcmUgZGVmaW5lZFxyXG4gKiAtIENyZWF0ZSBhIG1hdGVyaWFsIHBhcmFtZXRlciB0aGF0IGlzIHRvIGJlIHBhc3NlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRvIHlvdXIgbGlnaHRpbmcgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBUT0RPOlxyXG4gKiAtIEFkZCBhcmVhIGxpZ2h0IHN1cHBvcnQuXHJcbiAqIC0gQWRkIHNwaGVyZSBsaWdodCBzdXBwb3J0LlxyXG4gKiAtIEFkZCBkaWZmdXNlIGxpZ2h0IHByb2JlIChpcnJhZGlhbmNlIGN1YmVtYXApIHN1cHBvcnQuXHJcbiAqL1xyXG5cclxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcclxuXHJcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xyXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XHJcbmdlb21ldHJ5LnZpZXdEaXIgPSAoIGlzT3J0aG9ncmFwaGljICkgPyB2ZWMzKCAwLCAwLCAxICkgOiBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcclxuXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXHJcblxyXG5cdGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCA9IGNsZWFyY29hdE5vcm1hbDtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxyXG5cclxuXHRmbG9hdCBkb3ROVmkgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xyXG5cclxuXHRpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID09IDAuMCApIHtcclxuXHJcblx0XHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IDAuMDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IHNhdHVyYXRlKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2UgPiAwLjAgKSB7XHJcblxyXG5cdFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsID0gZXZhbElyaWRlc2NlbmNlKCAxLjAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SLCBkb3ROVmksIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICk7XHJcblxyXG5cdFx0Ly8gSXJpZGVzY2VuY2UgRjAgYXBwcm94aW1hdGlvblxyXG5cdFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2VGMCA9IFNjaGxpY2tfdG9fRjAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgMS4wLCBkb3ROVmkgKTtcclxuXHJcblx0fVxyXG5cclxuI2VuZGlmXHJcblxyXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xyXG5cclxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxyXG5cclxuXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XHJcblx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcclxuXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3c7XHJcblx0I2VuZGlmXHJcblxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcclxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xyXG5cclxuXHRcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdGdldFBvaW50TGlnaHRJbmZvKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcclxuXHJcblx0XHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIClcclxuXHRcdHBvaW50TGlnaHRTaGFkb3cgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xyXG5cdFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93QmlhcywgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcclxuXHRcdCNlbmRpZlxyXG5cclxuXHRcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcclxuXHJcblx0fVxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxyXG5cclxuXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xyXG5cdHZlYzQgc3BvdENvbG9yO1xyXG5cdHZlYzMgc3BvdExpZ2h0Q29vcmQ7XHJcblx0Ym9vbCBpblNwb3RMaWdodE1hcDtcclxuXHJcblx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxyXG5cdFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3c7XHJcblx0I2VuZGlmXHJcblxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcclxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XHJcblxyXG5cdFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdGdldFNwb3RMaWdodEluZm8oIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XHJcblxyXG5cdFx0Ly8gc3BvdCBsaWdodHMgYXJlIG9yZGVyZWQgW3NoYWRvd3Mgd2l0aCBtYXBzLCBzaGFkb3dzIHdpdGhvdXQgbWFwcywgbWFwcyB3aXRob3V0IHNoYWRvd3MsIG5vbmVdXHJcblx0XHQjaWYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfU0hBRE9XU19XSVRIX01BUFMgKVxyXG5cdFx0I2RlZmluZSBTUE9UX0xJR0hUX01BUF9JTkRFWCBVTlJPTExFRF9MT09QX0lOREVYXHJcblx0XHQjZWxpZiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIClcclxuXHRcdCNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggTlVNX1NQT1RfTElHSFRfTUFQU1xyXG5cdFx0I2Vsc2VcclxuXHRcdCNkZWZpbmUgU1BPVF9MSUdIVF9NQVBfSU5ERVggKCBVTlJPTExFRF9MT09QX0lOREVYIC0gTlVNX1NQT1RfTElHSFRfU0hBRE9XUyArIE5VTV9TUE9UX0xJR0hUX1NIQURPV1NfV0lUSF9NQVBTIClcclxuXHRcdCNlbmRpZlxyXG5cclxuXHRcdCNpZiAoIFNQT1RfTElHSFRfTUFQX0lOREVYIDwgTlVNX1NQT1RfTElHSFRfTUFQUyApXHJcblx0XHRcdHNwb3RMaWdodENvb3JkID0gdlNwb3RMaWdodENvb3JkWyBpIF0ueHl6IC8gdlNwb3RMaWdodENvb3JkWyBpIF0udztcclxuXHRcdFx0aW5TcG90TGlnaHRNYXAgPSBhbGwoIGxlc3NUaGFuKCBhYnMoIHNwb3RMaWdodENvb3JkICogMi4gLSAxLiApLCB2ZWMzKCAxLjAgKSApICk7XHJcblx0XHRcdHNwb3RDb2xvciA9IHRleHR1cmUyRCggc3BvdExpZ2h0TWFwWyBTUE9UX0xJR0hUX01BUF9JTkRFWCBdLCBzcG90TGlnaHRDb29yZC54eSApO1xyXG5cdFx0XHRkaXJlY3RMaWdodC5jb2xvciA9IGluU3BvdExpZ2h0TWFwID8gZGlyZWN0TGlnaHQuY29sb3IgKiBzcG90Q29sb3IucmdiIDogZGlyZWN0TGlnaHQuY29sb3I7XHJcblx0XHQjZW5kaWZcclxuXHJcblx0XHQjdW5kZWYgU1BPVF9MSUdIVF9NQVBfSU5ERVhcclxuXHJcblx0XHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKVxyXG5cdFx0c3BvdExpZ2h0U2hhZG93ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xyXG5cdFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZTcG90TGlnaHRDb29yZFsgaSBdICkgOiAxLjA7XHJcblx0XHQjZW5kaWZcclxuXHJcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgKCBOVU1fRElSX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxyXG5cclxuXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XHJcblx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXHJcblx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93O1xyXG5cdCNlbmRpZlxyXG5cclxuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XHJcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XHJcblxyXG5cdFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XHJcblxyXG5cdFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xyXG5cclxuXHRcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTIClcclxuXHRcdGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdO1xyXG5cdFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gKCBkaXJlY3RMaWdodC52aXNpYmxlICYmIHJlY2VpdmVTaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XHJcblx0XHQjZW5kaWZcclxuXHJcblx0XHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKVxyXG5cclxuXHRSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQ7XHJcblxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcclxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcclxuXHJcblx0XHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcclxuXHRcdFJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xyXG5cclxuXHR9XHJcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXHJcblxyXG5cdHZlYzMgaWJsSXJyYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xyXG5cclxuXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xyXG5cclxuXHRpcnJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeS5ub3JtYWwgKTtcclxuXHJcblx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXHJcblxyXG5cdFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxyXG5cdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xyXG5cclxuXHRcdFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5Lm5vcm1hbCApO1xyXG5cclxuXHRcdH1cclxuXHRcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXHJcblxyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXHJcblxyXG5cdHZlYzMgcmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcclxuXHR2ZWMzIGNsZWFyY29hdFJhZGlhbmNlID0gdmVjMyggMC4wICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXHJcblxyXG5cdCNpZmRlZiBVU0VfTElHSFRNQVBcclxuXHJcblx0XHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2TGlnaHRNYXBVdiApO1xyXG5cdFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApICYmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxyXG5cclxuXHRcdGlibElycmFkaWFuY2UgKz0gZ2V0SUJMSXJyYWRpYW5jZSggZ2VvbWV0cnkubm9ybWFsICk7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxyXG5cclxuXHQjaWZkZWYgVVNFX0FOSVNPVFJPUFlcclxuXHJcblx0XHRyYWRpYW5jZSArPSBnZXRJQkxBbmlzb3Ryb3B5UmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwucm91Z2huZXNzLCBtYXRlcmlhbC5hbmlzb3Ryb3B5QiwgbWF0ZXJpYWwuYW5pc290cm9weSApO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHJhZGlhbmNlICs9IGdldElCTFJhZGlhbmNlKCBnZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIG1hdGVyaWFsLnJvdWdobmVzcyApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcclxuXHJcblx0XHRjbGVhcmNvYXRSYWRpYW5jZSArPSBnZXRJQkxSYWRpYW5jZSggZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXHJcblxyXG5cdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXHJcblxyXG5cdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBpYmxJcnJhZGlhbmNlLCBjbGVhcmNvYXRSYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcclxuXHJcblx0Ly8gRG9pbmcgYSBzdHJpY3QgY29tcGFyaXNvbiB3aXRoID09IDEuMCBjYW4gY2F1c2Ugbm9pc2UgYXJ0aWZhY3RzXHJcblx0Ly8gb24gc29tZSBwbGF0Zm9ybXMuIFNlZSBpc3N1ZSAjMTc2MjMuXHJcblx0Z2xfRnJhZ0RlcHRoRVhUID0gdklzUGVyc3BlY3RpdmUgPT0gMC4wID8gZ2xfRnJhZ0Nvb3JkLnogOiBsb2cyKCB2RnJhZ0RlcHRoICkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcclxuXHJcblx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xyXG5cdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcclxuXHR2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcclxuXHJcblx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcclxuXHJcblx0XHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XHJcblx0XHR2YXJ5aW5nIGZsb2F0IHZJc1BlcnNwZWN0aXZlO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxyXG5cclxuXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxyXG5cclxuXHRcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xyXG5cdFx0dklzUGVyc3BlY3RpdmUgPSBmbG9hdCggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICk7XHJcblxyXG5cdCNlbHNlXHJcblxyXG5cdFx0aWYgKCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKSB7XHJcblxyXG5cdFx0XHRnbF9Qb3NpdGlvbi56ID0gbG9nMiggbWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7XHJcblxyXG5cdFx0XHRnbF9Qb3NpdGlvbi56ICo9IGdsX1Bvc2l0aW9uLnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX01BUFxyXG5cclxuXHRkaWZmdXNlQ29sb3IgKj0gdGV4dHVyZTJEKCBtYXAsIHZNYXBVdiApO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXHJcblxyXG5cdCNpZiBkZWZpbmVkKCBVU0VfUE9JTlRTX1VWIClcclxuXHJcblx0XHR2ZWMyIHV2ID0gdlV2O1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9NQVBcclxuXHJcblx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB1diApO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgVVNFX0FMUEhBTUFQXHJcblxyXG5cdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHV2ICkuZztcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgZGVmaW5lZCggVVNFX1BPSU5UU19VViApXHJcblxyXG5cdHZhcnlpbmcgdmVjMiB2VXY7XHJcblxyXG4jZWxzZVxyXG5cclxuXHQjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXHJcblxyXG5cdFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9NQVBcclxuXHJcblx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgVVNFX0FMUEhBTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbmZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcclxuXHJcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXHJcblxyXG5cdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdk1ldGFsbmVzc01hcFV2ICk7XHJcblxyXG5cdC8vIHJlYWRzIGNoYW5uZWwgQiwgY29tcGF0aWJsZSB3aXRoIGEgY29tYmluZWQgT2NjbHVzaW9uUm91Z2huZXNzTWV0YWxsaWMgKFJHQikgdGV4dHVyZVxyXG5cdG1ldGFsbmVzc0ZhY3RvciAqPSB0ZXhlbE1ldGFsbmVzcy5iO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgZGVmaW5lZCggVVNFX01PUlBIQ09MT1JTICkgJiYgZGVmaW5lZCggTU9SUEhUQVJHRVRTX1RFWFRVUkUgKVxyXG5cclxuXHQvLyBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UgaXMgc2V0IGJhc2VkIG9uIEJ1ZmZlckdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlIHZhbHVlOlxyXG5cdC8vIFdoZW4gbW9ycGhUYXJnZXRzUmVsYXRpdmUgaXMgZmFsc2UsIHRoaXMgaXMgc2V0IHRvIDEgLSBzdW0oaW5mbHVlbmNlcyk7IHRoaXMgcmVzdWx0cyBpbiBub3JtYWwgPSBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxyXG5cdC8vIFdoZW4gbW9ycGhUYXJnZXRzUmVsYXRpdmUgaXMgdHJ1ZSwgdGhpcyBpcyBzZXQgdG8gMTsgYXMgYSByZXN1bHQsIGFsbCBtb3JwaCB0YXJnZXRzIGFyZSBzaW1wbHkgYWRkZWQgdG8gdGhlIGJhc2UgYWZ0ZXIgd2VpZ2h0aW5nXHJcblx0dkNvbG9yICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcclxuXHJcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xyXG5cclxuXHRcdCNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxyXG5cclxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcclxuXHJcblx0XHQjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKVxyXG5cclxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkucmdiICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XHJcblxyXG5cdFx0I2VuZGlmXHJcblxyXG5cdH1cclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX01PUlBITk9STUFMU1xyXG5cclxuXHQvLyBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UgaXMgc2V0IGJhc2VkIG9uIEJ1ZmZlckdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlIHZhbHVlOlxyXG5cdC8vIFdoZW4gbW9ycGhUYXJnZXRzUmVsYXRpdmUgaXMgZmFsc2UsIHRoaXMgaXMgc2V0IHRvIDEgLSBzdW0oaW5mbHVlbmNlcyk7IHRoaXMgcmVzdWx0cyBpbiBub3JtYWwgPSBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxyXG5cdC8vIFdoZW4gbW9ycGhUYXJnZXRzUmVsYXRpdmUgaXMgdHJ1ZSwgdGhpcyBpcyBzZXQgdG8gMTsgYXMgYSByZXN1bHQsIGFsbCBtb3JwaCB0YXJnZXRzIGFyZSBzaW1wbHkgYWRkZWQgdG8gdGhlIGJhc2UgYWZ0ZXIgd2VpZ2h0aW5nXHJcblx0b2JqZWN0Tm9ybWFsICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcclxuXHJcblx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXHJcblxyXG5cdFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSBvYmplY3ROb3JtYWwgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAxICkueHl6ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcclxuXHRcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDEgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcclxuXHRcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDIgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcclxuXHRcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcclxuXHJcblx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XHJcblxyXG5cdCNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRVxyXG5cclxuXHRcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTtcclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEQXJyYXkgbW9ycGhUYXJnZXRzVGV4dHVyZTtcclxuXHRcdHVuaWZvcm0gaXZlYzIgbW9ycGhUYXJnZXRzVGV4dHVyZVNpemU7XHJcblxyXG5cdFx0dmVjNCBnZXRNb3JwaCggY29uc3QgaW4gaW50IHZlcnRleEluZGV4LCBjb25zdCBpbiBpbnQgbW9ycGhUYXJnZXRJbmRleCwgY29uc3QgaW4gaW50IG9mZnNldCApIHtcclxuXHJcblx0XHRcdGludCB0ZXhlbEluZGV4ID0gdmVydGV4SW5kZXggKiBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgKyBvZmZzZXQ7XHJcblx0XHRcdGludCB5ID0gdGV4ZWxJbmRleCAvIG1vcnBoVGFyZ2V0c1RleHR1cmVTaXplLng7XHJcblx0XHRcdGludCB4ID0gdGV4ZWxJbmRleCAtIHkgKiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZS54O1xyXG5cclxuXHRcdFx0aXZlYzMgbW9ycGhVViA9IGl2ZWMzKCB4LCB5LCBtb3JwaFRhcmdldEluZGV4ICk7XHJcblx0XHRcdHJldHVybiB0ZXhlbEZldGNoKCBtb3JwaFRhcmdldHNUZXh0dXJlLCBtb3JwaFVWLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xyXG5cclxuXHRcdFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcclxuXHJcblx0XHQjZWxzZVxyXG5cclxuXHRcdFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcclxuXHJcblx0Ly8gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlIGlzIHNldCBiYXNlZCBvbiBCdWZmZXJHZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSB2YWx1ZTpcclxuXHQvLyBXaGVuIG1vcnBoVGFyZ2V0c1JlbGF0aXZlIGlzIGZhbHNlLCB0aGlzIGlzIHNldCB0byAxIC0gc3VtKGluZmx1ZW5jZXMpOyB0aGlzIHJlc3VsdHMgaW4gcG9zaXRpb24gPSBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxyXG5cdC8vIFdoZW4gbW9ycGhUYXJnZXRzUmVsYXRpdmUgaXMgdHJ1ZSwgdGhpcyBpcyBzZXQgdG8gMTsgYXMgYSByZXN1bHQsIGFsbCBtb3JwaCB0YXJnZXRzIGFyZSBzaW1wbHkgYWRkZWQgdG8gdGhlIGJhc2UgYWZ0ZXIgd2VpZ2h0aW5nXHJcblx0dHJhbnNmb3JtZWQgKj0gbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xyXG5cclxuXHQjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcclxuXHJcblx0XHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICE9IDAuMCApIHRyYW5zZm9ybWVkICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMCApLnh5eiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDAgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcclxuXHRcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0MSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xyXG5cdFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQyICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XHJcblx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDMgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcclxuXHJcblx0XHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcclxuXHJcblx0XHRcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xyXG5cdFx0XHR0cmFuc2Zvcm1lZCArPSBtb3JwaFRhcmdldDUgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcclxuXHRcdFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ2ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XHJcblx0XHRcdHRyYW5zZm9ybWVkICs9IG1vcnBoVGFyZ2V0NyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xyXG5cclxuXHRcdCNlbmRpZlxyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG5mbG9hdCBmYWNlRGlyZWN0aW9uID0gZ2xfRnJvbnRGYWNpbmcgPyAxLjAgOiAtIDEuMDtcclxuXHJcbiNpZmRlZiBGTEFUX1NIQURFRFxyXG5cclxuXHR2ZWMzIGZkeCA9IGRGZHgoIHZWaWV3UG9zaXRpb24gKTtcclxuXHR2ZWMzIGZkeSA9IGRGZHkoIHZWaWV3UG9zaXRpb24gKTtcclxuXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcclxuXHJcbiNlbHNlXHJcblxyXG5cdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XHJcblxyXG5cdCNpZmRlZiBET1VCTEVfU0lERURcclxuXHJcblx0XHRub3JtYWwgKj0gZmFjZURpcmVjdGlvbjtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQX1RBTkdFTlRTUEFDRSApIHx8IGRlZmluZWQoIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKVxyXG5cclxuXHQjaWZkZWYgVVNFX1RBTkdFTlRcclxuXHJcblx0XHRtYXQzIHRibiA9IG1hdDMoIG5vcm1hbGl6ZSggdlRhbmdlbnQgKSwgbm9ybWFsaXplKCB2Qml0YW5nZW50ICksIG5vcm1hbCApO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdG1hdDMgdGJuID0gZ2V0VGFuZ2VudEZyYW1lKCAtIHZWaWV3UG9zaXRpb24sIG5vcm1hbCxcclxuXHRcdCNpZiBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcclxuXHRcdFx0dk5vcm1hbE1hcFV2XHJcblx0XHQjZWxpZiBkZWZpbmVkKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApXHJcblx0XHRcdHZDbGVhcmNvYXROb3JtYWxNYXBVdlxyXG5cdFx0I2Vsc2VcclxuXHRcdFx0dlV2XHJcblx0XHQjZW5kaWZcclxuXHRcdCk7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWYgZGVmaW5lZCggRE9VQkxFX1NJREVEICkgJiYgISBkZWZpbmVkKCBGTEFUX1NIQURFRCApXHJcblxyXG5cdFx0dGJuWzBdICo9IGZhY2VEaXJlY3Rpb247XHJcblx0XHR0Ym5bMV0gKj0gZmFjZURpcmVjdGlvbjtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxyXG5cclxuXHQjaWZkZWYgVVNFX1RBTkdFTlRcclxuXHJcblx0XHRtYXQzIHRibjIgPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApLCBub3JtYWwgKTtcclxuXHJcblx0I2Vsc2VcclxuXHJcblx0XHRtYXQzIHRibjIgPSBnZXRUYW5nZW50RnJhbWUoIC0gdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZiBkZWZpbmVkKCBET1VCTEVfU0lERUQgKSAmJiAhIGRlZmluZWQoIEZMQVRfU0hBREVEIClcclxuXHJcblx0XHR0Ym4yWzBdICo9IGZhY2VEaXJlY3Rpb247XHJcblx0XHR0Ym4yWzFdICo9IGZhY2VEaXJlY3Rpb247XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcblxyXG4vLyBub24gcGVydHVyYmVkIG5vcm1hbCBmb3IgY2xlYXJjb2F0IGFtb25nIG90aGVyc1xyXG5cclxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtcclxuXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcblxyXG4jaWZkZWYgVVNFX05PUk1BTE1BUF9PQkpFQ1RTUEFDRVxyXG5cclxuXHRub3JtYWwgPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdk5vcm1hbE1hcFV2ICkueHl6ICogMi4wIC0gMS4wOyAvLyBvdmVycmlkZXMgYm90aCBmbGF0U2hhZGluZyBhbmQgYXR0cmlidXRlIG5vcm1hbHNcclxuXHJcblx0I2lmZGVmIEZMSVBfU0lERURcclxuXHJcblx0XHRub3JtYWwgPSAtIG5vcm1hbDtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZmRlZiBET1VCTEVfU0lERURcclxuXHJcblx0XHRub3JtYWwgPSBub3JtYWwgKiBmYWNlRGlyZWN0aW9uO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0bm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcclxuXHJcbiNlbGlmIGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcclxuXHJcblx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZOb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDtcclxuXHRtYXBOLnh5ICo9IG5vcm1hbFNjYWxlO1xyXG5cclxuXHRub3JtYWwgPSBub3JtYWxpemUoIHRibiAqIG1hcE4gKTtcclxuXHJcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcclxuXHJcblx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpLCBmYWNlRGlyZWN0aW9uICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmbmRlZiBGTEFUX1NIQURFRFxyXG5cclxuXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcclxuXHJcblx0I2lmZGVmIFVTRV9UQU5HRU5UXHJcblxyXG5cdFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xyXG5cdFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZm5kZWYgRkxBVF9TSEFERURcclxuXHJcblx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XHJcblxyXG5cdCNpZmRlZiBVU0VfVEFOR0VOVFxyXG5cclxuXHRcdHZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcclxuXHRcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZuZGVmIEZMQVRfU0hBREVEIC8vIG5vcm1hbCBpcyBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcclxuXHJcblx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcclxuXHJcblx0I2lmZGVmIFVTRV9UQU5HRU5UXHJcblxyXG5cdFx0dlRhbmdlbnQgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkVGFuZ2VudCApO1xyXG5cdFx0dkJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcclxuXHJcblx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xyXG5cdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9OT1JNQUxNQVBfT0JKRUNUU1BBQ0VcclxuXHJcblx0dW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmICEgZGVmaW5lZCAoIFVTRV9UQU5HRU5UICkgJiYgKCBkZWZpbmVkICggVVNFX05PUk1BTE1BUF9UQU5HRU5UU1BBQ0UgKSB8fCBkZWZpbmVkICggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApIClcclxuXHJcblx0Ly8gTm9ybWFsIE1hcHBpbmcgV2l0aG91dCBQcmVjb21wdXRlZCBUYW5nZW50c1xyXG5cdC8vIGh0dHA6Ly93d3cudGhldGVudGhwbGFuZXQuZGUvYXJjaGl2ZXMvMTE4MFxyXG5cclxuXHRtYXQzIGdldFRhbmdlbnRGcmFtZSggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiB1diApIHtcclxuXHJcblx0XHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcclxuXHRcdHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xyXG5cdFx0dmVjMiBzdDAgPSBkRmR4KCB1di5zdCApO1xyXG5cdFx0dmVjMiBzdDEgPSBkRmR5KCB1di5zdCApO1xyXG5cclxuXHRcdHZlYzMgTiA9IHN1cmZfbm9ybTsgLy8gbm9ybWFsaXplZFxyXG5cclxuXHRcdHZlYzMgcTFwZXJwID0gY3Jvc3MoIHExLCBOICk7XHJcblx0XHR2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApO1xyXG5cclxuXHRcdHZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7XHJcblx0XHR2ZWMzIEIgPSBxMXBlcnAgKiBzdDAueSArIHEwcGVycCAqIHN0MS55O1xyXG5cclxuXHRcdGZsb2F0IGRldCA9IG1heCggZG90KCBULCBUICksIGRvdCggQiwgQiApICk7XHJcblx0XHRmbG9hdCBzY2FsZSA9ICggZGV0ID09IDAuMCApID8gMC4wIDogaW52ZXJzZXNxcnQoIGRldCApO1xyXG5cclxuXHRcdHJldHVybiBtYXQzKCBUICogc2NhbGUsIEIgKiBzY2FsZSwgTiApO1xyXG5cclxuXHR9XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcclxuXHJcblx0dmVjMyBjbGVhcmNvYXROb3JtYWwgPSBnZW9tZXRyeU5vcm1hbDtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcclxuXHJcblx0dmVjMyBjbGVhcmNvYXRNYXBOID0gdGV4dHVyZTJEKCBjbGVhcmNvYXROb3JtYWxNYXAsIHZDbGVhcmNvYXROb3JtYWxNYXBVdiApLnh5eiAqIDIuMCAtIDEuMDtcclxuXHRjbGVhcmNvYXRNYXBOLnh5ICo9IGNsZWFyY29hdE5vcm1hbFNjYWxlO1xyXG5cclxuXHRjbGVhcmNvYXROb3JtYWwgPSBub3JtYWxpemUoIHRibjIgKiBjbGVhcmNvYXRNYXBOICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE1hcDtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfTk9STUFMTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdE5vcm1hbE1hcDtcclxuXHR1bmlmb3JtIHZlYzIgY2xlYXJjb2F0Tm9ybWFsU2NhbGU7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXRSb3VnaG5lc3NNYXA7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcclxuXHJcblx0dW5pZm9ybSBzYW1wbGVyMkQgaXJpZGVzY2VuY2VNYXA7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBPUEFRVUVcclxuZGlmZnVzZUNvbG9yLmEgPSAxLjA7XHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cclxuZGlmZnVzZUNvbG9yLmEgKj0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGE7XHJcbiNlbmRpZlxyXG5cclxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxudmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xyXG5cdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xyXG59XHJcblxyXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcclxuXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcclxufVxyXG5cclxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1LjsgLy8gZnJhY3Rpb24gLT4gMC4uMSAoaW5jbHVkaW5nIDEpXHJcbmNvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuOyAvLyAwLi4xIC0+IGZyYWN0aW9uIChleGNsdWRpbmcgMSlcclxuXHJcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAyNTYuICk7XHJcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xyXG5cclxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XHJcblxyXG52ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHtcclxuXHR2ZWM0IHIgPSB2ZWM0KCBmcmFjdCggdiAqIFBhY2tGYWN0b3JzICksIHYgKTtcclxuXHRyLnl6dyAtPSByLnh5eiAqIFNoaWZ0UmlnaHQ4OyAvLyB0aWR5IG92ZXJmbG93XHJcblx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcclxufVxyXG5cclxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcclxuXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XHJcbn1cclxuXHJcbnZlYzIgcGFja0RlcHRoVG9SRyggaW4gaGlnaHAgZmxvYXQgdiApIHtcclxuXHRyZXR1cm4gcGFja0RlcHRoVG9SR0JBKCB2ICkueXg7XHJcbn1cclxuXHJcbmZsb2F0IHVucGFja1JHVG9EZXB0aCggY29uc3QgaW4gaGlnaHAgdmVjMiB2ICkge1xyXG5cdHJldHVybiB1bnBhY2tSR0JBVG9EZXB0aCggdmVjNCggdi54eSwgMC4wLCAwLjAgKSApO1xyXG59XHJcblxyXG52ZWM0IHBhY2sySGFsZlRvUkdCQSggdmVjMiB2ICkge1xyXG5cdHZlYzQgciA9IHZlYzQoIHYueCwgZnJhY3QoIHYueCAqIDI1NS4wICksIHYueSwgZnJhY3QoIHYueSAqIDI1NS4wICkgKTtcclxuXHRyZXR1cm4gdmVjNCggci54IC0gci55IC8gMjU1LjAsIHIueSwgci56IC0gci53IC8gMjU1LjAsIHIudyApO1xyXG59XHJcblxyXG52ZWMyIHVucGFja1JHQkFUbzJIYWxmKCB2ZWM0IHYgKSB7XHJcblx0cmV0dXJuIHZlYzIoIHYueCArICggdi55IC8gMjU1LjAgKSwgdi56ICsgKCB2LncgLyAyNTUuMCApICk7XHJcbn1cclxuXHJcbi8vIE5PVEU6IHZpZXdaLCB0aGUgei1jb29yZGluYXRlIGluIGNhbWVyYSBzcGFjZSwgaXMgbmVnYXRpdmUgZm9yIHBvaW50cyBpbiBmcm9udCBvZiB0aGUgY2FtZXJhXHJcblxyXG5mbG9hdCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XHJcblx0Ly8gLW5lYXIgbWFwcyB0byAwOyAtZmFyIG1hcHMgdG8gMVxyXG5cdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XHJcbn1cclxuXHJcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgZGVwdGgsIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcclxuXHQvLyBtYXBzIG9ydGhvZ3JhcGhpYyBkZXB0aCBpbiBbIDAsIDEgXSB0byB2aWV3WlxyXG5cdHJldHVybiBkZXB0aCAqICggbmVhciAtIGZhciApIC0gbmVhcjtcclxufVxyXG5cclxuLy8gTk9URTogaHR0cHM6Ly90d2l0dGVyLmNvbS9nb25uYXZpcy9zdGF0dXMvMTM3NzE4Mzc4Njk0OTk1OTY4MlxyXG5cclxuZmxvYXQgdmlld1pUb1BlcnNwZWN0aXZlRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XHJcblx0Ly8gLW5lYXIgbWFwcyB0byAwOyAtZmFyIG1hcHMgdG8gMVxyXG5cdHJldHVybiAoICggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApO1xyXG59XHJcblxyXG5mbG9hdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgZGVwdGgsIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcclxuXHQvLyBtYXBzIHBlcnNwZWN0aXZlIGRlcHRoIGluIFsgMCwgMSBdIHRvIHZpZXdaXHJcblx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGRlcHRoIC0gZmFyICk7XHJcbn1cclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFBSRU1VTFRJUExJRURfQUxQSEFcclxuXHJcblx0Ly8gR2V0IGdldCBub3JtYWwgYmxlbmRpbmcgd2l0aCBwcmVtdWx0aXBsZWQsIHVzZSB3aXRoIEN1c3RvbUJsZW5kaW5nLCBPbmVGYWN0b3IsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIEFkZEVxdWF0aW9uLlxyXG5cdGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxudmVjNCBtdlBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xyXG5cclxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXHJcblxyXG5cdG12UG9zaXRpb24gPSBpbnN0YW5jZU1hdHJpeCAqIG12UG9zaXRpb247XHJcblxyXG4jZW5kaWZcclxuXHJcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xyXG5cclxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIERJVEhFUklOR1xyXG5cclxuXHRnbF9GcmFnQ29sb3IucmdiID0gZGl0aGVyaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIERJVEhFUklOR1xyXG5cclxuXHQvLyBiYXNlZCBvbiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvTXNsR1I4XHJcblx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XHJcblx0XHQvL0NhbGN1bGF0ZSBncmlkIHBvc2l0aW9uXHJcblx0XHRmbG9hdCBncmlkX3Bvc2l0aW9uID0gcmFuZCggZ2xfRnJhZ0Nvb3JkLnh5ICk7XHJcblxyXG5cdFx0Ly9TaGlmdCB0aGUgaW5kaXZpZHVhbCBjb2xvcnMgZGlmZmVyZW50bHksIHRodXMgbWFraW5nIGl0IGV2ZW4gaGFyZGVyIHRvIHNlZSB0aGUgZGl0aGVyaW5nIHBhdHRlcm5cclxuXHRcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XHJcblxyXG5cdFx0Ly9tb2RpZnkgc2hpZnQgYWNjb3JkaW5nIHRvIGdyaWQgcG9zaXRpb24uXHJcblx0XHRkaXRoZXJfc2hpZnRfUkdCID0gbWl4KCAyLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCAtMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgZ3JpZF9wb3NpdGlvbiApO1xyXG5cclxuXHRcdC8vc2hpZnQgdGhlIGNvbG9yIGJ5IGRpdGhlcl9zaGlmdFxyXG5cdFx0cmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjtcclxuXHR9XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzO1xyXG5cclxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcclxuXHJcblx0dmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2Um91Z2huZXNzTWFwVXYgKTtcclxuXHJcblx0Ly8gcmVhZHMgY2hhbm5lbCBHLCBjb21wYXRpYmxlIHdpdGggYSBjb21iaW5lZCBPY2NsdXNpb25Sb3VnaG5lc3NNZXRhbGxpYyAoUkdCKSB0ZXh0dXJlXHJcblx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcclxuXHJcblx0dW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwO1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXHJcblxyXG5cdHZhcnlpbmcgdmVjNCB2U3BvdExpZ2h0Q29vcmRbIE5VTV9TUE9UX0xJR0hUX0NPT1JEUyBdO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaWYgTlVNX1NQT1RfTElHSFRfTUFQUyA+IDBcclxuXHJcblx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdExpZ2h0TWFwWyBOVU1fU1BPVF9MSUdIVF9NQVBTIF07XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfU0hBRE9XTUFQXHJcblxyXG5cdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXHJcblxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xyXG5cdFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcclxuXHJcblx0XHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyB7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0JpYXM7XHJcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XHJcblx0XHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcclxuXHRcdFx0dmVjMiBzaGFkb3dNYXBTaXplO1xyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXHJcblxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHRcdHN0cnVjdCBTcG90TGlnaHRTaGFkb3cge1xyXG5cdFx0XHRmbG9hdCBzaGFkb3dCaWFzO1xyXG5cdFx0XHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xyXG5cdFx0XHRmbG9hdCBzaGFkb3dSYWRpdXM7XHJcblx0XHRcdHZlYzIgc2hhZG93TWFwU2l6ZTtcclxuXHRcdH07XHJcblxyXG5cdFx0dW5pZm9ybSBTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93c1sgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxyXG5cclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xyXG5cdFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHRcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcclxuXHRcdFx0ZmxvYXQgc2hhZG93QmlhcztcclxuXHRcdFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcclxuXHRcdFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xyXG5cdFx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcclxuXHRcdH07XHJcblxyXG5cdFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0LypcclxuXHQjaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXHJcblxyXG5cdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IGNyZWF0ZSB1bmlmb3JtcyBmb3IgYXJlYSBsaWdodCBzaGFkb3dzXHJcblxyXG5cdCNlbmRpZlxyXG5cdCovXHJcblxyXG5cdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmVjMiB0ZXh0dXJlMkREaXN0cmlidXRpb24oIHNhbXBsZXIyRCBzaGFkb3csIHZlYzIgdXYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHVucGFja1JHQkFUbzJIYWxmKCB0ZXh0dXJlMkQoIHNoYWRvdywgdXYgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsb2F0IFZTTVNoYWRvdyAoc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApe1xyXG5cclxuXHRcdGZsb2F0IG9jY2x1c2lvbiA9IDEuMDtcclxuXHJcblx0XHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2hhZG93LCB1diApO1xyXG5cclxuXHRcdGZsb2F0IGhhcmRfc2hhZG93ID0gc3RlcCggY29tcGFyZSAsIGRpc3RyaWJ1dGlvbi54ICk7IC8vIEhhcmQgU2hhZG93XHJcblxyXG5cdFx0aWYgKGhhcmRfc2hhZG93ICE9IDEuMCApIHtcclxuXHJcblx0XHRcdGZsb2F0IGRpc3RhbmNlID0gY29tcGFyZSAtIGRpc3RyaWJ1dGlvbi54IDtcclxuXHRcdFx0ZmxvYXQgdmFyaWFuY2UgPSBtYXgoIDAuMDAwMDAsIGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKTtcclxuXHRcdFx0ZmxvYXQgc29mdG5lc3NfcHJvYmFiaWxpdHkgPSB2YXJpYW5jZSAvICh2YXJpYW5jZSArIGRpc3RhbmNlICogZGlzdGFuY2UgKTsgLy8gQ2hlYmV5c2hldnMgaW5lcXVhbGl0eVxyXG5cdFx0XHRzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IGNsYW1wKCAoIHNvZnRuZXNzX3Byb2JhYmlsaXR5IC0gMC4zICkgLyAoIDAuOTUgLSAwLjMgKSwgMC4wLCAxLjAgKTsgLy8gMC4zIHJlZHVjZXMgbGlnaHQgYmxlZWRcclxuXHRcdFx0b2NjbHVzaW9uID0gY2xhbXAoIG1heCggaGFyZF9zaGFkb3csIHNvZnRuZXNzX3Byb2JhYmlsaXR5ICksIDAuMCwgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG9jY2x1c2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xyXG5cclxuXHRcdGZsb2F0IHNoYWRvdyA9IDEuMDtcclxuXHJcblx0XHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcclxuXHRcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhcztcclxuXHJcblx0XHRib29sIGluRnJ1c3R1bSA9IHNoYWRvd0Nvb3JkLnggPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnggPD0gMS4wICYmIHNoYWRvd0Nvb3JkLnkgPj0gMC4wICYmIHNoYWRvd0Nvb3JkLnkgPD0gMS4wO1xyXG5cdFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGluRnJ1c3R1bSAmJiBzaGFkb3dDb29yZC56IDw9IDEuMDtcclxuXHJcblx0XHRpZiAoIGZydXN0dW1UZXN0ICkge1xyXG5cclxuXHRcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxyXG5cclxuXHRcdFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XHJcblxyXG5cdFx0XHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xyXG5cdFx0XHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xyXG5cdFx0XHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xyXG5cdFx0XHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xyXG5cdFx0XHRmbG9hdCBkeDIgPSBkeDAgLyAyLjA7XHJcblx0XHRcdGZsb2F0IGR5MiA9IGR5MCAvIDIuMDtcclxuXHRcdFx0ZmxvYXQgZHgzID0gZHgxIC8gMi4wO1xyXG5cdFx0XHRmbG9hdCBkeTMgPSBkeTEgLyAyLjA7XHJcblxyXG5cdFx0XHRzaGFkb3cgPSAoXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MywgZHkyICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MiwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTMgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXHJcblx0XHRcdCkgKiAoIDEuMCAvIDE3LjAgKTtcclxuXHJcblx0XHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXHJcblxyXG5cdFx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcclxuXHRcdFx0ZmxvYXQgZHggPSB0ZXhlbFNpemUueDtcclxuXHRcdFx0ZmxvYXQgZHkgPSB0ZXhlbFNpemUueTtcclxuXHJcblx0XHRcdHZlYzIgdXYgPSBzaGFkb3dDb29yZC54eTtcclxuXHRcdFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2hhZG93TWFwU2l6ZSArIDAuNSApO1xyXG5cdFx0XHR1diAtPSBmICogdGV4ZWxTaXplO1xyXG5cclxuXHRcdFx0c2hhZG93ID0gKFxyXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYsIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgK1xyXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB0ZXhlbFNpemUsIHNoYWRvd0Nvb3JkLnogKSArXHJcblx0XHRcdFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRcdFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAyLjAgKiBkeCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdFx0XHRcdCBmLnggKSArXHJcblx0XHRcdFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0XHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0XHQgZi54ICkgK1xyXG5cdFx0XHRcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdFx0XHRcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0XHQgZi55ICkgK1xyXG5cdFx0XHRcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRcdFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCBkeCwgMi4wICogZHkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRcdFx0IGYueSApICtcclxuXHRcdFx0XHRtaXgoIG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdFx0XHRcdFx0ICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0XHRcdCAgZi54ICksXHJcblx0XHRcdFx0XHQgbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0XHRcdCAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0XHRcdCAgZi54ICksXHJcblx0XHRcdFx0XHQgZi55IClcclxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XHJcblxyXG5cdFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcclxuXHJcblx0XHRcdHNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xyXG5cclxuXHRcdCNlbHNlIC8vIG5vIHBlcmNlbnRhZ2UtY2xvc2VyIGZpbHRlcmluZzpcclxuXHJcblx0XHRcdHNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNoYWRvdztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjdWJlVG9VVigpIG1hcHMgYSAzRCBkaXJlY3Rpb24gdmVjdG9yIHN1aXRhYmxlIGZvciBjdWJlIHRleHR1cmUgbWFwcGluZyB0byBhIDJEXHJcblx0Ly8gdmVjdG9yIHN1aXRhYmxlIGZvciAyRCB0ZXh0dXJlIG1hcHBpbmcuIFRoaXMgY29kZSB1c2VzIHRoZSBmb2xsb3dpbmcgbGF5b3V0IGZvciB0aGVcclxuXHQvLyAyRCB0ZXh0dXJlOlxyXG5cdC8vXHJcblx0Ly8geHpYWlxyXG5cdC8vICB5IFlcclxuXHQvL1xyXG5cdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG5cdC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxyXG5cdC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxyXG5cdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxyXG5cdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxyXG5cdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cdC8vXHJcblx0Ly8gU291cmNlIGFuZCB0ZXN0IGJlZDpcclxuXHQvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90c2Nody9kYTEwYzQzYzQ2N2NlOGFmZDBjNFxyXG5cclxuXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XHJcblxyXG5cdFx0Ly8gTnVtYmVyIG9mIHRleGVscyB0byBhdm9pZCBhdCB0aGUgZWRnZSBvZiBlYWNoIHNxdWFyZVxyXG5cclxuXHRcdHZlYzMgYWJzViA9IGFicyggdiApO1xyXG5cclxuXHRcdC8vIEludGVyc2VjdCB1bml0IGN1YmVcclxuXHJcblx0XHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcclxuXHRcdGFic1YgKj0gc2NhbGVUb0N1YmU7XHJcblxyXG5cdFx0Ly8gQXBwbHkgc2NhbGUgdG8gYXZvaWQgc2VhbXNcclxuXHJcblx0XHQvLyB0d28gdGV4ZWxzIGxlc3MgcGVyIHNxdWFyZSAob25lIHRleGVsIHdpbGwgZG8gZm9yIE5FQVJFU1QpXHJcblx0XHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XHJcblxyXG5cdFx0Ly8gVW53cmFwXHJcblxyXG5cdFx0Ly8gc3BhY2U6IC0xIC4uLiAxIHJhbmdlIGZvciBlYWNoIHNxdWFyZVxyXG5cdFx0Ly9cclxuXHRcdC8vICNYIyNcdFx0ZGltICAgIDo9ICggNCAsIDIgKVxyXG5cdFx0Ly8gICMgI1x0XHRjZW50ZXIgOj0gKCAxICwgMSApXHJcblxyXG5cdFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xyXG5cclxuXHRcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XHJcblx0XHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XHJcblxyXG5cdFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xyXG5cclxuXHRcdFx0aWYgKCB2LnogPiAwLjAgKVxyXG5cdFx0XHRcdHBsYW5hci54ID0gNC4wIC0gdi54O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XHJcblxyXG5cdFx0XHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xyXG5cdFx0XHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcclxuXHJcblx0XHRcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XHJcblx0XHRcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XHJcblx0XHRcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRyYW5zZm9ybSB0byBVViBzcGFjZVxyXG5cclxuXHRcdC8vIHNjYWxlIDo9IDAuNSAvIGRpbVxyXG5cdFx0Ly8gdHJhbnNsYXRlIDo9ICggY2VudGVyICsgMC41ICkgLyBkaW1cclxuXHRcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQsIGZsb2F0IHNoYWRvd0NhbWVyYU5lYXIsIGZsb2F0IHNoYWRvd0NhbWVyYUZhciApIHtcclxuXHJcblx0XHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gKCBzaGFkb3dNYXBTaXplICogdmVjMiggNC4wLCAyLjAgKSApO1xyXG5cclxuXHRcdC8vIGZvciBwb2ludCBsaWdodHMsIHRoZSB1bmlmb3JtIEB2U2hhZG93Q29vcmQgaXMgcmUtcHVycG9zZWQgdG8gaG9sZFxyXG5cdFx0Ly8gdGhlIHZlY3RvciBmcm9tIHRoZSBsaWdodCB0byB0aGUgd29ybGQtc3BhY2UgcG9zaXRpb24gb2YgdGhlIGZyYWdtZW50LlxyXG5cdFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XHJcblxyXG5cdFx0Ly8gZHAgPSBub3JtYWxpemVkIGRpc3RhbmNlIGZyb20gbGlnaHQgdG8gZnJhZ21lbnQgcG9zaXRpb25cclxuXHRcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7IC8vIG5lZWQgdG8gY2xhbXA/XHJcblx0XHRkcCArPSBzaGFkb3dCaWFzO1xyXG5cclxuXHRcdC8vIGJkM0QgPSBiYXNlIGRpcmVjdGlvbiAzRFxyXG5cdFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcclxuXHJcblx0XHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxyXG5cclxuXHRcdFx0dmVjMiBvZmZzZXQgPSB2ZWMyKCAtIDEsIDEgKSAqIHNoYWRvd1JhZGl1cyAqIHRleGVsU2l6ZS55O1xyXG5cclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xyXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xyXG5cdFx0XHRcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcclxuXHRcdFx0XHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXHJcblx0XHRcdFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwIClcclxuXHRcdFx0KSAqICggMS4wIC8gOS4wICk7XHJcblxyXG5cdFx0I2Vsc2UgLy8gbm8gcGVyY2VudGFnZS1jbG9zZXIgZmlsdGVyaW5nXHJcblxyXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcclxuXHJcblx0XHQjZW5kaWZcclxuXHJcblx0fVxyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcblxyXG4jaWYgTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMFxyXG5cclxuXHR1bmlmb3JtIG1hdDQgc3BvdExpZ2h0TWF0cml4WyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcclxuXHR2YXJ5aW5nIHZlYzQgdlNwb3RMaWdodENvb3JkWyBOVU1fU1BPVF9MSUdIVF9DT09SRFMgXTtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9TSEFET1dNQVBcclxuXHJcblx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcclxuXHJcblx0XHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xyXG5cdFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcclxuXHJcblx0XHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyB7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0JpYXM7XHJcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XHJcblx0XHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcclxuXHRcdFx0dmVjMiBzaGFkb3dNYXBTaXplO1xyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgPiAwXHJcblxyXG5cdFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0JpYXM7XHJcblx0XHRcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XHJcblx0XHRcdGZsb2F0IHNoYWRvd1JhZGl1cztcclxuXHRcdFx0dmVjMiBzaGFkb3dNYXBTaXplO1xyXG5cdFx0fTtcclxuXHJcblx0XHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXHJcblxyXG5cdFx0dW5pZm9ybSBtYXQ0IHBvaW50U2hhZG93TWF0cml4WyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xyXG5cdFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHRcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcclxuXHRcdFx0ZmxvYXQgc2hhZG93QmlhcztcclxuXHRcdFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcclxuXHRcdFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xyXG5cdFx0XHR2ZWMyIHNoYWRvd01hcFNpemU7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XHJcblx0XHRcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcclxuXHRcdH07XHJcblxyXG5cdFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0LypcclxuXHQjaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXHJcblxyXG5cdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHVuaWZvcm1zIGZvciBhcmVhIGxpZ2h0IHNoYWRvd3NcclxuXHJcblx0I2VuZGlmXHJcblx0Ki9cclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG5cclxuI2lmICggZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmICggTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMCB8fCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDAgKSApIHx8ICggTlVNX1NQT1RfTElHSFRfQ09PUkRTID4gMCApXHJcblxyXG5cdC8vIE9mZnNldHRpbmcgdGhlIHBvc2l0aW9uIHVzZWQgZm9yIHF1ZXJ5aW5nIG9jY2x1c2lvbiBhbG9uZyB0aGUgd29ybGQgbm9ybWFsIGNhbiBiZSB1c2VkIHRvIHJlZHVjZSBzaGFkb3cgYWNuZS5cclxuXHR2ZWMzIHNoYWRvd1dvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcclxuXHR2ZWM0IHNoYWRvd1dvcmxkUG9zaXRpb247XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQIClcclxuXHJcblx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcclxuXHJcblx0XHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XHJcblx0XHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7XHJcblx0XHRcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcclxuXHJcblx0XHR9XHJcblx0XHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxyXG5cclxuXHRcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcclxuXHRcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xyXG5cclxuXHRcdFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24gKyB2ZWM0KCBzaGFkb3dXb3JsZE5vcm1hbCAqIHBvaW50TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xyXG5cdFx0XHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XHJcblxyXG5cdFx0fVxyXG5cdFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdC8qXHJcblx0I2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxyXG5cclxuXHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiB1cGRhdGUgdkFyZWFTaGFkb3dDb29yZCB3aXRoIGFyZWEgbGlnaHQgaW5mb1xyXG5cclxuXHQjZW5kaWZcclxuXHQqL1xyXG5cclxuI2VuZGlmXHJcblxyXG4vLyBzcG90IGxpZ2h0cyBjYW4gYmUgZXZhbHVhdGVkIHdpdGhvdXQgYWN0aXZlIHNoYWRvdyBtYXBwaW5nICh3aGVuIFNwb3RMaWdodC5tYXAgaXMgdXNlZClcclxuXHJcbiNpZiBOVU1fU1BPVF9MSUdIVF9DT09SRFMgPiAwXHJcblxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcclxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9DT09SRFM7IGkgKysgKSB7XHJcblxyXG5cdFx0c2hhZG93V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb247XHJcblx0XHQjaWYgKCBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgVU5ST0xMRURfTE9PUF9JTkRFWCA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgKVxyXG5cdFx0XHRzaGFkb3dXb3JsZFBvc2l0aW9uLnh5eiArPSBzaGFkb3dXb3JsZE5vcm1hbCAqIHNwb3RMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzO1xyXG5cdFx0I2VuZGlmXHJcblx0XHR2U3BvdExpZ2h0Q29vcmRbIGkgXSA9IHNwb3RMaWdodE1hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3NpdGlvbjtcclxuXHJcblx0fVxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXHJcblxyXG4jZW5kaWZcclxuXHJcblxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG5mbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xyXG5cclxuXHRmbG9hdCBzaGFkb3cgPSAxLjA7XHJcblxyXG5cdCNpZmRlZiBVU0VfU0hBRE9XTUFQXHJcblxyXG5cdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXHJcblxyXG5cdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodDtcclxuXHJcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxyXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcclxuXHJcblx0XHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXTtcclxuXHRcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcclxuXHJcblx0fVxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcclxuXHJcblx0U3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodDtcclxuXHJcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxyXG5cdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XHJcblxyXG5cdFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0U2hhZG93c1sgaSBdO1xyXG5cdFx0c2hhZG93ICo9IHJlY2VpdmVTaGFkb3cgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdExpZ2h0Q29vcmRbIGkgXSApIDogMS4wO1xyXG5cclxuXHR9XHJcblx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcclxuXHJcblx0UG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0O1xyXG5cclxuXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XHJcblx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XHJcblxyXG5cdFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRTaGFkb3dzWyBpIF07XHJcblx0XHRzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcclxuXHJcblx0fVxyXG5cdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQvKlxyXG5cdCNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcclxuXHJcblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogdXBkYXRlIHNoYWRvdyBmb3IgQXJlYSBsaWdodFxyXG5cclxuXHQjZW5kaWZcclxuXHQqL1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0cmV0dXJuIHNoYWRvdztcclxuXHJcbn1cclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9TS0lOTklOR1xyXG5cclxuXHRtYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcclxuXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcclxuXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcclxuXHRtYXQ0IGJvbmVNYXRXID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LncgKTtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX1NLSU5OSU5HXHJcblxyXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xyXG5cdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcclxuXHJcblx0dW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XHJcblx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVTaXplO1xyXG5cclxuXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XHJcblxyXG5cdFx0ZmxvYXQgaiA9IGkgKiA0LjA7XHJcblx0XHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcclxuXHRcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKSApO1xyXG5cclxuXHRcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApO1xyXG5cdFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XHJcblxyXG5cdFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XHJcblxyXG5cdFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xyXG5cdFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xyXG5cdFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xyXG5cdFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xyXG5cclxuXHRcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGJvbmU7XHJcblxyXG5cdH1cclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWZkZWYgVVNFX1NLSU5OSU5HXHJcblxyXG5cdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XHJcblxyXG5cdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xyXG5cdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xyXG5cdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xyXG5cdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xyXG5cdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xyXG5cclxuXHR0cmFuc2Zvcm1lZCA9ICggYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkICkueHl6O1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfU0tJTk5JTkdcclxuXHJcblx0bWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XHJcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcclxuXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xyXG5cdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XHJcblx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcclxuXHRza2luTWF0cml4ID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcclxuXHJcblx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XHJcblxyXG5cdCNpZmRlZiBVU0VfVEFOR0VOVFxyXG5cclxuXHRcdG9iamVjdFRhbmdlbnQgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbmZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XHJcblxyXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXHJcblxyXG5cdHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZTcGVjdWxhck1hcFV2ICk7XHJcblx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcclxuXHJcbiNlbHNlXHJcblxyXG5cdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcclxuXHJcblx0Z2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmbmRlZiBzYXR1cmF0ZVxyXG4vLyA8Y29tbW9uPiBtYXkgaGF2ZSBkZWZpbmVkIHNhdHVyYXRlKCkgYWxyZWFkeVxyXG4jZGVmaW5lIHNhdHVyYXRlKCBhICkgY2xhbXAoIGEsIDAuMCwgMS4wIClcclxuI2VuZGlmXHJcblxyXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XHJcblxyXG4vLyBleHBvc3VyZSBvbmx5XHJcbnZlYzMgTGluZWFyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XHJcblxyXG5cdHJldHVybiBzYXR1cmF0ZSggdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yICk7XHJcblxyXG59XHJcblxyXG4vLyBzb3VyY2U6IGh0dHBzOi8vd3d3LmNzLnV0YWguZWR1L2RvY3MvdGVjaHJlcG9ydHMvMjAwMi9wZGYvVVVDUy0wMi0wMDEucGRmXHJcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcclxuXHJcblx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcclxuXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcclxuXHJcbn1cclxuXHJcbi8vIHNvdXJjZTogaHR0cDovL2ZpbG1pY3dvcmxkcy5jb20vYmxvZy9maWxtaWMtdG9uZW1hcHBpbmctb3BlcmF0b3JzL1xyXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xyXG5cclxuXHQvLyBvcHRpbWl6ZWQgZmlsbWljIG9wZXJhdG9yIGJ5IEppbSBIZWpsIGFuZCBSaWNoYXJkIEJ1cmdlc3MtRGF3c29uXHJcblx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcclxuXHRjb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTtcclxuXHRyZXR1cm4gcG93KCAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDAuNSApICkgLyAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDEuNyApICsgMC4wNiApLCB2ZWMzKCAyLjIgKSApO1xyXG5cclxufVxyXG5cclxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vc2VsZnNoYWRvdy9sdGNfY29kZS9ibG9iL21hc3Rlci93ZWJnbC9zaGFkZXJzL2x0Yy9sdGNfYmxpdC5mc1xyXG52ZWMzIFJSVEFuZE9EVEZpdCggdmVjMyB2ICkge1xyXG5cclxuXHR2ZWMzIGEgPSB2ICogKCB2ICsgMC4wMjQ1Nzg2ICkgLSAwLjAwMDA5MDUzNztcclxuXHR2ZWMzIGIgPSB2ICogKCAwLjk4MzcyOSAqIHYgKyAwLjQzMjk1MTAgKSArIDAuMjM4MDgxO1xyXG5cdHJldHVybiBhIC8gYjtcclxuXHJcbn1cclxuXHJcbi8vIHRoaXMgaW1wbGVtZW50YXRpb24gb2YgQUNFUyBpcyBtb2RpZmllZCB0byBhY2NvbW1vZGF0ZSBhIGJyaWdodGVyIHZpZXdpbmcgZW52aXJvbm1lbnQuXHJcbi8vIHRoZSBzY2FsZSBmYWN0b3Igb2YgMS8wLjYgaXMgc3ViamVjdGl2ZS4gc2VlIGRpc2N1c3Npb24gaW4gIzE5NjIxLlxyXG5cclxudmVjMyBBQ0VTRmlsbWljVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XHJcblxyXG5cdC8vIHNSR0IgPT4gWFlaID0+IEQ2NV8yX0Q2MCA9PiBBUDEgPT4gUlJUX1NBVFxyXG5cdGNvbnN0IG1hdDMgQUNFU0lucHV0TWF0ID0gbWF0MyhcclxuXHRcdHZlYzMoIDAuNTk3MTksIDAuMDc2MDAsIDAuMDI4NDAgKSwgLy8gdHJhbnNwb3NlZCBmcm9tIHNvdXJjZVxyXG5cdFx0dmVjMyggMC4zNTQ1OCwgMC45MDgzNCwgMC4xMzM4MyApLFxyXG5cdFx0dmVjMyggMC4wNDgyMywgMC4wMTU2NiwgMC44Mzc3NyApXHJcblx0KTtcclxuXHJcblx0Ly8gT0RUX1NBVCA9PiBYWVogPT4gRDYwXzJfRDY1ID0+IHNSR0JcclxuXHRjb25zdCBtYXQzIEFDRVNPdXRwdXRNYXQgPSBtYXQzKFxyXG5cdFx0dmVjMyggIDEuNjA0NzUsIC0wLjEwMjA4LCAtMC4wMDMyNyApLCAvLyB0cmFuc3Bvc2VkIGZyb20gc291cmNlXHJcblx0XHR2ZWMzKCAtMC41MzEwOCwgIDEuMTA4MTMsIC0wLjA3Mjc2ICksXHJcblx0XHR2ZWMzKCAtMC4wNzM2NywgLTAuMDA2MDUsICAxLjA3NjAyIClcclxuXHQpO1xyXG5cclxuXHRjb2xvciAqPSB0b25lTWFwcGluZ0V4cG9zdXJlIC8gMC42O1xyXG5cclxuXHRjb2xvciA9IEFDRVNJbnB1dE1hdCAqIGNvbG9yO1xyXG5cclxuXHQvLyBBcHBseSBSUlQgYW5kIE9EVFxyXG5cdGNvbG9yID0gUlJUQW5kT0RURml0KCBjb2xvciApO1xyXG5cclxuXHRjb2xvciA9IEFDRVNPdXRwdXRNYXQgKiBjb2xvcjtcclxuXHJcblx0Ly8gQ2xhbXAgdG8gWzAsIDFdXHJcblx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciApO1xyXG5cclxufVxyXG5cclxudmVjMyBDdXN0b21Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHsgcmV0dXJuIGNvbG9yOyB9XHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXHJcblxyXG5cdG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA9IHRyYW5zbWlzc2lvbjtcclxuXHRtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IDEuMDtcclxuXHRtYXRlcmlhbC50aGlja25lc3MgPSB0aGlja25lc3M7XHJcblx0bWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGF0dGVudWF0aW9uRGlzdGFuY2U7XHJcblx0bWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciA9IGF0dGVudWF0aW9uQ29sb3I7XHJcblxyXG5cdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXHJcblxyXG5cdFx0bWF0ZXJpYWwudHJhbnNtaXNzaW9uICo9IHRleHR1cmUyRCggdHJhbnNtaXNzaW9uTWFwLCB2VHJhbnNtaXNzaW9uTWFwVXYgKS5yO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9USElDS05FU1NNQVBcclxuXHJcblx0XHRtYXRlcmlhbC50aGlja25lc3MgKj0gdGV4dHVyZTJEKCB0aGlja25lc3NNYXAsIHZUaGlja25lc3NNYXBVdiApLmc7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHR2ZWMzIHBvcyA9IHZXb3JsZFBvc2l0aW9uO1xyXG5cdHZlYzMgdiA9IG5vcm1hbGl6ZSggY2FtZXJhUG9zaXRpb24gLSBwb3MgKTtcclxuXHR2ZWMzIG4gPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcclxuXHJcblx0dmVjNCB0cmFuc21pdHRlZCA9IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oXHJcblx0XHRuLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXHJcblx0XHRwb3MsIG1vZGVsTWF0cml4LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCBtYXRlcmlhbC5pb3IsIG1hdGVyaWFsLnRoaWNrbmVzcyxcclxuXHRcdG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgKTtcclxuXHJcblx0bWF0ZXJpYWwudHJhbnNtaXNzaW9uQWxwaGEgPSBtaXgoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbkFscGhhLCB0cmFuc21pdHRlZC5hLCBtYXRlcmlhbC50cmFuc21pc3Npb24gKTtcclxuXHJcblx0dG90YWxEaWZmdXNlID0gbWl4KCB0b3RhbERpZmZ1c2UsIHRyYW5zbWl0dGVkLnJnYiwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uICk7XHJcblxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cclxuXHJcblx0Ly8gVHJhbnNtaXNzaW9uIGNvZGUgaXMgYmFzZWQgb24gZ2xURi1TYW1wbGVyLVZpZXdlclxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi1TYW1wbGUtVmlld2VyXHJcblxyXG5cdHVuaWZvcm0gZmxvYXQgdHJhbnNtaXNzaW9uO1xyXG5cdHVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzO1xyXG5cdHVuaWZvcm0gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZTtcclxuXHR1bmlmb3JtIHZlYzMgYXR0ZW51YXRpb25Db2xvcjtcclxuXHJcblx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcclxuXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25NYXA7XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWZkZWYgVVNFX1RISUNLTkVTU01BUFxyXG5cclxuXHRcdHVuaWZvcm0gc2FtcGxlcjJEIHRoaWNrbmVzc01hcDtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdHVuaWZvcm0gdmVjMiB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZTtcclxuXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwO1xyXG5cclxuXHR1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XHJcblx0dW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XHJcblxyXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcclxuXHJcblx0Ly8gTWlwcGVkIEJpY3ViaWMgVGV4dHVyZSBGaWx0ZXJpbmcgYnkgTjhcclxuXHQvLyBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvRGwyU0RXXHJcblxyXG5cdGZsb2F0IHcwKCBmbG9hdCBhICkge1xyXG5cclxuXHRcdHJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogKCBhICogKCAtIGEgKyAzLjAgKSAtIDMuMCApICsgMS4wICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZmxvYXQgdzEoIGZsb2F0IGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggMS4wIC8gNi4wICkgKiAoIGEgKiAgYSAqICggMy4wICogYSAtIDYuMCApICsgNC4wICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZmxvYXQgdzIoIGZsb2F0IGEgKXtcclxuXHJcblx0XHRyZXR1cm4gKCAxLjAgLyA2LjAgKSAqICggYSAqICggYSAqICggLSAzLjAgKiBhICsgMy4wICkgKyAzLjAgKSArIDEuMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsb2F0IHczKCBmbG9hdCBhICkge1xyXG5cclxuXHRcdHJldHVybiAoIDEuMCAvIDYuMCApICogKCBhICogYSAqIGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBnMCBhbmQgZzEgYXJlIHRoZSB0d28gYW1wbGl0dWRlIGZ1bmN0aW9uc1xyXG5cdGZsb2F0IGcwKCBmbG9hdCBhICkge1xyXG5cclxuXHRcdHJldHVybiB3MCggYSApICsgdzEoIGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmbG9hdCBnMSggZmxvYXQgYSApIHtcclxuXHJcblx0XHRyZXR1cm4gdzIoIGEgKSArIHczKCBhICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gaDAgYW5kIGgxIGFyZSB0aGUgdHdvIG9mZnNldCBmdW5jdGlvbnNcclxuXHRmbG9hdCBoMCggZmxvYXQgYSApIHtcclxuXHJcblx0XHRyZXR1cm4gLSAxLjAgKyB3MSggYSApIC8gKCB3MCggYSApICsgdzEoIGEgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsb2F0IGgxKCBmbG9hdCBhICkge1xyXG5cclxuXHRcdHJldHVybiAxLjAgKyB3MyggYSApIC8gKCB3MiggYSApICsgdzMoIGEgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZlYzQgYmljdWJpYyggc2FtcGxlcjJEIHRleCwgdmVjMiB1diwgdmVjNCB0ZXhlbFNpemUsIGZsb2F0IGxvZCApIHtcclxuXHJcblx0XHR1diA9IHV2ICogdGV4ZWxTaXplLnp3ICsgMC41O1xyXG5cclxuXHRcdHZlYzIgaXV2ID0gZmxvb3IoIHV2ICk7XHJcblx0XHR2ZWMyIGZ1diA9IGZyYWN0KCB1diApO1xyXG5cclxuXHRcdGZsb2F0IGcweCA9IGcwKCBmdXYueCApO1xyXG5cdFx0ZmxvYXQgZzF4ID0gZzEoIGZ1di54ICk7XHJcblx0XHRmbG9hdCBoMHggPSBoMCggZnV2LnggKTtcclxuXHRcdGZsb2F0IGgxeCA9IGgxKCBmdXYueCApO1xyXG5cdFx0ZmxvYXQgaDB5ID0gaDAoIGZ1di55ICk7XHJcblx0XHRmbG9hdCBoMXkgPSBoMSggZnV2LnkgKTtcclxuXHJcblx0XHR2ZWMyIHAwID0gKCB2ZWMyKCBpdXYueCArIGgweCwgaXV2LnkgKyBoMHkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5O1xyXG5cdFx0dmVjMiBwMSA9ICggdmVjMiggaXV2LnggKyBoMXgsIGl1di55ICsgaDB5ICkgLSAwLjUgKSAqIHRleGVsU2l6ZS54eTtcclxuXHRcdHZlYzIgcDIgPSAoIHZlYzIoIGl1di54ICsgaDB4LCBpdXYueSArIGgxeSApIC0gMC41ICkgKiB0ZXhlbFNpemUueHk7XHJcblx0XHR2ZWMyIHAzID0gKCB2ZWMyKCBpdXYueCArIGgxeCwgaXV2LnkgKyBoMXkgKSAtIDAuNSApICogdGV4ZWxTaXplLnh5O1xyXG5cclxuXHRcdHJldHVybiBnMCggZnV2LnkgKSAqICggZzB4ICogdGV4dHVyZUxvZCggdGV4LCBwMCwgbG9kICkgKyBnMXggKiB0ZXh0dXJlTG9kKCB0ZXgsIHAxLCBsb2QgKSApICtcclxuXHRcdFx0ZzEoIGZ1di55ICkgKiAoIGcweCAqIHRleHR1cmVMb2QoIHRleCwgcDIsIGxvZCApICsgZzF4ICogdGV4dHVyZUxvZCggdGV4LCBwMywgbG9kICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2ZWM0IHRleHR1cmVCaWN1YmljKCBzYW1wbGVyMkQgc2FtcGxlciwgdmVjMiB1diwgZmxvYXQgbG9kICkge1xyXG5cclxuXHRcdHZlYzIgZkxvZFNpemUgPSB2ZWMyKCB0ZXh0dXJlU2l6ZSggc2FtcGxlciwgaW50KCBsb2QgKSApICk7XHJcblx0XHR2ZWMyIGNMb2RTaXplID0gdmVjMiggdGV4dHVyZVNpemUoIHNhbXBsZXIsIGludCggbG9kICsgMS4wICkgKSApO1xyXG5cdFx0dmVjMiBmTG9kU2l6ZUludiA9IDEuMCAvIGZMb2RTaXplO1xyXG5cdFx0dmVjMiBjTG9kU2l6ZUludiA9IDEuMCAvIGNMb2RTaXplO1xyXG5cdFx0dmVjNCBmU2FtcGxlID0gYmljdWJpYyggc2FtcGxlciwgdXYsIHZlYzQoIGZMb2RTaXplSW52LCBmTG9kU2l6ZSApLCBmbG9vciggbG9kICkgKTtcclxuXHRcdHZlYzQgY1NhbXBsZSA9IGJpY3ViaWMoIHNhbXBsZXIsIHV2LCB2ZWM0KCBjTG9kU2l6ZUludiwgY0xvZFNpemUgKSwgY2VpbCggbG9kICkgKTtcclxuXHRcdHJldHVybiBtaXgoIGZTYW1wbGUsIGNTYW1wbGUsIGZyYWN0KCBsb2QgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXggKSB7XHJcblxyXG5cdFx0Ly8gRGlyZWN0aW9uIG9mIHJlZnJhY3RlZCBsaWdodC5cclxuXHRcdHZlYzMgcmVmcmFjdGlvblZlY3RvciA9IHJlZnJhY3QoIC0gdiwgbm9ybWFsaXplKCBuICksIDEuMCAvIGlvciApO1xyXG5cclxuXHRcdC8vIENvbXB1dGUgcm90YXRpb24taW5kZXBlbmRhbnQgc2NhbGluZyBvZiB0aGUgbW9kZWwgbWF0cml4LlxyXG5cdFx0dmVjMyBtb2RlbFNjYWxlO1xyXG5cdFx0bW9kZWxTY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLnh5eiApICk7XHJcblx0XHRtb2RlbFNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueHl6ICkgKTtcclxuXHRcdG1vZGVsU2NhbGUueiA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDIgXS54eXogKSApO1xyXG5cclxuXHRcdC8vIFRoZSB0aGlja25lc3MgaXMgc3BlY2lmaWVkIGluIGxvY2FsIHNwYWNlLlxyXG5cdFx0cmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTtcclxuXHJcblx0fVxyXG5cclxuXHRmbG9hdCBhcHBseUlvclRvUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcclxuXHJcblx0XHQvLyBTY2FsZSByb3VnaG5lc3Mgd2l0aCBJT1Igc28gdGhhdCBhbiBJT1Igb2YgMS4wIHJlc3VsdHMgaW4gbm8gbWljcm9mYWNldCByZWZyYWN0aW9uIGFuZFxyXG5cdFx0Ly8gYW4gSU9SIG9mIDEuNSByZXN1bHRzIGluIHRoZSBkZWZhdWx0IGFtb3VudCBvZiBtaWNyb2ZhY2V0IHJlZnJhY3Rpb24uXHJcblx0XHRyZXR1cm4gcm91Z2huZXNzICogY2xhbXAoIGlvciAqIDIuMCAtIDIuMCwgMC4wLCAxLjAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2ZWM0IGdldFRyYW5zbWlzc2lvblNhbXBsZSggY29uc3QgaW4gdmVjMiBmcmFnQ29vcmQsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgaW9yICkge1xyXG5cclxuXHRcdGZsb2F0IGxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7XHJcblx0XHRyZXR1cm4gdGV4dHVyZUJpY3ViaWMoIHRyYW5zbWlzc2lvblNhbXBsZXJNYXAsIGZyYWdDb29yZC54eSwgbG9kICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmVjMyB2b2x1bWVBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgdHJhbnNtaXNzaW9uRGlzdGFuY2UsIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcclxuXHJcblx0XHRpZiAoIGlzaW5mKCBhdHRlbnVhdGlvbkRpc3RhbmNlICkgKSB7XHJcblxyXG5cdFx0XHQvLyBBdHRlbnVhdGlvbiBkaXN0YW5jZSBpcyAr4oieLCBpLmUuIHRoZSB0cmFuc21pdHRlZCBjb2xvciBpcyBub3QgYXR0ZW51YXRlZCBhdCBhbGwuXHJcblx0XHRcdHJldHVybiB2ZWMzKCAxLjAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gQ29tcHV0ZSBsaWdodCBhdHRlbnVhdGlvbiB1c2luZyBCZWVyJ3MgbGF3LlxyXG5cdFx0XHR2ZWMzIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgPSAtbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkgLyBhdHRlbnVhdGlvbkRpc3RhbmNlO1xyXG5cdFx0XHR2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7IC8vIEJlZXIncyBsYXdcclxuXHRcdFx0cmV0dXJuIHRyYW5zbWl0dGFuY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHZlYzQgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IsXHJcblx0XHRjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNwZWN1bGFyRjkwLCBjb25zdCBpbiB2ZWMzIHBvc2l0aW9uLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4LFxyXG5cdFx0Y29uc3QgaW4gbWF0NCB2aWV3TWF0cml4LCBjb25zdCBpbiBtYXQ0IHByb2pNYXRyaXgsIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLFxyXG5cdFx0Y29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xyXG5cclxuXHRcdHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcclxuXHRcdHZlYzMgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uICsgdHJhbnNtaXNzaW9uUmF5O1xyXG5cclxuXHRcdC8vIFByb2plY3QgcmVmcmFjdGVkIHZlY3RvciBvbiB0aGUgZnJhbWVidWZmZXIsIHdoaWxlIG1hcHBpbmcgdG8gbm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMuXHJcblx0XHR2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7XHJcblx0XHR2ZWMyIHJlZnJhY3Rpb25Db29yZHMgPSBuZGNQb3MueHkgLyBuZGNQb3MudztcclxuXHRcdHJlZnJhY3Rpb25Db29yZHMgKz0gMS4wO1xyXG5cdFx0cmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7XHJcblxyXG5cdFx0Ly8gU2FtcGxlIGZyYW1lYnVmZmVyIHRvIGdldCBwaXhlbCB0aGUgcmVmcmFjdGVkIHJheSBoaXRzLlxyXG5cdFx0dmVjNCB0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApO1xyXG5cclxuXHRcdHZlYzMgdHJhbnNtaXR0YW5jZSA9IGRpZmZ1c2VDb2xvciAqIHZvbHVtZUF0dGVudWF0aW9uKCBsZW5ndGgoIHRyYW5zbWlzc2lvblJheSApLCBhdHRlbnVhdGlvbkNvbG9yLCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XHJcblx0XHR2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IHRyYW5zbWl0dGFuY2UgKiB0cmFuc21pdHRlZExpZ2h0LnJnYjtcclxuXHJcblx0XHQvLyBHZXQgdGhlIHNwZWN1bGFyIGNvbXBvbmVudC5cclxuXHRcdHZlYzMgRiA9IEVudmlyb25tZW50QlJERiggbiwgdiwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzcyApO1xyXG5cclxuXHRcdC8vIEFzIGxlc3MgbGlnaHQgaXMgdHJhbnNtaXR0ZWQsIHRoZSBvcGFjaXR5IHNob3VsZCBiZSBpbmNyZWFzZWQuIFRoaXMgc2ltcGxlIGFwcHJveGltYXRpb24gZG9lcyBhIGRlY2VudCBqb2IgXHJcblx0XHQvLyBvZiBtb2R1bGF0aW5nIGEgQ1NTIGJhY2tncm91bmQsIGFuZCBoYXMgbm8gZWZmZWN0IHdoZW4gdGhlIGJ1ZmZlciBpcyBvcGFxdWUsIGR1ZSB0byBhIHNvbGlkIG9iamVjdCBvciBjbGVhciBjb2xvci5cclxuXHRcdGZsb2F0IHRyYW5zbWl0dGFuY2VGYWN0b3IgPSAoIHRyYW5zbWl0dGFuY2UuciArIHRyYW5zbWl0dGFuY2UuZyArIHRyYW5zbWl0dGFuY2UuYiApIC8gMy4wO1xyXG5cclxuXHRcdHJldHVybiB2ZWM0KCAoIDEuMCAtIEYgKSAqIGF0dGVudWF0ZWRDb2xvciwgMS4wIC0gKCAxLjAgLSB0cmFuc21pdHRlZExpZ2h0LmEgKSAqIHRyYW5zbWl0dGFuY2VGYWN0b3IgKTtcclxuXHJcblx0fVxyXG4jZW5kaWZcclxuYDtcclxuIiwiZXhwb3J0IGRlZmF1bHQgLyogZ2xzbCAqL2BcclxuI2lmIGRlZmluZWQoIFVTRV9VViApIHx8IGRlZmluZWQoIFVTRV9BTklTT1RST1BZIClcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX01BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdk1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQUxQSEFNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZBbHBoYU1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfTElHSFRNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZMaWdodE1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQU9NQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZBb01hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQlVNUE1BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdkJ1bXBNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdk5vcm1hbE1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZFbWlzc2l2ZU1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXHJcblxyXG5cdHZhcnlpbmcgdmVjMiB2TWV0YWxuZXNzTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZBbmlzb3Ryb3B5TWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXROb3JtYWxNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcclxuXHJcblx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFTUFQXHJcblxyXG5cdHZhcnlpbmcgdmVjMiB2SXJpZGVzY2VuY2VNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdlNoZWVuQ29sb3JNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFyQ29sb3JNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUFxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdlNwZWN1bGFySW50ZW5zaXR5TWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIHRyYW5zbWlzc2lvbk1hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdlRyYW5zbWlzc2lvbk1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyB0aGlja25lc3NNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZUaGlja25lc3NNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgZGVmaW5lZCggVVNFX1VWICkgfHwgZGVmaW5lZCggVVNFX0FOSVNPVFJPUFkgKVxyXG5cclxuXHR2YXJ5aW5nIHZlYzIgdlV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBtYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0FMUEhBTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBhbHBoYU1hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdkFscGhhTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9MSUdIVE1BUFxyXG5cclxuXHR1bmlmb3JtIG1hdDMgbGlnaHRNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZMaWdodE1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQU9NQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIGFvTWFwVHJhbnNmb3JtO1xyXG5cdHZhcnlpbmcgdmVjMiB2QW9NYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0JVTVBNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIGJ1bXBNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZCdW1wTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIG5vcm1hbE1hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdk5vcm1hbE1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBkaXNwbGFjZW1lbnRNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZEaXNwbGFjZW1lbnRNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0VNSVNTSVZFTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBlbWlzc2l2ZU1hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdkVtaXNzaXZlTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIG1ldGFsbmVzc01hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdk1ldGFsbmVzc01hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyByb3VnaG5lc3NNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZSb3VnaG5lc3NNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0FOSVNPVFJPUFlNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIGFuaXNvdHJvcHlNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZBbmlzb3Ryb3B5TWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIGNsZWFyY29hdE1hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdkNsZWFyY29hdE1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxyXG5cclxuXHR1bmlmb3JtIG1hdDMgY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtO1xyXG5cdHZhcnlpbmcgdmVjMiB2Q2xlYXJjb2F0Tm9ybWFsTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRfUk9VR0hORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBjbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZDbGVhcmNvYXRSb3VnaG5lc3NNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBzaGVlbkNvbG9yTWFwVHJhbnNmb3JtO1xyXG5cdHZhcnlpbmcgdmVjMiB2U2hlZW5Db2xvck1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdlNoZWVuUm91Z2huZXNzTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxyXG5cclxuXHR1bmlmb3JtIG1hdDMgaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZJcmlkZXNjZW5jZU1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXHJcblxyXG5cdHVuaWZvcm0gbWF0MyBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdklyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxyXG5cclxuXHR1bmlmb3JtIG1hdDMgc3BlY3VsYXJNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZTcGVjdWxhck1hcFV2O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfQ09MT1JNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIHNwZWN1bGFyQ29sb3JNYXBUcmFuc2Zvcm07XHJcblx0dmFyeWluZyB2ZWMyIHZTcGVjdWxhckNvbG9yTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtO1xyXG5cdHZhcnlpbmcgdmVjMiB2U3BlY3VsYXJJbnRlbnNpdHlNYXBVdjtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxyXG5cclxuXHR1bmlmb3JtIG1hdDMgdHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtO1xyXG5cdHZhcnlpbmcgdmVjMiB2VHJhbnNtaXNzaW9uTWFwVXY7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9USElDS05FU1NNQVBcclxuXHJcblx0dW5pZm9ybSBtYXQzIHRoaWNrbmVzc01hcFRyYW5zZm9ybTtcclxuXHR2YXJ5aW5nIHZlYzIgdlRoaWNrbmVzc01hcFV2O1xyXG5cclxuI2VuZGlmXHJcbmA7XHJcbiIsImV4cG9ydCBkZWZhdWx0IC8qIGdsc2wgKi9gXHJcbiNpZiBkZWZpbmVkKCBVU0VfVVYgKSB8fCBkZWZpbmVkKCBVU0VfQU5JU09UUk9QWSApXHJcblxyXG5cdHZVdiA9IHZlYzMoIHV2LCAxICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9NQVBcclxuXHJcblx0dk1hcFV2ID0gKCBtYXBUcmFuc2Zvcm0gKiB2ZWMzKCBNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQUxQSEFNQVBcclxuXHJcblx0dkFscGhhTWFwVXYgPSAoIGFscGhhTWFwVHJhbnNmb3JtICogdmVjMyggQUxQSEFNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfTElHSFRNQVBcclxuXHJcblx0dkxpZ2h0TWFwVXYgPSAoIGxpZ2h0TWFwVHJhbnNmb3JtICogdmVjMyggTElHSFRNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQU9NQVBcclxuXHJcblx0dkFvTWFwVXYgPSAoIGFvTWFwVHJhbnNmb3JtICogdmVjMyggQU9NQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQlVNUE1BUFxyXG5cclxuXHR2QnVtcE1hcFV2ID0gKCBidW1wTWFwVHJhbnNmb3JtICogdmVjMyggQlVNUE1BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcclxuXHJcblx0dk5vcm1hbE1hcFV2ID0gKCBub3JtYWxNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBOT1JNQUxNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXHJcblxyXG5cdHZEaXNwbGFjZW1lbnRNYXBVdiA9ICggZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtICogdmVjMyggRElTUExBQ0VNRU5UTUFQX1VWLCAxICkgKS54eTtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX0VNSVNTSVZFTUFQXHJcblxyXG5cdHZFbWlzc2l2ZU1hcFV2ID0gKCBlbWlzc2l2ZU1hcFRyYW5zZm9ybSAqIHZlYzMoIEVNSVNTSVZFTUFQX1VWLCAxICkgKS54eTtcclxuXHJcbiNlbmRpZlxyXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxyXG5cclxuXHR2TWV0YWxuZXNzTWFwVXYgPSAoIG1ldGFsbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIE1FVEFMTkVTU01BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcclxuXHJcblx0dlJvdWdobmVzc01hcFV2ID0gKCByb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxyXG5cclxuXHR2QW5pc290cm9weU1hcFV2ID0gKCBhbmlzb3Ryb3B5TWFwVHJhbnNmb3JtICogdmVjMyggQU5JU09UUk9QWU1BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRNQVBcclxuXHJcblx0dkNsZWFyY29hdE1hcFV2ID0gKCBjbGVhcmNvYXRNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBDTEVBUkNPQVRNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUFxyXG5cclxuXHR2Q2xlYXJjb2F0Tm9ybWFsTWFwVXYgPSAoIGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVF9OT1JNQUxNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxyXG5cclxuXHR2Q2xlYXJjb2F0Um91Z2huZXNzTWFwVXYgPSAoIGNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIENMRUFSQ09BVF9ST1VHSE5FU1NNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcclxuXHJcblx0dklyaWRlc2NlbmNlTWFwVXYgPSAoIGlyaWRlc2NlbmNlTWFwVHJhbnNmb3JtICogdmVjMyggSVJJREVTQ0VOQ0VNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQXHJcblxyXG5cdHZJcmlkZXNjZW5jZVRoaWNrbmVzc01hcFV2ID0gKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIElSSURFU0NFTkNFX1RISUNLTkVTU01BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TSEVFTl9DT0xPUk1BUFxyXG5cclxuXHR2U2hlZW5Db2xvck1hcFV2ID0gKCBzaGVlbkNvbG9yTWFwVHJhbnNmb3JtICogdmVjMyggU0hFRU5fQ09MT1JNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfU0hFRU5fUk9VR0hORVNTTUFQXHJcblxyXG5cdHZTaGVlblJvdWdobmVzc01hcFV2ID0gKCBzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybSAqIHZlYzMoIFNIRUVOX1JPVUdITkVTU01BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxyXG5cclxuXHR2U3BlY3VsYXJNYXBVdiA9ICggc3BlY3VsYXJNYXBUcmFuc2Zvcm0gKiB2ZWMzKCBTUEVDVUxBUk1BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9TUEVDVUxBUl9DT0xPUk1BUFxyXG5cclxuXHR2U3BlY3VsYXJDb2xvck1hcFV2ID0gKCBzcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtICogdmVjMyggU1BFQ1VMQVJfQ09MT1JNQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfU1BFQ1VMQVJfSU5URU5TSVRZTUFQXHJcblxyXG5cdHZTcGVjdWxhckludGVuc2l0eU1hcFV2ID0gKCBzcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybSAqIHZlYzMoIFNQRUNVTEFSX0lOVEVOU0lUWU1BUF9VViwgMSApICkueHk7XHJcblxyXG4jZW5kaWZcclxuI2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcclxuXHJcblx0dlRyYW5zbWlzc2lvbk1hcFV2ID0gKCB0cmFuc21pc3Npb25NYXBUcmFuc2Zvcm0gKiB2ZWMzKCBUUkFOU01JU1NJT05NQVBfVVYsIDEgKSApLnh5O1xyXG5cclxuI2VuZGlmXHJcbiNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXHJcblxyXG5cdHZUaGlja25lc3NNYXBVdiA9ICggdGhpY2tuZXNzTWFwVHJhbnNmb3JtICogdmVjMyggVEhJQ0tORVNTTUFQX1VWLCAxICkgKS54eTtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgZGVmYXVsdCAvKiBnbHNsICovYFxyXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKSB8fCBkZWZpbmVkICggVVNFX1RSQU5TTUlTU0lPTiApIHx8IE5VTV9TUE9UX0xJR0hUX0NPT1JEUyA+IDBcclxuXHJcblx0dmVjNCB3b3JsZFBvc2l0aW9uID0gdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xyXG5cclxuXHQjaWZkZWYgVVNFX0lOU1RBTkNJTkdcclxuXHJcblx0XHR3b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0d29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogd29ybGRQb3NpdGlvbjtcclxuXHJcbiNlbmRpZlxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxudmFyeWluZyB2ZWMyIHZVdjtcclxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xyXG5cclxuXHRnbF9Qb3NpdGlvbiA9IHZlYzQoIHBvc2l0aW9uLnh5LCAxLjAsIDEuMCApO1xyXG5cclxufVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gLyogZ2xzbCAqL2BcclxudW5pZm9ybSBzYW1wbGVyMkQgdDJEO1xyXG51bmlmb3JtIGZsb2F0IGJhY2tncm91bmRJbnRlbnNpdHk7XHJcblxyXG52YXJ5aW5nIHZlYzIgdlV2O1xyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHR2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKCB0MkQsIHZVdiApO1xyXG5cclxuXHR0ZXhDb2xvci5yZ2IgKj0gYmFja2dyb3VuZEludGVuc2l0eTtcclxuXHJcblx0Z2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7XHJcblxyXG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cclxuXHJcbn1cclxuYDtcclxuIiwiZXhwb3J0IGNvbnN0IHZlcnRleCA9IC8qIGdsc2wgKi9gXHJcbnZhcnlpbmcgdmVjMyB2V29ybGREaXJlY3Rpb247XHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cclxuXHJcblx0Z2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7IC8vIHNldCB6IHRvIGNhbWVyYS5mYXJcclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcblxyXG4jaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcclxuXHJcbiNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxyXG5cclxuXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XHJcblxyXG4jZW5kaWZcclxuXHJcbnVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcclxudW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kQmx1cnJpbmVzcztcclxudW5pZm9ybSBmbG9hdCBiYWNrZ3JvdW5kSW50ZW5zaXR5O1xyXG5cclxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXHJcblxyXG5cdFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTtcclxuXHJcblx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXHJcblxyXG5cdFx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlVVYoIGVudk1hcCwgdldvcmxkRGlyZWN0aW9uLCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyApO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHZlYzQgdGV4Q29sb3IgPSB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdHRleENvbG9yLnJnYiAqPSBiYWNrZ3JvdW5kSW50ZW5zaXR5O1xyXG5cclxuXHRnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjtcclxuXHJcblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XHJcblxyXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxyXG5cclxuXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udzsgLy8gc2V0IHogdG8gY2FtZXJhLmZhclxyXG5cclxufVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gLyogZ2xzbCAqL2BcclxudW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcclxudW5pZm9ybSBmbG9hdCB0RmxpcDtcclxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xyXG5cclxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0dmVjNCB0ZXhDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGREaXJlY3Rpb24ueCwgdldvcmxkRGlyZWN0aW9uLnl6ICkgKTtcclxuXHJcblx0Z2xfRnJhZ0NvbG9yID0gdGV4Q29sb3I7XHJcblx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcclxuXHJcblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxuI2luY2x1ZGUgPGNvbW1vbj5cclxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxuLy8gVGhpcyBpcyB1c2VkIGZvciBjb21wdXRpbmcgYW4gZXF1aXZhbGVudCBvZiBnbF9GcmFnQ29vcmQueiB0aGF0IGlzIGFzIGhpZ2ggcHJlY2lzaW9uIGFzIHBvc3NpYmxlLlxyXG4vLyBTb21lIHBsYXRmb3JtcyBjb21wdXRlIGdsX0ZyYWdDb29yZCBhdCBhIGxvd2VyIHByZWNpc2lvbiB3aGljaCBtYWtlcyB0aGUgbWFudWFsbHkgY29tcHV0ZWQgdmFsdWUgYmV0dGVyIGZvclxyXG4vLyBkZXB0aC1iYXNlZCBwb3N0cHJvY2Vzc2luZyBlZmZlY3RzLiBSZXByb2R1Y2VkIG9uIGlQYWQgd2l0aCBBMTAgcHJvY2Vzc29yIC8gaVBhZE9TIDEzLjMuMS5cclxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XHJcblxyXG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XHJcblxyXG5cdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXHJcblxyXG5cdFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cclxuXHRcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XHJcblx0XHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cclxuXHJcblx0dkhpZ2hQcmVjaXNpb25aVyA9IGdsX1Bvc2l0aW9uLnp3O1xyXG5cclxufVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gLyogZ2xzbCAqL2BcclxuI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxyXG5cclxuXHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDxwYWNraW5nPlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVztcclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cclxuXHJcblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcclxuXHJcblx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxyXG5cclxuXHRcdGRpZmZ1c2VDb2xvci5hID0gb3BhY2l0eTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cclxuXHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxyXG5cclxuXHQvLyBIaWdoZXIgcHJlY2lzaW9uIGVxdWl2YWxlbnQgb2YgZ2xfRnJhZ0Nvb3JkLnouIFRoaXMgYXNzdW1lcyBkZXB0aFJhbmdlIGhhcyBiZWVuIGxlZnQgdG8gaXRzIGRlZmF1bHQgdmFsdWVzLlxyXG5cdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXWzBdIC8gdkhpZ2hQcmVjaXNpb25aV1sxXSArIDAuNTtcclxuXHJcblx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxyXG5cclxuXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCAtIGZyYWdDb29yZFogKSwgb3BhY2l0eSApO1xyXG5cclxuXHQjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcclxuXHJcblx0XHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGZyYWdDb29yZFogKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG59XHJcbmA7XHJcbiIsImV4cG9ydCBjb25zdCB2ZXJ0ZXggPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIERJU1RBTkNFXHJcblxyXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxyXG5cclxuXHQjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxyXG5cclxuXHRcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0XHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxyXG5cdFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XHJcblxyXG5cdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XHJcblxyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIERJU1RBTkNFXHJcblxyXG51bmlmb3JtIHZlYzMgcmVmZXJlbmNlUG9zaXRpb247XHJcbnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlO1xyXG51bmlmb3JtIGZsb2F0IGZhckRpc3RhbmNlO1xyXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8cGFja2luZz5cclxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4gKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxyXG5cclxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xyXG5cclxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XHJcblxyXG5cdGZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTtcclxuXHRkaXN0ID0gKCBkaXN0IC0gbmVhckRpc3RhbmNlICkgLyAoIGZhckRpc3RhbmNlIC0gbmVhckRpc3RhbmNlICk7XHJcblx0ZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7IC8vIGNsYW1wIHRvIFsgMCwgMSBdXHJcblxyXG5cdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZGlzdCApO1xyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdHZXb3JsZERpcmVjdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XHJcblxyXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxyXG5cclxufVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gLyogZ2xzbCAqL2BcclxudW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xyXG5cclxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGREaXJlY3Rpb24gKTtcclxuXHJcblx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xyXG5cclxuXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcclxuXHJcblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxudW5pZm9ybSBmbG9hdCBzY2FsZTtcclxuYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcclxuXHJcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xyXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XHJcblxyXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xyXG51bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcclxuXHJcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XHJcblxyXG5cdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xyXG5cclxuXHRcdGRpc2NhcmQ7XHJcblxyXG5cdH1cclxuXHJcblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XHJcblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cclxuXHJcblx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7IC8vIHNpbXBsZSBzaGFkZXJcclxuXHJcblx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cclxuXHJcbn1cclxuYDtcclxuIiwiZXhwb3J0IGNvbnN0IHZlcnRleCA9IC8qIGdsc2wgKi9gXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxyXG5cclxuXHQjaWYgZGVmaW5lZCAoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkICggVVNFX1NLSU5OSU5HIClcclxuXHJcblx0XHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxyXG5cdFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cclxuXHRcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XHJcblx0XHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0XHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XHJcblxyXG5cdCNlbmRpZlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cclxuXHJcblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xyXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XHJcblxyXG4jaWZuZGVmIEZMQVRfU0hBREVEXHJcblxyXG5cdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xyXG5cclxuI2VuZGlmXHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxyXG5cclxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcclxuXHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxyXG5cclxuXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xyXG5cclxuXHQvLyBhY2N1bXVsYXRpb24gKGJha2VkIGluZGlyZWN0IGxpZ2h0aW5nIG9ubHkpXHJcblx0I2lmZGVmIFVTRV9MSUdIVE1BUFxyXG5cclxuXHRcdHZlYzQgbGlnaHRNYXBUZXhlbCA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZMaWdodE1hcFV2ICk7XHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRNYXBUZXhlbC5yZ2IgKiBsaWdodE1hcEludGVuc2l0eSAqIFJFQ0lQUk9DQUxfUEk7XHJcblxyXG5cdCNlbHNlXHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0Ly8gbW9kdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cclxuXHJcblx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGRpZmZ1c2VDb2xvci5yZ2I7XHJcblxyXG5cdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcclxuXHJcblx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cclxuXHJcblx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxuI2RlZmluZSBMQU1CRVJUXHJcblxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cclxuXHJcblx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XHJcblxyXG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XHJcblxyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIExBTUJFUlRcclxuXHJcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xyXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XHJcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDxwYWNraW5nPlxyXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YnNkZnM+XHJcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cclxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxyXG5cclxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcclxuXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xyXG5cdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XHJcblxyXG5cdC8vIGFjY3VtdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cclxuXHJcblx0Ly8gbW9kdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cclxuXHJcblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcclxuXHJcblx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XHJcblxyXG59XHJcbmA7XHJcbiIsImV4cG9ydCBjb25zdCB2ZXJ0ZXggPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIE1BVENBUFxyXG5cclxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XHJcblxyXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cclxuXHJcblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxyXG5cclxuXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcbiNkZWZpbmUgTUFUQ0FQXHJcblxyXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcclxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xyXG51bmlmb3JtIHNhbXBsZXIyRCBtYXRjYXA7XHJcblxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cclxuXHJcblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XHJcblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxyXG5cclxuXHR2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcclxuXHR2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7XHJcblx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcclxuXHR2ZWMyIHV2ID0gdmVjMiggZG90KCB4LCBub3JtYWwgKSwgZG90KCB5LCBub3JtYWwgKSApICogMC40OTUgKyAwLjU7IC8vIDAuNDk1IHRvIHJlbW92ZSBhcnRpZmFjdHMgY2F1c2VkIGJ5IHVuZGVyc2l6ZWQgbWF0Y2FwIGRpc2tzXHJcblxyXG5cdCNpZmRlZiBVU0VfTUFUQ0FQXHJcblxyXG5cdFx0dmVjNCBtYXRjYXBDb2xvciA9IHRleHR1cmUyRCggbWF0Y2FwLCB1diApO1xyXG5cclxuXHQjZWxzZVxyXG5cclxuXHRcdHZlYzQgbWF0Y2FwQ29sb3IgPSB2ZWM0KCB2ZWMzKCBtaXgoIDAuMiwgMC44LCB1di55ICkgKSwgMS4wICk7IC8vIGRlZmF1bHQgaWYgbWF0Y2FwIGlzIG1pc3NpbmdcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdHZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7XHJcblxyXG5cdCNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cclxuXHJcbn1cclxuYDtcclxuIiwiZXhwb3J0IGNvbnN0IHZlcnRleCA9IC8qIGdsc2wgKi9gXHJcbiNkZWZpbmUgTk9STUFMXHJcblxyXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcclxuXHJcblx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cclxuXHJcblx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cclxuXHJcblx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XHJcblxyXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcclxuXHJcblx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XHJcblxyXG4jZW5kaWZcclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcbiNkZWZpbmUgTk9STUFMXHJcblxyXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XHJcblxyXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFIClcclxuXHJcblx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XHJcblxyXG4jZW5kaWZcclxuXHJcbiNpbmNsdWRlIDxwYWNraW5nPlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XHJcblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxyXG5cclxuXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrTm9ybWFsVG9SR0IoIG5vcm1hbCApLCBvcGFjaXR5ICk7XHJcblxyXG5cdCNpZmRlZiBPUEFRVUVcclxuXHJcblx0XHRnbF9GcmFnQ29sb3IuYSA9IDEuMDtcclxuXHJcblx0I2VuZGlmXHJcblxyXG59XHJcbmA7XHJcbiIsImV4cG9ydCBjb25zdCB2ZXJ0ZXggPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIFBIT05HXHJcblxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cclxuXHJcblx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XHJcblxyXG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XHJcblxyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIFBIT05HXHJcblxyXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcclxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xyXG51bmlmb3JtIHZlYzMgc3BlY3VsYXI7XHJcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xyXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8cGFja2luZz5cclxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGJzZGZzPlxyXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XHJcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XHJcblxyXG5cdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xyXG5cdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XHJcblx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcclxuXHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYWhhc2hfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XHJcblx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxyXG5cdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cclxuXHJcblx0Ly8gYWNjdW11bGF0aW9uXHJcblx0I2luY2x1ZGUgPGxpZ2h0c19waG9uZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cclxuXHJcblx0Ly8gbW9kdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cclxuXHJcblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcclxuXHJcblx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8b3BhcXVlX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XHJcblxyXG59XHJcbmA7XHJcbiIsImV4cG9ydCBjb25zdCB2ZXJ0ZXggPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIFNUQU5EQVJEXHJcblxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXHJcblxyXG5cdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcclxuXHJcbiNlbmRpZlxyXG5cclxuI2luY2x1ZGUgPGNvbW1vbj5cclxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxub3JtYWxfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XHJcblxyXG5cdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XHJcblxyXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxyXG5cclxuXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcclxuXHJcblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cclxuXHJcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXHJcblxyXG5cdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XHJcblxyXG4jZW5kaWZcclxufVxyXG5gO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gLyogZ2xzbCAqL2BcclxuI2RlZmluZSBTVEFOREFSRFxyXG5cclxuI2lmZGVmIFBIWVNJQ0FMXHJcblx0I2RlZmluZSBJT1JcclxuXHQjZGVmaW5lIFVTRV9TUEVDVUxBUlxyXG4jZW5kaWZcclxuXHJcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xyXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XHJcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xyXG51bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcclxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xyXG5cclxuI2lmZGVmIElPUlxyXG5cdHVuaWZvcm0gZmxvYXQgaW9yO1xyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfU1BFQ1VMQVJcclxuXHR1bmlmb3JtIGZsb2F0IHNwZWN1bGFySW50ZW5zaXR5O1xyXG5cdHVuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yO1xyXG5cclxuXHQjaWZkZWYgVVNFX1NQRUNVTEFSX0NPTE9STUFQXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhckNvbG9yTWFwO1xyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWZkZWYgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJJbnRlbnNpdHlNYXA7XHJcblx0I2VuZGlmXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcclxuXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdDtcclxuXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdFJvdWdobmVzcztcclxuI2VuZGlmXHJcblxyXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXHJcblx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTtcclxuXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlSU9SO1xyXG5cdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xyXG5cdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xyXG4jZW5kaWZcclxuXHJcbiNpZmRlZiBVU0VfU0hFRU5cclxuXHR1bmlmb3JtIHZlYzMgc2hlZW5Db2xvcjtcclxuXHR1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzO1xyXG5cclxuXHQjaWZkZWYgVVNFX1NIRUVOX0NPTE9STUFQXHJcblx0XHR1bmlmb3JtIHNhbXBsZXIyRCBzaGVlbkNvbG9yTWFwO1xyXG5cdCNlbmRpZlxyXG5cclxuXHQjaWZkZWYgVVNFX1NIRUVOX1JPVUdITkVTU01BUFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgc2hlZW5Sb3VnaG5lc3NNYXA7XHJcblx0I2VuZGlmXHJcbiNlbmRpZlxyXG5cclxuI2lmZGVmIFVTRV9BTklTT1RST1BZXHJcblx0dW5pZm9ybSB2ZWMyIGFuaXNvdHJvcHlWZWN0b3I7XHJcblxyXG5cdCNpZmRlZiBVU0VfQU5JU09UUk9QWU1BUFxyXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgYW5pc290cm9weU1hcDtcclxuXHQjZW5kaWZcclxuI2VuZGlmXHJcblxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDxwYWNraW5nPlxyXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxpcmlkZXNjZW5jZV9mcmFnbWVudD5cclxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cclxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjbGVhcmNvYXRfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxyXG5cclxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcclxuXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xyXG5cdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbj5cclxuXHQjaW5jbHVkZSA8Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzPlxyXG5cdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cclxuXHJcblx0Ly8gYWNjdW11bGF0aW9uXHJcblx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cclxuXHJcblx0Ly8gbW9kdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cclxuXHJcblx0dmVjMyB0b3RhbERpZmZ1c2UgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xyXG5cdHZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjtcclxuXHJcblx0I2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9mcmFnbWVudD5cclxuXHJcblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdG90YWxEaWZmdXNlICsgdG90YWxTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcclxuXHJcblx0I2lmZGVmIFVTRV9TSEVFTlxyXG5cclxuXHRcdC8vIFNoZWVuIGVuZXJneSBjb21wZW5zYXRpb24gYXBwcm94aW1hdGlvbiBjYWxjdWxhdGlvbiBjYW4gYmUgZm91bmQgYXQgdGhlIGVuZCBvZlxyXG5cdFx0Ly8gaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xVDBEMVZTeVI0QWxscUlKVFFBcmFFSXpqbGI1aDRGS0gvdmlldz91c3A9c2hhcmluZ1xyXG5cdFx0ZmxvYXQgc2hlZW5FbmVyZ3lDb21wID0gMS4wIC0gMC4xNTcgKiBtYXgzKCBtYXRlcmlhbC5zaGVlbkNvbG9yICk7XHJcblxyXG5cdFx0b3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiBzaGVlbkVuZXJneUNvbXAgKyBzaGVlblNwZWN1bGFyO1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcclxuXHJcblx0XHRmbG9hdCBkb3ROVmNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcclxuXHJcblx0XHR2ZWMzIEZjYyA9IEZfU2NobGljayggbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgZG90TlZjYyApO1xyXG5cclxuXHRcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogKCAxLjAgLSBtYXRlcmlhbC5jbGVhcmNvYXQgKiBGY2MgKSArIGNsZWFyY29hdFNwZWN1bGFyICogbWF0ZXJpYWwuY2xlYXJjb2F0O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxuI2RlZmluZSBUT09OXHJcblxyXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cclxuXHJcblx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XHJcblxyXG5cdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XHJcblxyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovYFxyXG4jZGVmaW5lIFRPT05cclxuXHJcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xyXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XHJcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDxwYWNraW5nPlxyXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxic2Rmcz5cclxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxyXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cclxuXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cclxuXHJcblx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XHJcblx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcclxuXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xyXG5cclxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XHJcblxyXG5cdC8vIGFjY3VtdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxsaWdodHNfdG9vbl9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxyXG5cdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cclxuXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cclxuXHJcblx0Ly8gbW9kdWxhdGlvblxyXG5cdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cclxuXHJcblx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcclxuXHJcblx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxudW5pZm9ybSBmbG9hdCBzaXplO1xyXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xyXG5cclxuI2luY2x1ZGUgPGNvbW1vbj5cclxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cclxuXHJcbiNpZmRlZiBVU0VfUE9JTlRTX1VWXHJcblxyXG5cdHZhcnlpbmcgdmVjMiB2VXY7XHJcblx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xyXG5cclxuI2VuZGlmXHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpZmRlZiBVU0VfUE9JTlRTX1VWXHJcblxyXG5cdFx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblxyXG5cdGdsX1BvaW50U2l6ZSA9IHNpemU7XHJcblxyXG5cdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXHJcblxyXG5cdFx0Ym9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdGlmICggaXNQZXJzcGVjdGl2ZSApIGdsX1BvaW50U2l6ZSAqPSAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTtcclxuXHJcblx0I2VuZGlmXHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xyXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XHJcblxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhbHBoYWhhc2hfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxyXG5cclxuXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcclxuXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcclxuXHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxtYXBfcGFydGljbGVfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cclxuXHJcblx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XHJcblxyXG5cdCNpbmNsdWRlIDxvcGFxdWVfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxjb2xvcnNwYWNlX2ZyYWdtZW50PlxyXG5cdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XHJcblxyXG59XHJcbmA7XHJcbiIsImV4cG9ydCBjb25zdCB2ZXJ0ZXggPSAvKiBnbHNsICovYFxyXG4jaW5jbHVkZSA8Y29tbW9uPlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XHJcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxyXG5cclxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxyXG5cdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cclxuXHJcblx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cclxuXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cclxuXHJcbn1cclxuYDtcclxuXHJcbmV4cG9ydCBjb25zdCBmcmFnbWVudCA9IC8qIGdsc2wgKi9gXHJcbnVuaWZvcm0gdmVjMyBjb2xvcjtcclxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xyXG5cclxuI2luY2x1ZGUgPGNvbW1vbj5cclxuI2luY2x1ZGUgPHBhY2tpbmc+XHJcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGJzZGZzPlxyXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cclxuXHJcblx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7XHJcblxyXG5cdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Y29sb3JzcGFjZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxyXG5cclxufVxyXG5gO1xyXG4iLCJleHBvcnQgY29uc3QgdmVydGV4ID0gLyogZ2xzbCAqL2BcclxudW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcclxudW5pZm9ybSB2ZWMyIGNlbnRlcjtcclxuXHJcbiNpbmNsdWRlIDxjb21tb24+XHJcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cclxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxyXG5cclxuXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcclxuXHJcblx0dmVjMiBzY2FsZTtcclxuXHRzY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLngsIG1vZGVsTWF0cml4WyAwIF0ueSwgbW9kZWxNYXRyaXhbIDAgXS56ICkgKTtcclxuXHRzY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLngsIG1vZGVsTWF0cml4WyAxIF0ueSwgbW9kZWxNYXRyaXhbIDEgXS56ICkgKTtcclxuXHJcblx0I2lmbmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXHJcblxyXG5cdFx0Ym9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdGlmICggaXNQZXJzcGVjdGl2ZSApIHNjYWxlICo9IC0gbXZQb3NpdGlvbi56O1xyXG5cclxuXHQjZW5kaWZcclxuXHJcblx0dmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uLnh5IC0gKCBjZW50ZXIgLSB2ZWMyKCAwLjUgKSApICkgKiBzY2FsZTtcclxuXHJcblx0dmVjMiByb3RhdGVkUG9zaXRpb247XHJcblx0cm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xyXG5cdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcclxuXHJcblx0bXZQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247XHJcblxyXG5cdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XHJcblxyXG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XHJcblx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XHJcblxyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovYFxyXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcclxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xyXG5cclxuI2luY2x1ZGUgPGNvbW1vbj5cclxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cclxuI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XHJcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxyXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XHJcblxyXG5cdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xyXG5cdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xyXG5cclxuXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8YWxwaGFoYXNoX2ZyYWdtZW50PlxyXG5cclxuXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcclxuXHJcblx0I2luY2x1ZGUgPG9wYXF1ZV9mcmFnbWVudD5cclxuXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGNvbG9yc3BhY2VfZnJhZ21lbnQ+XHJcblx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cclxuXHJcbn1cclxuYDtcclxuIiwiaW1wb3J0IGFscGhhaGFzaF9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2FscGhhaGFzaF9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvYWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBhbHBoYW1hcF9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2FscGhhbWFwX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgYWxwaGFtYXBfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2FscGhhbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBhbHBoYXRlc3RfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBhbHBoYXRlc3RfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2FscGhhdGVzdF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgYW9tYXBfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9hb21hcF9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGFvbWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9hb21hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgYmVnaW5fdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvYmVnaW5fdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgYmVnaW5ub3JtYWxfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvYmVnaW5ub3JtYWxfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgYnNkZnMgZnJvbSAnLi9TaGFkZXJDaHVuay9ic2Rmcy5nbHNsLmpzJztcclxuaW1wb3J0IGlyaWRlc2NlbmNlX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvaXJpZGVzY2VuY2VfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBidW1wbWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9jbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2NsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL2NsaXBwaW5nX3BsYW5lc192ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBjb2xvcl9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2NvbG9yX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgY29sb3JfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBjb2xvcl9wYXJzX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgY29sb3JfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvY29sb3JfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgY29tbW9uIGZyb20gJy4vU2hhZGVyQ2h1bmsvY29tbW9uLmdsc2wuanMnO1xyXG5pbXBvcnQgY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgZGVmYXVsdG5vcm1hbF92ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9kZWZhdWx0bm9ybWFsX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgZW1pc3NpdmVtYXBfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgY29sb3JzcGFjZV9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2NvbG9yc3BhY2VfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBjb2xvcnNwYWNlX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9jb2xvcnNwYWNlX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBlbnZtYXBfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9lbnZtYXBfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9lbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBlbnZtYXBfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2Vudm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgZW52bWFwX3BhcnNfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgZW52bWFwX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBmb2dfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvZm9nX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IGZvZ19wYXJzX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL2ZvZ19wYXJzX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IGZvZ19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2ZvZ19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGZvZ19wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGxpZ2h0bWFwX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRtYXBfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBsaWdodG1hcF9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGxpZ2h0c19sYW1iZXJ0X2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRzX2xhbWJlcnRfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGxpZ2h0c19wYXJzX2JlZ2luIGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRzX3BhcnNfYmVnaW4uZ2xzbC5qcyc7XHJcbmltcG9ydCBlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2Vudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgbGlnaHRzX3Rvb25fZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9saWdodHNfdG9vbl9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGxpZ2h0c190b29uX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9saWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgbGlnaHRzX3Bob25nX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2xpZ2h0c19waHlzaWNhbF9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBsaWdodHNfZnJhZ21lbnRfYmVnaW4gZnJvbSAnLi9TaGFkZXJDaHVuay9saWdodHNfZnJhZ21lbnRfYmVnaW4uZ2xzbC5qcyc7XHJcbmltcG9ydCBsaWdodHNfZnJhZ21lbnRfbWFwcyBmcm9tICcuL1NoYWRlckNodW5rL2xpZ2h0c19mcmFnbWVudF9tYXBzLmdsc2wuanMnO1xyXG5pbXBvcnQgbGlnaHRzX2ZyYWdtZW50X2VuZCBmcm9tICcuL1NoYWRlckNodW5rL2xpZ2h0c19mcmFnbWVudF9lbmQuZ2xzbC5qcyc7XHJcbmltcG9ydCBsb2dkZXB0aGJ1Zl9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgbG9nZGVwdGhidWZfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgbWFwX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgbWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IG1hcF9wYXJ0aWNsZV9mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBtZXRhbG5lc3NtYXBfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL21ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgbW9ycGhjb2xvcl92ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9tb3JwaGNvbG9yX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IG1vcnBobm9ybWFsX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL21vcnBobm9ybWFsX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBtb3JwaHRhcmdldF92ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9tb3JwaHRhcmdldF92ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBub3JtYWxfZnJhZ21lbnRfYmVnaW4gZnJvbSAnLi9TaGFkZXJDaHVuay9ub3JtYWxfZnJhZ21lbnRfYmVnaW4uZ2xzbC5qcyc7XHJcbmltcG9ydCBub3JtYWxfZnJhZ21lbnRfbWFwcyBmcm9tICcuL1NoYWRlckNodW5rL25vcm1hbF9mcmFnbWVudF9tYXBzLmdsc2wuanMnO1xyXG5pbXBvcnQgbm9ybWFsX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9ub3JtYWxfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IG5vcm1hbF9wYXJzX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL25vcm1hbF9wYXJzX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IG5vcm1hbF92ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9ub3JtYWxfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9ub3JtYWxtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4gZnJvbSAnLi9TaGFkZXJDaHVuay9jbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luLmdsc2wuanMnO1xyXG5pbXBvcnQgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzIGZyb20gJy4vU2hhZGVyQ2h1bmsvY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzLmdsc2wuanMnO1xyXG5pbXBvcnQgY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9jbGVhcmNvYXRfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9pcmlkZXNjZW5jZV9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgb3BhcXVlX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvb3BhcXVlX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgcGFja2luZyBmcm9tICcuL1NoYWRlckNodW5rL3BhY2tpbmcuZ2xzbC5qcyc7XHJcbmltcG9ydCBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IHByb2plY3RfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvcHJvamVjdF92ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBkaXRoZXJpbmdfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9kaXRoZXJpbmdfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL2RpdGhlcmluZ19wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgcm91Z2huZXNzbWFwX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvcm91Z2huZXNzbWFwX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9yb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbC5qcyc7XHJcbmltcG9ydCBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBzaGFkb3dtYXBfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCBmcm9tICcuL1NoYWRlckNodW5rL3NoYWRvd21hc2tfcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IHNraW5iYXNlX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL3NraW5iYXNlX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IHNraW5uaW5nX3BhcnNfdmVydGV4IGZyb20gJy4vU2hhZGVyQ2h1bmsvc2tpbm5pbmdfcGFyc192ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBza2lubmluZ192ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbC5qcyc7XHJcbmltcG9ydCBza2lubm9ybWFsX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL3NraW5ub3JtYWxfdmVydGV4Lmdsc2wuanMnO1xyXG5pbXBvcnQgc3BlY3VsYXJtYXBfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgdG9uZW1hcHBpbmdfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay90b25lbWFwcGluZ19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay90b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgdHJhbnNtaXNzaW9uX2ZyYWdtZW50IGZyb20gJy4vU2hhZGVyQ2h1bmsvdHJhbnNtaXNzaW9uX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay90cmFuc21pc3Npb25fcGFyc19mcmFnbWVudC5nbHNsLmpzJztcclxuaW1wb3J0IHV2X3BhcnNfZnJhZ21lbnQgZnJvbSAnLi9TaGFkZXJDaHVuay91dl9wYXJzX2ZyYWdtZW50Lmdsc2wuanMnO1xyXG5pbXBvcnQgdXZfcGFyc192ZXJ0ZXggZnJvbSAnLi9TaGFkZXJDaHVuay91dl9wYXJzX3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IHV2X3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL3V2X3ZlcnRleC5nbHNsLmpzJztcclxuaW1wb3J0IHdvcmxkcG9zX3ZlcnRleCBmcm9tICcuL1NoYWRlckNodW5rL3dvcmxkcG9zX3ZlcnRleC5nbHNsLmpzJztcclxuXHJcbmltcG9ydCAqIGFzIGJhY2tncm91bmQgZnJvbSAnLi9TaGFkZXJMaWIvYmFja2dyb3VuZC5nbHNsLmpzJztcclxuaW1wb3J0ICogYXMgYmFja2dyb3VuZEN1YmUgZnJvbSAnLi9TaGFkZXJMaWIvYmFja2dyb3VuZEN1YmUuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIGN1YmUgZnJvbSAnLi9TaGFkZXJMaWIvY3ViZS5nbHNsLmpzJztcclxuaW1wb3J0ICogYXMgZGVwdGggZnJvbSAnLi9TaGFkZXJMaWIvZGVwdGguZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIGRpc3RhbmNlUkdCQSBmcm9tICcuL1NoYWRlckxpYi9kaXN0YW5jZVJHQkEuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIGVxdWlyZWN0IGZyb20gJy4vU2hhZGVyTGliL2VxdWlyZWN0Lmdsc2wuanMnO1xyXG5pbXBvcnQgKiBhcyBsaW5lZGFzaGVkIGZyb20gJy4vU2hhZGVyTGliL2xpbmVkYXNoZWQuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIG1lc2hiYXNpYyBmcm9tICcuL1NoYWRlckxpYi9tZXNoYmFzaWMuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIG1lc2hsYW1iZXJ0IGZyb20gJy4vU2hhZGVyTGliL21lc2hsYW1iZXJ0Lmdsc2wuanMnO1xyXG5pbXBvcnQgKiBhcyBtZXNobWF0Y2FwIGZyb20gJy4vU2hhZGVyTGliL21lc2htYXRjYXAuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIG1lc2hub3JtYWwgZnJvbSAnLi9TaGFkZXJMaWIvbWVzaG5vcm1hbC5nbHNsLmpzJztcclxuaW1wb3J0ICogYXMgbWVzaHBob25nIGZyb20gJy4vU2hhZGVyTGliL21lc2hwaG9uZy5nbHNsLmpzJztcclxuaW1wb3J0ICogYXMgbWVzaHBoeXNpY2FsIGZyb20gJy4vU2hhZGVyTGliL21lc2hwaHlzaWNhbC5nbHNsLmpzJztcclxuaW1wb3J0ICogYXMgbWVzaHRvb24gZnJvbSAnLi9TaGFkZXJMaWIvbWVzaHRvb24uZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIHBvaW50cyBmcm9tICcuL1NoYWRlckxpYi9wb2ludHMuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIHNoYWRvdyBmcm9tICcuL1NoYWRlckxpYi9zaGFkb3cuZ2xzbC5qcyc7XHJcbmltcG9ydCAqIGFzIHNwcml0ZSBmcm9tICcuL1NoYWRlckxpYi9zcHJpdGUuZ2xzbC5qcyc7XHJcblxyXG5leHBvcnQgY29uc3QgU2hhZGVyQ2h1bmsgPSB7XHJcblx0YWxwaGFoYXNoX2ZyYWdtZW50OiBhbHBoYWhhc2hfZnJhZ21lbnQsXHJcblx0YWxwaGFoYXNoX3BhcnNfZnJhZ21lbnQ6IGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50LFxyXG5cdGFscGhhbWFwX2ZyYWdtZW50OiBhbHBoYW1hcF9mcmFnbWVudCxcclxuXHRhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OiBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxyXG5cdGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50OiBhbHBoYXRlc3RfcGFyc19mcmFnbWVudCxcclxuXHRhb21hcF9mcmFnbWVudDogYW9tYXBfZnJhZ21lbnQsXHJcblx0YW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcclxuXHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcclxuXHRiZWdpbm5vcm1hbF92ZXJ0ZXg6IGJlZ2lubm9ybWFsX3ZlcnRleCxcclxuXHRic2RmczogYnNkZnMsXHJcblx0aXJpZGVzY2VuY2VfZnJhZ21lbnQ6IGlyaWRlc2NlbmNlX2ZyYWdtZW50LFxyXG5cdGJ1bXBtYXBfcGFyc19mcmFnbWVudDogYnVtcG1hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50LFxyXG5cdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcclxuXHRjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCxcclxuXHRjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfdmVydGV4LFxyXG5cdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcclxuXHRjb2xvcl9wYXJzX2ZyYWdtZW50OiBjb2xvcl9wYXJzX2ZyYWdtZW50LFxyXG5cdGNvbG9yX3BhcnNfdmVydGV4OiBjb2xvcl9wYXJzX3ZlcnRleCxcclxuXHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcclxuXHRjb21tb246IGNvbW1vbixcclxuXHRjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6IGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCxcclxuXHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXHJcblx0ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgsXHJcblx0ZGlzcGxhY2VtZW50bWFwX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3ZlcnRleCxcclxuXHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXHJcblx0ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDogZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCxcclxuXHRjb2xvcnNwYWNlX2ZyYWdtZW50OiBjb2xvcnNwYWNlX2ZyYWdtZW50LFxyXG5cdGNvbG9yc3BhY2VfcGFyc19mcmFnbWVudDogY29sb3JzcGFjZV9wYXJzX2ZyYWdtZW50LFxyXG5cdGVudm1hcF9mcmFnbWVudDogZW52bWFwX2ZyYWdtZW50LFxyXG5cdGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudDogZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50LFxyXG5cdGVudm1hcF9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfcGFyc19mcmFnbWVudCxcclxuXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IGVudm1hcF9wYXJzX3ZlcnRleCxcclxuXHRlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudDogZW52bWFwX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQsXHJcblx0ZW52bWFwX3ZlcnRleDogZW52bWFwX3ZlcnRleCxcclxuXHRmb2dfdmVydGV4OiBmb2dfdmVydGV4LFxyXG5cdGZvZ19wYXJzX3ZlcnRleDogZm9nX3BhcnNfdmVydGV4LFxyXG5cdGZvZ19mcmFnbWVudDogZm9nX2ZyYWdtZW50LFxyXG5cdGZvZ19wYXJzX2ZyYWdtZW50OiBmb2dfcGFyc19mcmFnbWVudCxcclxuXHRncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OiBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdGxpZ2h0bWFwX2ZyYWdtZW50OiBsaWdodG1hcF9mcmFnbWVudCxcclxuXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBsaWdodG1hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdGxpZ2h0c19sYW1iZXJ0X2ZyYWdtZW50OiBsaWdodHNfbGFtYmVydF9mcmFnbWVudCxcclxuXHRsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50OiBsaWdodHNfbGFtYmVydF9wYXJzX2ZyYWdtZW50LFxyXG5cdGxpZ2h0c19wYXJzX2JlZ2luOiBsaWdodHNfcGFyc19iZWdpbixcclxuXHRsaWdodHNfdG9vbl9mcmFnbWVudDogbGlnaHRzX3Rvb25fZnJhZ21lbnQsXHJcblx0bGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudDogbGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudCxcclxuXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcclxuXHRsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDogbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQsXHJcblx0bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQsXHJcblx0bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxyXG5cdGxpZ2h0c19mcmFnbWVudF9iZWdpbjogbGlnaHRzX2ZyYWdtZW50X2JlZ2luLFxyXG5cdGxpZ2h0c19mcmFnbWVudF9tYXBzOiBsaWdodHNfZnJhZ21lbnRfbWFwcyxcclxuXHRsaWdodHNfZnJhZ21lbnRfZW5kOiBsaWdodHNfZnJhZ21lbnRfZW5kLFxyXG5cdGxvZ2RlcHRoYnVmX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9mcmFnbWVudCxcclxuXHRsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50LFxyXG5cdGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcclxuXHRsb2dkZXB0aGJ1Zl92ZXJ0ZXg6IGxvZ2RlcHRoYnVmX3ZlcnRleCxcclxuXHRtYXBfZnJhZ21lbnQ6IG1hcF9mcmFnbWVudCxcclxuXHRtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0bWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfZnJhZ21lbnQsXHJcblx0bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50LFxyXG5cdG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxyXG5cdG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50OiBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCxcclxuXHRtb3JwaGNvbG9yX3ZlcnRleDogbW9ycGhjb2xvcl92ZXJ0ZXgsXHJcblx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXHJcblx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxyXG5cdG1vcnBodGFyZ2V0X3ZlcnRleDogbW9ycGh0YXJnZXRfdmVydGV4LFxyXG5cdG5vcm1hbF9mcmFnbWVudF9iZWdpbjogbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxyXG5cdG5vcm1hbF9mcmFnbWVudF9tYXBzOiBub3JtYWxfZnJhZ21lbnRfbWFwcyxcclxuXHRub3JtYWxfcGFyc19mcmFnbWVudDogbm9ybWFsX3BhcnNfZnJhZ21lbnQsXHJcblx0bm9ybWFsX3BhcnNfdmVydGV4OiBub3JtYWxfcGFyc192ZXJ0ZXgsXHJcblx0bm9ybWFsX3ZlcnRleDogbm9ybWFsX3ZlcnRleCxcclxuXHRub3JtYWxtYXBfcGFyc19mcmFnbWVudDogbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0Y2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjogY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbixcclxuXHRjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHM6IGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcyxcclxuXHRjbGVhcmNvYXRfcGFyc19mcmFnbWVudDogY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQsXHJcblx0aXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudDogaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudCxcclxuXHRvcGFxdWVfZnJhZ21lbnQ6IG9wYXF1ZV9mcmFnbWVudCxcclxuXHRwYWNraW5nOiBwYWNraW5nLFxyXG5cdHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQsXHJcblx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxyXG5cdGRpdGhlcmluZ19mcmFnbWVudDogZGl0aGVyaW5nX2ZyYWdtZW50LFxyXG5cdGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50OiBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCxcclxuXHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcclxuXHRyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDogcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxyXG5cdHNoYWRvd21hcF92ZXJ0ZXg6IHNoYWRvd21hcF92ZXJ0ZXgsXHJcblx0c2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQsXHJcblx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXHJcblx0c2tpbm5pbmdfcGFyc192ZXJ0ZXg6IHNraW5uaW5nX3BhcnNfdmVydGV4LFxyXG5cdHNraW5uaW5nX3ZlcnRleDogc2tpbm5pbmdfdmVydGV4LFxyXG5cdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcclxuXHRzcGVjdWxhcm1hcF9mcmFnbWVudDogc3BlY3VsYXJtYXBfZnJhZ21lbnQsXHJcblx0c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDogc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCxcclxuXHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXHJcblx0dG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDogdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCxcclxuXHR0cmFuc21pc3Npb25fZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9mcmFnbWVudCxcclxuXHR0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudDogdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQsXHJcblx0dXZfcGFyc19mcmFnbWVudDogdXZfcGFyc19mcmFnbWVudCxcclxuXHR1dl9wYXJzX3ZlcnRleDogdXZfcGFyc192ZXJ0ZXgsXHJcblx0dXZfdmVydGV4OiB1dl92ZXJ0ZXgsXHJcblx0d29ybGRwb3NfdmVydGV4OiB3b3JsZHBvc192ZXJ0ZXgsXHJcblxyXG5cdGJhY2tncm91bmRfdmVydDogYmFja2dyb3VuZC52ZXJ0ZXgsXHJcblx0YmFja2dyb3VuZF9mcmFnOiBiYWNrZ3JvdW5kLmZyYWdtZW50LFxyXG5cdGJhY2tncm91bmRDdWJlX3ZlcnQ6IGJhY2tncm91bmRDdWJlLnZlcnRleCxcclxuXHRiYWNrZ3JvdW5kQ3ViZV9mcmFnOiBiYWNrZ3JvdW5kQ3ViZS5mcmFnbWVudCxcclxuXHRjdWJlX3ZlcnQ6IGN1YmUudmVydGV4LFxyXG5cdGN1YmVfZnJhZzogY3ViZS5mcmFnbWVudCxcclxuXHRkZXB0aF92ZXJ0OiBkZXB0aC52ZXJ0ZXgsXHJcblx0ZGVwdGhfZnJhZzogZGVwdGguZnJhZ21lbnQsXHJcblx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IGRpc3RhbmNlUkdCQS52ZXJ0ZXgsXHJcblx0ZGlzdGFuY2VSR0JBX2ZyYWc6IGRpc3RhbmNlUkdCQS5mcmFnbWVudCxcclxuXHRlcXVpcmVjdF92ZXJ0OiBlcXVpcmVjdC52ZXJ0ZXgsXHJcblx0ZXF1aXJlY3RfZnJhZzogZXF1aXJlY3QuZnJhZ21lbnQsXHJcblx0bGluZWRhc2hlZF92ZXJ0OiBsaW5lZGFzaGVkLnZlcnRleCxcclxuXHRsaW5lZGFzaGVkX2ZyYWc6IGxpbmVkYXNoZWQuZnJhZ21lbnQsXHJcblx0bWVzaGJhc2ljX3ZlcnQ6IG1lc2hiYXNpYy52ZXJ0ZXgsXHJcblx0bWVzaGJhc2ljX2ZyYWc6IG1lc2hiYXNpYy5mcmFnbWVudCxcclxuXHRtZXNobGFtYmVydF92ZXJ0OiBtZXNobGFtYmVydC52ZXJ0ZXgsXHJcblx0bWVzaGxhbWJlcnRfZnJhZzogbWVzaGxhbWJlcnQuZnJhZ21lbnQsXHJcblx0bWVzaG1hdGNhcF92ZXJ0OiBtZXNobWF0Y2FwLnZlcnRleCxcclxuXHRtZXNobWF0Y2FwX2ZyYWc6IG1lc2htYXRjYXAuZnJhZ21lbnQsXHJcblx0bWVzaG5vcm1hbF92ZXJ0OiBtZXNobm9ybWFsLnZlcnRleCxcclxuXHRtZXNobm9ybWFsX2ZyYWc6IG1lc2hub3JtYWwuZnJhZ21lbnQsXHJcblx0bWVzaHBob25nX3ZlcnQ6IG1lc2hwaG9uZy52ZXJ0ZXgsXHJcblx0bWVzaHBob25nX2ZyYWc6IG1lc2hwaG9uZy5mcmFnbWVudCxcclxuXHRtZXNocGh5c2ljYWxfdmVydDogbWVzaHBoeXNpY2FsLnZlcnRleCxcclxuXHRtZXNocGh5c2ljYWxfZnJhZzogbWVzaHBoeXNpY2FsLmZyYWdtZW50LFxyXG5cdG1lc2h0b29uX3ZlcnQ6IG1lc2h0b29uLnZlcnRleCxcclxuXHRtZXNodG9vbl9mcmFnOiBtZXNodG9vbi5mcmFnbWVudCxcclxuXHRwb2ludHNfdmVydDogcG9pbnRzLnZlcnRleCxcclxuXHRwb2ludHNfZnJhZzogcG9pbnRzLmZyYWdtZW50LFxyXG5cdHNoYWRvd192ZXJ0OiBzaGFkb3cudmVydGV4LFxyXG5cdHNoYWRvd19mcmFnOiBzaGFkb3cuZnJhZ21lbnQsXHJcblx0c3ByaXRlX3ZlcnQ6IHNwcml0ZS52ZXJ0ZXgsXHJcblx0c3ByaXRlX2ZyYWc6IHNwcml0ZS5mcmFnbWVudFxyXG59O1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4My5qcyc7XHJcblxyXG4vKipcclxuICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcclxuICovXHJcblxyXG5jb25zdCBVbmlmb3Jtc0xpYiA9IHtcclxuXHJcblx0Y29tbW9uOiB7XHJcblxyXG5cdFx0ZGlmZnVzZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4ZmZmZmZmICkgfSxcclxuXHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxyXG5cclxuXHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0bWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHJcblx0XHRhbHBoYU1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0YWxwaGFNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cclxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9XHJcblxyXG5cdH0sXHJcblxyXG5cdHNwZWN1bGFybWFwOiB7XHJcblxyXG5cdFx0c3BlY3VsYXJNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdHNwZWN1bGFyTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRlbnZtYXA6IHtcclxuXHJcblx0XHRlbnZNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdGZsaXBFbnZNYXA6IHsgdmFsdWU6IC0gMSB9LFxyXG5cdFx0cmVmbGVjdGl2aXR5OiB7IHZhbHVlOiAxLjAgfSwgLy8gYmFzaWMsIGxhbWJlcnQsIHBob25nXHJcblx0XHRpb3I6IHsgdmFsdWU6IDEuNSB9LCAvLyBwaHlzaWNhbFxyXG5cdFx0cmVmcmFjdGlvblJhdGlvOiB7IHZhbHVlOiAwLjk4IH0sIC8vIGJhc2ljLCBsYW1iZXJ0LCBwaG9uZ1xyXG5cclxuXHR9LFxyXG5cclxuXHRhb21hcDoge1xyXG5cclxuXHRcdGFvTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRhb01hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9LFxyXG5cdFx0YW9NYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGxpZ2h0bWFwOiB7XHJcblxyXG5cdFx0bGlnaHRNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdGxpZ2h0TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXHJcblx0XHRsaWdodE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH1cclxuXHJcblx0fSxcclxuXHJcblx0YnVtcG1hcDoge1xyXG5cclxuXHRcdGJ1bXBNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdGJ1bXBNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cdFx0YnVtcFNjYWxlOiB7IHZhbHVlOiAxIH1cclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsbWFwOiB7XHJcblxyXG5cdFx0bm9ybWFsTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRub3JtYWxNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cdFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoIDEsIDEgKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3BsYWNlbWVudG1hcDoge1xyXG5cclxuXHRcdGRpc3BsYWNlbWVudE1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0ZGlzcGxhY2VtZW50TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdGRpc3BsYWNlbWVudFNjYWxlOiB7IHZhbHVlOiAxIH0sXHJcblx0XHRkaXNwbGFjZW1lbnRCaWFzOiB7IHZhbHVlOiAwIH1cclxuXHJcblx0fSxcclxuXHJcblx0ZW1pc3NpdmVtYXA6IHtcclxuXHJcblx0XHRlbWlzc2l2ZU1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0ZW1pc3NpdmVNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ldGFsbmVzc21hcDoge1xyXG5cclxuXHRcdG1ldGFsbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0bWV0YWxuZXNzTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VnaG5lc3NtYXA6IHtcclxuXHJcblx0XHRyb3VnaG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdHJvdWdobmVzc01hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH1cclxuXHJcblx0fSxcclxuXHJcblx0Z3JhZGllbnRtYXA6IHtcclxuXHJcblx0XHRncmFkaWVudE1hcDogeyB2YWx1ZTogbnVsbCB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGZvZzoge1xyXG5cclxuXHRcdGZvZ0RlbnNpdHk6IHsgdmFsdWU6IDAuMDAwMjUgfSxcclxuXHRcdGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcclxuXHRcdGZvZ0ZhcjogeyB2YWx1ZTogMjAwMCB9LFxyXG5cdFx0Zm9nQ29sb3I6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH1cclxuXHJcblx0fSxcclxuXHJcblx0bGlnaHRzOiB7XHJcblxyXG5cdFx0YW1iaWVudExpZ2h0Q29sb3I6IHsgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0bGlnaHRQcm9iZTogeyB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRkaXJlY3Rpb25hbExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcclxuXHRcdFx0ZGlyZWN0aW9uOiB7fSxcclxuXHRcdFx0Y29sb3I6IHt9XHJcblx0XHR9IH0sXHJcblxyXG5cdFx0ZGlyZWN0aW9uYWxMaWdodFNoYWRvd3M6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdHNoYWRvd0JpYXM6IHt9LFxyXG5cdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcclxuXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcclxuXHRcdFx0c2hhZG93TWFwU2l6ZToge31cclxuXHRcdH0gfSxcclxuXHJcblx0XHRkaXJlY3Rpb25hbFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcclxuXHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdHNwb3RMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdGNvbG9yOiB7fSxcclxuXHRcdFx0cG9zaXRpb246IHt9LFxyXG5cdFx0XHRkaXJlY3Rpb246IHt9LFxyXG5cdFx0XHRkaXN0YW5jZToge30sXHJcblx0XHRcdGNvbmVDb3M6IHt9LFxyXG5cdFx0XHRwZW51bWJyYUNvczoge30sXHJcblx0XHRcdGRlY2F5OiB7fVxyXG5cdFx0fSB9LFxyXG5cclxuXHRcdHNwb3RMaWdodFNoYWRvd3M6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdHNoYWRvd0JpYXM6IHt9LFxyXG5cdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiB7fSxcclxuXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcclxuXHRcdFx0c2hhZG93TWFwU2l6ZToge31cclxuXHRcdH0gfSxcclxuXHJcblx0XHRzcG90TGlnaHRNYXA6IHsgdmFsdWU6IFtdIH0sXHJcblx0XHRzcG90U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxyXG5cdFx0c3BvdExpZ2h0TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdHBvaW50TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRjb2xvcjoge30sXHJcblx0XHRcdHBvc2l0aW9uOiB7fSxcclxuXHRcdFx0ZGVjYXk6IHt9LFxyXG5cdFx0XHRkaXN0YW5jZToge31cclxuXHRcdH0gfSxcclxuXHJcblx0XHRwb2ludExpZ2h0U2hhZG93czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcclxuXHRcdFx0c2hhZG93Qmlhczoge30sXHJcblx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IHt9LFxyXG5cdFx0XHRzaGFkb3dSYWRpdXM6IHt9LFxyXG5cdFx0XHRzaGFkb3dNYXBTaXplOiB7fSxcclxuXHRcdFx0c2hhZG93Q2FtZXJhTmVhcjoge30sXHJcblx0XHRcdHNoYWRvd0NhbWVyYUZhcjoge31cclxuXHRcdH0gfSxcclxuXHJcblx0XHRwb2ludFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcclxuXHRcdHBvaW50U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdGhlbWlzcGhlcmVMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdGRpcmVjdGlvbjoge30sXHJcblx0XHRcdHNreUNvbG9yOiB7fSxcclxuXHRcdFx0Z3JvdW5kQ29sb3I6IHt9XHJcblx0XHR9IH0sXHJcblxyXG5cdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgQlJERiBkYXRhIG5lZWRzIHRvIGJlIG1vdmVkIGZyb20gZXhhbXBsZSB0byBtYWluIHNyY1xyXG5cdFx0cmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdGNvbG9yOiB7fSxcclxuXHRcdFx0cG9zaXRpb246IHt9LFxyXG5cdFx0XHR3aWR0aDoge30sXHJcblx0XHRcdGhlaWdodDoge31cclxuXHRcdH0gfSxcclxuXHJcblx0XHRsdGNfMTogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0bHRjXzI6IHsgdmFsdWU6IG51bGwgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRwb2ludHM6IHtcclxuXHJcblx0XHRkaWZmdXNlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHhmZmZmZmYgKSB9LFxyXG5cdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXHJcblx0XHRzaXplOiB7IHZhbHVlOiAxLjAgfSxcclxuXHRcdHNjYWxlOiB7IHZhbHVlOiAxLjAgfSxcclxuXHRcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdGFscGhhTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9LFxyXG5cdFx0dXZUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdHNwcml0ZToge1xyXG5cclxuXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweGZmZmZmZiApIH0sXHJcblx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfSxcclxuXHRcdGNlbnRlcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSB9LFxyXG5cdFx0cm90YXRpb246IHsgdmFsdWU6IDAuMCB9LFxyXG5cdFx0bWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRtYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdGFscGhhTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdGFscGhhVGVzdDogeyB2YWx1ZTogMCB9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5leHBvcnQgeyBVbmlmb3Jtc0xpYiB9O1xyXG4iLCJpbXBvcnQgeyBTaGFkZXJDaHVuayB9IGZyb20gJy4vU2hhZGVyQ2h1bmsuanMnO1xyXG5pbXBvcnQgeyBtZXJnZVVuaWZvcm1zIH0gZnJvbSAnLi9Vbmlmb3Jtc1V0aWxzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBVbmlmb3Jtc0xpYiB9IGZyb20gJy4vVW5pZm9ybXNMaWIuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXgzLmpzJztcclxuXHJcbmNvbnN0IFNoYWRlckxpYiA9IHtcclxuXHJcblx0YmFzaWM6IHtcclxuXHJcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXHJcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2dcclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY192ZXJ0LFxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY19mcmFnXHJcblxyXG5cdH0sXHJcblxyXG5cdGxhbWJlcnQ6IHtcclxuXHJcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXHJcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcclxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0ZW1pc3NpdmU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCAweDAwMDAwMCApIH1cclxuXHRcdFx0fVxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXHJcblxyXG5cdH0sXHJcblxyXG5cdHBob25nOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xyXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXHJcblx0XHRcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbnZtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2csXHJcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxyXG5cdFx0XHRcdHNwZWN1bGFyOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgxMTExMTEgKSB9LFxyXG5cdFx0XHRcdHNoaW5pbmVzczogeyB2YWx1ZTogMzAgfVxyXG5cdFx0XHR9XHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfZnJhZ1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdGFuZGFyZDoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcclxuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbnZtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5yb3VnaG5lc3NtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXHJcblx0XHRcdHtcclxuXHRcdFx0XHRlbWlzc2l2ZTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRyb3VnaG5lc3M6IHsgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XHRcdG1ldGFsbmVzczogeyB2YWx1ZTogMC4wIH0sXHJcblx0XHRcdFx0ZW52TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0gLy8gdGVtcG9yYXJ5XHJcblx0XHRcdH1cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXHJcblxyXG5cdH0sXHJcblxyXG5cdHRvb246IHtcclxuXHJcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXHJcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmdyYWRpZW50bWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2csXHJcblx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgwMDAwMDAgKSB9XHJcblx0XHRcdH1cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2h0b29uX3ZlcnQsXHJcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHRvb25fZnJhZ1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXRjYXA6IHtcclxuXHJcblx0XHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXHJcblx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcclxuXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG1hdGNhcDogeyB2YWx1ZTogbnVsbCB9XHJcblx0XHRcdH1cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2htYXRjYXBfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobWF0Y2FwX2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0cG9pbnRzOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xyXG5cdFx0XHRVbmlmb3Jtc0xpYi5wb2ludHMsXHJcblx0XHRcdFVuaWZvcm1zTGliLmZvZ1xyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXHJcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0ZGFzaGVkOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xyXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXHJcblx0XHRcdFVuaWZvcm1zTGliLmZvZyxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHNjYWxlOiB7IHZhbHVlOiAxIH0sXHJcblx0XHRcdFx0ZGFzaFNpemU6IHsgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHR0b3RhbFNpemU6IHsgdmFsdWU6IDIgfVxyXG5cdFx0XHR9XHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXHJcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF9mcmFnXHJcblxyXG5cdH0sXHJcblxyXG5cdGRlcHRoOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xyXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXHJcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcFxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF9mcmFnXHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbDoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcclxuXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXHJcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XHJcblx0XHRcdH1cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hub3JtYWxfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobm9ybWFsX2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0c3ByaXRlOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xyXG5cdFx0XHRVbmlmb3Jtc0xpYi5zcHJpdGUsXHJcblx0XHRcdFVuaWZvcm1zTGliLmZvZ1xyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuc3ByaXRlX3ZlcnQsXHJcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc3ByaXRlX2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0YmFja2dyb3VuZDoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblx0XHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdFx0dDJEOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdGJhY2tncm91bmRJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmJhY2tncm91bmRfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kX2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0YmFja2dyb3VuZEN1YmU6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cdFx0XHRlbnZNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0ZmxpcEVudk1hcDogeyB2YWx1ZTogLSAxIH0sXHJcblx0XHRcdGJhY2tncm91bmRCbHVycmluZXNzOiB7IHZhbHVlOiAwIH0sXHJcblx0XHRcdGJhY2tncm91bmRJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmJhY2tncm91bmRDdWJlX3ZlcnQsXHJcblx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuYmFja2dyb3VuZEN1YmVfZnJhZ1xyXG5cclxuXHR9LFxyXG5cclxuXHRjdWJlOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0dEN1YmU6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0dEZsaXA6IHsgdmFsdWU6IC0gMSB9LFxyXG5cdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1aXJlY3Q6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cdFx0XHR0RXF1aXJlY3Q6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF92ZXJ0LFxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VSR0JBOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IC8qQF9fUFVSRV9fKi8gbWVyZ2VVbmlmb3JtcyggW1xyXG5cdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXHJcblx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHJlZmVyZW5jZVBvc2l0aW9uOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCkgfSxcclxuXHRcdFx0XHRuZWFyRGlzdGFuY2U6IHsgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHRmYXJEaXN0YW5jZTogeyB2YWx1ZTogMTAwMCB9XHJcblx0XHRcdH1cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV92ZXJ0LFxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXHJcblxyXG5cdH0sXHJcblxyXG5cdHNoYWRvdzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiAvKkBfX1BVUkVfXyovIG1lcmdlVW5pZm9ybXMoIFtcclxuXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxyXG5cdFx0XHRVbmlmb3Jtc0xpYi5mb2csXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjb2xvcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgQ29sb3IoIDB4MDAwMDAgKSB9LFxyXG5cdFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XHJcblx0XHRcdH0sXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuU2hhZGVyTGliLnBoeXNpY2FsID0ge1xyXG5cclxuXHR1bmlmb3JtczogLypAX19QVVJFX18qLyBtZXJnZVVuaWZvcm1zKCBbXHJcblx0XHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXHJcblx0XHR7XHJcblx0XHRcdGNsZWFyY29hdDogeyB2YWx1ZTogMCB9LFxyXG5cdFx0XHRjbGVhcmNvYXRNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0Y2xlYXJjb2F0TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdFx0Y2xlYXJjb2F0Tm9ybWFsTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXHJcblx0XHRcdGNsZWFyY29hdE5vcm1hbFNjYWxlOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCAxLCAxICkgfSxcclxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzOiB7IHZhbHVlOiAwIH0sXHJcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRjbGVhcmNvYXRSb3VnaG5lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cdFx0XHRpcmlkZXNjZW5jZTogeyB2YWx1ZTogMCB9LFxyXG5cdFx0XHRpcmlkZXNjZW5jZU1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRpcmlkZXNjZW5jZU1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXHJcblx0XHRcdGlyaWRlc2NlbmNlSU9SOiB7IHZhbHVlOiAxLjMgfSxcclxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtOiB7IHZhbHVlOiAxMDAgfSxcclxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtOiB7IHZhbHVlOiA0MDAgfSxcclxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cdFx0XHRzaGVlbjogeyB2YWx1ZTogMCB9LFxyXG5cdFx0XHRzaGVlbkNvbG9yOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxyXG5cdFx0XHRzaGVlbkNvbG9yTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdHNoZWVuQ29sb3JNYXBUcmFuc2Zvcm06IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDMoKSB9LFxyXG5cdFx0XHRzaGVlblJvdWdobmVzczogeyB2YWx1ZTogMSB9LFxyXG5cdFx0XHRzaGVlblJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRzaGVlblJvdWdobmVzc01hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXHJcblx0XHRcdHRyYW5zbWlzc2lvbjogeyB2YWx1ZTogMCB9LFxyXG5cdFx0XHR0cmFuc21pc3Npb25NYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0dHJhbnNtaXNzaW9uTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdFx0dHJhbnNtaXNzaW9uU2FtcGxlclNpemU6IHsgdmFsdWU6IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKSB9LFxyXG5cdFx0XHR0cmFuc21pc3Npb25TYW1wbGVyTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdHRoaWNrbmVzczogeyB2YWx1ZTogMCB9LFxyXG5cdFx0XHR0aGlja25lc3NNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0dGhpY2tuZXNzTWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdFx0YXR0ZW51YXRpb25EaXN0YW5jZTogeyB2YWx1ZTogMCB9LFxyXG5cdFx0XHRhdHRlbnVhdGlvbkNvbG9yOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxyXG5cdFx0XHRzcGVjdWxhckNvbG9yOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBDb2xvciggMSwgMSwgMSApIH0sXHJcblx0XHRcdHNwZWN1bGFyQ29sb3JNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0c3BlY3VsYXJDb2xvck1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXHJcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0sXHJcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwVHJhbnNmb3JtOiB7IHZhbHVlOiAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCkgfSxcclxuXHRcdFx0YW5pc290cm9weVZlY3RvcjogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpIH0sXHJcblx0XHRcdGFuaXNvdHJvcHlNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0YW5pc290cm9weU1hcFRyYW5zZm9ybTogeyB2YWx1ZTogLypAX19QVVJFX18qLyBuZXcgTWF0cml4MygpIH0sXHJcblx0XHR9XHJcblx0XSApLFxyXG5cclxuXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxyXG5cdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQgeyBTaGFkZXJMaWIgfTtcclxuIiwiaW1wb3J0IHsgQmFja1NpZGUsIEZyb250U2lkZSwgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsIFNSR0JDb2xvclNwYWNlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgQm94R2VvbWV0cnkgfSBmcm9tICcuLi8uLi9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgUGxhbmVHZW9tZXRyeSB9IGZyb20gJy4uLy4uL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IFNoYWRlck1hdGVyaWFsIH0gZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uLy4uL29iamVjdHMvTWVzaC5qcyc7XHJcbmltcG9ydCB7IFNoYWRlckxpYiB9IGZyb20gJy4uL3NoYWRlcnMvU2hhZGVyTGliLmpzJztcclxuaW1wb3J0IHsgY2xvbmVVbmlmb3JtcywgZ2V0VW5saXRVbmlmb3JtQ29sb3JTcGFjZSB9IGZyb20gJy4uL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qcyc7XHJcblxyXG5jb25zdCBfcmdiID0geyByOiAwLCBiOiAwLCBnOiAwIH07XHJcblxyXG5mdW5jdGlvbiBXZWJHTEJhY2tncm91bmQoIHJlbmRlcmVyLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgc3RhdGUsIG9iamVjdHMsIGFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XHJcblxyXG5cdGNvbnN0IGNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0bGV0IGNsZWFyQWxwaGEgPSBhbHBoYSA9PT0gdHJ1ZSA/IDAgOiAxO1xyXG5cclxuXHRsZXQgcGxhbmVNZXNoO1xyXG5cdGxldCBib3hNZXNoO1xyXG5cclxuXHRsZXQgY3VycmVudEJhY2tncm91bmQgPSBudWxsO1xyXG5cdGxldCBjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSAwO1xyXG5cdGxldCBjdXJyZW50VG9uZW1hcHBpbmcgPSBudWxsO1xyXG5cclxuXHRmdW5jdGlvbiByZW5kZXIoIHJlbmRlckxpc3QsIHNjZW5lICkge1xyXG5cclxuXHRcdGxldCBmb3JjZUNsZWFyID0gZmFsc2U7XHJcblx0XHRsZXQgYmFja2dyb3VuZCA9IHNjZW5lLmlzU2NlbmUgPT09IHRydWUgPyBzY2VuZS5iYWNrZ3JvdW5kIDogbnVsbDtcclxuXHJcblx0XHRpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1c2VQTVJFTSA9IHNjZW5lLmJhY2tncm91bmRCbHVycmluZXNzID4gMDsgLy8gdXNlIFBNUkVNIGlmIHRoZSB1c2VyIHdhbnRzIHRvIGJsdXIgdGhlIGJhY2tncm91bmRcclxuXHRcdFx0YmFja2dyb3VuZCA9ICggdXNlUE1SRU0gPyBjdWJldXZtYXBzIDogY3ViZW1hcHMgKS5nZXQoIGJhY2tncm91bmQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBiYWNrZ3JvdW5kID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDb2xvciApIHtcclxuXHJcblx0XHRcdHNldENsZWFyKCBiYWNrZ3JvdW5kLCAxICk7XHJcblx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB4ciA9IHJlbmRlcmVyLnhyO1xyXG5cdFx0Y29uc3QgZW52aXJvbm1lbnRCbGVuZE1vZGUgPSB4ci5nZXRFbnZpcm9ubWVudEJsZW5kTW9kZSgpO1xyXG5cclxuXHRcdHN3aXRjaCAoIGVudmlyb25tZW50QmxlbmRNb2RlICkge1xyXG5cclxuXHRcdFx0Y2FzZSAnb3BhcXVlJzpcclxuXHRcdFx0XHRmb3JjZUNsZWFyID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ2FkZGl0aXZlJzpcclxuXHRcdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAwLCAwLCAwLCAxLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcclxuXHRcdFx0XHRmb3JjZUNsZWFyID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ2FscGhhLWJsZW5kJzpcclxuXHRcdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAwLCAwLCAwLCAwLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcclxuXHRcdFx0XHRmb3JjZUNsZWFyID0gdHJ1ZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZW5kZXJlci5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcclxuXHJcblx0XHRcdHJlbmRlcmVyLmNsZWFyKCByZW5kZXJlci5hdXRvQ2xlYXJDb2xvciwgcmVuZGVyZXIuYXV0b0NsZWFyRGVwdGgsIHJlbmRlcmVyLmF1dG9DbGVhclN0ZW5jaWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBiYWNrZ3JvdW5kICYmICggYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlIHx8IGJhY2tncm91bmQubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgKSApIHtcclxuXHJcblx0XHRcdGlmICggYm94TWVzaCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRib3hNZXNoID0gbmV3IE1lc2goXHJcblx0XHRcdFx0XHRuZXcgQm94R2VvbWV0cnkoIDEsIDEsIDEgKSxcclxuXHRcdFx0XHRcdG5ldyBTaGFkZXJNYXRlcmlhbCgge1xyXG5cdFx0XHRcdFx0XHRuYW1lOiAnQmFja2dyb3VuZEN1YmVNYXRlcmlhbCcsXHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zOiBjbG9uZVVuaWZvcm1zKCBTaGFkZXJMaWIuYmFja2dyb3VuZEN1YmUudW5pZm9ybXMgKSxcclxuXHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZEN1YmUudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyTGliLmJhY2tncm91bmRDdWJlLmZyYWdtZW50U2hhZGVyLFxyXG5cdFx0XHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcclxuXHRcdFx0XHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdFx0XHRcdGZvZzogZmFsc2VcclxuXHRcdFx0XHRcdH0gKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGJveE1lc2guZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCAnbm9ybWFsJyApO1xyXG5cdFx0XHRcdGJveE1lc2guZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCAndXYnICk7XHJcblxyXG5cdFx0XHRcdGJveE1lc2gub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Ly8gYWRkIFwiZW52TWFwXCIgbWF0ZXJpYWwgcHJvcGVydHkgc28gdGhlIHJlbmRlcmVyIGNhbiBldmFsdWF0ZSBpdCBsaWtlIGZvciBidWlsdC1pbiBtYXRlcmlhbHNcclxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGJveE1lc2gubWF0ZXJpYWwsICdlbnZNYXAnLCB7XHJcblxyXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy51bmlmb3Jtcy5lbnZNYXAudmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdG9iamVjdHMudXBkYXRlKCBib3hNZXNoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IGJhY2tncm91bmQ7XHJcblx0XHRcdGJveE1lc2gubWF0ZXJpYWwudW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlICYmIGJhY2tncm91bmQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSApID8gLSAxIDogMTtcclxuXHRcdFx0Ym94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kQmx1cnJpbmVzcy52YWx1ZSA9IHNjZW5lLmJhY2tncm91bmRCbHVycmluZXNzO1xyXG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLmJhY2tncm91bmRJbnRlbnNpdHkudmFsdWUgPSBzY2VuZS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xyXG5cdFx0XHRib3hNZXNoLm1hdGVyaWFsLnRvbmVNYXBwZWQgPSAoIGJhY2tncm91bmQuY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGZhbHNlIDogdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggY3VycmVudEJhY2tncm91bmQgIT09IGJhY2tncm91bmQgfHxcclxuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gIT09IGJhY2tncm91bmQudmVyc2lvbiB8fFxyXG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGJveE1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XHJcblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmRWZXJzaW9uID0gYmFja2dyb3VuZC52ZXJzaW9uO1xyXG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ym94TWVzaC5sYXllcnMuZW5hYmxlQWxsKCk7XHJcblxyXG5cdFx0XHQvLyBwdXNoIHRvIHRoZSBwcmUtc29ydGVkIG9wYXF1ZSByZW5kZXIgbGlzdFxyXG5cdFx0XHRyZW5kZXJMaXN0LnVuc2hpZnQoIGJveE1lc2gsIGJveE1lc2guZ2VvbWV0cnksIGJveE1lc2gubWF0ZXJpYWwsIDAsIDAsIG51bGwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0aWYgKCBwbGFuZU1lc2ggPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cGxhbmVNZXNoID0gbmV3IE1lc2goXHJcblx0XHRcdFx0XHRuZXcgUGxhbmVHZW9tZXRyeSggMiwgMiApLFxyXG5cdFx0XHRcdFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRcdFx0XHRcdG5hbWU6ICdCYWNrZ3JvdW5kTWF0ZXJpYWwnLFxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtczogY2xvbmVVbmlmb3JtcyggU2hhZGVyTGliLmJhY2tncm91bmQudW5pZm9ybXMgKSxcclxuXHRcdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsXHJcblx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC5mcmFnbWVudFNoYWRlcixcclxuXHRcdFx0XHRcdFx0c2lkZTogRnJvbnRTaWRlLFxyXG5cdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0Zm9nOiBmYWxzZVxyXG5cdFx0XHRcdFx0fSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0cGxhbmVNZXNoLmdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcclxuXHJcblx0XHRcdFx0Ly8gYWRkIFwibWFwXCIgbWF0ZXJpYWwgcHJvcGVydHkgc28gdGhlIHJlbmRlcmVyIGNhbiBldmFsdWF0ZSBpdCBsaWtlIGZvciBidWlsdC1pbiBtYXRlcmlhbHNcclxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHBsYW5lTWVzaC5tYXRlcmlhbCwgJ21hcCcsIHtcclxuXHJcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnVuaWZvcm1zLnQyRC52YWx1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0b2JqZWN0cy51cGRhdGUoIHBsYW5lTWVzaCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnQyRC52YWx1ZSA9IGJhY2tncm91bmQ7XHJcblx0XHRcdHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5iYWNrZ3JvdW5kSW50ZW5zaXR5LnZhbHVlID0gc2NlbmUuYmFja2dyb3VuZEludGVuc2l0eTtcclxuXHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLnRvbmVNYXBwZWQgPSAoIGJhY2tncm91bmQuY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGZhbHNlIDogdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggYmFja2dyb3VuZC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGxhbmVNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoIGJhY2tncm91bmQubWF0cml4ICk7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8XHJcblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmRWZXJzaW9uICE9PSBiYWNrZ3JvdW5kLnZlcnNpb24gfHxcclxuXHRcdFx0XHRjdXJyZW50VG9uZW1hcHBpbmcgIT09IHJlbmRlcmVyLnRvbmVNYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50QmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XHJcblx0XHRcdFx0Y3VycmVudEJhY2tncm91bmRWZXJzaW9uID0gYmFja2dyb3VuZC52ZXJzaW9uO1xyXG5cdFx0XHRcdGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGxhbmVNZXNoLmxheWVycy5lbmFibGVBbGwoKTtcclxuXHJcblx0XHRcdC8vIHB1c2ggdG8gdGhlIHByZS1zb3J0ZWQgb3BhcXVlIHJlbmRlciBsaXN0XHJcblx0XHRcdHJlbmRlckxpc3QudW5zaGlmdCggcGxhbmVNZXNoLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRDbGVhciggY29sb3IsIGFscGhhICkge1xyXG5cclxuXHRcdGNvbG9yLmdldFJHQiggX3JnYiwgZ2V0VW5saXRVbmlmb3JtQ29sb3JTcGFjZSggcmVuZGVyZXIgKSApO1xyXG5cclxuXHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIF9yZ2IuciwgX3JnYi5nLCBfcmdiLmIsIGFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGdldENsZWFyQ29sb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBjbGVhckNvbG9yO1xyXG5cclxuXHRcdH0sXHJcblx0XHRzZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSA9IDEgKSB7XHJcblxyXG5cdFx0XHRjbGVhckNvbG9yLnNldCggY29sb3IgKTtcclxuXHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xyXG5cdFx0XHRzZXRDbGVhciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRnZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gY2xlYXJBbHBoYTtcclxuXHJcblx0XHR9LFxyXG5cdFx0c2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCBhbHBoYSApIHtcclxuXHJcblx0XHRcdGNsZWFyQWxwaGEgPSBhbHBoYTtcclxuXHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0cmVuZGVyOiByZW5kZXJcclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTEJhY2tncm91bmQgfTtcclxuIiwi77u/aW1wb3J0IHsgSW50VHlwZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5mdW5jdGlvbiBXZWJHTEJpbmRpbmdTdGF0ZXMoIGdsLCBleHRlbnNpb25zLCBhdHRyaWJ1dGVzLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG5cdGNvbnN0IG1heFZlcnRleEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xyXG5cclxuXHRjb25zdCBleHRlbnNpb24gPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPyBudWxsIDogZXh0ZW5zaW9ucy5nZXQoICdPRVNfdmVydGV4X2FycmF5X29iamVjdCcgKTtcclxuXHRjb25zdCB2YW9BdmFpbGFibGUgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgfHwgZXh0ZW5zaW9uICE9PSBudWxsO1xyXG5cclxuXHRjb25zdCBiaW5kaW5nU3RhdGVzID0ge307XHJcblxyXG5cdGNvbnN0IGRlZmF1bHRTdGF0ZSA9IGNyZWF0ZUJpbmRpbmdTdGF0ZSggbnVsbCApO1xyXG5cdGxldCBjdXJyZW50U3RhdGUgPSBkZWZhdWx0U3RhdGU7XHJcblx0bGV0IGZvcmNlVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwKCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgaW5kZXggKSB7XHJcblxyXG5cdFx0bGV0IHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIHZhb0F2YWlsYWJsZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHN0YXRlID0gZ2V0QmluZGluZ1N0YXRlKCBnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFN0YXRlICE9PSBzdGF0ZSApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFN0YXRlID0gc3RhdGU7XHJcblx0XHRcdFx0YmluZFZlcnRleEFycmF5T2JqZWN0KCBjdXJyZW50U3RhdGUub2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gbmVlZHNVcGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4ICk7XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSBzYXZlQ2FjaGUoIG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IHdpcmVmcmFtZSA9ICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICk7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRTdGF0ZS5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkuaWQgfHxcclxuXHRcdFx0XHRjdXJyZW50U3RhdGUucHJvZ3JhbSAhPT0gcHJvZ3JhbS5pZCB8fFxyXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZS53aXJlZnJhbWUgIT09IHdpcmVmcmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFN0YXRlLmdlb21ldHJ5ID0gZ2VvbWV0cnkuaWQ7XHJcblx0XHRcdFx0Y3VycmVudFN0YXRlLnByb2dyYW0gPSBwcm9ncmFtLmlkO1xyXG5cdFx0XHRcdGN1cnJlbnRTdGF0ZS53aXJlZnJhbWUgPSB3aXJlZnJhbWU7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy51cGRhdGUoIGluZGV4LCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgfHwgZm9yY2VVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRmb3JjZVVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZXMuZ2V0KCBpbmRleCApLmJ1ZmZlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllcy5pc1dlYkdMMiApIHJldHVybiBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xyXG5cclxuXHRcdHJldHVybiBleHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBiaW5kVmVydGV4QXJyYXlPYmplY3QoIHZhbyApIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllcy5pc1dlYkdMMiApIHJldHVybiBnbC5iaW5kVmVydGV4QXJyYXkoIHZhbyApO1xyXG5cclxuXHRcdHJldHVybiBleHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKCB2YW8gKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVWZXJ0ZXhBcnJheU9iamVjdCggdmFvICkge1xyXG5cclxuXHRcdGlmICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyICkgcmV0dXJuIGdsLmRlbGV0ZVZlcnRleEFycmF5KCB2YW8gKTtcclxuXHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9uLmRlbGV0ZVZlcnRleEFycmF5T0VTKCB2YW8gKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRCaW5kaW5nU3RhdGUoIGdlb21ldHJ5LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRjb25zdCB3aXJlZnJhbWUgPSAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApO1xyXG5cclxuXHRcdGxldCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnkuaWQgXTtcclxuXHJcblx0XHRpZiAoIHByb2dyYW1NYXAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHByb2dyYW1NYXAgPSB7fTtcclxuXHRcdFx0YmluZGluZ1N0YXRlc1sgZ2VvbWV0cnkuaWQgXSA9IHByb2dyYW1NYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbIHByb2dyYW0uaWQgXTtcclxuXHJcblx0XHRpZiAoIHN0YXRlTWFwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZU1hcCA9IHt9O1xyXG5cdFx0XHRwcm9ncmFtTWFwWyBwcm9ncmFtLmlkIF0gPSBzdGF0ZU1hcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHN0YXRlID0gc3RhdGVNYXBbIHdpcmVmcmFtZSBdO1xyXG5cclxuXHRcdGlmICggc3RhdGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHN0YXRlID0gY3JlYXRlQmluZGluZ1N0YXRlKCBjcmVhdGVWZXJ0ZXhBcnJheU9iamVjdCgpICk7XHJcblx0XHRcdHN0YXRlTWFwWyB3aXJlZnJhbWUgXSA9IHN0YXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3RhdGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlQmluZGluZ1N0YXRlKCB2YW8gKSB7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IFtdO1xyXG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBbXTtcclxuXHRcdGNvbnN0IGF0dHJpYnV0ZURpdmlzb3JzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWF4VmVydGV4QXR0cmlidXRlczsgaSArKyApIHtcclxuXHJcblx0XHRcdG5ld0F0dHJpYnV0ZXNbIGkgXSA9IDA7XHJcblx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yc1sgaSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9uIG5vbi1WQU8gc3VwcG9ydCBicm93c2VyXHJcblx0XHRcdGdlb21ldHJ5OiBudWxsLFxyXG5cdFx0XHRwcm9ncmFtOiBudWxsLFxyXG5cdFx0XHR3aXJlZnJhbWU6IGZhbHNlLFxyXG5cclxuXHRcdFx0bmV3QXR0cmlidXRlczogbmV3QXR0cmlidXRlcyxcclxuXHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXM6IGVuYWJsZWRBdHRyaWJ1dGVzLFxyXG5cdFx0XHRhdHRyaWJ1dGVEaXZpc29yczogYXR0cmlidXRlRGl2aXNvcnMsXHJcblx0XHRcdG9iamVjdDogdmFvLFxyXG5cdFx0XHRhdHRyaWJ1dGVzOiB7fSxcclxuXHRcdFx0aW5kZXg6IG51bGxcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG5lZWRzVXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtLCBpbmRleCApIHtcclxuXHJcblx0XHRjb25zdCBjYWNoZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZXM7XHJcblx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGxldCBhdHRyaWJ1dGVzTnVtID0gMDtcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjYWNoZWRBdHRyaWJ1dGUgPSBjYWNoZWRBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHRcdFx0bGV0IGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcgJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4ICkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XHJcblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciApIGdlb21ldHJ5QXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlQ29sb3I7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZS5hdHRyaWJ1dGUgIT09IGdlb21ldHJ5QXR0cmlidXRlICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgJiYgY2FjaGVkQXR0cmlidXRlLmRhdGEgIT09IGdlb21ldHJ5QXR0cmlidXRlLmRhdGEgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlc051bSArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSAhPT0gYXR0cmlidXRlc051bSApIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdGlmICggY3VycmVudFN0YXRlLmluZGV4ICE9PSBpbmRleCApIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzYXZlQ2FjaGUoIG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4ICkge1xyXG5cclxuXHRcdGNvbnN0IGNhY2hlID0ge307XHJcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdGxldCBhdHRyaWJ1dGVzTnVtID0gMDtcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRsZXQgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbmFtZSA9PT0gJ2luc3RhbmNlTWF0cml4JyAmJiBvYmplY3QuaW5zdGFuY2VNYXRyaXggKSBhdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VNYXRyaXg7XHJcblx0XHRcdFx0XHRpZiAoIG5hbWUgPT09ICdpbnN0YW5jZUNvbG9yJyAmJiBvYmplY3QuaW5zdGFuY2VDb2xvciApIGF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSB7fTtcclxuXHRcdFx0XHRkYXRhLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmRhdGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGF0YS5kYXRhID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FjaGVbIG5hbWUgXSA9IGRhdGE7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZXNOdW0gKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGN1cnJlbnRTdGF0ZS5hdHRyaWJ1dGVzID0gY2FjaGU7XHJcblx0XHRjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSA9IGF0dHJpYnV0ZXNOdW07XHJcblxyXG5cdFx0Y3VycmVudFN0YXRlLmluZGV4ID0gaW5kZXg7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW5pdEF0dHJpYnV0ZXMoKSB7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUubmV3QXR0cmlidXRlcztcclxuXHRcdGNvbnN0IGVuYWJsZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzO1xyXG5cdFx0Y29uc3QgYXR0cmlidXRlRGl2aXNvcnMgPSBjdXJyZW50U3RhdGUuYXR0cmlidXRlRGl2aXNvcnM7XHJcblxyXG5cdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiA/IGdsIDogZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uWyBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPyAndmVydGV4QXR0cmliRGl2aXNvcicgOiAndmVydGV4QXR0cmliRGl2aXNvckFOR0xFJyBdKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKTtcclxuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gbWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xyXG5cdFx0Y29uc3QgZW5hYmxlZEF0dHJpYnV0ZXMgPSBjdXJyZW50U3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xyXG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB2ZXJ0ZXhBdHRyaWJQb2ludGVyKCBpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQsIGludGVnZXIgKSB7XHJcblxyXG5cdFx0aWYgKCBpbnRlZ2VyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Z2wudmVydGV4QXR0cmliSVBvaW50ZXIoIGluZGV4LCBzaXplLCB0eXBlLCBzdHJpZGUsIG9mZnNldCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBvYmplY3QsIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRpZiAoIGNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gZmFsc2UgJiYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoIHx8IGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSApIHtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApID09PSBudWxsICkgcmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbml0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Y29uc3QgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRsZXQgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbmFtZSA9PT0gJ2luc3RhbmNlTWF0cml4JyAmJiBvYmplY3QuaW5zdGFuY2VNYXRyaXggKSBnZW9tZXRyeUF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZU1hdHJpeDtcclxuXHRcdFx0XHRcdGlmICggbmFtZSA9PT0gJ2luc3RhbmNlQ29sb3InICYmIG9iamVjdC5pbnN0YW5jZUNvbG9yICkgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBvYmplY3QuaW5zdGFuY2VDb2xvcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgbm9ybWFsaXplZCA9IGdlb21ldHJ5QXR0cmlidXRlLm5vcm1hbGl6ZWQ7XHJcblx0XHRcdFx0XHRjb25zdCBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5QXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVE9ETyBBdHRyaWJ1dGUgbWF5IG5vdCBiZSBhdmFpbGFibGUgb24gY29udGV4dCByZXN0b3JlXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XHJcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XHJcblx0XHRcdFx0XHRjb25zdCBieXRlc1BlckVsZW1lbnQgPSBhdHRyaWJ1dGUuYnl0ZXNQZXJFbGVtZW50O1xyXG5cclxuXHRcdFx0XHRcdC8vIGNoZWNrIGZvciBpbnRlZ2VyIGF0dHJpYnV0ZXMgKFdlYkdMIDIgb25seSlcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbnRlZ2VyID0gKCBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IHRydWUgJiYgKCB0eXBlID09PSBnbC5JTlQgfHwgdHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UIHx8IGdlb21ldHJ5QXR0cmlidXRlLmdwdVR5cGUgPT09IEludFR5cGUgKSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggIT09IHRydWUgJiYgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG5cdFx0XHRcdFx0XHRcdFx0cHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIGksXHJcblx0XHRcdFx0XHRcdFx0XHRzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUsXHJcblx0XHRcdFx0XHRcdFx0XHR0eXBlLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsaXplZCxcclxuXHRcdFx0XHRcdFx0XHRcdHN0cmlkZSAqIGJ5dGVzUGVyRWxlbWVudCxcclxuXHRcdFx0XHRcdFx0XHRcdCggb2Zmc2V0ICsgKCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKSAqIGkgKSAqIGJ5dGVzUGVyRWxlbWVudCxcclxuXHRcdFx0XHRcdFx0XHRcdGludGVnZXJcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgaSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAhPT0gdHJ1ZSAmJiBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmVydGV4QXR0cmliUG9pbnRlcihcclxuXHRcdFx0XHRcdFx0XHRcdHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gKyBpLFxyXG5cdFx0XHRcdFx0XHRcdFx0c2l6ZSAvIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplLFxyXG5cdFx0XHRcdFx0XHRcdFx0dHlwZSxcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbGl6ZWQsXHJcblx0XHRcdFx0XHRcdFx0XHRzaXplICogYnl0ZXNQZXJFbGVtZW50LFxyXG5cdFx0XHRcdFx0XHRcdFx0KCBzaXplIC8gcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemUgKSAqIGkgKiBieXRlc1BlckVsZW1lbnQsXHJcblx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3dpdGNoICggdmFsdWUubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliM2Z2KCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0cmVzZXQoKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBnZW9tZXRyeUlkIGluIGJpbmRpbmdTdGF0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnlJZCBdO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgcHJvZ3JhbUlkIGluIHByb2dyYW1NYXAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN0YXRlTWFwID0gcHJvZ3JhbU1hcFsgcHJvZ3JhbUlkIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCApIHtcclxuXHJcblx0XHRcdFx0XHRkZWxldGVWZXJ0ZXhBcnJheU9iamVjdCggc3RhdGVNYXBbIHdpcmVmcmFtZSBdLm9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZU1hcFsgd2lyZWZyYW1lIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGVsZXRlIHByb2dyYW1NYXBbIHByb2dyYW1JZCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbIGdlb21ldHJ5SWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVsZWFzZVN0YXRlc09mR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGlmICggYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnkuaWQgXSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW1NYXAgPSBiaW5kaW5nU3RhdGVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IHByb2dyYW1JZCBpbiBwcm9ncmFtTWFwICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RhdGVNYXAgPSBwcm9ncmFtTWFwWyBwcm9ncmFtSWQgXTtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCApIHtcclxuXHJcblx0XHRcdFx0ZGVsZXRlVmVydGV4QXJyYXlPYmplY3QoIHN0YXRlTWFwWyB3aXJlZnJhbWUgXS5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIHN0YXRlTWFwWyB3aXJlZnJhbWUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlbGV0ZSBwcm9ncmFtTWFwWyBwcm9ncmFtSWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlIGJpbmRpbmdTdGF0ZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVsZWFzZVN0YXRlc09mUHJvZ3JhbSggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBnZW9tZXRyeUlkIGluIGJpbmRpbmdTdGF0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1sgZ2VvbWV0cnlJZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9ncmFtTWFwWyBwcm9ncmFtLmlkIF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RhdGVNYXAgPSBwcm9ncmFtTWFwWyBwcm9ncmFtLmlkIF07XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCB3aXJlZnJhbWUgaW4gc3RhdGVNYXAgKSB7XHJcblxyXG5cdFx0XHRcdGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KCBzdGF0ZU1hcFsgd2lyZWZyYW1lIF0ub2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSBzdGF0ZU1hcFsgd2lyZWZyYW1lIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkZWxldGUgcHJvZ3JhbU1hcFsgcHJvZ3JhbS5pZCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNldCgpIHtcclxuXHJcblx0XHRyZXNldERlZmF1bHRTdGF0ZSgpO1xyXG5cdFx0Zm9yY2VVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggY3VycmVudFN0YXRlID09PSBkZWZhdWx0U3RhdGUgKSByZXR1cm47XHJcblxyXG5cdFx0Y3VycmVudFN0YXRlID0gZGVmYXVsdFN0YXRlO1xyXG5cdFx0YmluZFZlcnRleEFycmF5T2JqZWN0KCBjdXJyZW50U3RhdGUub2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcclxuXHJcblx0ZnVuY3Rpb24gcmVzZXREZWZhdWx0U3RhdGUoKSB7XHJcblxyXG5cdFx0ZGVmYXVsdFN0YXRlLmdlb21ldHJ5ID0gbnVsbDtcclxuXHRcdGRlZmF1bHRTdGF0ZS5wcm9ncmFtID0gbnVsbDtcclxuXHRcdGRlZmF1bHRTdGF0ZS53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHNldHVwOiBzZXR1cCxcclxuXHRcdHJlc2V0OiByZXNldCxcclxuXHRcdHJlc2V0RGVmYXVsdFN0YXRlOiByZXNldERlZmF1bHRTdGF0ZSxcclxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2UsXHJcblx0XHRyZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeTogcmVsZWFzZVN0YXRlc09mR2VvbWV0cnksXHJcblx0XHRyZWxlYXNlU3RhdGVzT2ZQcm9ncmFtOiByZWxlYXNlU3RhdGVzT2ZQcm9ncmFtLFxyXG5cclxuXHRcdGluaXRBdHRyaWJ1dGVzOiBpbml0QXR0cmlidXRlcyxcclxuXHRcdGVuYWJsZUF0dHJpYnV0ZTogZW5hYmxlQXR0cmlidXRlLFxyXG5cdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6IGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzXHJcblxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xCaW5kaW5nU3RhdGVzIH07XHJcbiIsImZ1bmN0aW9uIFdlYkdMQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG5cdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xyXG5cclxuXHRsZXQgbW9kZTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0bW9kZSA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xyXG5cclxuXHRcdGdsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xyXG5cclxuXHRcdGluZm8udXBkYXRlKCBjb3VudCwgbW9kZSwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggc3RhcnQsIGNvdW50LCBwcmltY291bnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwcmltY291bnQgPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0bGV0IGV4dGVuc2lvbiwgbWV0aG9kTmFtZTtcclxuXHJcblx0XHRpZiAoIGlzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZ2w7XHJcblx0XHRcdG1ldGhvZE5hbWUgPSAnZHJhd0FycmF5c0luc3RhbmNlZCc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHRcdFx0bWV0aG9kTmFtZSA9ICdkcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUnO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRleHRlbnNpb25bIG1ldGhvZE5hbWUgXSggbW9kZSwgc3RhcnQsIGNvdW50LCBwcmltY291bnQgKTtcclxuXHJcblx0XHRpbmZvLnVwZGF0ZSggY291bnQsIG1vZGUsIHByaW1jb3VudCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XHJcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xCdWZmZXJSZW5kZXJlciB9O1xyXG4iLCJmdW5jdGlvbiBXZWJHTENhcGFiaWxpdGllcyggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGxldCBtYXhBbmlzb3Ryb3B5O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdGlmICggbWF4QW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIG1heEFuaXNvdHJvcHk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdFx0bWF4QW5pc290cm9weSA9IGdsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1heEFuaXNvdHJvcHk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0aWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcclxuXHRcdFx0XHRnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiAnaGlnaHAnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xyXG5cclxuXHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcclxuXHRcdFx0XHRnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuICdtZWRpdW1wJztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICdsb3dwJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdCBpc1dlYkdMMiA9IHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnV2ViR0wyUmVuZGVyaW5nQ29udGV4dCc7XHJcblxyXG5cdGxldCBwcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnO1xyXG5cdGNvbnN0IG1heFByZWNpc2lvbiA9IGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICk7XHJcblxyXG5cdGlmICggbWF4UHJlY2lzaW9uICE9PSBwcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCBwcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIG1heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG5cdFx0cHJlY2lzaW9uID0gbWF4UHJlY2lzaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IGRyYXdCdWZmZXJzID0gaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoICdXRUJHTF9kcmF3X2J1ZmZlcnMnICk7XHJcblxyXG5cdGNvbnN0IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09IHRydWU7XHJcblxyXG5cdGNvbnN0IG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG5cdGNvbnN0IG1heFZlcnRleFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHRjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xyXG5cdGNvbnN0IG1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XHJcblxyXG5cdGNvbnN0IG1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xyXG5cdGNvbnN0IG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xyXG5cdGNvbnN0IG1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XHJcblx0Y29uc3QgbWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xyXG5cclxuXHRjb25zdCB2ZXJ0ZXhUZXh0dXJlcyA9IG1heFZlcnRleFRleHR1cmVzID4gMDtcclxuXHRjb25zdCBmbG9hdEZyYWdtZW50VGV4dHVyZXMgPSBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcyggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdGNvbnN0IGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XHJcblxyXG5cdGNvbnN0IG1heFNhbXBsZXMgPSBpc1dlYkdMMiA/IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1NBTVBMRVMgKSA6IDA7XHJcblxyXG5cdHJldHVybiB7XHJcblxyXG5cdFx0aXNXZWJHTDI6IGlzV2ViR0wyLFxyXG5cclxuXHRcdGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcclxuXHJcblx0XHRnZXRNYXhBbmlzb3Ryb3B5OiBnZXRNYXhBbmlzb3Ryb3B5LFxyXG5cdFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXHJcblxyXG5cdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXHJcblx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxyXG5cclxuXHRcdG1heFRleHR1cmVzOiBtYXhUZXh0dXJlcyxcclxuXHRcdG1heFZlcnRleFRleHR1cmVzOiBtYXhWZXJ0ZXhUZXh0dXJlcyxcclxuXHRcdG1heFRleHR1cmVTaXplOiBtYXhUZXh0dXJlU2l6ZSxcclxuXHRcdG1heEN1YmVtYXBTaXplOiBtYXhDdWJlbWFwU2l6ZSxcclxuXHJcblx0XHRtYXhBdHRyaWJ1dGVzOiBtYXhBdHRyaWJ1dGVzLFxyXG5cdFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxyXG5cdFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxyXG5cdFx0bWF4RnJhZ21lbnRVbmlmb3JtczogbWF4RnJhZ21lbnRVbmlmb3JtcyxcclxuXHJcblx0XHR2ZXJ0ZXhUZXh0dXJlczogdmVydGV4VGV4dHVyZXMsXHJcblx0XHRmbG9hdEZyYWdtZW50VGV4dHVyZXM6IGZsb2F0RnJhZ21lbnRUZXh0dXJlcyxcclxuXHRcdGZsb2F0VmVydGV4VGV4dHVyZXM6IGZsb2F0VmVydGV4VGV4dHVyZXMsXHJcblxyXG5cdFx0bWF4U2FtcGxlczogbWF4U2FtcGxlc1xyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFdlYkdMQ2FwYWJpbGl0aWVzIH07XHJcbiIsImltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgeyBQbGFuZSB9IGZyb20gJy4uLy4uL21hdGgvUGxhbmUuanMnO1xyXG5cclxuZnVuY3Rpb24gV2ViR0xDbGlwcGluZyggcHJvcGVydGllcyApIHtcclxuXHJcblx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRsZXQgZ2xvYmFsU3RhdGUgPSBudWxsLFxyXG5cdFx0bnVtR2xvYmFsUGxhbmVzID0gMCxcclxuXHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXHJcblx0XHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2U7XHJcblxyXG5cdGNvbnN0IHBsYW5lID0gbmV3IFBsYW5lKCksXHJcblx0XHR2aWV3Tm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKSxcclxuXHJcblx0XHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XHJcblxyXG5cdHRoaXMudW5pZm9ybSA9IHVuaWZvcm07XHJcblx0dGhpcy5udW1QbGFuZXMgPSAwO1xyXG5cdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gMDtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCBwbGFuZXMsIGVuYWJsZUxvY2FsQ2xpcHBpbmcgKSB7XHJcblxyXG5cdFx0Y29uc3QgZW5hYmxlZCA9XHJcblx0XHRcdHBsYW5lcy5sZW5ndGggIT09IDAgfHxcclxuXHRcdFx0ZW5hYmxlTG9jYWxDbGlwcGluZyB8fFxyXG5cdFx0XHQvLyBlbmFibGUgc3RhdGUgb2YgcHJldmlvdXMgZnJhbWUgLSB0aGUgY2xpcHBpbmcgY29kZSBoYXMgdG9cclxuXHRcdFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxyXG5cdFx0XHRudW1HbG9iYWxQbGFuZXMgIT09IDAgfHxcclxuXHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQ7XHJcblxyXG5cdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xyXG5cclxuXHRcdG51bUdsb2JhbFBsYW5lcyA9IHBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIGVuYWJsZWQ7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYmVnaW5TaGFkb3dzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xyXG5cdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldEdsb2JhbFN0YXRlID0gZnVuY3Rpb24gKCBwbGFuZXMsIGNhbWVyYSApIHtcclxuXHJcblx0XHRnbG9iYWxTdGF0ZSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCAwICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlICkge1xyXG5cclxuXHRcdGNvbnN0IHBsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLFxyXG5cdFx0XHRjbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbixcclxuXHRcdFx0Y2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoICEgbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgcGxhbmVzID09PSBudWxsIHx8IHBsYW5lcy5sZW5ndGggPT09IDAgfHwgcmVuZGVyaW5nU2hhZG93cyAmJiAhIGNsaXBTaGFkb3dzICkge1xyXG5cclxuXHRcdFx0Ly8gdGhlcmUncyBubyBsb2NhbCBjbGlwcGluZ1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJpbmdTaGFkb3dzICkge1xyXG5cclxuXHRcdFx0XHQvLyB0aGVyZSdzIG5vIGdsb2JhbCBjbGlwcGluZ1xyXG5cclxuXHRcdFx0XHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXNldEdsb2JhbFN0YXRlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcclxuXHRcdFx0XHRsR2xvYmFsID0gbkdsb2JhbCAqIDQ7XHJcblxyXG5cdFx0XHRsZXQgZHN0QXJyYXkgPSBtYXRlcmlhbFByb3BlcnRpZXMuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xyXG5cclxuXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5OyAvLyBlbnN1cmUgdW5pcXVlIHN0YXRlXHJcblxyXG5cdFx0XHRkc3RBcnJheSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBsR2xvYmFsLCB1c2VDYWNoZSApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBsR2xvYmFsOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRkc3RBcnJheVsgaSBdID0gZ2xvYmFsU3RhdGVbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XHJcblx0XHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcclxuXHRcdFx0dGhpcy5udW1QbGFuZXMgKz0gbkdsb2JhbDtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xyXG5cclxuXHRcdGlmICggdW5pZm9ybS52YWx1ZSAhPT0gZ2xvYmFsU3RhdGUgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XHJcblx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSBudW1HbG9iYWxQbGFuZXMgPiAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XHJcblx0XHRzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBkc3RPZmZzZXQsIHNraXBUcmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0Y29uc3QgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwO1xyXG5cdFx0bGV0IGRzdEFycmF5ID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIG5QbGFuZXMgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XHJcblxyXG5cdFx0XHRpZiAoIHNraXBUcmFuc2Zvcm0gIT09IHRydWUgfHwgZHN0QXJyYXkgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXHJcblx0XHRcdFx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcclxuXHJcblx0XHRcdFx0dmlld05vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSApIHtcclxuXHJcblx0XHRcdFx0XHRkc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGZsYXRTaXplICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpNCA9IGRzdE9mZnNldDsgaSAhPT0gblBsYW5lczsgKysgaSwgaTQgKz0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRwbGFuZS5jb3B5KCBwbGFuZXNbIGkgXSApLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCwgdmlld05vcm1hbE1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdHBsYW5lLm5vcm1hbC50b0FycmF5KCBkc3RBcnJheSwgaTQgKTtcclxuXHRcdFx0XHRcdGRzdEFycmF5WyBpNCArIDMgXSA9IHBsYW5lLmNvbnN0YW50O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7XHJcblx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xyXG5cdFx0c2NvcGUubnVtSW50ZXJzZWN0aW9uID0gMDtcclxuXHJcblx0XHRyZXR1cm4gZHN0QXJyYXk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTENsaXBwaW5nIH07XHJcbiIsImltcG9ydCB7IEN1YmVSZWZsZWN0aW9uTWFwcGluZywgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi9XZWJHTEN1YmVSZW5kZXJUYXJnZXQuanMnO1xyXG5cclxuZnVuY3Rpb24gV2ViR0xDdWJlTWFwcyggcmVuZGVyZXIgKSB7XHJcblxyXG5cdGxldCBjdWJlbWFwcyA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdGZ1bmN0aW9uIG1hcFRleHR1cmVNYXBwaW5nKCB0ZXh0dXJlLCBtYXBwaW5nICkge1xyXG5cclxuXHRcdGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldCggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1RleHR1cmUgJiYgdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcclxuXHJcblx0XHRcdGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY3ViZW1hcHMuaGFzKCB0ZXh0dXJlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgY3ViZW1hcCA9IGN1YmVtYXBzLmdldCggdGV4dHVyZSApLnRleHR1cmU7XHJcblx0XHRcdFx0XHRyZXR1cm4gbWFwVGV4dHVyZU1hcHBpbmcoIGN1YmVtYXAsIHRleHR1cmUubWFwcGluZyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGltYWdlID0gdGV4dHVyZS5pbWFnZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGltYWdlICYmIGltYWdlLmhlaWdodCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCBpbWFnZS5oZWlnaHQgLyAyICk7XHJcblx0XHRcdFx0XHRcdHJlbmRlclRhcmdldC5mcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZSggcmVuZGVyZXIsIHRleHR1cmUgKTtcclxuXHRcdFx0XHRcdFx0Y3ViZW1hcHMuc2V0KCB0ZXh0dXJlLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWFwVGV4dHVyZU1hcHBpbmcoIHJlbmRlclRhcmdldC50ZXh0dXJlLCB0ZXh0dXJlLm1hcHBpbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaW1hZ2Ugbm90IHlldCByZWFkeS4gdHJ5IHRoZSBjb252ZXJzaW9uIG5leHQgZnJhbWVcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0Y29uc3QgY3ViZW1hcCA9IGN1YmVtYXBzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggY3ViZW1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y3ViZW1hcHMuZGVsZXRlKCB0ZXh0dXJlICk7XHJcblx0XHRcdGN1YmVtYXAuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xyXG5cclxuXHRcdGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Z2V0OiBnZXQsXHJcblx0XHRkaXNwb3NlOiBkaXNwb3NlXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMQ3ViZU1hcHMgfTtcclxuIiwiaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSAnLi9DYW1lcmEuanMnO1xyXG5cclxuY2xhc3MgT3J0aG9ncmFwaGljQ2FtZXJhIGV4dGVuZHMgQ2FtZXJhIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGxlZnQgPSAtIDEsIHJpZ2h0ID0gMSwgdG9wID0gMSwgYm90dG9tID0gLSAxLCBuZWFyID0gMC4xLCBmYXIgPSAyMDAwICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XHJcblxyXG5cdFx0dGhpcy56b29tID0gMTtcclxuXHRcdHRoaXMudmlldyA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5sZWZ0ID0gbGVmdDtcclxuXHRcdHRoaXMucmlnaHQgPSByaWdodDtcclxuXHRcdHRoaXMudG9wID0gdG9wO1xyXG5cdFx0dGhpcy5ib3R0b20gPSBib3R0b207XHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcclxuXHRcdHRoaXMuZmFyID0gZmFyO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XHJcblx0XHR0aGlzLnJpZ2h0ID0gc291cmNlLnJpZ2h0O1xyXG5cdFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xyXG5cdFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xyXG5cdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcblx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblxyXG5cdFx0dGhpcy56b29tID0gc291cmNlLnpvb207XHJcblx0XHR0aGlzLnZpZXcgPSBzb3VyY2UudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnZpZXcgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRWaWV3T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZpZXcgPSB7XHJcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcclxuXHRcdFx0XHRmdWxsV2lkdGg6IDEsXHJcblx0XHRcdFx0ZnVsbEhlaWdodDogMSxcclxuXHRcdFx0XHRvZmZzZXRYOiAwLFxyXG5cdFx0XHRcdG9mZnNldFk6IDAsXHJcblx0XHRcdFx0d2lkdGg6IDEsXHJcblx0XHRcdFx0aGVpZ2h0OiAxXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XHJcblx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XHJcblx0XHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XHJcblx0XHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XHJcblx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcclxuXHRcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xlYXJWaWV3T2Zmc2V0KCkge1xyXG5cclxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpIHtcclxuXHJcblx0XHRjb25zdCBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XHJcblx0XHRjb25zdCBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XHJcblx0XHRjb25zdCBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcclxuXHRcdGNvbnN0IGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xyXG5cclxuXHRcdGxldCBsZWZ0ID0gY3ggLSBkeDtcclxuXHRcdGxldCByaWdodCA9IGN4ICsgZHg7XHJcblx0XHRsZXQgdG9wID0gY3kgKyBkeTtcclxuXHRcdGxldCBib3R0b20gPSBjeSAtIGR5O1xyXG5cclxuXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2NhbGVXID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyB0aGlzLnZpZXcuZnVsbFdpZHRoIC8gdGhpcy56b29tO1xyXG5cdFx0XHRjb25zdCBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5mdWxsSGVpZ2h0IC8gdGhpcy56b29tO1xyXG5cclxuXHRcdFx0bGVmdCArPSBzY2FsZVcgKiB0aGlzLnZpZXcub2Zmc2V0WDtcclxuXHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogdGhpcy52aWV3LndpZHRoO1xyXG5cdFx0XHR0b3AgLT0gc2NhbGVIICogdGhpcy52aWV3Lm9mZnNldFk7XHJcblx0XHRcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqIHRoaXMudmlldy5oZWlnaHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIsIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSApO1xyXG5cclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICkuaW52ZXJ0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xyXG5cdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcclxuXHRcdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcclxuXHRcdGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xyXG5cdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XHJcblx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBPcnRob2dyYXBoaWNDYW1lcmEgfTtcclxuIiwiaW1wb3J0IHtcclxuXHRDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXHJcblx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxyXG5cdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxyXG5cdExpbmVhckZpbHRlcixcclxuXHROb1RvbmVNYXBwaW5nLFxyXG5cdE5vQmxlbmRpbmcsXHJcblx0UkdCQUZvcm1hdCxcclxuXHRIYWxmRmxvYXRUeXBlLFxyXG5cdEJhY2tTaWRlLFxyXG5cdExpbmVhclNSR0JDb2xvclNwYWNlXHJcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL29iamVjdHMvTWVzaC5qcyc7XHJcbmltcG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvT3J0aG9ncmFwaGljQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICcuLi9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanMnO1xyXG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IEJveEdlb21ldHJ5IH0gZnJvbSAnLi4vZ2VvbWV0cmllcy9Cb3hHZW9tZXRyeS5qcyc7XHJcblxyXG5jb25zdCBMT0RfTUlOID0gNDtcclxuXHJcbi8vIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25zIChyYWRpYW5zKSBhc3NvY2lhdGVkIHdpdGggdGhlIGV4dHJhIG1pcHMuIFRoZXNlIGFyZVxyXG4vLyBjaG9zZW4gdG8gYXBwcm94aW1hdGUgYSBUcm93YnJpZGdlLVJlaXR6IGRpc3RyaWJ1dGlvbiBmdW5jdGlvbiB0aW1lcyB0aGVcclxuLy8gZ2VvbWV0cmljIHNoYWRvd2luZyBmdW5jdGlvbi4gVGhlc2Ugc2lnbWEgdmFsdWVzIHNxdWFyZWQgbXVzdCBtYXRjaCB0aGVcclxuLy8gdmFyaWFuY2UgI2RlZmluZXMgaW4gY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50Lmdsc2wuanMuXHJcbmNvbnN0IEVYVFJBX0xPRF9TSUdNQSA9IFsgMC4xMjUsIDAuMjE1LCAwLjM1LCAwLjQ0NiwgMC41MjYsIDAuNTgyIF07XHJcblxyXG4vLyBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIGJsdXIgZm9yIGxvb3AuIFNtYWxsZXIgc2lnbWFzIHdpbGwgdXNlIGZld2VyXHJcbi8vIHNhbXBsZXMgYW5kIGV4aXQgZWFybHksIGJ1dCBub3QgcmVjb21waWxlIHRoZSBzaGFkZXIuXHJcbmNvbnN0IE1BWF9TQU1QTEVTID0gMjA7XHJcblxyXG5jb25zdCBfZmxhdENhbWVyYSA9IC8qQF9fUFVSRV9fKi8gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgpO1xyXG5jb25zdCBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCk7XHJcbmxldCBfb2xkVGFyZ2V0ID0gbnVsbDtcclxuXHJcbi8vIEdvbGRlbiBSYXRpb1xyXG5jb25zdCBQSEkgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuY29uc3QgSU5WX1BISSA9IDEgLyBQSEk7XHJcblxyXG4vLyBWZXJ0aWNlcyBvZiBhIGRvZGVjYWhlZHJvbiAoZXhjZXB0IHRoZSBvcHBvc2l0ZXMsIHdoaWNoIHJlcHJlc2VudCB0aGVcclxuLy8gc2FtZSBheGlzKSwgdXNlZCBhcyBheGlzIGRpcmVjdGlvbnMgZXZlbmx5IHNwcmVhZCBvbiBhIHNwaGVyZS5cclxuY29uc3QgX2F4aXNEaXJlY3Rpb25zID0gW1xyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIDEsIDEsIDEgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAtIDEgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIDEsIDEsIC0gMSApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIFBISSwgSU5WX1BISSApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIFBISSwgLSBJTlZfUEhJICksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggSU5WX1BISSwgMCwgUEhJICksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggLSBJTlZfUEhJLCAwLCBQSEkgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCBQSEksIElOVl9QSEksIDAgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIFBISSwgSU5WX1BISSwgMCApIF07XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBnZW5lcmF0ZXMgYSBQcmVmaWx0ZXJlZCwgTWlwbWFwcGVkIFJhZGlhbmNlIEVudmlyb25tZW50IE1hcFxyXG4gKiAoUE1SRU0pIGZyb20gYSBjdWJlTWFwIGVudmlyb25tZW50IHRleHR1cmUuIFRoaXMgYWxsb3dzIGRpZmZlcmVudCBsZXZlbHMgb2ZcclxuICogYmx1ciB0byBiZSBxdWlja2x5IGFjY2Vzc2VkIGJhc2VkIG9uIG1hdGVyaWFsIHJvdWdobmVzcy4gSXQgaXMgcGFja2VkIGludG8gYVxyXG4gKiBzcGVjaWFsIEN1YmVVViBmb3JtYXQgdGhhdCBhbGxvd3MgdXMgdG8gcGVyZm9ybSBjdXN0b20gaW50ZXJwb2xhdGlvbiBzbyB0aGF0XHJcbiAqIHdlIGNhbiBzdXBwb3J0IG5vbmxpbmVhciBmb3JtYXRzIHN1Y2ggYXMgUkdCRS4gVW5saWtlIGEgdHJhZGl0aW9uYWwgbWlwbWFwXHJcbiAqIGNoYWluLCBpdCBvbmx5IGdvZXMgZG93biB0byB0aGUgTE9EX01JTiBsZXZlbCAoYWJvdmUpLCBhbmQgdGhlbiBjcmVhdGVzIGV4dHJhXHJcbiAqIGV2ZW4gbW9yZSBmaWx0ZXJlZCAnbWlwcycgYXQgdGhlIHNhbWUgTE9EX01JTiByZXNvbHV0aW9uLCBhc3NvY2lhdGVkIHdpdGhcclxuICogaGlnaGVyIHJvdWdobmVzcyBsZXZlbHMuIEluIHRoaXMgd2F5IHdlIG1haW50YWluIHJlc29sdXRpb24gdG8gc21vb3RobHlcclxuICogaW50ZXJwb2xhdGUgZGlmZnVzZSBsaWdodGluZyB3aGlsZSBsaW1pdGluZyBzYW1wbGluZyBjb21wdXRhdGlvbi5cclxuICpcclxuICogUGFwZXI6IEZhc3QsIEFjY3VyYXRlIEltYWdlLUJhc2VkIExpZ2h0aW5nXHJcbiAqIGh0dHBzOi8vZHJpdmUuZ29vZ2xlLmNvbS9maWxlL2QvMTV5OHJfVXBLbFU5U3ZWNElMYjBDM3FDUGVjUzhwdkx6L3ZpZXdcclxuKi9cclxuXHJcbmNsYXNzIFBNUkVNR2VuZXJhdG9yIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblx0XHR0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5fbG9kTWF4ID0gMDtcclxuXHRcdHRoaXMuX2N1YmVTaXplID0gMDtcclxuXHRcdHRoaXMuX2xvZFBsYW5lcyA9IFtdO1xyXG5cdFx0dGhpcy5fc2l6ZUxvZHMgPSBbXTtcclxuXHRcdHRoaXMuX3NpZ21hcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2JsdXJNYXRlcmlhbCA9IG51bGw7XHJcblx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBudWxsO1xyXG5cdFx0dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKCB0aGlzLl9ibHVyTWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGEgc3VwcGxpZWQgU2NlbmUsIHdoaWNoIGNhbiBiZSBmYXN0ZXIgdGhhbiB1c2luZyBhblxyXG5cdCAqIGltYWdlIGlmIG5ldHdvcmtpbmcgYmFuZHdpZHRoIGlzIGxvdy4gT3B0aW9uYWwgc2lnbWEgc3BlY2lmaWVzIGEgYmx1ciByYWRpdXNcclxuXHQgKiBpbiByYWRpYW5zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNjZW5lIGJlZm9yZSBQTVJFTSBnZW5lcmF0aW9uLiBPcHRpb25hbCBuZWFyXHJcblx0ICogYW5kIGZhciBwbGFuZXMgZW5zdXJlIHRoZSBzY2VuZSBpcyByZW5kZXJlZCBpbiBpdHMgZW50aXJldHkgKHRoZSBjdWJlQ2FtZXJhXHJcblx0ICogaXMgcGxhY2VkIGF0IHRoZSBvcmlnaW4pLlxyXG5cdCAqL1xyXG5cdGZyb21TY2VuZSggc2NlbmUsIHNpZ21hID0gMCwgbmVhciA9IDAuMSwgZmFyID0gMTAwICkge1xyXG5cclxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHJcblx0XHR0aGlzLl9zZXRTaXplKCAyNTYgKTtcclxuXHJcblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcclxuXHRcdGN1YmVVVlJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fc2NlbmVUb0N1YmVVViggc2NlbmUsIG5lYXIsIGZhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0aWYgKCBzaWdtYSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIHNpZ21hICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FwcGx5UE1SRU0oIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5fY2xlYW51cCggY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxyXG5cdCAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGltYWdlIHNpemUgaXMgMWsgKDEwMjQgeCA1MTIpLFxyXG5cdCAqIGFzIHRoaXMgbWF0Y2hlcyBiZXN0IHdpdGggdGhlIDI1NiB4IDI1NiBjdWJlbWFwIG91dHB1dC5cclxuXHQgKi9cclxuXHRmcm9tRXF1aXJlY3Rhbmd1bGFyKCBlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKCBlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYW4gY3ViZW1hcCB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxyXG5cdCAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGN1YmUgc2l6ZSBpcyAyNTYgeCAyNTYsXHJcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxyXG5cdCAqL1xyXG5cdGZyb21DdWJlbWFwKCBjdWJlbWFwLCByZW5kZXJUYXJnZXQgPSBudWxsICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9mcm9tVGV4dHVyZSggY3ViZW1hcCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBjdWJlbWFwIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xyXG5cdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cclxuXHQgKi9cclxuXHRjb21waWxlQ3ViZW1hcFNoYWRlcigpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IF9nZXRDdWJlbWFwTWF0ZXJpYWwoKTtcclxuXHRcdFx0dGhpcy5fY29tcGlsZU1hdGVyaWFsKCB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUHJlLWNvbXBpbGVzIHRoZSBlcXVpcmVjdGFuZ3VsYXIgc2hhZGVyLiBZb3UgY2FuIGdldCBmYXN0ZXIgc3RhcnQtdXAgYnkgaW52b2tpbmcgdGhpcyBtZXRob2QgZHVyaW5nXHJcblx0ICogeW91ciB0ZXh0dXJlJ3MgbmV0d29yayBmZXRjaCBmb3IgaW5jcmVhc2VkIGNvbmN1cnJlbmN5LlxyXG5cdCAqL1xyXG5cdGNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXIoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fZXF1aXJlY3RNYXRlcmlhbCA9IF9nZXRFcXVpcmVjdE1hdGVyaWFsKCk7XHJcblx0XHRcdHRoaXMuX2NvbXBpbGVNYXRlcmlhbCggdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwb3NlcyBvZiB0aGUgUE1SRU1HZW5lcmF0b3IncyBpbnRlcm5hbCBtZW1vcnkuIE5vdGUgdGhhdCBQTVJFTUdlbmVyYXRvciBpcyBhIHN0YXRpYyBjbGFzcyxcclxuXHQgKiBzbyB5b3Ugc2hvdWxkIG5vdCBuZWVkIG1vcmUgdGhhbiBvbmUgUE1SRU1HZW5lcmF0b3Igb2JqZWN0LiBJZiB5b3UgZG8sIGNhbGxpbmcgZGlzcG9zZSgpIG9uXHJcblx0ICogb25lIG9mIHRoZW0gd2lsbCBjYXVzZSBhbnkgb3RoZXJzIHRvIGFsc28gYmVjb21lIHVudXNhYmxlLlxyXG5cdCAqL1xyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5fZGlzcG9zZSgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5fY3ViZW1hcE1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5fY3ViZW1hcE1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHRcdGlmICggdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHByaXZhdGUgaW50ZXJmYWNlXHJcblxyXG5cdF9zZXRTaXplKCBjdWJlU2l6ZSApIHtcclxuXHJcblx0XHR0aGlzLl9sb2RNYXggPSBNYXRoLmZsb29yKCBNYXRoLmxvZzIoIGN1YmVTaXplICkgKTtcclxuXHRcdHRoaXMuX2N1YmVTaXplID0gTWF0aC5wb3coIDIsIHRoaXMuX2xvZE1heCApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9kaXNwb3NlKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5fYmx1ck1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ICE9PSBudWxsICkgdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9sb2RQbGFuZXNbIGkgXS5kaXNwb3NlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9jbGVhbnVwKCBvdXRwdXRUYXJnZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBfb2xkVGFyZ2V0ICk7XHJcblx0XHRvdXRwdXRUYXJnZXQuc2Npc3NvclRlc3QgPSBmYWxzZTtcclxuXHRcdF9zZXRWaWV3cG9ydCggb3V0cHV0VGFyZ2V0LCAwLCAwLCBvdXRwdXRUYXJnZXQud2lkdGgsIG91dHB1dFRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfZnJvbVRleHR1cmUoIHRleHR1cmUsIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICkge1xyXG5cclxuXHRcdFx0dGhpcy5fc2V0U2l6ZSggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDAgPyAxNiA6ICggdGV4dHVyZS5pbWFnZVsgMCBdLndpZHRoIHx8IHRleHR1cmUuaW1hZ2VbIDAgXS5pbWFnZS53aWR0aCApICk7XHJcblxyXG5cdFx0fSBlbHNlIHsgLy8gRXF1aXJlY3Rhbmd1bGFyXHJcblxyXG5cdFx0XHR0aGlzLl9zZXRTaXplKCB0ZXh0dXJlLmltYWdlLndpZHRoIC8gNCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfb2xkVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xyXG5cdFx0dGhpcy5fdGV4dHVyZVRvQ3ViZVVWKCB0ZXh0dXJlLCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcclxuXHRcdHRoaXMuX2FwcGx5UE1SRU0oIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5fY2xlYW51cCggY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRfYWxsb2NhdGVUYXJnZXRzKCkge1xyXG5cclxuXHRcdGNvbnN0IHdpZHRoID0gMyAqIE1hdGgubWF4KCB0aGlzLl9jdWJlU2l6ZSwgMTYgKiA3ICk7XHJcblx0XHRjb25zdCBoZWlnaHQgPSA0ICogdGhpcy5fY3ViZVNpemU7XHJcblxyXG5cdFx0Y29uc3QgcGFyYW1zID0ge1xyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXHJcblx0XHRcdHR5cGU6IEhhbGZGbG9hdFR5cGUsXHJcblx0XHRcdGZvcm1hdDogUkdCQUZvcm1hdCxcclxuXHRcdFx0Y29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID09PSBudWxsIHx8IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5oZWlnaHQgIT09IGhlaWdodCApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2Rpc3Bvc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgcGFyYW1zICk7XHJcblxyXG5cdFx0XHRjb25zdCB7IF9sb2RNYXggfSA9IHRoaXM7XHJcblx0XHRcdCggeyBzaXplTG9kczogdGhpcy5fc2l6ZUxvZHMsIGxvZFBsYW5lczogdGhpcy5fbG9kUGxhbmVzLCBzaWdtYXM6IHRoaXMuX3NpZ21hcyB9ID0gX2NyZWF0ZVBsYW5lcyggX2xvZE1heCApICk7XHJcblxyXG5cdFx0XHR0aGlzLl9ibHVyTWF0ZXJpYWwgPSBfZ2V0Qmx1clNoYWRlciggX2xvZE1heCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xyXG5cclxuXHR9XHJcblxyXG5cdF9jb21waWxlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGNvbnN0IHRtcE1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyAwIF0sIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLl9yZW5kZXJlci5jb21waWxlKCB0bXBNZXNoLCBfZmxhdENhbWVyYSApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9zY2VuZVRvQ3ViZVVWKCBzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgZm92ID0gOTA7XHJcblx0XHRjb25zdCBhc3BlY3QgPSAxO1xyXG5cdFx0Y29uc3QgY3ViZUNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdFx0Y29uc3QgdXBTaWduID0gWyAxLCAtIDEsIDEsIDEsIDEsIDEgXTtcclxuXHRcdGNvbnN0IGZvcndhcmRTaWduID0gWyAxLCAxLCAxLCAtIDEsIC0gMSwgLSAxIF07XHJcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdGNvbnN0IG9yaWdpbmFsQXV0b0NsZWFyID0gcmVuZGVyZXIuYXV0b0NsZWFyO1xyXG5cdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcclxuXHRcdHJlbmRlcmVyLmdldENsZWFyQ29sb3IoIF9jbGVhckNvbG9yICk7XHJcblxyXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xyXG5cdFx0cmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3QgYmFja2dyb3VuZE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7XHJcblx0XHRcdG5hbWU6ICdQTVJFTS5CYWNrZ3JvdW5kJyxcclxuXHRcdFx0c2lkZTogQmFja1NpZGUsXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlLFxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGNvbnN0IGJhY2tncm91bmRCb3ggPSBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCksIGJhY2tncm91bmRNYXRlcmlhbCApO1xyXG5cclxuXHRcdGxldCB1c2VTb2xpZENvbG9yID0gZmFsc2U7XHJcblx0XHRjb25zdCBiYWNrZ3JvdW5kID0gc2NlbmUuYmFja2dyb3VuZDtcclxuXHJcblx0XHRpZiAoIGJhY2tncm91bmQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJhY2tncm91bmQuaXNDb2xvciApIHtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoIGJhY2tncm91bmQgKTtcclxuXHRcdFx0XHRzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcclxuXHRcdFx0XHR1c2VTb2xpZENvbG9yID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoIF9jbGVhckNvbG9yICk7XHJcblx0XHRcdHVzZVNvbGlkQ29sb3IgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY29sID0gaSAlIDM7XHJcblxyXG5cdFx0XHRpZiAoIGNvbCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoIDAsIHVwU2lnblsgaSBdLCAwICk7XHJcblx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoIGZvcndhcmRTaWduWyBpIF0sIDAsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGNvbCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoIDAsIDAsIHVwU2lnblsgaSBdICk7XHJcblx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoIDAsIGZvcndhcmRTaWduWyBpIF0sIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGN1YmVDYW1lcmEudXAuc2V0KCAwLCB1cFNpZ25bIGkgXSwgMCApO1xyXG5cdFx0XHRcdGN1YmVDYW1lcmEubG9va0F0KCAwLCAwLCBmb3J3YXJkU2lnblsgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBzaXplID0gdGhpcy5fY3ViZVNpemU7XHJcblxyXG5cdFx0XHRfc2V0Vmlld3BvcnQoIGN1YmVVVlJlbmRlclRhcmdldCwgY29sICogc2l6ZSwgaSA+IDIgPyBzaXplIDogMCwgc2l6ZSwgc2l6ZSApO1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdGlmICggdXNlU29saWRDb2xvciApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIucmVuZGVyKCBiYWNrZ3JvdW5kQm94LCBjdWJlQ2FtZXJhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjdWJlQ2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJhY2tncm91bmRCb3guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0YmFja2dyb3VuZEJveC5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcclxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IG9yaWdpbmFsQXV0b0NsZWFyO1xyXG5cdFx0c2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XHJcblxyXG5cdH1cclxuXHJcblx0X3RleHR1cmVUb0N1YmVVViggdGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcblxyXG5cdFx0Y29uc3QgaXNDdWJlVGV4dHVyZSA9ICggdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgKTtcclxuXHJcblx0XHRpZiAoIGlzQ3ViZVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsID0gX2dldEN1YmVtYXBNYXRlcmlhbCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsLnVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSApID8gLSAxIDogMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID0gX2dldEVxdWlyZWN0TWF0ZXJpYWwoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBpc0N1YmVUZXh0dXJlID8gdGhpcy5fY3ViZW1hcE1hdGVyaWFsIDogdGhpcy5fZXF1aXJlY3RNYXRlcmlhbDtcclxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCggdGhpcy5fbG9kUGxhbmVzWyAwIF0sIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0Y29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcclxuXHJcblx0XHR1bmlmb3Jtc1sgJ2Vudk1hcCcgXS52YWx1ZSA9IHRleHR1cmU7XHJcblxyXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xyXG5cclxuXHRcdF9zZXRWaWV3cG9ydCggY3ViZVVWUmVuZGVyVGFyZ2V0LCAwLCAwLCAzICogc2l6ZSwgMiAqIHNpemUgKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBtZXNoLCBfZmxhdENhbWVyYSApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcclxuXHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcclxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzaWdtYSA9IE1hdGguc3FydCggdGhpcy5fc2lnbWFzWyBpIF0gKiB0aGlzLl9zaWdtYXNbIGkgXSAtIHRoaXMuX3NpZ21hc1sgaSAtIDEgXSAqIHRoaXMuX3NpZ21hc1sgaSAtIDEgXSApO1xyXG5cclxuXHRcdFx0Y29uc3QgcG9sZUF4aXMgPSBfYXhpc0RpcmVjdGlvbnNbICggaSAtIDEgKSAlIF9heGlzRGlyZWN0aW9ucy5sZW5ndGggXTtcclxuXHJcblx0XHRcdHRoaXMuX2JsdXIoIGN1YmVVVlJlbmRlclRhcmdldCwgaSAtIDEsIGksIHNpZ21hLCBwb2xlQXhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBhIHR3by1wYXNzIEdhdXNzaWFuIGJsdXIgZm9yIGEgY3ViZW1hcC4gTm9ybWFsbHkgdGhpcyBpcyBkb25lXHJcblx0ICogdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5LCBidXQgdGhpcyBicmVha3MgZG93biBvbiBhIGN1YmUuIEhlcmUgd2UgYXBwbHlcclxuXHQgKiB0aGUgYmx1ciBsYXRpdHVkaW5hbGx5IChhcm91bmQgdGhlIHBvbGVzKSwgYW5kIHRoZW4gbG9uZ2l0dWRpbmFsbHkgKHRvd2FyZHNcclxuXHQgKiB0aGUgcG9sZXMpIHRvIGFwcHJveGltYXRlIHRoZSBvcnRob2dvbmFsbHktc2VwYXJhYmxlIGJsdXIuIEl0IGlzIGxlYXN0XHJcblx0ICogYWNjdXJhdGUgYXQgdGhlIHBvbGVzLCBidXQgc3RpbGwgZG9lcyBhIGRlY2VudCBqb2IuXHJcblx0ICovXHJcblx0X2JsdXIoIGN1YmVVVlJlbmRlclRhcmdldCwgbG9kSW4sIGxvZE91dCwgc2lnbWEsIHBvbGVBeGlzICkge1xyXG5cclxuXHRcdGNvbnN0IHBpbmdQb25nUmVuZGVyVGFyZ2V0ID0gdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0dGhpcy5faGFsZkJsdXIoXHJcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcclxuXHRcdFx0cGluZ1BvbmdSZW5kZXJUYXJnZXQsXHJcblx0XHRcdGxvZEluLFxyXG5cdFx0XHRsb2RPdXQsXHJcblx0XHRcdHNpZ21hLFxyXG5cdFx0XHQnbGF0aXR1ZGluYWwnLFxyXG5cdFx0XHRwb2xlQXhpcyApO1xyXG5cclxuXHRcdHRoaXMuX2hhbGZCbHVyKFxyXG5cdFx0XHRwaW5nUG9uZ1JlbmRlclRhcmdldCxcclxuXHRcdFx0Y3ViZVVWUmVuZGVyVGFyZ2V0LFxyXG5cdFx0XHRsb2RPdXQsXHJcblx0XHRcdGxvZE91dCxcclxuXHRcdFx0c2lnbWEsXHJcblx0XHRcdCdsb25naXR1ZGluYWwnLFxyXG5cdFx0XHRwb2xlQXhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9oYWxmQmx1ciggdGFyZ2V0SW4sIHRhcmdldE91dCwgbG9kSW4sIGxvZE91dCwgc2lnbWFSYWRpYW5zLCBkaXJlY3Rpb24sIHBvbGVBeGlzICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcblx0XHRjb25zdCBibHVyTWF0ZXJpYWwgPSB0aGlzLl9ibHVyTWF0ZXJpYWw7XHJcblxyXG5cdFx0aWYgKCBkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoXHJcblx0XHRcdFx0J2JsdXIgZGlyZWN0aW9uIG11c3QgYmUgZWl0aGVyIGxhdGl0dWRpbmFsIG9yIGxvbmdpdHVkaW5hbCEnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIGF0IHdoaWNoIHRvIGN1dCBvZmYgdGhlIGRpc2NyZXRlIGFwcHJveGltYXRpb24uXHJcblx0XHRjb25zdCBTVEFOREFSRF9ERVZJQVRJT05TID0gMztcclxuXHJcblx0XHRjb25zdCBibHVyTWVzaCA9IG5ldyBNZXNoKCB0aGlzLl9sb2RQbGFuZXNbIGxvZE91dCBdLCBibHVyTWF0ZXJpYWwgKTtcclxuXHRcdGNvbnN0IGJsdXJVbmlmb3JtcyA9IGJsdXJNYXRlcmlhbC51bmlmb3JtcztcclxuXHJcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLl9zaXplTG9kc1sgbG9kSW4gXSAtIDE7XHJcblx0XHRjb25zdCByYWRpYW5zUGVyUGl4ZWwgPSBpc0Zpbml0ZSggc2lnbWFSYWRpYW5zICkgPyBNYXRoLlBJIC8gKCAyICogcGl4ZWxzICkgOiAyICogTWF0aC5QSSAvICggMiAqIE1BWF9TQU1QTEVTIC0gMSApO1xyXG5cdFx0Y29uc3Qgc2lnbWFQaXhlbHMgPSBzaWdtYVJhZGlhbnMgLyByYWRpYW5zUGVyUGl4ZWw7XHJcblx0XHRjb25zdCBzYW1wbGVzID0gaXNGaW5pdGUoIHNpZ21hUmFkaWFucyApID8gMSArIE1hdGguZmxvb3IoIFNUQU5EQVJEX0RFVklBVElPTlMgKiBzaWdtYVBpeGVscyApIDogTUFYX1NBTVBMRVM7XHJcblxyXG5cdFx0aWYgKCBzYW1wbGVzID4gTUFYX1NBTVBMRVMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oIGBzaWdtYVJhZGlhbnMsICR7XHJcblx0XHRcdFx0c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke1xyXG5cdFx0XHRcdHNhbXBsZXN9IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHtNQVhfU0FNUExFU31gICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHdlaWdodHMgPSBbXTtcclxuXHRcdGxldCBzdW0gPSAwO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IE1BWF9TQU1QTEVTOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeCA9IGkgLyBzaWdtYVBpeGVscztcclxuXHRcdFx0Y29uc3Qgd2VpZ2h0ID0gTWF0aC5leHAoIC0geCAqIHggLyAyICk7XHJcblx0XHRcdHdlaWdodHMucHVzaCggd2VpZ2h0ICk7XHJcblxyXG5cdFx0XHRpZiAoIGkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHN1bSArPSB3ZWlnaHQ7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBpIDwgc2FtcGxlcyApIHtcclxuXHJcblx0XHRcdFx0c3VtICs9IDIgKiB3ZWlnaHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0d2VpZ2h0c1sgaSBdID0gd2VpZ2h0c1sgaSBdIC8gc3VtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRibHVyVW5pZm9ybXNbICdlbnZNYXAnIF0udmFsdWUgPSB0YXJnZXRJbi50ZXh0dXJlO1xyXG5cdFx0Ymx1clVuaWZvcm1zWyAnc2FtcGxlcycgXS52YWx1ZSA9IHNhbXBsZXM7XHJcblx0XHRibHVyVW5pZm9ybXNbICd3ZWlnaHRzJyBdLnZhbHVlID0gd2VpZ2h0cztcclxuXHRcdGJsdXJVbmlmb3Jtc1sgJ2xhdGl0dWRpbmFsJyBdLnZhbHVlID0gZGlyZWN0aW9uID09PSAnbGF0aXR1ZGluYWwnO1xyXG5cclxuXHRcdGlmICggcG9sZUF4aXMgKSB7XHJcblxyXG5cdFx0XHRibHVyVW5pZm9ybXNbICdwb2xlQXhpcycgXS52YWx1ZSA9IHBvbGVBeGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB7IF9sb2RNYXggfSA9IHRoaXM7XHJcblx0XHRibHVyVW5pZm9ybXNbICdkVGhldGEnIF0udmFsdWUgPSByYWRpYW5zUGVyUGl4ZWw7XHJcblx0XHRibHVyVW5pZm9ybXNbICdtaXBJbnQnIF0udmFsdWUgPSBfbG9kTWF4IC0gbG9kSW47XHJcblxyXG5cdFx0Y29uc3Qgb3V0cHV0U2l6ZSA9IHRoaXMuX3NpemVMb2RzWyBsb2RPdXQgXTtcclxuXHRcdGNvbnN0IHggPSAzICogb3V0cHV0U2l6ZSAqICggbG9kT3V0ID4gX2xvZE1heCAtIExPRF9NSU4gPyBsb2RPdXQgLSBfbG9kTWF4ICsgTE9EX01JTiA6IDAgKTtcclxuXHRcdGNvbnN0IHkgPSA0ICogKCB0aGlzLl9jdWJlU2l6ZSAtIG91dHB1dFNpemUgKTtcclxuXHJcblx0XHRfc2V0Vmlld3BvcnQoIHRhcmdldE91dCwgeCwgeSwgMyAqIG91dHB1dFNpemUsIDIgKiBvdXRwdXRTaXplICk7XHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHRhcmdldE91dCApO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBibHVyTWVzaCwgX2ZsYXRDYW1lcmEgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlUGxhbmVzKCBsb2RNYXggKSB7XHJcblxyXG5cdGNvbnN0IGxvZFBsYW5lcyA9IFtdO1xyXG5cdGNvbnN0IHNpemVMb2RzID0gW107XHJcblx0Y29uc3Qgc2lnbWFzID0gW107XHJcblxyXG5cdGxldCBsb2QgPSBsb2RNYXg7XHJcblxyXG5cdGNvbnN0IHRvdGFsTG9kcyA9IGxvZE1heCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdG90YWxMb2RzOyBpICsrICkge1xyXG5cclxuXHRcdGNvbnN0IHNpemVMb2QgPSBNYXRoLnBvdyggMiwgbG9kICk7XHJcblx0XHRzaXplTG9kcy5wdXNoKCBzaXplTG9kICk7XHJcblx0XHRsZXQgc2lnbWEgPSAxLjAgLyBzaXplTG9kO1xyXG5cclxuXHRcdGlmICggaSA+IGxvZE1heCAtIExPRF9NSU4gKSB7XHJcblxyXG5cdFx0XHRzaWdtYSA9IEVYVFJBX0xPRF9TSUdNQVsgaSAtIGxvZE1heCArIExPRF9NSU4gLSAxIF07XHJcblxyXG5cdFx0fSBlbHNlIGlmICggaSA9PT0gMCApIHtcclxuXHJcblx0XHRcdHNpZ21hID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2lnbWFzLnB1c2goIHNpZ21hICk7XHJcblxyXG5cdFx0Y29uc3QgdGV4ZWxTaXplID0gMS4wIC8gKCBzaXplTG9kIC0gMiApO1xyXG5cdFx0Y29uc3QgbWluID0gLSB0ZXhlbFNpemU7XHJcblx0XHRjb25zdCBtYXggPSAxICsgdGV4ZWxTaXplO1xyXG5cdFx0Y29uc3QgdXYxID0gWyBtaW4sIG1pbiwgbWF4LCBtaW4sIG1heCwgbWF4LCBtaW4sIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWF4IF07XHJcblxyXG5cdFx0Y29uc3QgY3ViZUZhY2VzID0gNjtcclxuXHRcdGNvbnN0IHZlcnRpY2VzID0gNjtcclxuXHRcdGNvbnN0IHBvc2l0aW9uU2l6ZSA9IDM7XHJcblx0XHRjb25zdCB1dlNpemUgPSAyO1xyXG5cdFx0Y29uc3QgZmFjZUluZGV4U2l6ZSA9IDE7XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvblNpemUgKiB2ZXJ0aWNlcyAqIGN1YmVGYWNlcyApO1xyXG5cdFx0Y29uc3QgdXYgPSBuZXcgRmxvYXQzMkFycmF5KCB1dlNpemUgKiB2ZXJ0aWNlcyAqIGN1YmVGYWNlcyApO1xyXG5cdFx0Y29uc3QgZmFjZUluZGV4ID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGZhY2UgPSAwOyBmYWNlIDwgY3ViZUZhY2VzOyBmYWNlICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeCA9ICggZmFjZSAlIDMgKSAqIDIgLyAzIC0gMTtcclxuXHRcdFx0Y29uc3QgeSA9IGZhY2UgPiAyID8gMCA6IC0gMTtcclxuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZXMgPSBbXHJcblx0XHRcdFx0eCwgeSwgMCxcclxuXHRcdFx0XHR4ICsgMiAvIDMsIHksIDAsXHJcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcclxuXHRcdFx0XHR4LCB5LCAwLFxyXG5cdFx0XHRcdHggKyAyIC8gMywgeSArIDEsIDAsXHJcblx0XHRcdFx0eCwgeSArIDEsIDBcclxuXHRcdFx0XTtcclxuXHRcdFx0cG9zaXRpb24uc2V0KCBjb29yZGluYXRlcywgcG9zaXRpb25TaXplICogdmVydGljZXMgKiBmYWNlICk7XHJcblx0XHRcdHV2LnNldCggdXYxLCB1dlNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UgKTtcclxuXHRcdFx0Y29uc3QgZmlsbCA9IFsgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSBdO1xyXG5cdFx0XHRmYWNlSW5kZXguc2V0KCBmaWxsLCBmYWNlSW5kZXhTaXplICogdmVydGljZXMgKiBmYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBsYW5lcyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0cGxhbmVzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIHBvc2l0aW9uU2l6ZSApICk7XHJcblx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1diwgdXZTaXplICkgKTtcclxuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICdmYWNlSW5kZXgnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBmYWNlSW5kZXgsIGZhY2VJbmRleFNpemUgKSApO1xyXG5cdFx0bG9kUGxhbmVzLnB1c2goIHBsYW5lcyApO1xyXG5cclxuXHRcdGlmICggbG9kID4gTE9EX01JTiApIHtcclxuXHJcblx0XHRcdGxvZCAtLTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHsgbG9kUGxhbmVzLCBzaXplTG9kcywgc2lnbWFzIH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKSB7XHJcblxyXG5cdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgcGFyYW1zICk7XHJcblx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xyXG5cdGN1YmVVVlJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSAnUE1SRU0uY3ViZVV2JztcclxuXHRjdWJlVVZSZW5kZXJUYXJnZXQuc2Npc3NvclRlc3QgPSB0cnVlO1xyXG5cdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfc2V0Vmlld3BvcnQoIHRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0dGFyZ2V0LnZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xyXG5cdHRhcmdldC5zY2lzc29yLnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gX2dldEJsdXJTaGFkZXIoIGxvZE1heCwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0Y29uc3Qgd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoIE1BWF9TQU1QTEVTICk7XHJcblx0Y29uc3QgcG9sZUF4aXMgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cdGNvbnN0IHNoYWRlck1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XHJcblxyXG5cdFx0bmFtZTogJ1NwaGVyaWNhbEdhdXNzaWFuQmx1cicsXHJcblxyXG5cdFx0ZGVmaW5lczoge1xyXG5cdFx0XHQnbic6IE1BWF9TQU1QTEVTLFxyXG5cdFx0XHQnQ1VCRVVWX1RFWEVMX1dJRFRIJzogMS4wIC8gd2lkdGgsXHJcblx0XHRcdCdDVUJFVVZfVEVYRUxfSEVJR0hUJzogMS4wIC8gaGVpZ2h0LFxyXG5cdFx0XHQnQ1VCRVVWX01BWF9NSVAnOiBgJHtsb2RNYXh9LjBgLFxyXG5cdFx0fSxcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cdFx0XHQnZW52TWFwJzogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHQnc2FtcGxlcyc6IHsgdmFsdWU6IDEgfSxcclxuXHRcdFx0J3dlaWdodHMnOiB7IHZhbHVlOiB3ZWlnaHRzIH0sXHJcblx0XHRcdCdsYXRpdHVkaW5hbCc6IHsgdmFsdWU6IGZhbHNlIH0sXHJcblx0XHRcdCdkVGhldGEnOiB7IHZhbHVlOiAwIH0sXHJcblx0XHRcdCdtaXBJbnQnOiB7IHZhbHVlOiAwIH0sXHJcblx0XHRcdCdwb2xlQXhpcyc6IHsgdmFsdWU6IHBvbGVBeGlzIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi9gXHJcblxyXG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xyXG5cclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XHJcblxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XHJcblx0XHRcdHVuaWZvcm0gaW50IHNhbXBsZXM7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgd2VpZ2h0c1sgbiBdO1xyXG5cdFx0XHR1bmlmb3JtIGJvb2wgbGF0aXR1ZGluYWw7XHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgZFRoZXRhO1xyXG5cdFx0XHR1bmlmb3JtIGZsb2F0IG1pcEludDtcclxuXHRcdFx0dW5pZm9ybSB2ZWMzIHBvbGVBeGlzO1xyXG5cclxuXHRcdFx0I2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXHJcblx0XHRcdCNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XHJcblxyXG5cdFx0XHR2ZWMzIGdldFNhbXBsZSggZmxvYXQgdGhldGEsIHZlYzMgYXhpcyApIHtcclxuXHJcblx0XHRcdFx0ZmxvYXQgY29zVGhldGEgPSBjb3MoIHRoZXRhICk7XHJcblx0XHRcdFx0Ly8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uXHJcblx0XHRcdFx0dmVjMyBzYW1wbGVEaXJlY3Rpb24gPSB2T3V0cHV0RGlyZWN0aW9uICogY29zVGhldGFcclxuXHRcdFx0XHRcdCsgY3Jvc3MoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqIHNpbiggdGhldGEgKVxyXG5cdFx0XHRcdFx0KyBheGlzICogZG90KCBheGlzLCB2T3V0cHV0RGlyZWN0aW9uICkgKiAoIDEuMCAtIGNvc1RoZXRhICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXJlY3Rpb24sIG1pcEludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cclxuXHRcdFx0XHR2ZWMzIGF4aXMgPSBsYXRpdHVkaW5hbCA/IHBvbGVBeGlzIDogY3Jvc3MoIHBvbGVBeGlzLCB2T3V0cHV0RGlyZWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdGlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkge1xyXG5cclxuXHRcdFx0XHRcdGF4aXMgPSB2ZWMzKCB2T3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgLSB2T3V0cHV0RGlyZWN0aW9uLnggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRheGlzID0gbm9ybWFsaXplKCBheGlzICk7XHJcblxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggaW50IGkgPSAxOyBpIDwgbjsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggaSA+PSBzYW1wbGVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZsb2F0IHRoZXRhID0gZFRoZXRhICogZmxvYXQoIGkgKTtcclxuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCAtMS4wICogdGhldGEsIGF4aXMgKTtcclxuXHRcdFx0XHRcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgaSBdICogZ2V0U2FtcGxlKCB0aGV0YSwgYXhpcyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblx0XHRgLFxyXG5cclxuXHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxyXG5cdFx0ZGVwdGhUZXN0OiBmYWxzZSxcclxuXHRcdGRlcHRoV3JpdGU6IGZhbHNlXHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHNoYWRlck1hdGVyaWFsO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gX2dldEVxdWlyZWN0TWF0ZXJpYWwoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcclxuXHJcblx0XHRuYW1lOiAnRXF1aXJlY3Rhbmd1bGFyVG9DdWJlVVYnLFxyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblx0XHRcdCdlbnZNYXAnOiB7IHZhbHVlOiBudWxsIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IC8qIGdsc2wgKi9gXHJcblxyXG5cdFx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xyXG5cclxuXHRcdFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XHJcblxyXG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XHJcblxyXG5cdFx0XHQjaW5jbHVkZSA8Y29tbW9uPlxyXG5cclxuXHRcdFx0dm9pZCBtYWluKCkge1xyXG5cclxuXHRcdFx0XHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xyXG5cdFx0XHRcdHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBvdXRwdXREaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEICggZW52TWFwLCB1diApLnJnYiwgMS4wICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHRgLFxyXG5cclxuXHRcdGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxyXG5cdFx0ZGVwdGhUZXN0OiBmYWxzZSxcclxuXHRcdGRlcHRoV3JpdGU6IGZhbHNlXHJcblxyXG5cdH0gKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9nZXRDdWJlbWFwTWF0ZXJpYWwoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcclxuXHJcblx0XHRuYW1lOiAnQ3ViZW1hcFRvQ3ViZVVWJyxcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cdFx0XHQnZW52TWFwJzogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHQnZmxpcEVudk1hcCc6IHsgdmFsdWU6IC0gMSB9XHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogX2dldENvbW1vblZlcnRleFNoYWRlcigpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovYFxyXG5cclxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGludDtcclxuXHJcblx0XHRcdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcclxuXHJcblx0XHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xyXG5cclxuXHRcdFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XHJcblxyXG5cdFx0XHR2b2lkIG1haW4oKSB7XHJcblxyXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiB2T3V0cHV0RGlyZWN0aW9uLngsIHZPdXRwdXREaXJlY3Rpb24ueXogKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0YCxcclxuXHJcblx0XHRibGVuZGluZzogTm9CbGVuZGluZyxcclxuXHRcdGRlcHRoVGVzdDogZmFsc2UsXHJcblx0XHRkZXB0aFdyaXRlOiBmYWxzZVxyXG5cclxuXHR9ICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCkge1xyXG5cclxuXHRyZXR1cm4gLyogZ2xzbCAqL2BcclxuXHJcblx0XHRwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHRcdHByZWNpc2lvbiBtZWRpdW1wIGludDtcclxuXHJcblx0XHRhdHRyaWJ1dGUgZmxvYXQgZmFjZUluZGV4O1xyXG5cclxuXHRcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xyXG5cclxuXHRcdC8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb25cclxuXHRcdHZlYzMgZ2V0RGlyZWN0aW9uKCB2ZWMyIHV2LCBmbG9hdCBmYWNlICkge1xyXG5cclxuXHRcdFx0dXYgPSAyLjAgKiB1diAtIDEuMDtcclxuXHJcblx0XHRcdHZlYzMgZGlyZWN0aW9uID0gdmVjMyggdXYsIDEuMCApO1xyXG5cclxuXHRcdFx0aWYgKCBmYWNlID09IDAuMCApIHtcclxuXHJcblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDsgLy8gKCAxLCB2LCB1ICkgcG9zIHhcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkge1xyXG5cclxuXHRcdFx0XHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24ueHp5O1xyXG5cdFx0XHRcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC11LCAxLCAtdiApIHBvcyB5XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHtcclxuXHJcblx0XHRcdFx0ZGlyZWN0aW9uLnggKj0gLTEuMDsgLy8gKCAtdSwgdiwgMSApIHBvcyB6XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcclxuXHJcblx0XHRcdFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnp5eDtcclxuXHRcdFx0XHRkaXJlY3Rpb24ueHogKj0gLTEuMDsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeFxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7XHJcblxyXG5cdFx0XHRcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XHJcblx0XHRcdFx0ZGlyZWN0aW9uLnh5ICo9IC0xLjA7IC8vICggLXUsIC0xLCB2ICkgbmVnIHlcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNS4wICkge1xyXG5cclxuXHRcdFx0XHRkaXJlY3Rpb24ueiAqPSAtMS4wOyAvLyAoIHUsIHYsIC0xICkgbmVnIHpcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkaXJlY3Rpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHJcblx0XHRcdHZPdXRwdXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2LCBmYWNlSW5kZXggKTtcclxuXHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cdGA7XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBQTVJFTUdlbmVyYXRvciB9O1xyXG4iLCJpbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmVSZWZyYWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgUE1SRU1HZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9leHRyYXMvUE1SRU1HZW5lcmF0b3IuanMnO1xyXG5cclxuZnVuY3Rpb24gV2ViR0xDdWJlVVZNYXBzKCByZW5kZXJlciApIHtcclxuXHJcblx0bGV0IGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRsZXQgcG1yZW1HZW5lcmF0b3IgPSBudWxsO1xyXG5cclxuXHRmdW5jdGlvbiBnZXQoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcclxuXHJcblx0XHRcdGNvbnN0IGlzRXF1aXJlY3RNYXAgPSAoIG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nICk7XHJcblx0XHRcdGNvbnN0IGlzQ3ViZU1hcCA9ICggbWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZyApO1xyXG5cclxuXHRcdFx0Ly8gZXF1aXJlY3QvY3ViZSBtYXAgdG8gY3ViZVVWIGNvbnZlcnNpb25cclxuXHJcblx0XHRcdGlmICggaXNFcXVpcmVjdE1hcCB8fCBpc0N1YmVNYXAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgJiYgdGV4dHVyZS5uZWVkc1BNUkVNVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNQTVJFTVVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdGxldCByZW5kZXJUYXJnZXQgPSBjdWJlVVZtYXBzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggcG1yZW1HZW5lcmF0b3IgPT09IG51bGwgKSBwbXJlbUdlbmVyYXRvciA9IG5ldyBQTVJFTUdlbmVyYXRvciggcmVuZGVyZXIgKTtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQgPSBpc0VxdWlyZWN0TWFwID8gcG1yZW1HZW5lcmF0b3IuZnJvbUVxdWlyZWN0YW5ndWxhciggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICkgOiBwbXJlbUdlbmVyYXRvci5mcm9tQ3ViZW1hcCggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdFx0XHRjdWJlVVZtYXBzLnNldCggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlbmRlclRhcmdldC50ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3ViZVVWbWFwcy5oYXMoIHRleHR1cmUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBjdWJlVVZtYXBzLmdldCggdGV4dHVyZSApLnRleHR1cmU7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGltYWdlID0gdGV4dHVyZS5pbWFnZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggKCBpc0VxdWlyZWN0TWFwICYmIGltYWdlICYmIGltYWdlLmhlaWdodCA+IDAgKSB8fCAoIGlzQ3ViZU1hcCAmJiBpbWFnZSAmJiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoIGltYWdlICkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBwbXJlbUdlbmVyYXRvciA9PT0gbnVsbCApIHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKCByZW5kZXJlciApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBpc0VxdWlyZWN0TWFwID8gcG1yZW1HZW5lcmF0b3IuZnJvbUVxdWlyZWN0YW5ndWxhciggdGV4dHVyZSApIDogcG1yZW1HZW5lcmF0b3IuZnJvbUN1YmVtYXAoIHRleHR1cmUgKTtcclxuXHRcdFx0XHRcdFx0XHRjdWJlVVZtYXBzLnNldCggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGltYWdlIG5vdCB5ZXQgcmVhZHkuIHRyeSB0aGUgY29udmVyc2lvbiBuZXh0IGZyYW1lXHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoIGltYWdlICkge1xyXG5cclxuXHRcdGxldCBjb3VudCA9IDA7XHJcblx0XHRjb25zdCBsZW5ndGggPSA2O1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggaW1hZ2VbIGkgXSAhPT0gdW5kZWZpbmVkICkgY291bnQgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb3VudCA9PT0gbGVuZ3RoO1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0Y29uc3QgY3ViZW1hcFVWID0gY3ViZVVWbWFwcy5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIGN1YmVtYXBVViAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y3ViZVVWbWFwcy5kZWxldGUoIHRleHR1cmUgKTtcclxuXHRcdFx0Y3ViZW1hcFVWLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuXHJcblx0XHRjdWJlVVZtYXBzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHRpZiAoIHBtcmVtR2VuZXJhdG9yICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cG1yZW1HZW5lcmF0b3IuZGlzcG9zZSgpO1xyXG5cdFx0XHRwbXJlbUdlbmVyYXRvciA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRnZXQ6IGdldCxcclxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2VcclxuXHR9O1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgV2ViR0xDdWJlVVZNYXBzIH07XHJcbiIsImZ1bmN0aW9uIFdlYkdMRXh0ZW5zaW9ucyggZ2wgKSB7XHJcblxyXG5cdGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKCBuYW1lICkge1xyXG5cclxuXHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZXh0ZW5zaW9uO1xyXG5cclxuXHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcclxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9kZXB0aF90ZXh0dXJlJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcclxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xyXG5cclxuXHRcdHJldHVybiBleHRlbnNpb247XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHRoYXM6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBnZXRFeHRlbnNpb24oIG5hbWUgKSAhPT0gbnVsbDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGluaXQ6IGZ1bmN0aW9uICggY2FwYWJpbGl0aWVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgKSB7XHJcblxyXG5cdFx0XHRcdGdldEV4dGVuc2lvbiggJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnZXRFeHRlbnNpb24oICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xyXG5cdFx0XHRcdGdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdFx0XHRcdGdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XHJcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XHJcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cdFx0XHRcdGdldEV4dGVuc2lvbiggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICk7XHJcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCAnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnICk7XHJcblx0XHRcdFx0Z2V0RXh0ZW5zaW9uKCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcclxuXHRcdFx0Z2V0RXh0ZW5zaW9uKCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApO1xyXG5cdFx0XHRnZXRFeHRlbnNpb24oICdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGdldEV4dGVuc2lvbiggbmFtZSApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTEV4dGVuc2lvbnMgfTtcclxuIiwiaW1wb3J0IHsgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IGFycmF5TmVlZHNVaW50MzIgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XHJcblxyXG5mdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoIGdsLCBhdHRyaWJ1dGVzLCBpbmZvLCBiaW5kaW5nU3RhdGVzICkge1xyXG5cclxuXHRjb25zdCBnZW9tZXRyaWVzID0ge307XHJcblx0Y29uc3Qgd2lyZWZyYW1lQXR0cmlidXRlcyA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGdlb21ldHJ5LmluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhcnJheSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGFycmF5WyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHR3aXJlZnJhbWVBdHRyaWJ1dGVzLmRlbGV0ZSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YmluZGluZ1N0YXRlcy5yZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXQoIG9iamVjdCwgZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID09PSB0cnVlICkgcmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcblx0XHRnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gdHJ1ZTtcclxuXHJcblx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGUoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Ly8gVXBkYXRpbmcgaW5kZXggYnVmZmVyIGluIFZBTyBub3cuIFNlZSBXZWJHTEJpbmRpbmdTdGF0ZXMuXHJcblxyXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb3JwaCB0YXJnZXRzXHJcblxyXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0gW107XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0Y29uc3QgZ2VvbWV0cnlQb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRsZXQgdmVyc2lvbiA9IDA7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xyXG5cdFx0XHR2ZXJzaW9uID0gZ2VvbWV0cnlJbmRleC52ZXJzaW9uO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhID0gYXJyYXlbIGkgKyAwIF07XHJcblx0XHRcdFx0Y29uc3QgYiA9IGFycmF5WyBpICsgMSBdO1xyXG5cdFx0XHRcdGNvbnN0IGMgPSBhcnJheVsgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IGFycmF5ID0gZ2VvbWV0cnlQb3NpdGlvbi5hcnJheTtcclxuXHRcdFx0dmVyc2lvbiA9IGdlb21ldHJ5UG9zaXRpb24udmVyc2lvbjtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYSA9IGkgKyAwO1xyXG5cdFx0XHRcdGNvbnN0IGIgPSBpICsgMTtcclxuXHRcdFx0XHRjb25zdCBjID0gaSArIDI7XHJcblxyXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhdHRyaWJ1dGUgPSBuZXcgKCBhcnJheU5lZWRzVWludDMyKCBpbmRpY2VzICkgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApO1xyXG5cdFx0YXR0cmlidXRlLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG5cclxuXHRcdC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzXHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBwcmV2aW91c0F0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdGlmICggcHJldmlvdXNBdHRyaWJ1dGUgKSBhdHRyaWJ1dGVzLnJlbW92ZSggcHJldmlvdXNBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHdpcmVmcmFtZUF0dHJpYnV0ZXMuc2V0KCBnZW9tZXRyeSwgYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRjb25zdCBjdXJyZW50QXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50QXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0aGUgYXR0cmlidXRlIGlzIG9ic29sZXRlLCBjcmVhdGUgYSBuZXcgb25lXHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudEF0dHJpYnV0ZS52ZXJzaW9uIDwgZ2VvbWV0cnlJbmRleC52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0XHRcdHVwZGF0ZVdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR1cGRhdGVXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB3aXJlZnJhbWVBdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGdldDogZ2V0LFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblxyXG5cdFx0Z2V0V2lyZWZyYW1lQXR0cmlidXRlOiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGVcclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTEdlb21ldHJpZXMgfTtcclxuIiwiZnVuY3Rpb24gV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG5cdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xyXG5cclxuXHRsZXQgbW9kZTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0bW9kZSA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGxldCB0eXBlLCBieXRlc1BlckVsZW1lbnQ7XHJcblxyXG5cdGZ1bmN0aW9uIHNldEluZGV4KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0eXBlID0gdmFsdWUudHlwZTtcclxuXHRcdGJ5dGVzUGVyRWxlbWVudCA9IHZhbHVlLmJ5dGVzUGVyRWxlbWVudDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHRnbC5kcmF3RWxlbWVudHMoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIGJ5dGVzUGVyRWxlbWVudCApO1xyXG5cclxuXHRcdGluZm8udXBkYXRlKCBjb3VudCwgbW9kZSwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggc3RhcnQsIGNvdW50LCBwcmltY291bnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwcmltY291bnQgPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0bGV0IGV4dGVuc2lvbiwgbWV0aG9kTmFtZTtcclxuXHJcblx0XHRpZiAoIGlzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZ2w7XHJcblx0XHRcdG1ldGhvZE5hbWUgPSAnZHJhd0VsZW1lbnRzSW5zdGFuY2VkJztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cdFx0XHRtZXRob2ROYW1lID0gJ2RyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFJztcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGV4dGVuc2lvblsgbWV0aG9kTmFtZSBdKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQsIHByaW1jb3VudCApO1xyXG5cclxuXHRcdGluZm8udXBkYXRlKCBjb3VudCwgbW9kZSwgcHJpbWNvdW50ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcclxuXHR0aGlzLnNldEluZGV4ID0gc2V0SW5kZXg7XHJcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIgfTtcclxuIiwiZnVuY3Rpb24gV2ViR0xJbmZvKCBnbCApIHtcclxuXHJcblx0Y29uc3QgbWVtb3J5ID0ge1xyXG5cdFx0Z2VvbWV0cmllczogMCxcclxuXHRcdHRleHR1cmVzOiAwXHJcblx0fTtcclxuXHJcblx0Y29uc3QgcmVuZGVyID0ge1xyXG5cdFx0ZnJhbWU6IDAsXHJcblx0XHRjYWxsczogMCxcclxuXHRcdHRyaWFuZ2xlczogMCxcclxuXHRcdHBvaW50czogMCxcclxuXHRcdGxpbmVzOiAwXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKCBjb3VudCwgbW9kZSwgaW5zdGFuY2VDb3VudCApIHtcclxuXHJcblx0XHRyZW5kZXIuY2FsbHMgKys7XHJcblxyXG5cdFx0c3dpdGNoICggbW9kZSApIHtcclxuXHJcblx0XHRcdGNhc2UgZ2wuVFJJQU5HTEVTOlxyXG5cdFx0XHRcdHJlbmRlci50cmlhbmdsZXMgKz0gaW5zdGFuY2VDb3VudCAqICggY291bnQgLyAzICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIGdsLkxJTkVTOlxyXG5cdFx0XHRcdHJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogKCBjb3VudCAvIDIgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgZ2wuTElORV9TVFJJUDpcclxuXHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqICggY291bnQgLSAxICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIGdsLkxJTkVfTE9PUDpcclxuXHRcdFx0XHRyZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIGNvdW50O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBnbC5QT0lOVFM6XHJcblx0XHRcdFx0cmVuZGVyLnBvaW50cyArPSBpbnN0YW5jZUNvdW50ICogY291bnQ7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEluZm86IFVua25vd24gZHJhdyBtb2RlOicsIG1vZGUgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVzZXQoKSB7XHJcblxyXG5cdFx0cmVuZGVyLmNhbGxzID0gMDtcclxuXHRcdHJlbmRlci50cmlhbmdsZXMgPSAwO1xyXG5cdFx0cmVuZGVyLnBvaW50cyA9IDA7XHJcblx0XHRyZW5kZXIubGluZXMgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRtZW1vcnk6IG1lbW9yeSxcclxuXHRcdHJlbmRlcjogcmVuZGVyLFxyXG5cdFx0cHJvZ3JhbXM6IG51bGwsXHJcblx0XHRhdXRvUmVzZXQ6IHRydWUsXHJcblx0XHRyZXNldDogcmVzZXQsXHJcblx0XHR1cGRhdGU6IHVwZGF0ZVxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xJbmZvIH07XHJcbiIsImltcG9ydCB7IEZsb2F0VHlwZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IERhdGFBcnJheVRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9EYXRhQXJyYXlUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuZnVuY3Rpb24gbnVtZXJpY2FsU29ydCggYSwgYiApIHtcclxuXHJcblx0cmV0dXJuIGFbIDAgXSAtIGJbIDAgXTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFic051bWVyaWNhbFNvcnQoIGEsIGIgKSB7XHJcblxyXG5cdHJldHVybiBNYXRoLmFicyggYlsgMSBdICkgLSBNYXRoLmFicyggYVsgMSBdICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBXZWJHTE1vcnBodGFyZ2V0cyggZ2wsIGNhcGFiaWxpdGllcywgdGV4dHVyZXMgKSB7XHJcblxyXG5cdGNvbnN0IGluZmx1ZW5jZXNMaXN0ID0ge307XHJcblx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xyXG5cdGNvbnN0IG1vcnBoVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cdGNvbnN0IG1vcnBoID0gbmV3IFZlY3RvcjQoKTtcclxuXHJcblx0Y29uc3Qgd29ya0luZmx1ZW5jZXMgPSBbXTtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgODsgaSArKyApIHtcclxuXHJcblx0XHR3b3JrSW5mbHVlbmNlc1sgaSBdID0gWyBpLCAwIF07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtICkge1xyXG5cclxuXHRcdGNvbnN0IG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuXHRcdGlmICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB1c2luZyBhdHRyaWJ1dGVzLCB0aGUgV2ViR0wgMiBjb2RlIHBhdGggZW5jb2RlcyBtb3JwaCB0YXJnZXRzXHJcblx0XHRcdC8vIGludG8gYW4gYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcy4gRWFjaCBsYXllciByZXByZXNlbnRzIGEgc2luZ2xlIG1vcnBoIHRhcmdldC5cclxuXHJcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xyXG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHNDb3VudCA9ICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApID8gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoIDogMDtcclxuXHJcblx0XHRcdGxldCBlbnRyeSA9IG1vcnBoVGV4dHVyZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0aWYgKCBlbnRyeSA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5LmNvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBlbnRyeSAhPT0gdW5kZWZpbmVkICkgZW50cnkudGV4dHVyZS5kaXNwb3NlKCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGhhc01vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRjb25zdCBoYXNNb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0Y29uc3QgaGFzTW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IFtdO1xyXG5cdFx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgW107XHJcblx0XHRcdFx0Y29uc3QgbW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgfHwgW107XHJcblxyXG5cdFx0XHRcdGxldCB2ZXJ0ZXhEYXRhQ291bnQgPSAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gPT09IHRydWUgKSB2ZXJ0ZXhEYXRhQ291bnQgPSAxO1xyXG5cdFx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWxzID09PSB0cnVlICkgdmVydGV4RGF0YUNvdW50ID0gMjtcclxuXHRcdFx0XHRpZiAoIGhhc01vcnBoQ29sb3JzID09PSB0cnVlICkgdmVydGV4RGF0YUNvdW50ID0gMztcclxuXHJcblx0XHRcdFx0bGV0IHdpZHRoID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIHZlcnRleERhdGFDb3VudDtcclxuXHRcdFx0XHRsZXQgaGVpZ2h0ID0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCB3aWR0aCA+IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApIHtcclxuXHJcblx0XHRcdFx0XHRoZWlnaHQgPSBNYXRoLmNlaWwoIHdpZHRoIC8gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XHJcblx0XHRcdFx0XHR3aWR0aCA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCB3aWR0aCAqIGhlaWdodCAqIDQgKiBtb3JwaFRhcmdldHNDb3VudCApO1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUoIGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgbW9ycGhUYXJnZXRzQ291bnQgKTtcclxuXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBGbG9hdFR5cGU7XHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdC8vIGZpbGwgYnVmZmVyXHJcblxyXG5cdFx0XHRcdGNvbnN0IHZlcnRleERhdGFTdHJpZGUgPSB2ZXJ0ZXhEYXRhQ291bnQgKiA0O1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGkgXTtcclxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQ29sb3IgPSBtb3JwaENvbG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IHdpZHRoICogaGVpZ2h0ICogNCAqIGk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbW9ycGhUYXJnZXQuY291bnQ7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBzdHJpZGUgPSBqICogdmVydGV4RGF0YVN0cmlkZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bW9ycGguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhUYXJnZXQsIGogKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAwIF0gPSBtb3JwaC54O1xyXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMSBdID0gbW9ycGgueTtcclxuXHRcdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDIgXSA9IG1vcnBoLno7XHJcblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAzIF0gPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1vcnBoLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoTm9ybWFsLCBqICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNCBdID0gbW9ycGgueDtcclxuXHRcdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDUgXSA9IG1vcnBoLnk7XHJcblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA2IF0gPSBtb3JwaC56O1xyXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNyBdID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggaGFzTW9ycGhDb2xvcnMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1vcnBoLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQ29sb3IsIGogKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA4IF0gPSBtb3JwaC54O1xyXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgOSBdID0gbW9ycGgueTtcclxuXHRcdFx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDEwIF0gPSBtb3JwaC56O1xyXG5cdFx0XHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMTEgXSA9ICggbW9ycGhDb2xvci5pdGVtU2l6ZSA9PT0gNCApID8gbW9ycGgudyA6IDE7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVudHJ5ID0ge1xyXG5cdFx0XHRcdFx0Y291bnQ6IG1vcnBoVGFyZ2V0c0NvdW50LFxyXG5cdFx0XHRcdFx0dGV4dHVyZTogdGV4dHVyZSxcclxuXHRcdFx0XHRcdHNpemU6IG5ldyBWZWN0b3IyKCB3aWR0aCwgaGVpZ2h0IClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRtb3JwaFRleHR1cmVzLnNldCggZ2VvbWV0cnksIGVudHJ5ICk7XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIGRpc3Bvc2VUZXh0dXJlKCkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZGlzcG9zZSgpO1xyXG5cclxuXHRcdFx0XHRcdG1vcnBoVGV4dHVyZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgZGlzcG9zZVRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2VUZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0bGV0IG1vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzU3VtICs9IG9iamVjdEluZmx1ZW5jZXNbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1vcnBoQmFzZUluZmx1ZW5jZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID8gMSA6IDEgLSBtb3JwaEluZmx1ZW5jZXNTdW07XHJcblxyXG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlJywgbW9ycGhCYXNlSW5mbHVlbmNlICk7XHJcblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCBvYmplY3RJbmZsdWVuY2VzICk7XHJcblxyXG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRzVGV4dHVyZScsIGVudHJ5LnRleHR1cmUsIHRleHR1cmVzICk7XHJcblx0XHRcdHByb2dyYW0uZ2V0VW5pZm9ybXMoKS5zZXRWYWx1ZSggZ2wsICdtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZScsIGVudHJ5LnNpemUgKTtcclxuXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIFdoZW4gb2JqZWN0IGRvZXNuJ3QgaGF2ZSBtb3JwaCB0YXJnZXQgaW5mbHVlbmNlcyBkZWZpbmVkLCB3ZSB0cmVhdCBpdCBhcyBhIDAtbGVuZ3RoIGFycmF5XHJcblx0XHRcdC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIG1ha2Ugc3VyZSB3ZSBzZXQgdXAgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlIC8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzXHJcblxyXG5cdFx0XHRjb25zdCBsZW5ndGggPSBvYmplY3RJbmZsdWVuY2VzID09PSB1bmRlZmluZWQgPyAwIDogb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRsZXQgaW5mbHVlbmNlcyA9IGluZmx1ZW5jZXNMaXN0WyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBpbmZsdWVuY2VzID09PSB1bmRlZmluZWQgfHwgaW5mbHVlbmNlcy5sZW5ndGggIT09IGxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0Ly8gaW5pdGlhbGlzZSBsaXN0XHJcblxyXG5cdFx0XHRcdGluZmx1ZW5jZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGluZmx1ZW5jZXNbIGkgXSA9IFsgaSwgMCBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGluZmx1ZW5jZXNMaXN0WyBnZW9tZXRyeS5pZCBdID0gaW5mbHVlbmNlcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENvbGxlY3QgaW5mbHVlbmNlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGluZmx1ZW5jZVsgMCBdID0gaTtcclxuXHRcdFx0XHRpbmZsdWVuY2VbIDEgXSA9IG9iamVjdEluZmx1ZW5jZXNbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGluZmx1ZW5jZXMuc29ydCggYWJzTnVtZXJpY2FsU29ydCApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgODsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpIDwgbGVuZ3RoICYmIGluZmx1ZW5jZXNbIGkgXVsgMSBdICkge1xyXG5cclxuXHRcdFx0XHRcdHdvcmtJbmZsdWVuY2VzWyBpIF1bIDAgXSA9IGluZmx1ZW5jZXNbIGkgXVsgMCBdO1xyXG5cdFx0XHRcdFx0d29ya0luZmx1ZW5jZXNbIGkgXVsgMSBdID0gaW5mbHVlbmNlc1sgaSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0d29ya0luZmx1ZW5jZXNbIGkgXVsgMCBdID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcblx0XHRcdFx0XHR3b3JrSW5mbHVlbmNlc1sgaSBdWyAxIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3b3JrSW5mbHVlbmNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XHJcblxyXG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XHJcblxyXG5cdFx0XHRsZXQgbW9ycGhJbmZsdWVuY2VzU3VtID0gMDtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGluZmx1ZW5jZSA9IHdvcmtJbmZsdWVuY2VzWyBpIF07XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpbmZsdWVuY2VbIDAgXTtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGluZmx1ZW5jZVsgMSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICkgIT09IG1vcnBoVGFyZ2V0c1sgaW5kZXggXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoVGFyZ2V0c1sgaW5kZXggXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIG1vcnBoTm9ybWFscyAmJiBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICkgIT09IG1vcnBoTm9ybWFsc1sgaW5kZXggXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoTm9ybWFsc1sgaW5kZXggXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzU3VtICs9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGkgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtb3JwaE5vcm1hbHMgJiYgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEdMU0wgc2hhZGVyIHVzZXMgZm9ybXVsYSBiYXNlaW5mbHVlbmNlICogYmFzZSArIHN1bSh0YXJnZXQgKiBpbmZsdWVuY2UpXHJcblx0XHRcdC8vIFRoaXMgYWxsb3dzIHVzIHRvIHN3aXRjaCBiZXR3ZWVuIGFic29sdXRlIG1vcnBocyBhbmQgcmVsYXRpdmUgbW9ycGhzIHdpdGhvdXQgY2hhbmdpbmcgc2hhZGVyIGNvZGVcclxuXHRcdFx0Ly8gV2hlbiBiYXNlaW5mbHVlbmNlID0gMSAtIHN1bShpbmZsdWVuY2UpLCB0aGUgYWJvdmUgaXMgZXF1aXZhbGVudCB0byBzdW0oKHRhcmdldCAtIGJhc2UpICogaW5mbHVlbmNlKVxyXG5cdFx0XHRjb25zdCBtb3JwaEJhc2VJbmZsdWVuY2UgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA/IDEgOiAxIC0gbW9ycGhJbmZsdWVuY2VzU3VtO1xyXG5cclxuXHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKCBnbCwgJ21vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZScsIG1vcnBoQmFzZUluZmx1ZW5jZSApO1xyXG5cdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgbW9ycGhJbmZsdWVuY2VzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblxyXG5cdFx0dXBkYXRlOiB1cGRhdGVcclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTE1vcnBodGFyZ2V0cyB9O1xyXG4iLCJmdW5jdGlvbiBXZWJHTE9iamVjdHMoIGdsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvICkge1xyXG5cclxuXHRsZXQgdXBkYXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHRcdGNvbnN0IGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCwgZ2VvbWV0cnkgKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgb25jZSBwZXIgZnJhbWVcclxuXHJcblx0XHRpZiAoIHVwZGF0ZU1hcC5nZXQoIGJ1ZmZlcmdlb21ldHJ5ICkgIT09IGZyYW1lICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cmllcy51cGRhdGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHR1cGRhdGVNYXAuc2V0KCBidWZmZXJnZW9tZXRyeSwgZnJhbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuaGFzRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZU1hcC5nZXQoIG9iamVjdCApICE9PSBmcmFtZSApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlcy51cGRhdGUoIG9iamVjdC5pbnN0YW5jZU1hdHJpeCwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlcy51cGRhdGUoIG9iamVjdC5pbnN0YW5jZUNvbG9yLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1cGRhdGVNYXAuc2V0KCBvYmplY3QsIGZyYW1lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcclxuXHJcblx0XHRcdGlmICggdXBkYXRlTWFwLmdldCggc2tlbGV0b24gKSAhPT0gZnJhbWUgKSB7XHJcblxyXG5cdFx0XHRcdHNrZWxldG9uLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHR1cGRhdGVNYXAuc2V0KCBza2VsZXRvbiwgZnJhbWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dXBkYXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCBpbnN0YW5jZWRNZXNoID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdGluc3RhbmNlZE1lc2gucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlICk7XHJcblxyXG5cdFx0YXR0cmlidXRlcy5yZW1vdmUoIGluc3RhbmNlZE1lc2guaW5zdGFuY2VNYXRyaXggKTtcclxuXHJcblx0XHRpZiAoIGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIGF0dHJpYnV0ZXMucmVtb3ZlKCBpbnN0YW5jZWRNZXNoLmluc3RhbmNlQ29sb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHVwZGF0ZTogdXBkYXRlLFxyXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFdlYkdMT2JqZWN0cyB9O1xyXG4iLCIvKipcclxuICogVW5pZm9ybXMgb2YgYSBwcm9ncmFtLlxyXG4gKiBUaG9zZSBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUgd2l0aCBhIHNwZWNpYWwgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgdGhlIHJvb3QsXHJcbiAqIHdoaWNoIHlvdSBnZXQgYnkgY2FsbGluZyAnbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtICknLlxyXG4gKlxyXG4gKlxyXG4gKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcclxuICpcclxuICogLnNlcSAtIGFycmF5IG9mIG5lc3RlZCB1bmlmb3Jtc1xyXG4gKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcclxuICpcclxuICpcclxuICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxyXG4gKlxyXG4gKiAuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgW3RleHR1cmVzXSApXHJcbiAqXHJcbiAqIFx0XHR1cGxvYWRzIGEgdW5pZm9ybSB2YWx1ZShzKVxyXG4gKiAgXHR0aGUgJ3RleHR1cmVzJyBwYXJhbWV0ZXIgaXMgbmVlZGVkIGZvciBzYW1wbGVyIHVuaWZvcm1zXHJcbiAqXHJcbiAqXHJcbiAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyICh0ZXh0dXJlcyBmYWN0b3JpemF0aW9ucyk6XHJcbiAqXHJcbiAqIC51cGxvYWQoIGdsLCBzZXEsIHZhbHVlcywgdGV4dHVyZXMgKVxyXG4gKlxyXG4gKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcclxuICpcclxuICogLnNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSA6IGZpbHRlcmVkU2VxXHJcbiAqXHJcbiAqIFx0XHRmaWx0ZXJzICdzZXEnIGVudHJpZXMgd2l0aCBjb3JyZXNwb25kaW5nIGVudHJ5IGluIHZhbHVlc1xyXG4gKlxyXG4gKlxyXG4gKiBNZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyICh0ZXh0dXJlcyBmYWN0b3JpemF0aW9ucyk6XHJcbiAqXHJcbiAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlLCB0ZXh0dXJlcyApXHJcbiAqXHJcbiAqIFx0XHRzZXRzIHVuaWZvcm0gd2l0aCAgbmFtZSAnbmFtZScgdG8gJ3ZhbHVlJ1xyXG4gKlxyXG4gKiAuc2V0T3B0aW9uYWwoIGdsLCBvYmosIHByb3AgKVxyXG4gKlxyXG4gKiBcdFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQ3ViZVRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9UZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgRGF0YUFycmF5VGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0RhdGFBcnJheVRleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBEYXRhM0RUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRGF0YTNEVGV4dHVyZS5qcyc7XHJcblxyXG5jb25zdCBlbXB0eVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5ldyBUZXh0dXJlKCk7XHJcbmNvbnN0IGVtcHR5QXJyYXlUZXh0dXJlID0gLypAX19QVVJFX18qLyBuZXcgRGF0YUFycmF5VGV4dHVyZSgpO1xyXG5jb25zdCBlbXB0eTNkVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IERhdGEzRFRleHR1cmUoKTtcclxuY29uc3QgZW1wdHlDdWJlVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmVUZXh0dXJlKCk7XHJcblxyXG4vLyAtLS0gVXRpbGl0aWVzIC0tLVxyXG5cclxuLy8gQXJyYXkgQ2FjaGVzIChwcm92aWRlIHR5cGVkIGFycmF5cyBmb3IgdGVtcG9yYXJ5IGJ5IHNpemUpXHJcblxyXG5jb25zdCBhcnJheUNhY2hlRjMyID0gW107XHJcbmNvbnN0IGFycmF5Q2FjaGVJMzIgPSBbXTtcclxuXHJcbi8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xyXG5cclxuY29uc3QgbWF0NGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcclxuY29uc3QgbWF0M2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xyXG5jb25zdCBtYXQyYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICk7XHJcblxyXG4vLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcclxuXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oIGFycmF5LCBuQmxvY2tzLCBibG9ja1NpemUgKSB7XHJcblxyXG5cdGNvbnN0IGZpcnN0RWxlbSA9IGFycmF5WyAwIF07XHJcblxyXG5cdGlmICggZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCApIHJldHVybiBhcnJheTtcclxuXHQvLyB1bm9wdGltaXplZDogISBpc05hTiggZmlyc3RFbGVtIClcclxuXHQvLyBzZWUgaHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy85ODNcclxuXHJcblx0Y29uc3QgbiA9IG5CbG9ja3MgKiBibG9ja1NpemU7XHJcblx0bGV0IHIgPSBhcnJheUNhY2hlRjMyWyBuIF07XHJcblxyXG5cdGlmICggciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHIgPSBuZXcgRmxvYXQzMkFycmF5KCBuICk7XHJcblx0XHRhcnJheUNhY2hlRjMyWyBuIF0gPSByO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbkJsb2NrcyAhPT0gMCApIHtcclxuXHJcblx0XHRmaXJzdEVsZW0udG9BcnJheSggciwgMCApO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMSwgb2Zmc2V0ID0gMDsgaSAhPT0gbkJsb2NrczsgKysgaSApIHtcclxuXHJcblx0XHRcdG9mZnNldCArPSBibG9ja1NpemU7XHJcblx0XHRcdGFycmF5WyBpIF0udG9BcnJheSggciwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiByO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoIGEsIGIgKSB7XHJcblxyXG5cdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0aWYgKCBhWyBpIF0gIT09IGJbIGkgXSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlBcnJheSggYSwgYiApIHtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdGFbIGkgXSA9IGJbIGkgXTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cclxuXHJcbmZ1bmN0aW9uIGFsbG9jVGV4VW5pdHMoIHRleHR1cmVzLCBuICkge1xyXG5cclxuXHRsZXQgciA9IGFycmF5Q2FjaGVJMzJbIG4gXTtcclxuXHJcblx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0ciA9IG5ldyBJbnQzMkFycmF5KCBuICk7XHJcblx0XHRhcnJheUNhY2hlSTMyWyBuIF0gPSByO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRyWyBpIF0gPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHI7XHJcblxyXG59XHJcblxyXG4vLyAtLS0gU2V0dGVycyAtLS1cclxuXHJcbi8vIE5vdGU6IERlZmluaW5nIHRoZXNlIG1ldGhvZHMgZXh0ZXJuYWxseSwgYmVjYXVzZSB0aGV5IGNvbWUgaW4gYSBidW5jaFxyXG4vLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxyXG5cclxuLy8gU2luZ2xlIHNjYWxhclxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWMWYoIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGlmICggY2FjaGVbIDAgXSA9PT0gdiApIHJldHVybjtcclxuXHJcblx0Z2wudW5pZm9ybTFmKCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0Y2FjaGVbIDAgXSA9IHY7XHJcblxyXG59XHJcblxyXG4vLyBTaW5nbGUgZmxvYXQgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuVmVjdG9yTilcclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjJmKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSApIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0yZiggdGhpcy5hZGRyLCB2LngsIHYueSApO1xyXG5cclxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcclxuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcclxuXHJcblx0XHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjNmKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogKSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiApO1xyXG5cclxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcclxuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcclxuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoIHYuciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi5yIHx8IGNhY2hlWyAxIF0gIT09IHYuZyB8fCBjYWNoZVsgMiBdICE9PSB2LmIgKSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi5yLCB2LmcsIHYuYiApO1xyXG5cclxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYucjtcclxuXHRcdFx0Y2FjaGVbIDEgXSA9IHYuZztcclxuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuYjtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcclxuXHJcblx0XHRnbC51bmlmb3JtM2Z2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjRmKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogfHwgY2FjaGVbIDMgXSAhPT0gdi53ICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTRmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xyXG5cclxuXHRcdFx0Y2FjaGVbIDAgXSA9IHYueDtcclxuXHRcdFx0Y2FjaGVbIDEgXSA9IHYueTtcclxuXHRcdFx0Y2FjaGVbIDIgXSA9IHYuejtcclxuXHRcdFx0Y2FjaGVbIDMgXSA9IHYudztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcclxuXHJcblx0XHRnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8vIFNpbmdsZSBtYXRyaXggKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5NYXRyaXhOKVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVNMiggZ2wsIHYgKSB7XHJcblxyXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcclxuXHRjb25zdCBlbGVtZW50cyA9IHYuZWxlbWVudHM7XHJcblxyXG5cdGlmICggZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xyXG5cclxuXHRcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB2ICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIGVsZW1lbnRzICkgKSByZXR1cm47XHJcblxyXG5cdFx0bWF0MmFycmF5LnNldCggZWxlbWVudHMgKTtcclxuXHJcblx0XHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBtYXQyYXJyYXkgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCBlbGVtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZU0zKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cdGNvbnN0IGVsZW1lbnRzID0gdi5lbGVtZW50cztcclxuXHJcblx0aWYgKCBlbGVtZW50cyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgZWxlbWVudHMgKSApIHJldHVybjtcclxuXHJcblx0XHRtYXQzYXJyYXkuc2V0KCBlbGVtZW50cyApO1xyXG5cclxuXHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIGVsZW1lbnRzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlTTQoIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblx0Y29uc3QgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xyXG5cclxuXHRpZiAoIGVsZW1lbnRzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggY2FjaGUsIHYgKSApIHJldHVybjtcclxuXHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2ICk7XHJcblxyXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdiApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCBlbGVtZW50cyApICkgcmV0dXJuO1xyXG5cclxuXHRcdG1hdDRhcnJheS5zZXQoIGVsZW1lbnRzICk7XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5ICk7XHJcblxyXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgZWxlbWVudHMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gU2luZ2xlIGludGVnZXIgLyBib29sZWFuXHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZVYxaSggZ2wsIHYgKSB7XHJcblxyXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcclxuXHJcblx0aWYgKCBjYWNoZVsgMCBdID09PSB2ICkgcmV0dXJuO1xyXG5cclxuXHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRjYWNoZVsgMCBdID0gdjtcclxuXHJcbn1cclxuXHJcbi8vIFNpbmdsZSBpbnRlZ2VyIC8gYm9vbGVhbiB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWMmkoIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55ICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTJpKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XHJcblxyXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xyXG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xyXG5cclxuXHRcdGdsLnVuaWZvcm0yaXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWM2koIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55IHx8IGNhY2hlWyAyIF0gIT09IHYueiApIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0zaSggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56ICk7XHJcblxyXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xyXG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xyXG5cdFx0XHRjYWNoZVsgMiBdID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xyXG5cclxuXHRcdGdsLnVuaWZvcm0zaXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWNGkoIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjYWNoZVsgMCBdICE9PSB2LnggfHwgY2FjaGVbIDEgXSAhPT0gdi55IHx8IGNhY2hlWyAyIF0gIT09IHYueiB8fCBjYWNoZVsgMyBdICE9PSB2LncgKSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtNGkoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53ICk7XHJcblxyXG5cdFx0XHRjYWNoZVsgMCBdID0gdi54O1xyXG5cdFx0XHRjYWNoZVsgMSBdID0gdi55O1xyXG5cdFx0XHRjYWNoZVsgMiBdID0gdi56O1xyXG5cdFx0XHRjYWNoZVsgMyBdID0gdi53O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRpZiAoIGFycmF5c0VxdWFsKCBjYWNoZSwgdiApICkgcmV0dXJuO1xyXG5cclxuXHRcdGdsLnVuaWZvcm00aXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gU2luZ2xlIHVuc2lnbmVkIGludGVnZXJcclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjF1aSggZ2wsIHYgKSB7XHJcblxyXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcclxuXHJcblx0aWYgKCBjYWNoZVsgMCBdID09PSB2ICkgcmV0dXJuO1xyXG5cclxuXHRnbC51bmlmb3JtMXVpKCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0Y2FjaGVbIDAgXSA9IHY7XHJcblxyXG59XHJcblxyXG4vLyBTaW5nbGUgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWMnVpKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSApIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0ydWkoIHRoaXMuYWRkciwgdi54LCB2LnkgKTtcclxuXHJcblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XHJcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XHJcblxyXG5cdFx0Z2wudW5pZm9ybTJ1aXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWM3VpKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogKSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtM3VpKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcclxuXHJcblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XHJcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XHJcblx0XHRcdGNhY2hlWyAyIF0gPSB2Lno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XHJcblxyXG5cdFx0Z2wudW5pZm9ybTN1aXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWNHVpKCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggY2FjaGVbIDAgXSAhPT0gdi54IHx8IGNhY2hlWyAxIF0gIT09IHYueSB8fCBjYWNoZVsgMiBdICE9PSB2LnogfHwgY2FjaGVbIDMgXSAhPT0gdi53ICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTR1aSggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56LCB2LncgKTtcclxuXHJcblx0XHRcdGNhY2hlWyAwIF0gPSB2Lng7XHJcblx0XHRcdGNhY2hlWyAxIF0gPSB2Lnk7XHJcblx0XHRcdGNhY2hlWyAyIF0gPSB2Lno7XHJcblx0XHRcdGNhY2hlWyAzIF0gPSB2Lnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGlmICggYXJyYXlzRXF1YWwoIGNhY2hlLCB2ICkgKSByZXR1cm47XHJcblxyXG5cdFx0Z2wudW5pZm9ybTR1aXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdGNvcHlBcnJheSggY2FjaGUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbi8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZVQxKCBnbCwgdiwgdGV4dHVyZXMgKSB7XHJcblxyXG5cdGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZTtcclxuXHRjb25zdCB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xyXG5cclxuXHRpZiAoIGNhY2hlWyAwIF0gIT09IHVuaXQgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcclxuXHRcdGNhY2hlWyAwIF0gPSB1bml0O1xyXG5cclxuXHR9XHJcblxyXG5cdHRleHR1cmVzLnNldFRleHR1cmUyRCggdiB8fCBlbXB0eVRleHR1cmUsIHVuaXQgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVDNEMSggZ2wsIHYsIHRleHR1cmVzICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblx0Y29uc3QgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcclxuXHJcblx0aWYgKCBjYWNoZVsgMCBdICE9PSB1bml0ICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XHJcblx0XHRjYWNoZVsgMCBdID0gdW5pdDtcclxuXHJcblx0fVxyXG5cclxuXHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoIHYgfHwgZW1wdHkzZFRleHR1cmUsIHVuaXQgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVDYoIGdsLCB2LCB0ZXh0dXJlcyApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cdGNvbnN0IHVuaXQgPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XHJcblxyXG5cdGlmICggY2FjaGVbIDAgXSAhPT0gdW5pdCApIHtcclxuXHJcblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xyXG5cdFx0Y2FjaGVbIDAgXSA9IHVuaXQ7XHJcblxyXG5cdH1cclxuXHJcblx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUoIHYgfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdCApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVUMkRBcnJheTEoIGdsLCB2LCB0ZXh0dXJlcyApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cdGNvbnN0IHVuaXQgPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XHJcblxyXG5cdGlmICggY2FjaGVbIDAgXSAhPT0gdW5pdCApIHtcclxuXHJcblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xyXG5cdFx0Y2FjaGVbIDAgXSA9IHVuaXQ7XHJcblxyXG5cdH1cclxuXHJcblx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkoIHYgfHwgZW1wdHlBcnJheVRleHR1cmUsIHVuaXQgKTtcclxuXHJcbn1cclxuXHJcbi8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXHJcblxyXG5mdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlciggdHlwZSApIHtcclxuXHJcblx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlVjFmOyAvLyBGTE9BVFxyXG5cdFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZVYyZjsgLy8gX1ZFQzJcclxuXHRcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWVWM2Y7IC8vIF9WRUMzXHJcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRmOyAvLyBfVkVDNFxyXG5cclxuXHRcdGNhc2UgMHg4YjVhOiByZXR1cm4gc2V0VmFsdWVNMjsgLy8gX01BVDJcclxuXHRcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWVNMzsgLy8gX01BVDNcclxuXHRcdGNhc2UgMHg4YjVjOiByZXR1cm4gc2V0VmFsdWVNNDsgLy8gX01BVDRcclxuXHJcblx0XHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZVYxaTsgLy8gSU5ULCBCT09MXHJcblx0XHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZVYyaTsgLy8gX1ZFQzJcclxuXHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlVjNpOyAvLyBfVkVDM1xyXG5cdFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWVWNGk7IC8vIF9WRUM0XHJcblxyXG5cdFx0Y2FzZSAweDE0MDU6IHJldHVybiBzZXRWYWx1ZVYxdWk7IC8vIFVJTlRcclxuXHRcdGNhc2UgMHg4ZGM2OiByZXR1cm4gc2V0VmFsdWVWMnVpOyAvLyBfVkVDMlxyXG5cdFx0Y2FzZSAweDhkYzc6IHJldHVybiBzZXRWYWx1ZVYzdWk7IC8vIF9WRUMzXHJcblx0XHRjYXNlIDB4OGRjODogcmV0dXJuIHNldFZhbHVlVjR1aTsgLy8gX1ZFQzRcclxuXHJcblx0XHRjYXNlIDB4OGI1ZTogLy8gU0FNUExFUl8yRFxyXG5cdFx0Y2FzZSAweDhkNjY6IC8vIFNBTVBMRVJfRVhURVJOQUxfT0VTXHJcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcclxuXHRcdGNhc2UgMHg4ZGQyOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8yRFxyXG5cdFx0Y2FzZSAweDhiNjI6IC8vIFNBTVBMRVJfMkRfU0hBRE9XXHJcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQxO1xyXG5cclxuXHRcdGNhc2UgMHg4YjVmOiAvLyBTQU1QTEVSXzNEXHJcblx0XHRjYXNlIDB4OGRjYjogLy8gSU5UX1NBTVBMRVJfM0RcclxuXHRcdGNhc2UgMHg4ZGQzOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8zRFxyXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUM0QxO1xyXG5cclxuXHRcdGNhc2UgMHg4YjYwOiAvLyBTQU1QTEVSX0NVQkVcclxuXHRcdGNhc2UgMHg4ZGNjOiAvLyBJTlRfU0FNUExFUl9DVUJFXHJcblx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxyXG5cdFx0Y2FzZSAweDhkYzU6IC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcclxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDY7XHJcblxyXG5cdFx0Y2FzZSAweDhkYzE6IC8vIFNBTVBMRVJfMkRfQVJSQVlcclxuXHRcdGNhc2UgMHg4ZGNmOiAvLyBJTlRfU0FNUExFUl8yRF9BUlJBWVxyXG5cdFx0Y2FzZSAweDhkZDc6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEX0FSUkFZXHJcblx0XHRjYXNlIDB4OGRjNDogLy8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcclxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDJEQXJyYXkxO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuLy8gQXJyYXkgb2Ygc2NhbGFyc1xyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWMWZBcnJheSggZ2wsIHYgKSB7XHJcblxyXG5cdGdsLnVuaWZvcm0xZnYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxufVxyXG5cclxuLy8gQXJyYXkgb2YgdmVjdG9ycyAoZnJvbSBmbGF0IGFycmF5IG9yIGFycmF5IG9mIFRIUkVFLlZlY3Rvck4pXHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZVYyZkFycmF5KCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApO1xyXG5cclxuXHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIGRhdGEgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjNmQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBkYXRhID0gZmxhdHRlbiggdiwgdGhpcy5zaXplLCAzICk7XHJcblxyXG5cdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgZGF0YSApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWNGZBcnJheSggZ2wsIHYgKSB7XHJcblxyXG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKTtcclxuXHJcblx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBkYXRhICk7XHJcblxyXG59XHJcblxyXG4vLyBBcnJheSBvZiBtYXRyaWNlcyAoZnJvbSBmbGF0IGFycmF5IG9yIGFycmF5IG9mIFRIUkVFLk1hdHJpeE4pXHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZU0yQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRjb25zdCBkYXRhID0gZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICk7XHJcblxyXG5cdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIGRhdGEgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlTTNBcnJheSggZ2wsIHYgKSB7XHJcblxyXG5cdGNvbnN0IGRhdGEgPSBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDkgKTtcclxuXHJcblx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgZGF0YSApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVNNEFycmF5KCBnbCwgdiApIHtcclxuXHJcblx0Y29uc3QgZGF0YSA9IGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMTYgKTtcclxuXHJcblx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgZGF0YSApO1xyXG5cclxufVxyXG5cclxuLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW5cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjFpQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcbn1cclxuXHJcbi8vIEFycmF5IG9mIGludGVnZXIgLyBib29sZWFuIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSlcclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjJpQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRnbC51bmlmb3JtMml2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjNpQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRnbC51bmlmb3JtM2l2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjRpQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcbn1cclxuXHJcbi8vIEFycmF5IG9mIHVuc2lnbmVkIGludGVnZXJcclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjF1aUFycmF5KCBnbCwgdiApIHtcclxuXHJcblx0Z2wudW5pZm9ybTF1aXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxufVxyXG5cclxuLy8gQXJyYXkgb2YgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3JzIChmcm9tIGZsYXQgYXJyYXkpXHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZVYydWlBcnJheSggZ2wsIHYgKSB7XHJcblxyXG5cdGdsLnVuaWZvcm0ydWl2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVjN1aUFycmF5KCBnbCwgdiApIHtcclxuXHJcblx0Z2wudW5pZm9ybTN1aXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVWNHVpQXJyYXkoIGdsLCB2ICkge1xyXG5cclxuXHRnbC51bmlmb3JtNHVpdiggdGhpcy5hZGRyLCB2ICk7XHJcblxyXG59XHJcblxyXG5cclxuLy8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gM0QgLyBDdWJlIC8gMkRBcnJheSlcclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVDFBcnJheSggZ2wsIHYsIHRleHR1cmVzICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcclxuXHJcblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKCB0ZXh0dXJlcywgbiApO1xyXG5cclxuXHRpZiAoICEgYXJyYXlzRXF1YWwoIGNhY2hlLCB1bml0cyApICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB1bml0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHZbIGkgXSB8fCBlbXB0eVRleHR1cmUsIHVuaXRzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0VmFsdWVUM0RBcnJheSggZ2wsIHYsIHRleHR1cmVzICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcclxuXHJcblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKCB0ZXh0dXJlcywgbiApO1xyXG5cclxuXHRpZiAoICEgYXJyYXlzRXF1YWwoIGNhY2hlLCB1bml0cyApICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB1bml0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoIHZbIGkgXSB8fCBlbXB0eTNkVGV4dHVyZSwgdW5pdHNbIGkgXSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRWYWx1ZVQ2QXJyYXkoIGdsLCB2LCB0ZXh0dXJlcyApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cclxuXHRjb25zdCBuID0gdi5sZW5ndGg7XHJcblxyXG5cdGNvbnN0IHVuaXRzID0gYWxsb2NUZXhVbml0cyggdGV4dHVyZXMsIG4gKTtcclxuXHJcblx0aWYgKCAhIGFycmF5c0VxdWFsKCBjYWNoZSwgdW5pdHMgKSApIHtcclxuXHJcblx0XHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XHJcblxyXG5cdFx0Y29weUFycmF5KCBjYWNoZSwgdW5pdHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUoIHZbIGkgXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1sgaSBdICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFZhbHVlVDJEQXJyYXlBcnJheSggZ2wsIHYsIHRleHR1cmVzICkge1xyXG5cclxuXHRjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdGNvbnN0IG4gPSB2Lmxlbmd0aDtcclxuXHJcblx0Y29uc3QgdW5pdHMgPSBhbGxvY1RleFVuaXRzKCB0ZXh0dXJlcywgbiApO1xyXG5cclxuXHRpZiAoICEgYXJyYXlzRXF1YWwoIGNhY2hlLCB1bml0cyApICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcclxuXHJcblx0XHRjb3B5QXJyYXkoIGNhY2hlLCB1bml0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggdlsgaSBdIHx8IGVtcHR5QXJyYXlUZXh0dXJlLCB1bml0c1sgaSBdICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG4vLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciBhIHB1cmUgKGJvdHRvbS1sZXZlbCkgYXJyYXlcclxuXHJcbmZ1bmN0aW9uIGdldFB1cmVBcnJheVNldHRlciggdHlwZSApIHtcclxuXHJcblx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlVjFmQXJyYXk7IC8vIEZMT0FUXHJcblx0XHRjYXNlIDB4OGI1MDogcmV0dXJuIHNldFZhbHVlVjJmQXJyYXk7IC8vIF9WRUMyXHJcblx0XHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlVjNmQXJyYXk7IC8vIF9WRUMzXHJcblx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRmQXJyYXk7IC8vIF9WRUM0XHJcblxyXG5cdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZU0yQXJyYXk7IC8vIF9NQVQyXHJcblx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlTTNBcnJheTsgLy8gX01BVDNcclxuXHRcdGNhc2UgMHg4YjVjOiByZXR1cm4gc2V0VmFsdWVNNEFycmF5OyAvLyBfTUFUNFxyXG5cclxuXHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlVjFpQXJyYXk7IC8vIElOVCwgQk9PTFxyXG5cdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWVWMmlBcnJheTsgLy8gX1ZFQzJcclxuXHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlVjNpQXJyYXk7IC8vIF9WRUMzXHJcblx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZVY0aUFycmF5OyAvLyBfVkVDNFxyXG5cclxuXHRcdGNhc2UgMHgxNDA1OiByZXR1cm4gc2V0VmFsdWVWMXVpQXJyYXk7IC8vIFVJTlRcclxuXHRcdGNhc2UgMHg4ZGM2OiByZXR1cm4gc2V0VmFsdWVWMnVpQXJyYXk7IC8vIF9WRUMyXHJcblx0XHRjYXNlIDB4OGRjNzogcmV0dXJuIHNldFZhbHVlVjN1aUFycmF5OyAvLyBfVkVDM1xyXG5cdFx0Y2FzZSAweDhkYzg6IHJldHVybiBzZXRWYWx1ZVY0dWlBcnJheTsgLy8gX1ZFQzRcclxuXHJcblx0XHRjYXNlIDB4OGI1ZTogLy8gU0FNUExFUl8yRFxyXG5cdFx0Y2FzZSAweDhkNjY6IC8vIFNBTVBMRVJfRVhURVJOQUxfT0VTXHJcblx0XHRjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcclxuXHRcdGNhc2UgMHg4ZGQyOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8yRFxyXG5cdFx0Y2FzZSAweDhiNjI6IC8vIFNBTVBMRVJfMkRfU0hBRE9XXHJcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQxQXJyYXk7XHJcblxyXG5cdFx0Y2FzZSAweDhiNWY6IC8vIFNBTVBMRVJfM0RcclxuXHRcdGNhc2UgMHg4ZGNiOiAvLyBJTlRfU0FNUExFUl8zRFxyXG5cdFx0Y2FzZSAweDhkZDM6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzNEXHJcblx0XHRcdHJldHVybiBzZXRWYWx1ZVQzREFycmF5O1xyXG5cclxuXHRcdGNhc2UgMHg4YjYwOiAvLyBTQU1QTEVSX0NVQkVcclxuXHRcdGNhc2UgMHg4ZGNjOiAvLyBJTlRfU0FNUExFUl9DVUJFXHJcblx0XHRjYXNlIDB4OGRkNDogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfQ1VCRVxyXG5cdFx0Y2FzZSAweDhkYzU6IC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcclxuXHRcdFx0cmV0dXJuIHNldFZhbHVlVDZBcnJheTtcclxuXHJcblx0XHRjYXNlIDB4OGRjMTogLy8gU0FNUExFUl8yRF9BUlJBWVxyXG5cdFx0Y2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXHJcblx0XHRjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcclxuXHRcdGNhc2UgMHg4ZGM0OiAvLyBTQU1QTEVSXzJEX0FSUkFZX1NIQURPV1xyXG5cdFx0XHRyZXR1cm4gc2V0VmFsdWVUMkRBcnJheUFycmF5O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vLyAtLS0gVW5pZm9ybSBDbGFzc2VzIC0tLVxyXG5cclxuY2xhc3MgU2luZ2xlVW5pZm9ybSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcclxuXHJcblx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHR0aGlzLmFkZHIgPSBhZGRyO1xyXG5cdFx0dGhpcy5jYWNoZSA9IFtdO1xyXG5cdFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcclxuXHJcblx0XHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFB1cmVBcnJheVVuaWZvcm0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0dGhpcy5hZGRyID0gYWRkcjtcclxuXHRcdHRoaXMuY2FjaGUgPSBbXTtcclxuXHRcdHRoaXMuc2l6ZSA9IGFjdGl2ZUluZm8uc2l6ZTtcclxuXHRcdHRoaXMuc2V0VmFsdWUgPSBnZXRQdXJlQXJyYXlTZXR0ZXIoIGFjdGl2ZUluZm8udHlwZSApO1xyXG5cclxuXHRcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgU3RydWN0dXJlZFVuaWZvcm0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggaWQgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cclxuXHRcdHRoaXMuc2VxID0gW107XHJcblx0XHR0aGlzLm1hcCA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFZhbHVlKCBnbCwgdmFsdWUsIHRleHR1cmVzICkge1xyXG5cclxuXHRcdGNvbnN0IHNlcSA9IHRoaXMuc2VxO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1ID0gc2VxWyBpIF07XHJcblx0XHRcdHUuc2V0VmFsdWUoIGdsLCB2YWx1ZVsgdS5pZCBdLCB0ZXh0dXJlcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gLS0tIFRvcC1sZXZlbCAtLS1cclxuXHJcbi8vIFBhcnNlciAtIGJ1aWxkcyB1cCB0aGUgcHJvcGVydHkgdHJlZSBmcm9tIHRoZSBwYXRoIHN0cmluZ3NcclxuXHJcbmNvbnN0IFJlUGF0aFBhcnQgPSAvKFxcdyspKFxcXSk/KFxcW3xcXC4pPy9nO1xyXG5cclxuLy8gZXh0cmFjdHNcclxuLy8gXHQtIHRoZSBpZGVudGlmaWVyIChtZW1iZXIgbmFtZSBvciBhcnJheSBpbmRleClcclxuLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcclxuLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXHJcbi8vXHJcbi8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXHJcbi8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXHJcbi8vIGluIHRoZSB1bmlmb3JtIG5hbWVzLlxyXG5cclxuZnVuY3Rpb24gYWRkVW5pZm9ybSggY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0ICkge1xyXG5cclxuXHRjb250YWluZXIuc2VxLnB1c2goIHVuaWZvcm1PYmplY3QgKTtcclxuXHRjb250YWluZXIubWFwWyB1bmlmb3JtT2JqZWN0LmlkIF0gPSB1bmlmb3JtT2JqZWN0O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VVbmlmb3JtKCBhY3RpdmVJbmZvLCBhZGRyLCBjb250YWluZXIgKSB7XHJcblxyXG5cdGNvbnN0IHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXHJcblx0XHRwYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XHJcblxyXG5cdC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cclxuXHRSZVBhdGhQYXJ0Lmxhc3RJbmRleCA9IDA7XHJcblxyXG5cdHdoaWxlICggdHJ1ZSApIHtcclxuXHJcblx0XHRjb25zdCBtYXRjaCA9IFJlUGF0aFBhcnQuZXhlYyggcGF0aCApLFxyXG5cdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4O1xyXG5cclxuXHRcdGxldCBpZCA9IG1hdGNoWyAxIF07XHJcblx0XHRjb25zdCBpZElzSW5kZXggPSBtYXRjaFsgMiBdID09PSAnXScsXHJcblx0XHRcdHN1YnNjcmlwdCA9IG1hdGNoWyAzIF07XHJcblxyXG5cdFx0aWYgKCBpZElzSW5kZXggKSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXHJcblxyXG5cdFx0aWYgKCBzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCB8fCBzdWJzY3JpcHQgPT09ICdbJyAmJiBtYXRjaEVuZCArIDIgPT09IHBhdGhMZW5ndGggKSB7XHJcblxyXG5cdFx0XHQvLyBiYXJlIG5hbWUgb3IgXCJwdXJlXCIgYm90dG9tLWxldmVsIGFycmF5IFwiWzBdXCIgc3VmZml4XHJcblxyXG5cdFx0XHRhZGRVbmlmb3JtKCBjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0XHRuZXcgU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSA6XHJcblx0XHRcdFx0bmV3IFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgKTtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcclxuXHJcblx0XHRcdGNvbnN0IG1hcCA9IGNvbnRhaW5lci5tYXA7XHJcblx0XHRcdGxldCBuZXh0ID0gbWFwWyBpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBuZXh0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oIGlkICk7XHJcblx0XHRcdFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBuZXh0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb250YWluZXIgPSBuZXh0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gUm9vdCBDb250YWluZXJcclxuXHJcbmNsYXNzIFdlYkdMVW5pZm9ybXMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2wsIHByb2dyYW0gKSB7XHJcblxyXG5cdFx0dGhpcy5zZXEgPSBbXTtcclxuXHRcdHRoaXMubWFwID0ge307XHJcblxyXG5cdFx0Y29uc3QgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApLFxyXG5cdFx0XHRcdGFkZHIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIGluZm8ubmFtZSApO1xyXG5cclxuXHRcdFx0cGFyc2VVbmlmb3JtKCBpbmZvLCBhZGRyLCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldFZhbHVlKCBnbCwgbmFtZSwgdmFsdWUsIHRleHR1cmVzICkge1xyXG5cclxuXHRcdGNvbnN0IHUgPSB0aGlzLm1hcFsgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0ZXh0dXJlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE9wdGlvbmFsKCBnbCwgb2JqZWN0LCBuYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHYgPSBvYmplY3RbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIHYgIT09IHVuZGVmaW5lZCApIHRoaXMuc2V0VmFsdWUoIGdsLCBuYW1lLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIHVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCB0ZXh0dXJlcyApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdSA9IHNlcVsgaSBdLFxyXG5cdFx0XHRcdHYgPSB2YWx1ZXNbIHUuaWQgXTtcclxuXHJcblx0XHRcdGlmICggdi5uZWVkc1VwZGF0ZSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdGU6IGFsd2F5cyB1cGRhdGluZyB3aGVuIC5uZWVkc1VwZGF0ZSBpcyB1bmRlZmluZWRcclxuXHRcdFx0XHR1LnNldFZhbHVlKCBnbCwgdi52YWx1ZSwgdGV4dHVyZXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIHNlcVdpdGhWYWx1ZSggc2VxLCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgciA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1ID0gc2VxWyBpIF07XHJcblx0XHRcdGlmICggdS5pZCBpbiB2YWx1ZXMgKSByLnB1c2goIHUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHI7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMVW5pZm9ybXMgfTtcclxuIiwiZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XHJcblxyXG5cdGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cclxuXHRnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XHJcblx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XHJcblxyXG5cdHJldHVybiBzaGFkZXI7XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBXZWJHTFNoYWRlciB9O1xyXG4iLCJpbXBvcnQgeyBXZWJHTFVuaWZvcm1zIH0gZnJvbSAnLi9XZWJHTFVuaWZvcm1zLmpzJztcclxuaW1wb3J0IHsgV2ViR0xTaGFkZXIgfSBmcm9tICcuL1dlYkdMU2hhZGVyLmpzJztcclxuaW1wb3J0IHsgU2hhZGVyQ2h1bmsgfSBmcm9tICcuLi9zaGFkZXJzL1NoYWRlckNodW5rLmpzJztcclxuaW1wb3J0IHsgTm9Ub25lTWFwcGluZywgQWRkT3BlcmF0aW9uLCBNaXhPcGVyYXRpb24sIE11bHRpcGx5T3BlcmF0aW9uLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIFBDRlNvZnRTaGFkb3dNYXAsIFBDRlNoYWRvd01hcCwgVlNNU2hhZG93TWFwLCBBQ0VTRmlsbWljVG9uZU1hcHBpbmcsIENpbmVvblRvbmVNYXBwaW5nLCBDdXN0b21Ub25lTWFwcGluZywgUmVpbmhhcmRUb25lTWFwcGluZywgTGluZWFyVG9uZU1hcHBpbmcsIEdMU0wzLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgU1JHQkNvbG9yU3BhY2UgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxubGV0IHByb2dyYW1JZENvdW50ID0gMDtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVNvdXJjZSggc3RyaW5nLCBlcnJvckxpbmUgKSB7XHJcblxyXG5cdGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xyXG5cdGNvbnN0IGxpbmVzMiA9IFtdO1xyXG5cclxuXHRjb25zdCBmcm9tID0gTWF0aC5tYXgoIGVycm9yTGluZSAtIDYsIDAgKTtcclxuXHRjb25zdCB0byA9IE1hdGgubWluKCBlcnJvckxpbmUgKyA2LCBsaW5lcy5sZW5ndGggKTtcclxuXHJcblx0Zm9yICggbGV0IGkgPSBmcm9tOyBpIDwgdG87IGkgKysgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGluZSA9IGkgKyAxO1xyXG5cdFx0bGluZXMyLnB1c2goIGAke2xpbmUgPT09IGVycm9yTGluZSA/ICc+JyA6ICcgJ30gJHtsaW5lfTogJHtsaW5lc1sgaSBdfWAgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGluZXMyLmpvaW4oICdcXG4nICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdHN3aXRjaCAoIGNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0Y2FzZSBMaW5lYXJTUkdCQ29sb3JTcGFjZTpcclxuXHRcdFx0cmV0dXJuIFsgJ0xpbmVhcicsICcoIHZhbHVlICknIF07XHJcblx0XHRjYXNlIFNSR0JDb2xvclNwYWNlOlxyXG5cdFx0XHRyZXR1cm4gWyAnc1JHQicsICcoIHZhbHVlICknIF07XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIGNvbG9yIHNwYWNlOicsIGNvbG9yU3BhY2UgKTtcclxuXHRcdFx0cmV0dXJuIFsgJ0xpbmVhcicsICcoIHZhbHVlICknIF07XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNoYWRlckVycm9ycyggZ2wsIHNoYWRlciwgdHlwZSApIHtcclxuXHJcblx0Y29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICk7XHJcblx0Y29uc3QgZXJyb3JzID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkudHJpbSgpO1xyXG5cclxuXHRpZiAoIHN0YXR1cyAmJiBlcnJvcnMgPT09ICcnICkgcmV0dXJuICcnO1xyXG5cclxuXHRjb25zdCBlcnJvck1hdGNoZXMgPSAvRVJST1I6IDA6KFxcZCspLy5leGVjKCBlcnJvcnMgKTtcclxuXHRpZiAoIGVycm9yTWF0Y2hlcyApIHtcclxuXHJcblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICcqKicgKyB0eXBlICsgJyoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xyXG5cclxuXHRcdGNvbnN0IGVycm9yTGluZSA9IHBhcnNlSW50KCBlcnJvck1hdGNoZXNbIDEgXSApO1xyXG5cdFx0cmV0dXJuIHR5cGUudG9VcHBlckNhc2UoKSArICdcXG5cXG4nICsgZXJyb3JzICsgJ1xcblxcbicgKyBoYW5kbGVTb3VyY2UoIGdsLmdldFNoYWRlclNvdXJjZSggc2hhZGVyICksIGVycm9yTGluZSApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHJldHVybiBlcnJvcnM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBjb2xvclNwYWNlICkge1xyXG5cclxuXHRjb25zdCBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBjb2xvclNwYWNlICk7XHJcblx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG8nICsgY29tcG9uZW50c1sgMCBdICsgY29tcG9uZW50c1sgMSBdICsgJzsgfSc7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIHRvbmVNYXBwaW5nICkge1xyXG5cclxuXHRsZXQgdG9uZU1hcHBpbmdOYW1lO1xyXG5cclxuXHRzd2l0Y2ggKCB0b25lTWFwcGluZyApIHtcclxuXHJcblx0XHRjYXNlIExpbmVhclRvbmVNYXBwaW5nOlxyXG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnTGluZWFyJztcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBSZWluaGFyZFRvbmVNYXBwaW5nOlxyXG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnUmVpbmhhcmQnO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIENpbmVvblRvbmVNYXBwaW5nOlxyXG5cdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnT3B0aW1pemVkQ2luZW9uJztcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBBQ0VTRmlsbWljVG9uZU1hcHBpbmc6XHJcblx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9ICdBQ0VTRmlsbWljJztcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBDdXN0b21Ub25lTWFwcGluZzpcclxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0N1c3RvbSc7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogVW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6JywgdG9uZU1hcHBpbmcgKTtcclxuXHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ0xpbmVhcic7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuICd2ZWMzICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gJyArIHRvbmVNYXBwaW5nTmFtZSArICdUb25lTWFwcGluZyggY29sb3IgKTsgfSc7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUV4dGVuc2lvbnMoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGNvbnN0IGNodW5rcyA9IFtcclxuXHRcdCggcGFyYW1ldGVycy5leHRlbnNpb25EZXJpdmF0aXZlcyB8fCAhISBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVVkhlaWdodCB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXBUYW5nZW50U3BhY2UgfHwgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBwYXJhbWV0ZXJzLnNoYWRlcklEID09PSAncGh5c2ljYWwnICkgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXHJcblx0XHQoIHBhcmFtZXRlcnMuZXh0ZW5zaW9uRnJhZ0RlcHRoIHx8IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcclxuXHRcdCggcGFyYW1ldGVycy5leHRlbnNpb25EcmF3QnVmZmVycyAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRHJhd0J1ZmZlcnMgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlJyA6ICcnLFxyXG5cdFx0KCBwYXJhbWV0ZXJzLmV4dGVuc2lvblNoYWRlclRleHR1cmVMT0QgfHwgcGFyYW1ldGVycy5lbnZNYXAgfHwgcGFyYW1ldGVycy50cmFuc21pc3Npb24gKSAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxvZCA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGUnIDogJydcclxuXHRdO1xyXG5cclxuXHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcclxuXHJcblx0Y29uc3QgY2h1bmtzID0gW107XHJcblxyXG5cdGZvciAoIGNvbnN0IG5hbWUgaW4gZGVmaW5lcyApIHtcclxuXHJcblx0XHRjb25zdCB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICkge1xyXG5cclxuXHRjb25zdCBhdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdGNvbnN0IG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBuOyBpICsrICkge1xyXG5cclxuXHRcdGNvbnN0IGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcclxuXHRcdGNvbnN0IG5hbWUgPSBpbmZvLm5hbWU7XHJcblxyXG5cdFx0bGV0IGxvY2F0aW9uU2l6ZSA9IDE7XHJcblx0XHRpZiAoIGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUMiApIGxvY2F0aW9uU2l6ZSA9IDI7XHJcblx0XHRpZiAoIGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUMyApIGxvY2F0aW9uU2l6ZSA9IDM7XHJcblx0XHRpZiAoIGluZm8udHlwZSA9PT0gZ2wuRkxPQVRfTUFUNCApIGxvY2F0aW9uU2l6ZSA9IDQ7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBWRVJURVggQVRUUklCVVRFOicsIG5hbWUsIGkgKTtcclxuXHJcblx0XHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSB7XHJcblx0XHRcdHR5cGU6IGluZm8udHlwZSxcclxuXHRcdFx0bG9jYXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICksXHJcblx0XHRcdGxvY2F0aW9uU2l6ZTogbG9jYXRpb25TaXplXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBhdHRyaWJ1dGVzO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XHJcblxyXG5cdHJldHVybiBzdHJpbmcgIT09ICcnO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zdCBudW1TcG90TGlnaHRDb29yZHMgPSBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKyBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodE1hcHMgLSBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcztcclxuXHJcblx0cmV0dXJuIHN0cmluZ1xyXG5cdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXHJcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMgKVxyXG5cdFx0LnJlcGxhY2UoIC9OVU1fU1BPVF9MSUdIVF9NQVBTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0TWFwcyApXHJcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUX0NPT1JEUy9nLCBudW1TcG90TGlnaHRDb29yZHMgKVxyXG5cdFx0LnJlcGxhY2UoIC9OVU1fUkVDVF9BUkVBX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVJlY3RBcmVhTGlnaHRzIClcclxuXHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzIClcclxuXHRcdC5yZXBsYWNlKCAvTlVNX0hFTUlfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyApXHJcblx0XHQucmVwbGFjZSggL05VTV9ESVJfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0U2hhZG93cyApXHJcblx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUX1NIQURPV1NfV0lUSF9NQVBTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzIClcclxuXHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKVxyXG5cdFx0LnJlcGxhY2UoIC9OVU1fUE9JTlRfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRTaGFkb3dzICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoIHN0cmluZywgcGFyYW1ldGVycyApIHtcclxuXHJcblx0cmV0dXJuIHN0cmluZ1xyXG5cdFx0LnJlcGxhY2UoIC9OVU1fQ0xJUFBJTkdfUExBTkVTL2csIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMgKVxyXG5cdFx0LnJlcGxhY2UoIC9VTklPTl9DTElQUElOR19QTEFORVMvZywgKCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzIC0gcGFyYW1ldGVycy5udW1DbGlwSW50ZXJzZWN0aW9uICkgKTtcclxuXHJcbn1cclxuXHJcbi8vIFJlc29sdmUgSW5jbHVkZXNcclxuXHJcbmNvbnN0IGluY2x1ZGVQYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVJbmNsdWRlcyggc3RyaW5nICkge1xyXG5cclxuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIGluY2x1ZGVQYXR0ZXJuLCBpbmNsdWRlUmVwbGFjZXIgKTtcclxuXHJcbn1cclxuXHJcbmNvbnN0IHNoYWRlckNodW5rTWFwID0gbmV3IE1hcCggW1xyXG5cdFsgJ2VuY29kaW5nc19mcmFnbWVudCcsICdjb2xvcnNwYWNlX2ZyYWdtZW50JyBdLCAvLyBAZGVwcmVjYXRlZCwgcjE1NFxyXG5cdFsgJ2VuY29kaW5nc19wYXJzX2ZyYWdtZW50JywgJ2NvbG9yc3BhY2VfcGFyc19mcmFnbWVudCcgXSwgLy8gQGRlcHJlY2F0ZWQsIHIxNTRcclxuXHRbICdvdXRwdXRfZnJhZ21lbnQnLCAnb3BhcXVlX2ZyYWdtZW50JyBdLCAvLyBAZGVwcmVjYXRlZCwgcjE1NFxyXG5dICk7XHJcblxyXG5mdW5jdGlvbiBpbmNsdWRlUmVwbGFjZXIoIG1hdGNoLCBpbmNsdWRlICkge1xyXG5cclxuXHRsZXQgc3RyaW5nID0gU2hhZGVyQ2h1bmtbIGluY2x1ZGUgXTtcclxuXHJcblx0aWYgKCBzdHJpbmcgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRjb25zdCBuZXdJbmNsdWRlID0gc2hhZGVyQ2h1bmtNYXAuZ2V0KCBpbmNsdWRlICk7XHJcblxyXG5cdFx0aWYgKCBuZXdJbmNsdWRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzdHJpbmcgPSBTaGFkZXJDaHVua1sgbmV3SW5jbHVkZSBdO1xyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBTaGFkZXIgY2h1bmsgXCIlc1wiIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBcIiVzXCIgaW5zdGVhZC4nLCBpbmNsdWRlLCBuZXdJbmNsdWRlICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8JyArIGluY2x1ZGUgKyAnPicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc29sdmVJbmNsdWRlcyggc3RyaW5nICk7XHJcblxyXG59XHJcblxyXG4vLyBVbnJvbGwgTG9vcHNcclxuXHJcbmNvbnN0IHVucm9sbExvb3BQYXR0ZXJuID0gLyNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXHMrZm9yXFxzKlxcKFxccyppbnRcXHMraVxccyo9XFxzKihcXGQrKVxccyo7XFxzKmlcXHMqPFxccyooXFxkKylcXHMqO1xccyppXFxzKlxcK1xcK1xccypcXClcXHMqeyhbXFxzXFxTXSs/KX1cXHMrI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmQvZztcclxuXHJcbmZ1bmN0aW9uIHVucm9sbExvb3BzKCBzdHJpbmcgKSB7XHJcblxyXG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggdW5yb2xsTG9vcFBhdHRlcm4sIGxvb3BSZXBsYWNlciApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbG9vcFJlcGxhY2VyKCBtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCApIHtcclxuXHJcblx0bGV0IHN0cmluZyA9ICcnO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IHBhcnNlSW50KCBzdGFydCApOyBpIDwgcGFyc2VJbnQoIGVuZCApOyBpICsrICkge1xyXG5cclxuXHRcdHN0cmluZyArPSBzbmlwcGV0XHJcblx0XHRcdC5yZXBsYWNlKCAvXFxbXFxzKmlcXHMqXFxdL2csICdbICcgKyBpICsgJyBdJyApXHJcblx0XHRcdC5yZXBsYWNlKCAvVU5ST0xMRURfTE9PUF9JTkRFWC9nLCBpICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHN0cmluZztcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZVByZWNpc2lvbiggcGFyYW1ldGVycyApIHtcclxuXHJcblx0bGV0IHByZWNpc2lvbnN0cmluZyA9ICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDtcXG5wcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JztcclxuXHJcblx0aWYgKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ2hpZ2hwJyApIHtcclxuXHJcblx0XHRwcmVjaXNpb25zdHJpbmcgKz0gJ1xcbiNkZWZpbmUgSElHSF9QUkVDSVNJT04nO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xyXG5cclxuXHRcdHByZWNpc2lvbnN0cmluZyArPSAnXFxuI2RlZmluZSBNRURJVU1fUFJFQ0lTSU9OJztcclxuXHJcblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5wcmVjaXNpb24gPT09ICdsb3dwJyApIHtcclxuXHJcblx0XHRwcmVjaXNpb25zdHJpbmcgKz0gJ1xcbiNkZWZpbmUgTE9XX1BSRUNJU0lPTic7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHByZWNpc2lvbnN0cmluZztcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2hhZG93TWFwVHlwZURlZmluZSggcGFyYW1ldGVycyApIHtcclxuXHJcblx0bGV0IHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xyXG5cclxuXHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwICkge1xyXG5cclxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcclxuXHJcblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBQQ0ZTb2Z0U2hhZG93TWFwICkge1xyXG5cclxuXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFZTTVNoYWRvd01hcCApIHtcclxuXHJcblx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1ZTTSc7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHNoYWRvd01hcFR5cGVEZWZpbmU7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUVudk1hcFR5cGVEZWZpbmUoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGxldCBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xyXG5cclxuXHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIHBhcmFtZXRlcnMuZW52TWFwTW9kZSApIHtcclxuXHJcblx0XHRcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkVfVVYnO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZW52TWFwVHlwZURlZmluZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwTW9kZURlZmluZSggcGFyYW1ldGVycyApIHtcclxuXHJcblx0bGV0IGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggcGFyYW1ldGVycy5lbnZNYXBNb2RlICkge1xyXG5cclxuXHRcdFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XHJcblxyXG5cdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBlbnZNYXBNb2RlRGVmaW5lO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVFbnZNYXBCbGVuZGluZ0RlZmluZSggcGFyYW1ldGVycyApIHtcclxuXHJcblx0bGV0IGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19OT05FJztcclxuXHJcblx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBwYXJhbWV0ZXJzLmNvbWJpbmUgKSB7XHJcblxyXG5cdFx0XHRjYXNlIE11bHRpcGx5T3BlcmF0aW9uOlxyXG5cdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIE1peE9wZXJhdGlvbjpcclxuXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgQWRkT3BlcmF0aW9uOlxyXG5cdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZW52TWFwQmxlbmRpbmdEZWZpbmU7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUN1YmVVVlNpemUoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGNvbnN0IGltYWdlSGVpZ2h0ID0gcGFyYW1ldGVycy5lbnZNYXBDdWJlVVZIZWlnaHQ7XHJcblxyXG5cdGlmICggaW1hZ2VIZWlnaHQgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0Y29uc3QgbWF4TWlwID0gTWF0aC5sb2cyKCBpbWFnZUhlaWdodCApIC0gMjtcclxuXHJcblx0Y29uc3QgdGV4ZWxIZWlnaHQgPSAxLjAgLyBpbWFnZUhlaWdodDtcclxuXHJcblx0Y29uc3QgdGV4ZWxXaWR0aCA9IDEuMCAvICggMyAqIE1hdGgubWF4KCBNYXRoLnBvdyggMiwgbWF4TWlwICksIDcgKiAxNiApICk7XHJcblxyXG5cdHJldHVybiB7IHRleGVsV2lkdGgsIHRleGVsSGVpZ2h0LCBtYXhNaXAgfTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNhY2hlS2V5LCBwYXJhbWV0ZXJzLCBiaW5kaW5nU3RhdGVzICkge1xyXG5cclxuXHQvLyBUT0RPIFNlbmQgdGhpcyBldmVudCB0byBUaHJlZS5qcyBEZXZUb29sc1xyXG5cdC8vIGNvbnNvbGUubG9nKCAnV2ViR0xQcm9ncmFtJywgY2FjaGVLZXkgKTtcclxuXHJcblx0Y29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XHJcblxyXG5cdGNvbnN0IGRlZmluZXMgPSBwYXJhbWV0ZXJzLmRlZmluZXM7XHJcblxyXG5cdGxldCB2ZXJ0ZXhTaGFkZXIgPSBwYXJhbWV0ZXJzLnZlcnRleFNoYWRlcjtcclxuXHRsZXQgZnJhZ21lbnRTaGFkZXIgPSBwYXJhbWV0ZXJzLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRjb25zdCBzaGFkb3dNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVTaGFkb3dNYXBUeXBlRGVmaW5lKCBwYXJhbWV0ZXJzICk7XHJcblx0Y29uc3QgZW52TWFwVHlwZURlZmluZSA9IGdlbmVyYXRlRW52TWFwVHlwZURlZmluZSggcGFyYW1ldGVycyApO1xyXG5cdGNvbnN0IGVudk1hcE1vZGVEZWZpbmUgPSBnZW5lcmF0ZUVudk1hcE1vZGVEZWZpbmUoIHBhcmFtZXRlcnMgKTtcclxuXHRjb25zdCBlbnZNYXBCbGVuZGluZ0RlZmluZSA9IGdlbmVyYXRlRW52TWFwQmxlbmRpbmdEZWZpbmUoIHBhcmFtZXRlcnMgKTtcclxuXHRjb25zdCBlbnZNYXBDdWJlVVZTaXplID0gZ2VuZXJhdGVDdWJlVVZTaXplKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdGNvbnN0IGN1c3RvbUV4dGVuc2lvbnMgPSBwYXJhbWV0ZXJzLmlzV2ViR0wyID8gJycgOiBnZW5lcmF0ZUV4dGVuc2lvbnMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0Y29uc3QgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xyXG5cclxuXHRjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRsZXQgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcclxuXHRsZXQgdmVyc2lvblN0cmluZyA9IHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPyAnI3ZlcnNpb24gJyArIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gKyAnXFxuJyA6ICcnO1xyXG5cclxuXHRpZiAoIHBhcmFtZXRlcnMuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRwcmVmaXhWZXJ0ZXggPSBbXHJcblxyXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfVFlQRSAnICsgcGFyYW1ldGVycy5zaGFkZXJUeXBlLFxyXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxyXG5cclxuXHRcdFx0Y3VzdG9tRGVmaW5lc1xyXG5cclxuXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdGlmICggcHJlZml4VmVydGV4Lmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRwcmVmaXhWZXJ0ZXggKz0gJ1xcbic7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHByZWZpeEZyYWdtZW50ID0gW1xyXG5cclxuXHRcdFx0Y3VzdG9tRXh0ZW5zaW9ucyxcclxuXHJcblx0XHRcdCcjZGVmaW5lIFNIQURFUl9UWVBFICcgKyBwYXJhbWV0ZXJzLnNoYWRlclR5cGUsXHJcblx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBwYXJhbWV0ZXJzLnNoYWRlck5hbWUsXHJcblxyXG5cdFx0XHRjdXN0b21EZWZpbmVzXHJcblxyXG5cdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdFx0aWYgKCBwcmVmaXhGcmFnbWVudC5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0cHJlZml4RnJhZ21lbnQgKz0gJ1xcbic7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHByZWZpeFZlcnRleCA9IFtcclxuXHJcblx0XHRcdGdlbmVyYXRlUHJlY2lzaW9uKCBwYXJhbWV0ZXJzICksXHJcblxyXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfVFlQRSAnICsgcGFyYW1ldGVycy5zaGFkZXJUeXBlLFxyXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxyXG5cclxuXHRcdFx0Y3VzdG9tRGVmaW5lcyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuaW5zdGFuY2luZyA/ICcjZGVmaW5lIFVTRV9JTlNUQU5DSU5HJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvciA/ICcjZGVmaW5lIFVTRV9JTlNUQU5DSU5HX0NPTE9SJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cDIgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmFuaXNvdHJvcHlNYXAgPyAnI2RlZmluZSBVU0VfQU5JU09UUk9QWU1BUCcgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0TWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCcgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfSVJJREVTQ0VOQ0VfVEhJQ0tORVNTTUFQJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSX0NPTE9STUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCcgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmFscGhhSGFzaCA/ICcjZGVmaW5lIFVTRV9BTFBIQUhBU0gnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbiA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT04nIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uTWFwID8gJyNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTk1BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy50aGlja25lc3NNYXAgPyAnI2RlZmluZSBVU0VfVEhJQ0tORVNTTUFQJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOX0NPTE9STUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCcgOiAnJyxcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcFV2ID8gJyNkZWZpbmUgTUFQX1VWICcgKyBwYXJhbWV0ZXJzLm1hcFV2IDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXBVdiA/ICcjZGVmaW5lIEFMUEhBTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmFscGhhTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcFV2ID8gJyNkZWZpbmUgTElHSFRNQVBfVVYgJyArIHBhcmFtZXRlcnMubGlnaHRNYXBVdiA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmFvTWFwVXYgPyAnI2RlZmluZSBBT01BUF9VViAnICsgcGFyYW1ldGVycy5hb01hcFV2IDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBVdiA/ICcjZGVmaW5lIEVNSVNTSVZFTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwVXYgPyAnI2RlZmluZSBCVU1QTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmJ1bXBNYXBVdiA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcFV2ID8gJyNkZWZpbmUgTk9STUFMTUFQX1VWICcgKyBwYXJhbWV0ZXJzLm5vcm1hbE1hcFV2IDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwVXYgPyAnI2RlZmluZSBESVNQTEFDRU1FTlRNQVBfVVYgJyArIHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwVXYgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwVXYgPyAnI2RlZmluZSBNRVRBTE5FU1NNQVBfVVYgJyArIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXBVdiA/ICcjZGVmaW5lIFJPVUdITkVTU01BUF9VViAnICsgcGFyYW1ldGVycy5yb3VnaG5lc3NNYXBVdiA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5TWFwVXYgPyAnI2RlZmluZSBBTklTT1RST1BZTUFQX1VWICcgKyBwYXJhbWV0ZXJzLmFuaXNvdHJvcHlNYXBVdiA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiA/ICcjZGVmaW5lIENMRUFSQ09BVE1BUF9VViAnICsgcGFyYW1ldGVycy5jbGVhcmNvYXRNYXBVdiA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcFV2ID8gJyNkZWZpbmUgQ0xFQVJDT0FUX05PUk1BTE1BUF9VViAnICsgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXBVdiA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcFV2ID8gJyNkZWZpbmUgQ0xFQVJDT0FUX1JPVUdITkVTU01BUF9VViAnICsgcGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXBVdiA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcFV2ID8gJyNkZWZpbmUgSVJJREVTQ0VOQ0VNQVBfVVYgJyArIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VNYXBVdiA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwVXYgPyAnI2RlZmluZSBJUklERVNDRU5DRV9USElDS05FU1NNQVBfVVYgJyArIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwVXYgPyAnI2RlZmluZSBTSEVFTl9DT0xPUk1BUF9VViAnICsgcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zaGVlblJvdWdobmVzc01hcFV2ID8gJyNkZWZpbmUgU0hFRU5fUk9VR0hORVNTTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwVXYgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXBVdiA/ICcjZGVmaW5lIFNQRUNVTEFSTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwVXYgPyAnI2RlZmluZSBTUEVDVUxBUl9DT0xPUk1BUF9VViAnICsgcGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcFV2ID8gJyNkZWZpbmUgU1BFQ1VMQVJfSU5URU5TSVRZTUFQX1VWICcgKyBwYXJhbWV0ZXJzLnNwZWN1bGFySW50ZW5zaXR5TWFwVXYgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uTWFwVXYgPyAnI2RlZmluZSBUUkFOU01JU1NJT05NQVBfVVYgJyArIHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uTWFwVXYgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy50aGlja25lc3NNYXBVdiA/ICcjZGVmaW5lIFRISUNLTkVTU01BUF9VViAnICsgcGFyYW1ldGVycy50aGlja25lc3NNYXBVdiA6ICcnLFxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfVEFOR0VOVCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2MXMgPyAnI2RlZmluZSBVU0VfVVYxJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2MnMgPyAnI2RlZmluZSBVU0VfVVYyJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFV2M3MgPyAnI2RlZmluZSBVU0VfVVYzJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5wb2ludHNVdnMgPyAnI2RlZmluZSBVU0VfUE9JTlRTX1VWJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhDb2xvcnMgJiYgcGFyYW1ldGVycy5pc1dlYkdMMiApID8gJyNkZWZpbmUgVVNFX01PUlBIQ09MT1JTJyA6ICcnLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgKSA/ICcjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFJyA6ICcnLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgKSA/ICcjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSAnICsgcGFyYW1ldGVycy5tb3JwaFRleHR1cmVTdHJpZGUgOiAnJyxcclxuXHRcdFx0KCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0c0NvdW50ID4gMCAmJiBwYXJhbWV0ZXJzLmlzV2ViR0wyICkgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfQ09VTlQgJyArIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMudXNlTGVnYWN5TGlnaHRzID8gJyNkZWZpbmUgTEVHQUNZX0xJR0hUUycgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcclxuXHRcdFx0KCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aCApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcclxuXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcblx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHQndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxyXG5cdFx0XHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXHJcblx0XHRcdCd1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7JyxcclxuXHJcblx0XHRcdCcjaWZkZWYgVVNFX0lOU1RBTkNJTkcnLFxyXG5cclxuXHRcdFx0J1x0YXR0cmlidXRlIG1hdDQgaW5zdGFuY2VNYXRyaXg7JyxcclxuXHJcblx0XHRcdCcjZW5kaWYnLFxyXG5cclxuXHRcdFx0JyNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUicsXHJcblxyXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZUNvbG9yOycsXHJcblxyXG5cdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxyXG5cdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXHJcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxyXG5cclxuXHRcdFx0JyNpZmRlZiBVU0VfVVYxJyxcclxuXHJcblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMyIHV2MTsnLFxyXG5cclxuXHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHQnI2lmZGVmIFVTRV9VVjInLFxyXG5cclxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzIgdXYyOycsXHJcblxyXG5cdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdCcjaWZkZWYgVVNFX1VWMycsXHJcblxyXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMiB1djM7JyxcclxuXHJcblx0XHRcdCcjZW5kaWYnLFxyXG5cclxuXHRcdFx0JyNpZmRlZiBVU0VfVEFOR0VOVCcsXHJcblxyXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OycsXHJcblxyXG5cdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdCcjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBICknLFxyXG5cclxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgY29sb3I7JyxcclxuXHJcblx0XHRcdCcjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKScsXHJcblxyXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxyXG5cclxuXHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHQnI2lmICggZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApICYmICEgZGVmaW5lZCggTU9SUEhUQVJHRVRTX1RFWFRVUkUgKSApJyxcclxuXHJcblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxyXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7JyxcclxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXHJcblx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxyXG5cclxuXHRcdFx0J1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxyXG5cclxuXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcclxuXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcclxuXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JyxcclxuXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcclxuXHJcblx0XHRcdCdcdCNlbHNlJyxcclxuXHJcblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXHJcblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXHJcblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXHJcblx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXHJcblxyXG5cdFx0XHQnXHQjZW5kaWYnLFxyXG5cclxuXHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHQnI2lmZGVmIFVTRV9TS0lOTklORycsXHJcblxyXG5cdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JyxcclxuXHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxyXG5cclxuXHRcdFx0JyNlbmRpZicsXHJcblxyXG5cdFx0XHQnXFxuJ1xyXG5cclxuXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdHByZWZpeEZyYWdtZW50ID0gW1xyXG5cclxuXHRcdFx0Y3VzdG9tRXh0ZW5zaW9ucyxcclxuXHJcblx0XHRcdGdlbmVyYXRlUHJlY2lzaW9uKCBwYXJhbWV0ZXJzICksXHJcblxyXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfVFlQRSAnICsgcGFyYW1ldGVycy5zaGFkZXJUeXBlLFxyXG5cdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLFxyXG5cclxuXHRcdFx0Y3VzdG9tRGVmaW5lcyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAyID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMubWF0Y2FwID8gJyNkZWZpbmUgVVNFX01BVENBUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcclxuXHRcdFx0ZW52TWFwQ3ViZVVWU2l6ZSA/ICcjZGVmaW5lIENVQkVVVl9URVhFTF9XSURUSCAnICsgZW52TWFwQ3ViZVVWU2l6ZS50ZXhlbFdpZHRoIDogJycsXHJcblx0XHRcdGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICcgKyBlbnZNYXBDdWJlVVZTaXplLnRleGVsSGVpZ2h0IDogJycsXHJcblx0XHRcdGVudk1hcEN1YmVVVlNpemUgPyAnI2RlZmluZSBDVUJFVVZfTUFYX01JUCAnICsgZW52TWFwQ3ViZVVWU2l6ZS5tYXhNaXAgKyAnLjAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQX09CSkVDVFNQQUNFJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcFRhbmdlbnRTcGFjZSA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVBfVEFOR0VOVFNQQUNFJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5hbmlzb3Ryb3B5ID8gJyNkZWZpbmUgVVNFX0FOSVNPVFJPUFknIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYW5pc290cm9weU1hcCA/ICcjZGVmaW5lIFVTRV9BTklTT1RST1BZTUFQJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5jbGVhcmNvYXQgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmNsZWFyY29hdE1hcCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVRNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuY2xlYXJjb2F0Tm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlTWFwID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID8gJyNkZWZpbmUgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCcgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJDb2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUl9DT0xPUk1BUCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUl9JTlRFTlNJVFlNQVAnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgVVNFX0FMUEhBVEVTVCcgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYUhhc2ggPyAnI2RlZmluZSBVU0VfQUxQSEFIQVNIJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGVlbiA/ICcjZGVmaW5lIFVTRV9TSEVFTicgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOX0NPTE9STUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoZWVuUm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOX1JPVUdITkVTU01BUCcgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMudHJhbnNtaXNzaW9uID8gJyNkZWZpbmUgVVNFX1RSQU5TTUlTU0lPTicgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy50cmFuc21pc3Npb25NYXAgPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9USElDS05FU1NNQVAnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX1RBTkdFTlQnIDogJycsXHJcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzIHx8IHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleEFscGhhcyA/ICcjZGVmaW5lIFVTRV9DT0xPUl9BTFBIQScgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjFzID8gJyNkZWZpbmUgVVNFX1VWMScgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjJzID8gJyNkZWZpbmUgVVNFX1VWMicgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhVdjNzID8gJyNkZWZpbmUgVVNFX1VWMycgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMucG9pbnRzVXZzID8gJyNkZWZpbmUgVVNFX1BPSU5UU19VVicgOiAnJyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgPyAnI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy51c2VMZWdhY3lMaWdodHMgPyAnI2RlZmluZSBMRUdBQ1lfTElHSFRTJyA6ICcnLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxyXG5cclxuXHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXHJcblx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcclxuXHRcdFx0J3VuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsnLFxyXG5cclxuXHRcdFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyAnI2RlZmluZSBUT05FX01BUFBJTkcnIDogJycsXHJcblx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gU2hhZGVyQ2h1bmtbICd0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50JyBdIDogJycsIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdG9uZU1hcHBpbmcoKSBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XHJcblx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggJ3RvbmVNYXBwaW5nJywgcGFyYW1ldGVycy50b25lTWFwcGluZyApIDogJycsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLmRpdGhlcmluZyA/ICcjZGVmaW5lIERJVEhFUklORycgOiAnJyxcclxuXHRcdFx0cGFyYW1ldGVycy5vcGFxdWUgPyAnI2RlZmluZSBPUEFRVUUnIDogJycsXHJcblxyXG5cdFx0XHRTaGFkZXJDaHVua1sgJ2NvbG9yc3BhY2VfcGFyc19mcmFnbWVudCcgXSwgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcclxuXHRcdFx0Z2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCAnbGluZWFyVG9PdXRwdXRUZXhlbCcsIHBhcmFtZXRlcnMub3V0cHV0Q29sb3JTcGFjZSApLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy51c2VEZXB0aFBhY2tpbmcgPyAnI2RlZmluZSBERVBUSF9QQUNLSU5HICcgKyBwYXJhbWV0ZXJzLmRlcHRoUGFja2luZyA6ICcnLFxyXG5cclxuXHRcdFx0J1xcbidcclxuXHJcblx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2ZXJ0ZXhTaGFkZXIgPSByZXNvbHZlSW5jbHVkZXMoIHZlcnRleFNoYWRlciApO1xyXG5cdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xyXG5cdHZlcnRleFNoYWRlciA9IHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggdmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdGZyYWdtZW50U2hhZGVyID0gcmVzb2x2ZUluY2x1ZGVzKCBmcmFnbWVudFNoYWRlciApO1xyXG5cdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHRmcmFnbWVudFNoYWRlciA9IHJlcGxhY2VDbGlwcGluZ1BsYW5lTnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xyXG5cdGZyYWdtZW50U2hhZGVyID0gdW5yb2xsTG9vcHMoIGZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5pc1dlYkdMMiAmJiBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0Ly8gR0xTTCAzLjAgY29udmVyc2lvbiBmb3IgYnVpbHQtaW4gbWF0ZXJpYWxzIGFuZCBTaGFkZXJNYXRlcmlhbFxyXG5cclxuXHRcdHZlcnNpb25TdHJpbmcgPSAnI3ZlcnNpb24gMzAwIGVzXFxuJztcclxuXHJcblx0XHRwcmVmaXhWZXJ0ZXggPSBbXHJcblx0XHRcdCdwcmVjaXNpb24gbWVkaXVtcCBzYW1wbGVyMkRBcnJheTsnLFxyXG5cdFx0XHQnI2RlZmluZSBhdHRyaWJ1dGUgaW4nLFxyXG5cdFx0XHQnI2RlZmluZSB2YXJ5aW5nIG91dCcsXHJcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJ1xyXG5cdFx0XS5qb2luKCAnXFxuJyApICsgJ1xcbicgKyBwcmVmaXhWZXJ0ZXg7XHJcblxyXG5cdFx0cHJlZml4RnJhZ21lbnQgPSBbXHJcblx0XHRcdCcjZGVmaW5lIHZhcnlpbmcgaW4nLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzICkgPyAnJyA6ICdsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgaGlnaHAgdmVjNCBwY19mcmFnQ29sb3I7JyxcclxuXHRcdFx0KCBwYXJhbWV0ZXJzLmdsc2xWZXJzaW9uID09PSBHTFNMMyApID8gJycgOiAnI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yJyxcclxuXHRcdFx0JyNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCcsXHJcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJyxcclxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZScsXHJcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2onLFxyXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlMkRMb2RFWFQgdGV4dHVyZUxvZCcsXHJcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QnLFxyXG5cdFx0XHQnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kJyxcclxuXHRcdFx0JyNkZWZpbmUgdGV4dHVyZTJER3JhZEVYVCB0ZXh0dXJlR3JhZCcsXHJcblx0XHRcdCcjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCcsXHJcblx0XHRcdCcjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCdcclxuXHRcdF0uam9pbiggJ1xcbicgKSArICdcXG4nICsgcHJlZml4RnJhZ21lbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3QgdmVydGV4R2xzbCA9IHZlcnNpb25TdHJpbmcgKyBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XHJcblx0Y29uc3QgZnJhZ21lbnRHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XHJcblx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XHJcblxyXG5cdGNvbnN0IGdsVmVydGV4U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XHJcblx0Y29uc3QgZ2xGcmFnbWVudFNoYWRlciA9IFdlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcclxuXHJcblx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xyXG5cdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBwYXJhbWV0ZXJzLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcclxuXHJcblx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXHJcblx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHQvLyBjaGVjayBmb3IgbGluayBlcnJvcnNcclxuXHRpZiAoIHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzICkge1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW1Mb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApLnRyaW0oKTtcclxuXHRcdGNvbnN0IHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsVmVydGV4U2hhZGVyICkudHJpbSgpO1xyXG5cdFx0Y29uc3QgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbEZyYWdtZW50U2hhZGVyICkudHJpbSgpO1xyXG5cclxuXHRcdGxldCBydW5uYWJsZSA9IHRydWU7XHJcblx0XHRsZXQgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0cnVubmFibGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mIHJlbmRlcmVyLmRlYnVnLm9uU2hhZGVyRXJyb3IgPT09ICdmdW5jdGlvbicgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLmRlYnVnLm9uU2hhZGVyRXJyb3IoIGdsLCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gZGVmYXVsdCBlcnJvciByZXBvcnRpbmdcclxuXHJcblx0XHRcdFx0Y29uc3QgdmVydGV4RXJyb3JzID0gZ2V0U2hhZGVyRXJyb3JzKCBnbCwgZ2xWZXJ0ZXhTaGFkZXIsICd2ZXJ0ZXgnICk7XHJcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnRFcnJvcnMgPSBnZXRTaGFkZXJFcnJvcnMoIGdsLCBnbEZyYWdtZW50U2hhZGVyLCAnZnJhZ21lbnQnICk7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXHJcblx0XHRcdFx0XHQnVEhSRUUuV2ViR0xQcm9ncmFtOiBTaGFkZXIgRXJyb3IgJyArIGdsLmdldEVycm9yKCkgKyAnIC0gJyArXHJcblx0XHRcdFx0XHQnVkFMSURBVEVfU1RBVFVTICcgKyBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMgKSArICdcXG5cXG4nICtcclxuXHRcdFx0XHRcdCdQcm9ncmFtIEluZm8gTG9nOiAnICsgcHJvZ3JhbUxvZyArICdcXG4nICtcclxuXHRcdFx0XHRcdHZlcnRleEVycm9ycyArICdcXG4nICtcclxuXHRcdFx0XHRcdGZyYWdtZW50RXJyb3JzXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtTG9nICE9PSAnJyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzonLCBwcm9ncmFtTG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XHJcblxyXG5cdFx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xyXG5cclxuXHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXHJcblxyXG5cdFx0XHRcdHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXHJcblxyXG5cdFx0XHRcdHZlcnRleFNoYWRlcjoge1xyXG5cclxuXHRcdFx0XHRcdGxvZzogdmVydGV4TG9nLFxyXG5cdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcclxuXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHtcclxuXHJcblx0XHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxyXG5cdFx0XHRcdFx0cHJlZml4OiBwcmVmaXhGcmFnbWVudFxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBDbGVhbiB1cFxyXG5cclxuXHQvLyBDcmFzaGVzIGluIGlPUzkgYW5kIGlPUzEwLiAjMTg0MDJcclxuXHQvLyBnbC5kZXRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XHJcblx0Ly8gZ2wuZGV0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdGdsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXHJcblxyXG5cdGxldCBjYWNoZWRVbmlmb3JtcztcclxuXHJcblx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjYWNoZWRVbmlmb3JtcyA9IG5ldyBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXHJcblxyXG5cdGxldCBjYWNoZWRBdHRyaWJ1dGVzO1xyXG5cclxuXHR0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBmcmVlIHJlc291cmNlXHJcblxyXG5cdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRiaW5kaW5nU3RhdGVzLnJlbGVhc2VTdGF0ZXNPZlByb2dyYW0oIHRoaXMgKTtcclxuXHJcblx0XHRnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XHJcblx0XHR0aGlzLnByb2dyYW0gPSB1bmRlZmluZWQ7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMudHlwZSA9IHBhcmFtZXRlcnMuc2hhZGVyVHlwZTtcclxuXHR0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLnNoYWRlck5hbWU7XHJcblx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xyXG5cdHRoaXMuY2FjaGVLZXkgPSBjYWNoZUtleTtcclxuXHR0aGlzLnVzZWRUaW1lcyA9IDE7XHJcblx0dGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHR0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xyXG5cdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMUHJvZ3JhbSB9O1xyXG4iLCJsZXQgX2lkID0gMDtcclxuXHJcbmNsYXNzIFdlYkdMU2hhZGVyQ2FjaGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHR0aGlzLnNoYWRlckNhY2hlID0gbmV3IE1hcCgpO1xyXG5cdFx0dGhpcy5tYXRlcmlhbENhY2hlID0gbmV3IE1hcCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwudmVydGV4U2hhZGVyO1xyXG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlcjtcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhTaGFkZXJTdGFnZSA9IHRoaXMuX2dldFNoYWRlclN0YWdlKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdGNvbnN0IGZyYWdtZW50U2hhZGVyU3RhZ2UgPSB0aGlzLl9nZXRTaGFkZXJTdGFnZSggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbFNoYWRlcnMgPSB0aGlzLl9nZXRTaGFkZXJDYWNoZUZvck1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxTaGFkZXJzLmhhcyggdmVydGV4U2hhZGVyU3RhZ2UgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbFNoYWRlcnMuYWRkKCB2ZXJ0ZXhTaGFkZXJTdGFnZSApO1xyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXJTdGFnZS51c2VkVGltZXMgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxTaGFkZXJzLmhhcyggZnJhZ21lbnRTaGFkZXJTdGFnZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsU2hhZGVycy5hZGQoIGZyYWdtZW50U2hhZGVyU3RhZ2UgKTtcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXJTdGFnZS51c2VkVGltZXMgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbW92ZSggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWF0ZXJpYWxTaGFkZXJzID0gdGhpcy5tYXRlcmlhbENhY2hlLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBzaGFkZXJTdGFnZSBvZiBtYXRlcmlhbFNoYWRlcnMgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJTdGFnZS51c2VkVGltZXMgLS07XHJcblxyXG5cdFx0XHRpZiAoIHNoYWRlclN0YWdlLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuc2hhZGVyQ2FjaGUuZGVsZXRlKCBzaGFkZXJTdGFnZS5jb2RlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmVydGV4U2hhZGVySUQoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9nZXRTaGFkZXJTdGFnZSggbWF0ZXJpYWwudmVydGV4U2hhZGVyICkuaWQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RnJhZ21lbnRTaGFkZXJJRCggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2dldFNoYWRlclN0YWdlKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApLmlkO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5zaGFkZXJDYWNoZS5jbGVhcigpO1xyXG5cdFx0dGhpcy5tYXRlcmlhbENhY2hlLmNsZWFyKCk7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5tYXRlcmlhbENhY2hlO1xyXG5cdFx0bGV0IHNldCA9IGNhY2hlLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoIHNldCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0XHRjYWNoZS5zZXQoIG1hdGVyaWFsLCBzZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNldDtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0U2hhZGVyU3RhZ2UoIGNvZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgY2FjaGUgPSB0aGlzLnNoYWRlckNhY2hlO1xyXG5cdFx0bGV0IHN0YWdlID0gY2FjaGUuZ2V0KCBjb2RlICk7XHJcblxyXG5cdFx0aWYgKCBzdGFnZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c3RhZ2UgPSBuZXcgV2ViR0xTaGFkZXJTdGFnZSggY29kZSApO1xyXG5cdFx0XHRjYWNoZS5zZXQoIGNvZGUsIHN0YWdlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdGFnZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgV2ViR0xTaGFkZXJTdGFnZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjb2RlICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBfaWQgKys7XHJcblxyXG5cdFx0dGhpcy5jb2RlID0gY29kZTtcclxuXHRcdHRoaXMudXNlZFRpbWVzID0gMDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgV2ViR0xTaGFkZXJDYWNoZSB9O1xyXG4iLCJpbXBvcnQgeyBCYWNrU2lkZSwgRG91YmxlU2lkZSwgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsIE9iamVjdFNwYWNlTm9ybWFsTWFwLCBUYW5nZW50U3BhY2VOb3JtYWxNYXAsIE5vVG9uZU1hcHBpbmcsIE5vcm1hbEJsZW5kaW5nLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IExheWVycyB9IGZyb20gJy4uLy4uL2NvcmUvTGF5ZXJzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xQcm9ncmFtIH0gZnJvbSAnLi9XZWJHTFByb2dyYW0uanMnO1xyXG5pbXBvcnQgeyBXZWJHTFNoYWRlckNhY2hlIH0gZnJvbSAnLi9XZWJHTFNoYWRlckNhY2hlLmpzJztcclxuaW1wb3J0IHsgU2hhZGVyTGliIH0gZnJvbSAnLi4vc2hhZGVycy9TaGFkZXJMaWIuanMnO1xyXG5pbXBvcnQgeyBVbmlmb3Jtc1V0aWxzIH0gZnJvbSAnLi4vc2hhZGVycy9Vbmlmb3Jtc1V0aWxzLmpzJztcclxuXHJcbmZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMoIHJlbmRlcmVyLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBiaW5kaW5nU3RhdGVzLCBjbGlwcGluZyApIHtcclxuXHJcblx0Y29uc3QgX3Byb2dyYW1MYXllcnMgPSBuZXcgTGF5ZXJzKCk7XHJcblx0Y29uc3QgX2N1c3RvbVNoYWRlcnMgPSBuZXcgV2ViR0xTaGFkZXJDYWNoZSgpO1xyXG5cdGNvbnN0IHByb2dyYW1zID0gW107XHJcblxyXG5cdGNvbnN0IElTX1dFQkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcclxuXHRjb25zdCBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XHJcblx0Y29uc3QgU1VQUE9SVFNfVkVSVEVYX1RFWFRVUkVTID0gY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xyXG5cclxuXHRsZXQgcHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcclxuXHJcblx0Y29uc3Qgc2hhZGVySURzID0ge1xyXG5cdFx0TWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXHJcblx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXHJcblx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxyXG5cdFx0TWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXHJcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXHJcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcclxuXHRcdE1lc2hUb29uTWF0ZXJpYWw6ICd0b29uJyxcclxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxyXG5cdFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXHJcblx0XHRNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxyXG5cdFx0TGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXHJcblx0XHRMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxyXG5cdFx0UG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxyXG5cdFx0U2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnLFxyXG5cdFx0U3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q2hhbm5lbCggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gMCApIHJldHVybiAndXYnO1xyXG5cclxuXHRcdHJldHVybiBgdXYkeyB2YWx1ZSB9YDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKCBtYXRlcmlhbCwgbGlnaHRzLCBzaGFkb3dzLCBzY2VuZSwgb2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IGZvZyA9IHNjZW5lLmZvZztcclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cdFx0Y29uc3QgZW52aXJvbm1lbnQgPSBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gc2NlbmUuZW52aXJvbm1lbnQgOiBudWxsO1xyXG5cclxuXHRcdGNvbnN0IGVudk1hcCA9ICggbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcyApLmdldCggbWF0ZXJpYWwuZW52TWFwIHx8IGVudmlyb25tZW50ICk7XHJcblx0XHRjb25zdCBlbnZNYXBDdWJlVVZIZWlnaHQgPSAoICEhIGVudk1hcCApICYmICggZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgPyBlbnZNYXAuaW1hZ2UuaGVpZ2h0IDogbnVsbDtcclxuXHJcblx0XHRjb25zdCBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xyXG5cclxuXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXHJcblx0XHQvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIHByZWNpc2lvbiAhPT0gbWF0ZXJpYWwucHJlY2lzaW9uICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xyXG5cdFx0Y29uc3QgbW9ycGhUYXJnZXRzQ291bnQgPSAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XHJcblxyXG5cdFx0bGV0IG1vcnBoVGV4dHVyZVN0cmlkZSA9IDA7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG1vcnBoVGV4dHVyZVN0cmlkZSA9IDE7XHJcblx0XHRpZiAoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCApIG1vcnBoVGV4dHVyZVN0cmlkZSA9IDI7XHJcblx0XHRpZiAoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkgbW9ycGhUZXh0dXJlU3RyaWRlID0gMztcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyO1xyXG5cdFx0bGV0IGN1c3RvbVZlcnRleFNoYWRlcklELCBjdXN0b21GcmFnbWVudFNoYWRlcklEO1xyXG5cclxuXHRcdGlmICggc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzaGFkZXIgPSBTaGFkZXJMaWJbIHNoYWRlcklEIF07XHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXIudmVydGV4U2hhZGVyO1xyXG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyID0gbWF0ZXJpYWwudmVydGV4U2hhZGVyO1xyXG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdFx0X2N1c3RvbVNoYWRlcnMudXBkYXRlKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0Y3VzdG9tVmVydGV4U2hhZGVySUQgPSBfY3VzdG9tU2hhZGVycy5nZXRWZXJ0ZXhTaGFkZXJJRCggbWF0ZXJpYWwgKTtcclxuXHRcdFx0Y3VzdG9tRnJhZ21lbnRTaGFkZXJJRCA9IF9jdXN0b21TaGFkZXJzLmdldEZyYWdtZW50U2hhZGVySUQoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHJcblx0XHRjb25zdCBJU19JTlNUQU5DRURNRVNIID0gb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCA9PT0gdHJ1ZTtcclxuXHJcblx0XHRjb25zdCBIQVNfTUFQID0gISEgbWF0ZXJpYWwubWFwO1xyXG5cdFx0Y29uc3QgSEFTX01BVENBUCA9ICEhIG1hdGVyaWFsLm1hdGNhcDtcclxuXHRcdGNvbnN0IEhBU19FTlZNQVAgPSAhISBlbnZNYXA7XHJcblx0XHRjb25zdCBIQVNfQU9NQVAgPSAhISBtYXRlcmlhbC5hb01hcDtcclxuXHRcdGNvbnN0IEhBU19MSUdIVE1BUCA9ICEhIG1hdGVyaWFsLmxpZ2h0TWFwO1xyXG5cdFx0Y29uc3QgSEFTX0JVTVBNQVAgPSAhISBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0Y29uc3QgSEFTX05PUk1BTE1BUCA9ICEhIG1hdGVyaWFsLm5vcm1hbE1hcDtcclxuXHRcdGNvbnN0IEhBU19ESVNQTEFDRU1FTlRNQVAgPSAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHRjb25zdCBIQVNfRU1JU1NJVkVNQVAgPSAhISBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcblx0XHRjb25zdCBIQVNfTUVUQUxORVNTTUFQID0gISEgbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xyXG5cdFx0Y29uc3QgSEFTX1JPVUdITkVTU01BUCA9ICEhIG1hdGVyaWFsLnJvdWdobmVzc01hcDtcclxuXHJcblx0XHRjb25zdCBIQVNfQU5JU09UUk9QWSA9IG1hdGVyaWFsLmFuaXNvdHJvcHkgPiAwO1xyXG5cdFx0Y29uc3QgSEFTX0NMRUFSQ09BVCA9IG1hdGVyaWFsLmNsZWFyY29hdCA+IDA7XHJcblx0XHRjb25zdCBIQVNfSVJJREVTQ0VOQ0UgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDA7XHJcblx0XHRjb25zdCBIQVNfU0hFRU4gPSBtYXRlcmlhbC5zaGVlbiA+IDA7XHJcblx0XHRjb25zdCBIQVNfVFJBTlNNSVNTSU9OID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMDtcclxuXHJcblx0XHRjb25zdCBIQVNfQU5JU09UUk9QWU1BUCA9IEhBU19BTklTT1RST1BZICYmICEhIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXA7XHJcblxyXG5cdFx0Y29uc3QgSEFTX0NMRUFSQ09BVE1BUCA9IEhBU19DTEVBUkNPQVQgJiYgISEgbWF0ZXJpYWwuY2xlYXJjb2F0TWFwO1xyXG5cdFx0Y29uc3QgSEFTX0NMRUFSQ09BVF9OT1JNQUxNQVAgPSBIQVNfQ0xFQVJDT0FUICYmICEhIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcDtcclxuXHRcdGNvbnN0IEhBU19DTEVBUkNPQVRfUk9VR0hORVNTTUFQID0gSEFTX0NMRUFSQ09BVCAmJiAhISBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0Y29uc3QgSEFTX0lSSURFU0NFTkNFTUFQID0gSEFTX0lSSURFU0NFTkNFICYmICEhIG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwO1xyXG5cdFx0Y29uc3QgSEFTX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCA9IEhBU19JUklERVNDRU5DRSAmJiAhISBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcDtcclxuXHJcblx0XHRjb25zdCBIQVNfU0hFRU5fQ09MT1JNQVAgPSBIQVNfU0hFRU4gJiYgISEgbWF0ZXJpYWwuc2hlZW5Db2xvck1hcDtcclxuXHRcdGNvbnN0IEhBU19TSEVFTl9ST1VHSE5FU1NNQVAgPSBIQVNfU0hFRU4gJiYgISEgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0Y29uc3QgSEFTX1NQRUNVTEFSTUFQID0gISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblx0XHRjb25zdCBIQVNfU1BFQ1VMQVJfQ09MT1JNQVAgPSAhISBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwO1xyXG5cdFx0Y29uc3QgSEFTX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCA9ICEhIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xyXG5cclxuXHRcdGNvbnN0IEhBU19UUkFOU01JU1NJT05NQVAgPSBIQVNfVFJBTlNNSVNTSU9OICYmICEhIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcDtcclxuXHRcdGNvbnN0IEhBU19USElDS05FU1NNQVAgPSBIQVNfVFJBTlNNSVNTSU9OICYmICEhIG1hdGVyaWFsLnRoaWNrbmVzc01hcDtcclxuXHJcblx0XHRjb25zdCBIQVNfR1JBRElFTlRNQVAgPSAhISBtYXRlcmlhbC5ncmFkaWVudE1hcDtcclxuXHJcblx0XHRjb25zdCBIQVNfQUxQSEFNQVAgPSAhISBtYXRlcmlhbC5hbHBoYU1hcDtcclxuXHJcblx0XHRjb25zdCBIQVNfQUxQSEFURVNUID0gbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMDtcclxuXHJcblx0XHRjb25zdCBIQVNfQUxQSEFIQVNIID0gISEgbWF0ZXJpYWwuYWxwaGFIYXNoO1xyXG5cclxuXHRcdGNvbnN0IEhBU19FWFRFTlNJT05TID0gISEgbWF0ZXJpYWwuZXh0ZW5zaW9ucztcclxuXHJcblx0XHRjb25zdCBIQVNfQVRUUklCVVRFX1VWMSA9ICEhIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYxO1xyXG5cdFx0Y29uc3QgSEFTX0FUVFJJQlVURV9VVjIgPSAhISBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2MjtcclxuXHRcdGNvbnN0IEhBU19BVFRSSUJVVEVfVVYzID0gISEgZ2VvbWV0cnkuYXR0cmlidXRlcy51djM7XHJcblxyXG5cdFx0Y29uc3QgcGFyYW1ldGVycyA9IHtcclxuXHJcblx0XHRcdGlzV2ViR0wyOiBJU19XRUJHTDIsXHJcblxyXG5cdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXHJcblx0XHRcdHNoYWRlclR5cGU6IG1hdGVyaWFsLnR5cGUsXHJcblx0XHRcdHNoYWRlck5hbWU6IG1hdGVyaWFsLm5hbWUsXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleFNoYWRlcixcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50U2hhZGVyLFxyXG5cdFx0XHRkZWZpbmVzOiBtYXRlcmlhbC5kZWZpbmVzLFxyXG5cclxuXHRcdFx0Y3VzdG9tVmVydGV4U2hhZGVySUQ6IGN1c3RvbVZlcnRleFNoYWRlcklELFxyXG5cdFx0XHRjdXN0b21GcmFnbWVudFNoYWRlcklEOiBjdXN0b21GcmFnbWVudFNoYWRlcklELFxyXG5cclxuXHRcdFx0aXNSYXdTaGFkZXJNYXRlcmlhbDogbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCA9PT0gdHJ1ZSxcclxuXHRcdFx0Z2xzbFZlcnNpb246IG1hdGVyaWFsLmdsc2xWZXJzaW9uLFxyXG5cclxuXHRcdFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXHJcblxyXG5cdFx0XHRpbnN0YW5jaW5nOiBJU19JTlNUQU5DRURNRVNILFxyXG5cdFx0XHRpbnN0YW5jaW5nQ29sb3I6IElTX0lOU1RBTkNFRE1FU0ggJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwsXHJcblxyXG5cdFx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBTVVBQT1JUU19WRVJURVhfVEVYVFVSRVMsXHJcblx0XHRcdG91dHB1dENvbG9yU3BhY2U6ICggY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCApID8gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA6ICggY3VycmVudFJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlID8gY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLmNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZSApLFxyXG5cclxuXHRcdFx0bWFwOiBIQVNfTUFQLFxyXG5cdFx0XHRtYXRjYXA6IEhBU19NQVRDQVAsXHJcblx0XHRcdGVudk1hcDogSEFTX0VOVk1BUCxcclxuXHRcdFx0ZW52TWFwTW9kZTogSEFTX0VOVk1BUCAmJiBlbnZNYXAubWFwcGluZyxcclxuXHRcdFx0ZW52TWFwQ3ViZVVWSGVpZ2h0OiBlbnZNYXBDdWJlVVZIZWlnaHQsXHJcblx0XHRcdGFvTWFwOiBIQVNfQU9NQVAsXHJcblx0XHRcdGxpZ2h0TWFwOiBIQVNfTElHSFRNQVAsXHJcblx0XHRcdGJ1bXBNYXA6IEhBU19CVU1QTUFQLFxyXG5cdFx0XHRub3JtYWxNYXA6IEhBU19OT1JNQUxNQVAsXHJcblx0XHRcdGRpc3BsYWNlbWVudE1hcDogU1VQUE9SVFNfVkVSVEVYX1RFWFRVUkVTICYmIEhBU19ESVNQTEFDRU1FTlRNQVAsXHJcblx0XHRcdGVtaXNzaXZlTWFwOiBIQVNfRU1JU1NJVkVNQVAsXHJcblxyXG5cdFx0XHRub3JtYWxNYXBPYmplY3RTcGFjZTogSEFTX05PUk1BTE1BUCAmJiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBPYmplY3RTcGFjZU5vcm1hbE1hcCxcclxuXHRcdFx0bm9ybWFsTWFwVGFuZ2VudFNwYWNlOiBIQVNfTk9STUFMTUFQICYmIG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPT09IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCxcclxuXHJcblx0XHRcdG1ldGFsbmVzc01hcDogSEFTX01FVEFMTkVTU01BUCxcclxuXHRcdFx0cm91Z2huZXNzTWFwOiBIQVNfUk9VR0hORVNTTUFQLFxyXG5cclxuXHRcdFx0YW5pc290cm9weTogSEFTX0FOSVNPVFJPUFksXHJcblx0XHRcdGFuaXNvdHJvcHlNYXA6IEhBU19BTklTT1RST1BZTUFQLFxyXG5cclxuXHRcdFx0Y2xlYXJjb2F0OiBIQVNfQ0xFQVJDT0FULFxyXG5cdFx0XHRjbGVhcmNvYXRNYXA6IEhBU19DTEVBUkNPQVRNQVAsXHJcblx0XHRcdGNsZWFyY29hdE5vcm1hbE1hcDogSEFTX0NMRUFSQ09BVF9OT1JNQUxNQVAsXHJcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcDogSEFTX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVAsXHJcblxyXG5cdFx0XHRpcmlkZXNjZW5jZTogSEFTX0lSSURFU0NFTkNFLFxyXG5cdFx0XHRpcmlkZXNjZW5jZU1hcDogSEFTX0lSSURFU0NFTkNFTUFQLFxyXG5cdFx0XHRpcmlkZXNjZW5jZVRoaWNrbmVzc01hcDogSEFTX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCxcclxuXHJcblx0XHRcdHNoZWVuOiBIQVNfU0hFRU4sXHJcblx0XHRcdHNoZWVuQ29sb3JNYXA6IEhBU19TSEVFTl9DT0xPUk1BUCxcclxuXHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXA6IEhBU19TSEVFTl9ST1VHSE5FU1NNQVAsXHJcblxyXG5cdFx0XHRzcGVjdWxhck1hcDogSEFTX1NQRUNVTEFSTUFQLFxyXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwOiBIQVNfU1BFQ1VMQVJfQ09MT1JNQVAsXHJcblx0XHRcdHNwZWN1bGFySW50ZW5zaXR5TWFwOiBIQVNfU1BFQ1VMQVJfSU5URU5TSVRZTUFQLFxyXG5cclxuXHRcdFx0dHJhbnNtaXNzaW9uOiBIQVNfVFJBTlNNSVNTSU9OLFxyXG5cdFx0XHR0cmFuc21pc3Npb25NYXA6IEhBU19UUkFOU01JU1NJT05NQVAsXHJcblx0XHRcdHRoaWNrbmVzc01hcDogSEFTX1RISUNLTkVTU01BUCxcclxuXHJcblx0XHRcdGdyYWRpZW50TWFwOiBIQVNfR1JBRElFTlRNQVAsXHJcblxyXG5cdFx0XHRvcGFxdWU6IG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSBmYWxzZSAmJiBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcsXHJcblxyXG5cdFx0XHRhbHBoYU1hcDogSEFTX0FMUEhBTUFQLFxyXG5cdFx0XHRhbHBoYVRlc3Q6IEhBU19BTFBIQVRFU1QsXHJcblx0XHRcdGFscGhhSGFzaDogSEFTX0FMUEhBSEFTSCxcclxuXHJcblx0XHRcdGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0bWFwVXY6IEhBU19NQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwubWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0YW9NYXBVdjogSEFTX0FPTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmFvTWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0bGlnaHRNYXBVdjogSEFTX0xJR0hUTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmxpZ2h0TWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0YnVtcE1hcFV2OiBIQVNfQlVNUE1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5idW1wTWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0bm9ybWFsTWFwVXY6IEhBU19OT1JNQUxNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwubm9ybWFsTWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0ZGlzcGxhY2VtZW50TWFwVXY6IEhBU19ESVNQTEFDRU1FTlRNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0ZW1pc3NpdmVNYXBVdjogSEFTX0VNSVNTSVZFTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmVtaXNzaXZlTWFwLmNoYW5uZWwgKSxcclxuXHJcblx0XHRcdG1ldGFsbmVzc01hcFV2OiBIQVNfTUVUQUxORVNTTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLm1ldGFsbmVzc01hcC5jaGFubmVsICksXHJcblx0XHRcdHJvdWdobmVzc01hcFV2OiBIQVNfUk9VR0hORVNTTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLnJvdWdobmVzc01hcC5jaGFubmVsICksXHJcblxyXG5cdFx0XHRhbmlzb3Ryb3B5TWFwVXY6IEhBU19BTklTT1RST1BZTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAuY2hhbm5lbCApLFxyXG5cclxuXHRcdFx0Y2xlYXJjb2F0TWFwVXY6IEhBU19DTEVBUkNPQVRNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuY2xlYXJjb2F0TWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0Y2xlYXJjb2F0Tm9ybWFsTWFwVXY6IEhBU19DTEVBUkNPQVRfTk9STUFMTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcC5jaGFubmVsICksXHJcblx0XHRcdGNsZWFyY29hdFJvdWdobmVzc01hcFV2OiBIQVNfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAuY2hhbm5lbCApLFxyXG5cclxuXHRcdFx0aXJpZGVzY2VuY2VNYXBVdjogSEFTX0lSSURFU0NFTkNFTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0aXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdjogSEFTX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcC5jaGFubmVsICksXHJcblxyXG5cdFx0XHRzaGVlbkNvbG9yTWFwVXY6IEhBU19TSEVFTl9DT0xPUk1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0c2hlZW5Sb3VnaG5lc3NNYXBVdjogSEFTX1NIRUVOX1JPVUdITkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcC5jaGFubmVsICksXHJcblxyXG5cdFx0XHRzcGVjdWxhck1hcFV2OiBIQVNfU1BFQ1VMQVJNQVAgJiYgZ2V0Q2hhbm5lbCggbWF0ZXJpYWwuc3BlY3VsYXJNYXAuY2hhbm5lbCApLFxyXG5cdFx0XHRzcGVjdWxhckNvbG9yTWFwVXY6IEhBU19TUEVDVUxBUl9DT0xPUk1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwLmNoYW5uZWwgKSxcclxuXHRcdFx0c3BlY3VsYXJJbnRlbnNpdHlNYXBVdjogSEFTX1NQRUNVTEFSX0lOVEVOU0lUWU1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcC5jaGFubmVsICksXHJcblxyXG5cdFx0XHR0cmFuc21pc3Npb25NYXBVdjogSEFTX1RSQU5TTUlTU0lPTk1BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC50cmFuc21pc3Npb25NYXAuY2hhbm5lbCApLFxyXG5cdFx0XHR0aGlja25lc3NNYXBVdjogSEFTX1RISUNLTkVTU01BUCAmJiBnZXRDaGFubmVsKCBtYXRlcmlhbC50aGlja25lc3NNYXAuY2hhbm5lbCApLFxyXG5cclxuXHRcdFx0YWxwaGFNYXBVdjogSEFTX0FMUEhBTUFQICYmIGdldENoYW5uZWwoIG1hdGVyaWFsLmFscGhhTWFwLmNoYW5uZWwgKSxcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHR2ZXJ0ZXhUYW5nZW50czogISEgZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ICYmICggSEFTX05PUk1BTE1BUCB8fCBIQVNfQU5JU09UUk9QWSApLFxyXG5cdFx0XHR2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcclxuXHRcdFx0dmVydGV4QWxwaGFzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgISEgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLml0ZW1TaXplID09PSA0LFxyXG5cdFx0XHR2ZXJ0ZXhVdjFzOiBIQVNfQVRUUklCVVRFX1VWMSxcclxuXHRcdFx0dmVydGV4VXYyczogSEFTX0FUVFJJQlVURV9VVjIsXHJcblx0XHRcdHZlcnRleFV2M3M6IEhBU19BVFRSSUJVVEVfVVYzLFxyXG5cclxuXHRcdFx0cG9pbnRzVXZzOiBvYmplY3QuaXNQb2ludHMgPT09IHRydWUgJiYgISEgZ2VvbWV0cnkuYXR0cmlidXRlcy51diAmJiAoIEhBU19NQVAgfHwgSEFTX0FMUEhBTUFQICksXHJcblxyXG5cdFx0XHRmb2c6ICEhIGZvZyxcclxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2cgPT09IHRydWUsXHJcblx0XHRcdGZvZ0V4cDI6ICggZm9nICYmIGZvZy5pc0ZvZ0V4cDIgKSxcclxuXHJcblx0XHRcdGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5mbGF0U2hhZGluZyA9PT0gdHJ1ZSxcclxuXHJcblx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID09PSB0cnVlLFxyXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxyXG5cclxuXHRcdFx0c2tpbm5pbmc6IG9iamVjdC5pc1NraW5uZWRNZXNoID09PSB0cnVlLFxyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCxcclxuXHRcdFx0bW9ycGhOb3JtYWxzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQsXHJcblx0XHRcdG1vcnBoQ29sb3JzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCxcclxuXHRcdFx0bW9ycGhUYXJnZXRzQ291bnQ6IG1vcnBoVGFyZ2V0c0NvdW50LFxyXG5cdFx0XHRtb3JwaFRleHR1cmVTdHJpZGU6IG1vcnBoVGV4dHVyZVN0cmlkZSxcclxuXHJcblx0XHRcdG51bURpckxpZ2h0czogbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCxcclxuXHRcdFx0bnVtUG9pbnRMaWdodHM6IGxpZ2h0cy5wb2ludC5sZW5ndGgsXHJcblx0XHRcdG51bVNwb3RMaWdodHM6IGxpZ2h0cy5zcG90Lmxlbmd0aCxcclxuXHRcdFx0bnVtU3BvdExpZ2h0TWFwczogbGlnaHRzLnNwb3RMaWdodE1hcC5sZW5ndGgsXHJcblx0XHRcdG51bVJlY3RBcmVhTGlnaHRzOiBsaWdodHMucmVjdEFyZWEubGVuZ3RoLFxyXG5cdFx0XHRudW1IZW1pTGlnaHRzOiBsaWdodHMuaGVtaS5sZW5ndGgsXHJcblxyXG5cdFx0XHRudW1EaXJMaWdodFNoYWRvd3M6IGxpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcC5sZW5ndGgsXHJcblx0XHRcdG51bVBvaW50TGlnaHRTaGFkb3dzOiBsaWdodHMucG9pbnRTaGFkb3dNYXAubGVuZ3RoLFxyXG5cdFx0XHRudW1TcG90TGlnaHRTaGFkb3dzOiBsaWdodHMuc3BvdFNoYWRvd01hcC5sZW5ndGgsXHJcblx0XHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogbGlnaHRzLm51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwcyxcclxuXHJcblx0XHRcdG51bUNsaXBwaW5nUGxhbmVzOiBjbGlwcGluZy5udW1QbGFuZXMsXHJcblx0XHRcdG51bUNsaXBJbnRlcnNlY3Rpb246IGNsaXBwaW5nLm51bUludGVyc2VjdGlvbixcclxuXHJcblx0XHRcdGRpdGhlcmluZzogbWF0ZXJpYWwuZGl0aGVyaW5nLFxyXG5cclxuXHRcdFx0c2hhZG93TWFwRW5hYmxlZDogcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgJiYgc2hhZG93cy5sZW5ndGggPiAwLFxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcclxuXHJcblx0XHRcdHRvbmVNYXBwaW5nOiBtYXRlcmlhbC50b25lTWFwcGVkID8gcmVuZGVyZXIudG9uZU1hcHBpbmcgOiBOb1RvbmVNYXBwaW5nLFxyXG5cdFx0XHR1c2VMZWdhY3lMaWdodHM6IHJlbmRlcmVyLnVzZUxlZ2FjeUxpZ2h0cyxcclxuXHJcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhLFxyXG5cclxuXHRcdFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUsXHJcblx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUsXHJcblxyXG5cdFx0XHR1c2VEZXB0aFBhY2tpbmc6IG1hdGVyaWFsLmRlcHRoUGFja2luZyA+PSAwLFxyXG5cdFx0XHRkZXB0aFBhY2tpbmc6IG1hdGVyaWFsLmRlcHRoUGFja2luZyB8fCAwLFxyXG5cclxuXHRcdFx0aW5kZXgwQXR0cmlidXRlTmFtZTogbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSxcclxuXHJcblx0XHRcdGV4dGVuc2lvbkRlcml2YXRpdmVzOiBIQVNfRVhURU5TSU9OUyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLmRlcml2YXRpdmVzID09PSB0cnVlLFxyXG5cdFx0XHRleHRlbnNpb25GcmFnRGVwdGg6IEhBU19FWFRFTlNJT05TICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMuZnJhZ0RlcHRoID09PSB0cnVlLFxyXG5cdFx0XHRleHRlbnNpb25EcmF3QnVmZmVyczogSEFTX0VYVEVOU0lPTlMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycyA9PT0gdHJ1ZSxcclxuXHRcdFx0ZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRDogSEFTX0VYVEVOU0lPTlMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EID09PSB0cnVlLFxyXG5cclxuXHRcdFx0cmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGg6IElTX1dFQkdMMiB8fCBleHRlbnNpb25zLmhhcyggJ0VYVF9mcmFnX2RlcHRoJyApLFxyXG5cdFx0XHRyZW5kZXJlckV4dGVuc2lvbkRyYXdCdWZmZXJzOiBJU19XRUJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoICdXRUJHTF9kcmF3X2J1ZmZlcnMnICksXHJcblx0XHRcdHJlbmRlcmVyRXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxvZDogSVNfV0VCR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSxcclxuXHJcblx0XHRcdGN1c3RvbVByb2dyYW1DYWNoZUtleTogbWF0ZXJpYWwuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KClcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBwYXJhbWV0ZXJzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFByb2dyYW1DYWNoZUtleSggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRjb25zdCBhcnJheSA9IFtdO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcclxuXHJcblx0XHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc2hhZGVySUQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5jdXN0b21WZXJ0ZXhTaGFkZXJJRCApO1xyXG5cdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmN1c3RvbUZyYWdtZW50U2hhZGVySUQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gcGFyYW1ldGVycy5kZWZpbmVzICkge1xyXG5cclxuXHRcdFx0XHRhcnJheS5wdXNoKCBuYW1lICk7XHJcblx0XHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5kZWZpbmVzWyBuYW1lIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Z2V0UHJvZ3JhbUNhY2hlS2V5UGFyYW1ldGVycyggYXJyYXksIHBhcmFtZXRlcnMgKTtcclxuXHRcdFx0Z2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoIGFycmF5LCBwYXJhbWV0ZXJzICk7XHJcblx0XHRcdGFycmF5LnB1c2goIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkgKTtcclxuXHJcblx0XHRyZXR1cm4gYXJyYXkuam9pbigpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFByb2dyYW1DYWNoZUtleVBhcmFtZXRlcnMoIGFycmF5LCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMucHJlY2lzaW9uICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm91dHB1dENvbG9yU3BhY2UgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZW52TWFwTW9kZSApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5lbnZNYXBDdWJlVVZIZWlnaHQgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYWxwaGFNYXBVdiApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5saWdodE1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmFvTWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYnVtcE1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm5vcm1hbE1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMucm91Z2huZXNzTWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuYW5pc290cm9weU1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmNsZWFyY29hdE1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmNsZWFyY29hdFJvdWdobmVzc01hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmlyaWRlc2NlbmNlTWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBVdiApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwVXYgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXBVdiApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zcGVjdWxhck1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNwZWN1bGFyQ29sb3JNYXBVdiApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnRoaWNrbmVzc01hcFV2ICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLmNvbWJpbmUgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuZm9nRXhwMiApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubW9ycGhBdHRyaWJ1dGVDb3VudCApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1EaXJMaWdodHMgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5udW1TcG90TGlnaHRNYXBzICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bUhlbWlMaWdodHMgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtUmVjdEFyZWFMaWdodHMgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRTaGFkb3dzICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRTaGFkb3dzICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzICk7XHJcblx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMgKTtcclxuXHRcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMubnVtQ2xpcEludGVyc2VjdGlvbiApO1xyXG5cdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXlCb29sZWFucyggYXJyYXksIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0X3Byb2dyYW1MYXllcnMuZGlzYWJsZUFsbCgpO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5pc1dlYkdMMiApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMCApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5pbnN0YW5jaW5nIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAyICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAzICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMubWF0Y2FwIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA0ICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA1ICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMubm9ybWFsTWFwT2JqZWN0U3BhY2UgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDYgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5ub3JtYWxNYXBUYW5nZW50U3BhY2UgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDcgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5jbGVhcmNvYXQgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDggKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5pcmlkZXNjZW5jZSApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOSApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmFscGhhVGVzdCApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTAgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDExICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4QWxwaGFzIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxMiApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnZlcnRleFV2MXMgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEzICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMudmVydGV4VXYycyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTQgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy52ZXJ0ZXhVdjNzIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNSApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnZlcnRleFRhbmdlbnRzIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNiApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmFuaXNvdHJvcHkgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDE3ICk7XHJcblxyXG5cdFx0YXJyYXkucHVzaCggX3Byb2dyYW1MYXllcnMubWFzayApO1xyXG5cdFx0X3Byb2dyYW1MYXllcnMuZGlzYWJsZUFsbCgpO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5mb2cgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDAgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy51c2VGb2cgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5mbGF0U2hhZGluZyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMiApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDMgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5za2lubmluZyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggNCApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggNSApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggNiApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA3ICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCA4ICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggOSApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnVzZUxlZ2FjeUxpZ2h0cyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTAgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5kb3VibGVTaWRlZCApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTEgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy5mbGlwU2lkZWQgKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDEyICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMudXNlRGVwdGhQYWNraW5nIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxMyApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmRpdGhlcmluZyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTQgKTtcclxuXHRcdGlmICggcGFyYW1ldGVycy50cmFuc21pc3Npb24gKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDE1ICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hlZW4gKVxyXG5cdFx0XHRfcHJvZ3JhbUxheWVycy5lbmFibGUoIDE2ICk7XHJcblx0XHRpZiAoIHBhcmFtZXRlcnMub3BhcXVlIClcclxuXHRcdFx0X3Byb2dyYW1MYXllcnMuZW5hYmxlKCAxNyApO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnBvaW50c1V2cyApXHJcblx0XHRcdF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSggMTggKTtcclxuXHJcblx0XHRhcnJheS5wdXNoKCBfcHJvZ3JhbUxheWVycy5tYXNrICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0VW5pZm9ybXMoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGNvbnN0IHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XHJcblx0XHRsZXQgdW5pZm9ybXM7XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJJRCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNoYWRlciA9IFNoYWRlckxpYlsgc2hhZGVySUQgXTtcclxuXHRcdFx0dW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuaWZvcm1zO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFjcXVpcmVQcm9ncmFtKCBwYXJhbWV0ZXJzLCBjYWNoZUtleSApIHtcclxuXHJcblx0XHRsZXQgcHJvZ3JhbTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcclxuXHRcdGZvciAoIGxldCBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHByZWV4aXN0aW5nUHJvZ3JhbSA9IHByb2dyYW1zWyBwIF07XHJcblxyXG5cdFx0XHRpZiAoIHByZWV4aXN0aW5nUHJvZ3JhbS5jYWNoZUtleSA9PT0gY2FjaGVLZXkgKSB7XHJcblxyXG5cdFx0XHRcdHByb2dyYW0gPSBwcmVleGlzdGluZ1Byb2dyYW07XHJcblx0XHRcdFx0KysgcHJvZ3JhbS51c2VkVGltZXM7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHByb2dyYW0gPSBuZXcgV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY2FjaGVLZXksIHBhcmFtZXRlcnMsIGJpbmRpbmdTdGF0ZXMgKTtcclxuXHRcdFx0cHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxyXG5cdFx0XHRjb25zdCBpID0gcHJvZ3JhbXMuaW5kZXhPZiggcHJvZ3JhbSApO1xyXG5cdFx0XHRwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcclxuXHRcdFx0cHJvZ3JhbXMucG9wKCk7XHJcblxyXG5cdFx0XHQvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xyXG5cdFx0XHRwcm9ncmFtLmRlc3Ryb3koKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVsZWFzZVNoYWRlckNhY2hlKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRfY3VzdG9tU2hhZGVycy5yZW1vdmUoIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuXHJcblx0XHRfY3VzdG9tU2hhZGVycy5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGdldFBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMsXHJcblx0XHRnZXRQcm9ncmFtQ2FjaGVLZXk6IGdldFByb2dyYW1DYWNoZUtleSxcclxuXHRcdGdldFVuaWZvcm1zOiBnZXRVbmlmb3JtcyxcclxuXHRcdGFjcXVpcmVQcm9ncmFtOiBhY3F1aXJlUHJvZ3JhbSxcclxuXHRcdHJlbGVhc2VQcm9ncmFtOiByZWxlYXNlUHJvZ3JhbSxcclxuXHRcdHJlbGVhc2VTaGFkZXJDYWNoZTogcmVsZWFzZVNoYWRlckNhY2hlLFxyXG5cdFx0Ly8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxyXG5cdFx0cHJvZ3JhbXM6IHByb2dyYW1zLFxyXG5cdFx0ZGlzcG9zZTogZGlzcG9zZVxyXG5cdH07XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBXZWJHTFByb2dyYW1zIH07XHJcbiIsImZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcclxuXHJcblx0bGV0IHByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcclxuXHJcblx0XHRsZXQgbWFwID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtYXAgPSB7fTtcclxuXHRcdFx0cHJvcGVydGllcy5zZXQoIG9iamVjdCwgbWFwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXA7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIG9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0LCBrZXksIHZhbHVlICkge1xyXG5cclxuXHRcdHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKVsga2V5IF0gPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xyXG5cclxuXHRcdHByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRnZXQ6IGdldCxcclxuXHRcdHJlbW92ZTogcmVtb3ZlLFxyXG5cdFx0dXBkYXRlOiB1cGRhdGUsXHJcblx0XHRkaXNwb3NlOiBkaXNwb3NlXHJcblx0fTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTFByb3BlcnRpZXMgfTtcclxuIiwiZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XHJcblxyXG5cdGlmICggYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEuZ3JvdXBPcmRlciAtIGIuZ3JvdXBPcmRlcjtcclxuXHJcblx0fSBlbHNlIGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRyZXR1cm4gYS56IC0gYi56O1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xyXG5cclxuXHRpZiAoIGEuZ3JvdXBPcmRlciAhPT0gYi5ncm91cE9yZGVyICkge1xyXG5cclxuXHRcdHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdCgpIHtcclxuXHJcblx0Y29uc3QgcmVuZGVySXRlbXMgPSBbXTtcclxuXHRsZXQgcmVuZGVySXRlbXNJbmRleCA9IDA7XHJcblxyXG5cdGNvbnN0IG9wYXF1ZSA9IFtdO1xyXG5cdGNvbnN0IHRyYW5zbWlzc2l2ZSA9IFtdO1xyXG5cdGNvbnN0IHRyYW5zcGFyZW50ID0gW107XHJcblxyXG5cdGZ1bmN0aW9uIGluaXQoKSB7XHJcblxyXG5cdFx0cmVuZGVySXRlbXNJbmRleCA9IDA7XHJcblxyXG5cdFx0b3BhcXVlLmxlbmd0aCA9IDA7XHJcblx0XHR0cmFuc21pc3NpdmUubGVuZ3RoID0gMDtcclxuXHRcdHRyYW5zcGFyZW50Lmxlbmd0aCA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApIHtcclxuXHJcblx0XHRsZXQgcmVuZGVySXRlbSA9IHJlbmRlckl0ZW1zWyByZW5kZXJJdGVtc0luZGV4IF07XHJcblxyXG5cdFx0aWYgKCByZW5kZXJJdGVtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJJdGVtID0ge1xyXG5cdFx0XHRcdGlkOiBvYmplY3QuaWQsXHJcblx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxyXG5cdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcclxuXHRcdFx0XHRncm91cE9yZGVyOiBncm91cE9yZGVyLFxyXG5cdFx0XHRcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXHJcblx0XHRcdFx0ejogeixcclxuXHRcdFx0XHRncm91cDogZ3JvdXBcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJlbmRlckl0ZW1zWyByZW5kZXJJdGVtc0luZGV4IF0gPSByZW5kZXJJdGVtO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdFx0cmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXBPcmRlciA9IGdyb3VwT3JkZXI7XHJcblx0XHRcdHJlbmRlckl0ZW0ucmVuZGVyT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XHJcblx0XHRcdHJlbmRlckl0ZW0ueiA9IHo7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVySXRlbXNJbmRleCArKztcclxuXHJcblx0XHRyZXR1cm4gcmVuZGVySXRlbTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXAgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXAgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAuMCApIHtcclxuXHJcblx0XHRcdHRyYW5zbWlzc2l2ZS5wdXNoKCByZW5kZXJJdGVtICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0cmFuc3BhcmVudC5wdXNoKCByZW5kZXJJdGVtICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG9wYXF1ZS5wdXNoKCByZW5kZXJJdGVtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVuc2hpZnQoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJJdGVtID0gZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCApO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMC4wICkge1xyXG5cclxuXHRcdFx0dHJhbnNtaXNzaXZlLnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRyYW5zcGFyZW50LnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0b3BhcXVlLnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc29ydCggY3VzdG9tT3BhcXVlU29ydCwgY3VzdG9tVHJhbnNwYXJlbnRTb3J0ICkge1xyXG5cclxuXHRcdGlmICggb3BhcXVlLmxlbmd0aCA+IDEgKSBvcGFxdWUuc29ydCggY3VzdG9tT3BhcXVlU29ydCB8fCBwYWludGVyU29ydFN0YWJsZSApO1xyXG5cdFx0aWYgKCB0cmFuc21pc3NpdmUubGVuZ3RoID4gMSApIHRyYW5zbWlzc2l2ZS5zb3J0KCBjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblx0XHRpZiAoIHRyYW5zcGFyZW50Lmxlbmd0aCA+IDEgKSB0cmFuc3BhcmVudC5zb3J0KCBjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZmluaXNoKCkge1xyXG5cclxuXHRcdC8vIENsZWFyIHJlZmVyZW5jZXMgZnJvbSBpbmFjdGl2ZSByZW5kZXJJdGVtcyBpbiB0aGUgbGlzdFxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gcmVuZGVySXRlbXNJbmRleCwgaWwgPSByZW5kZXJJdGVtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSByZW5kZXJJdGVtc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJJdGVtLmlkID09PSBudWxsICkgYnJlYWs7XHJcblxyXG5cdFx0XHRyZW5kZXJJdGVtLmlkID0gbnVsbDtcclxuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBudWxsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gbnVsbDtcclxuXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG51bGw7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdG9wYXF1ZTogb3BhcXVlLFxyXG5cdFx0dHJhbnNtaXNzaXZlOiB0cmFuc21pc3NpdmUsXHJcblx0XHR0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQsXHJcblxyXG5cdFx0aW5pdDogaW5pdCxcclxuXHRcdHB1c2g6IHB1c2gsXHJcblx0XHR1bnNoaWZ0OiB1bnNoaWZ0LFxyXG5cdFx0ZmluaXNoOiBmaW5pc2gsXHJcblxyXG5cdFx0c29ydDogc29ydFxyXG5cdH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBXZWJHTFJlbmRlckxpc3RzKCkge1xyXG5cclxuXHRsZXQgbGlzdHMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRmdW5jdGlvbiBnZXQoIHNjZW5lLCByZW5kZXJDYWxsRGVwdGggKSB7XHJcblxyXG5cdFx0Y29uc3QgbGlzdEFycmF5ID0gbGlzdHMuZ2V0KCBzY2VuZSApO1xyXG5cdFx0bGV0IGxpc3Q7XHJcblxyXG5cdFx0aWYgKCBsaXN0QXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KCk7XHJcblx0XHRcdGxpc3RzLnNldCggc2NlbmUsIFsgbGlzdCBdICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ2FsbERlcHRoID49IGxpc3RBcnJheS5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KCk7XHJcblx0XHRcdFx0bGlzdEFycmF5LnB1c2goIGxpc3QgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGxpc3QgPSBsaXN0QXJyYXlbIHJlbmRlckNhbGxEZXB0aCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGlzdDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkaXNwb3NlKCkge1xyXG5cclxuXHRcdGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Z2V0OiBnZXQsXHJcblx0XHRkaXNwb3NlOiBkaXNwb3NlXHJcblx0fTtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTFJlbmRlckxpc3RzLCBXZWJHTFJlbmRlckxpc3QgfTtcclxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgVW5pZm9ybXNMaWIgfSBmcm9tICcuLi9zaGFkZXJzL1VuaWZvcm1zTGliLmpzJztcclxuXHJcbmZ1bmN0aW9uIFVuaWZvcm1zQ2FjaGUoKSB7XHJcblxyXG5cdGNvbnN0IGxpZ2h0cyA9IHt9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCBsaWdodCApIHtcclxuXHJcblx0XHRcdGlmICggbGlnaHRzWyBsaWdodC5pZCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBsaWdodHNbIGxpZ2h0LmlkIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgdW5pZm9ybXM7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBsaWdodC50eXBlICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxyXG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcclxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXHJcblx0XHRcdFx0XHRcdGNvbmVDb3M6IDAsXHJcblx0XHRcdFx0XHRcdHBlbnVtYnJhQ29zOiAwLFxyXG5cdFx0XHRcdFx0XHRkZWNheTogMFxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcclxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxyXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogMCxcclxuXHRcdFx0XHRcdFx0ZGVjYXk6IDBcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0XHRcdHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcclxuXHRcdFx0XHRcdFx0Z3JvdW5kQ29sb3I6IG5ldyBDb2xvcigpXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxyXG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcclxuXHRcdFx0XHRcdFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0XHRcdGhhbGZXaWR0aDogbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdFx0aGFsZkhlaWdodDogbmV3IFZlY3RvcjMoKVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGlnaHRzWyBsaWdodC5pZCBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdW5pZm9ybXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gU2hhZG93VW5pZm9ybXNDYWNoZSgpIHtcclxuXHJcblx0Y29uc3QgbGlnaHRzID0ge307XHJcblxyXG5cdHJldHVybiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGxpZ2h0c1sgbGlnaHQuaWQgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCB1bmlmb3JtcztcclxuXHJcblx0XHRcdHN3aXRjaCAoIGxpZ2h0LnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxyXG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXHJcblx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXHJcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcclxuXHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxyXG5cdFx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXHJcblx0XHRcdFx0XHRcdHNoYWRvd05vcm1hbEJpYXM6IDAsXHJcblx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcclxuXHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcclxuXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxyXG5cdFx0XHRcdFx0XHRzaGFkb3dOb3JtYWxCaWFzOiAwLFxyXG5cdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXHJcblx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKCksXHJcblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYU5lYXI6IDEsXHJcblx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjogMTAwMFxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2V0IFJlY3RBcmVhTGlnaHQgc2hhZG93IHVuaWZvcm1zXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdHJldHVybiB1bmlmb3JtcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuXHJcbmxldCBuZXh0VmVyc2lvbiA9IDA7XHJcblxyXG5mdW5jdGlvbiBzaGFkb3dDYXN0aW5nQW5kVGV4dHVyaW5nTGlnaHRzRmlyc3QoIGxpZ2h0QSwgbGlnaHRCICkge1xyXG5cclxuXHRyZXR1cm4gKCBsaWdodEIuY2FzdFNoYWRvdyA/IDIgOiAwICkgLSAoIGxpZ2h0QS5jYXN0U2hhZG93ID8gMiA6IDAgKSArICggbGlnaHRCLm1hcCA/IDEgOiAwICkgLSAoIGxpZ2h0QS5tYXAgPyAxIDogMCApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gV2ViR0xMaWdodHMoIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0Y29uc3QgY2FjaGUgPSBuZXcgVW5pZm9ybXNDYWNoZSgpO1xyXG5cclxuXHRjb25zdCBzaGFkb3dDYWNoZSA9IFNoYWRvd1VuaWZvcm1zQ2FjaGUoKTtcclxuXHJcblx0Y29uc3Qgc3RhdGUgPSB7XHJcblxyXG5cdFx0dmVyc2lvbjogMCxcclxuXHJcblx0XHRoYXNoOiB7XHJcblx0XHRcdGRpcmVjdGlvbmFsTGVuZ3RoOiAtIDEsXHJcblx0XHRcdHBvaW50TGVuZ3RoOiAtIDEsXHJcblx0XHRcdHNwb3RMZW5ndGg6IC0gMSxcclxuXHRcdFx0cmVjdEFyZWFMZW5ndGg6IC0gMSxcclxuXHRcdFx0aGVtaUxlbmd0aDogLSAxLFxyXG5cclxuXHRcdFx0bnVtRGlyZWN0aW9uYWxTaGFkb3dzOiAtIDEsXHJcblx0XHRcdG51bVBvaW50U2hhZG93czogLSAxLFxyXG5cdFx0XHRudW1TcG90U2hhZG93czogLSAxLFxyXG5cdFx0XHRudW1TcG90TWFwczogLSAxXHJcblx0XHR9LFxyXG5cclxuXHRcdGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxyXG5cdFx0cHJvYmU6IFtdLFxyXG5cdFx0ZGlyZWN0aW9uYWw6IFtdLFxyXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3c6IFtdLFxyXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IFtdLFxyXG5cdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxyXG5cdFx0c3BvdDogW10sXHJcblx0XHRzcG90TGlnaHRNYXA6IFtdLFxyXG5cdFx0c3BvdFNoYWRvdzogW10sXHJcblx0XHRzcG90U2hhZG93TWFwOiBbXSxcclxuXHRcdHNwb3RMaWdodE1hdHJpeDogW10sXHJcblx0XHRyZWN0QXJlYTogW10sXHJcblx0XHRyZWN0QXJlYUxUQzE6IG51bGwsXHJcblx0XHRyZWN0QXJlYUxUQzI6IG51bGwsXHJcblx0XHRwb2ludDogW10sXHJcblx0XHRwb2ludFNoYWRvdzogW10sXHJcblx0XHRwb2ludFNoYWRvd01hcDogW10sXHJcblx0XHRwb2ludFNoYWRvd01hdHJpeDogW10sXHJcblx0XHRoZW1pOiBbXSxcclxuXHRcdG51bVNwb3RMaWdodFNoYWRvd3NXaXRoTWFwczogMFxyXG5cclxuXHR9O1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkgc3RhdGUucHJvYmUucHVzaCggbmV3IFZlY3RvcjMoKSApO1xyXG5cclxuXHRjb25zdCB2ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcclxuXHRjb25zdCBtYXRyaXg0ID0gbmV3IE1hdHJpeDQoKTtcclxuXHRjb25zdCBtYXRyaXg0MiA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwKCBsaWdodHMsIHVzZUxlZ2FjeUxpZ2h0cyApIHtcclxuXHJcblx0XHRsZXQgciA9IDAsIGcgPSAwLCBiID0gMDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkgc3RhdGUucHJvYmVbIGkgXS5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRsZXQgZGlyZWN0aW9uYWxMZW5ndGggPSAwO1xyXG5cdFx0bGV0IHBvaW50TGVuZ3RoID0gMDtcclxuXHRcdGxldCBzcG90TGVuZ3RoID0gMDtcclxuXHRcdGxldCByZWN0QXJlYUxlbmd0aCA9IDA7XHJcblx0XHRsZXQgaGVtaUxlbmd0aCA9IDA7XHJcblxyXG5cdFx0bGV0IG51bURpcmVjdGlvbmFsU2hhZG93cyA9IDA7XHJcblx0XHRsZXQgbnVtUG9pbnRTaGFkb3dzID0gMDtcclxuXHRcdGxldCBudW1TcG90U2hhZG93cyA9IDA7XHJcblx0XHRsZXQgbnVtU3BvdE1hcHMgPSAwO1xyXG5cdFx0bGV0IG51bVNwb3RTaGFkb3dzV2l0aE1hcHMgPSAwO1xyXG5cclxuXHRcdC8vIG9yZGVyaW5nIDogW3NoYWRvdyBjYXN0aW5nICsgbWFwIHRleHR1cmluZywgbWFwIHRleHR1cmluZywgc2hhZG93IGNhc3RpbmcsIG5vbmUgXVxyXG5cdFx0bGlnaHRzLnNvcnQoIHNoYWRvd0Nhc3RpbmdBbmRUZXh0dXJpbmdMaWdodHNGaXJzdCApO1xyXG5cclxuXHRcdC8vIGFydGlzdC1mcmllbmRseSBsaWdodCBpbnRlbnNpdHkgc2NhbGluZyBmYWN0b3JcclxuXHRcdGNvbnN0IHNjYWxlRmFjdG9yID0gKCB1c2VMZWdhY3lMaWdodHMgPT09IHRydWUgKSA/IE1hdGguUEkgOiAxO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbGlnaHQgPSBsaWdodHNbIGkgXTtcclxuXHJcblx0XHRcdGNvbnN0IGNvbG9yID0gbGlnaHQuY29sb3I7XHJcblx0XHRcdGNvbnN0IGludGVuc2l0eSA9IGxpZ2h0LmludGVuc2l0eTtcclxuXHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcclxuXHJcblx0XHRcdGNvbnN0IHNoYWRvd01hcCA9ICggbGlnaHQuc2hhZG93ICYmIGxpZ2h0LnNoYWRvdy5tYXAgKSA/IGxpZ2h0LnNoYWRvdy5tYXAudGV4dHVyZSA6IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LmlzQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3RvcjtcclxuXHRcdFx0XHRnICs9IGNvbG9yLmcgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3RvcjtcclxuXHRcdFx0XHRiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3RvcjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzTGlnaHRQcm9iZSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgOTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5wcm9iZVsgaiBdLmFkZFNjYWxlZFZlY3RvciggbGlnaHQuc2guY29lZmZpY2llbnRzWyBqIF0sIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKiBzY2FsZUZhY3RvciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHNoYWRvd1VuaWZvcm1zID0gc2hhZG93Q2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcclxuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd05vcm1hbEJpYXMgPSBzaGFkb3cubm9ybWFsQmlhcztcclxuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBzaGFkb3dVbmlmb3JtcztcclxuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gc2hhZG93TWFwO1xyXG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xyXG5cclxuXHRcdFx0XHRcdG51bURpcmVjdGlvbmFsU2hhZG93cyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHVuaWZvcm1zO1xyXG5cclxuXHRcdFx0XHRkaXJlY3Rpb25hbExlbmd0aCArKztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzU3BvdExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKiBzY2FsZUZhY3RvciApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5wZW51bWJyYUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSAqICggMSAtIGxpZ2h0LnBlbnVtYnJhICkgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kZWNheSA9IGxpZ2h0LmRlY2F5O1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5zcG90WyBzcG90TGVuZ3RoIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0Lm1hcCApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXBbIG51bVNwb3RNYXBzIF0gPSBsaWdodC5tYXA7XHJcblx0XHRcdFx0XHRudW1TcG90TWFwcyArKztcclxuXHJcblx0XHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhlIGxpZ2h0TWF0cml4IGlzIHVwIHRvIGRhdGVcclxuXHRcdFx0XHRcdC8vIFRPRE8gOiBkbyBpdCBpZiByZXF1aXJlZCBvbmx5XHJcblx0XHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkgbnVtU3BvdFNoYWRvd3NXaXRoTWFwcyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXRyaXhbIHNwb3RMZW5ndGggXSA9IHNoYWRvdy5tYXRyaXg7XHJcblxyXG5cdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xyXG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnNwb3RTaGFkb3dbIHNwb3RMZW5ndGggXSA9IHNoYWRvd1VuaWZvcm1zO1xyXG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hcFsgc3BvdExlbmd0aCBdID0gc2hhZG93TWFwO1xyXG5cclxuXHRcdFx0XHRcdG51bVNwb3RTaGFkb3dzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNwb3RMZW5ndGggKys7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1JlY3RBcmVhTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBjb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuaGFsZldpZHRoLnNldCggbGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUucmVjdEFyZWFbIHJlY3RBcmVhTGVuZ3RoIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0cmVjdEFyZWFMZW5ndGggKys7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1BvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKiBzY2FsZUZhY3RvciApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcclxuXHJcblx0XHRcdFx0XHRjb25zdCBzaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XHJcblx0XHRcdFx0XHRzaGFkb3dVbmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xyXG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xyXG5cdFx0XHRcdFx0c2hhZG93VW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcclxuXHRcdFx0XHRcdHNoYWRvd1VuaWZvcm1zLnNoYWRvd0NhbWVyYUZhciA9IHNoYWRvdy5jYW1lcmEuZmFyO1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93WyBwb2ludExlbmd0aCBdID0gc2hhZG93VW5pZm9ybXM7XHJcblx0XHRcdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcFsgcG9pbnRMZW5ndGggXSA9IHNoYWRvd01hcDtcclxuXHRcdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcclxuXHJcblx0XHRcdFx0XHRudW1Qb2ludFNoYWRvd3MgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUucG9pbnRbIHBvaW50TGVuZ3RoIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0cG9pbnRMZW5ndGggKys7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0hlbWlzcGhlcmVMaWdodCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnNreUNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSAqIHNjYWxlRmFjdG9yICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZ3JvdW5kQ29sb3IuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICogc2NhbGVGYWN0b3IgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuaGVtaVsgaGVtaUxlbmd0aCBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHRcdGhlbWlMZW5ndGggKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVjdEFyZWFMZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFdlYkdMIDJcclxuXHJcblx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMxID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzE7XHJcblx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzI7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBXZWJHTCAxXHJcblxyXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5oYXMoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMxID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzE7XHJcblx0XHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzIgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZXh0ZW5zaW9ucy5oYXMoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfSEFMRl8xO1xyXG5cdFx0XHRcdFx0c3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0hBTEZfMjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5hYmxlIHRvIHVzZSBSZWN0QXJlYUxpZ2h0LiBNaXNzaW5nIFdlYkdMIGV4dGVuc2lvbnMuJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmFtYmllbnRbIDAgXSA9IHI7XHJcblx0XHRzdGF0ZS5hbWJpZW50WyAxIF0gPSBnO1xyXG5cdFx0c3RhdGUuYW1iaWVudFsgMiBdID0gYjtcclxuXHJcblx0XHRjb25zdCBoYXNoID0gc3RhdGUuaGFzaDtcclxuXHJcblx0XHRpZiAoIGhhc2guZGlyZWN0aW9uYWxMZW5ndGggIT09IGRpcmVjdGlvbmFsTGVuZ3RoIHx8XHJcblx0XHRcdGhhc2gucG9pbnRMZW5ndGggIT09IHBvaW50TGVuZ3RoIHx8XHJcblx0XHRcdGhhc2guc3BvdExlbmd0aCAhPT0gc3BvdExlbmd0aCB8fFxyXG5cdFx0XHRoYXNoLnJlY3RBcmVhTGVuZ3RoICE9PSByZWN0QXJlYUxlbmd0aCB8fFxyXG5cdFx0XHRoYXNoLmhlbWlMZW5ndGggIT09IGhlbWlMZW5ndGggfHxcclxuXHRcdFx0aGFzaC5udW1EaXJlY3Rpb25hbFNoYWRvd3MgIT09IG51bURpcmVjdGlvbmFsU2hhZG93cyB8fFxyXG5cdFx0XHRoYXNoLm51bVBvaW50U2hhZG93cyAhPT0gbnVtUG9pbnRTaGFkb3dzIHx8XHJcblx0XHRcdGhhc2gubnVtU3BvdFNoYWRvd3MgIT09IG51bVNwb3RTaGFkb3dzIHx8XHJcblx0XHRcdGhhc2gubnVtU3BvdE1hcHMgIT09IG51bVNwb3RNYXBzICkge1xyXG5cclxuXHRcdFx0c3RhdGUuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XHJcblx0XHRcdHN0YXRlLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcclxuXHRcdFx0c3RhdGUucmVjdEFyZWEubGVuZ3RoID0gcmVjdEFyZWFMZW5ndGg7XHJcblx0XHRcdHN0YXRlLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0XHRzdGF0ZS5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XHJcblxyXG5cdFx0XHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdy5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XHJcblx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwLmxlbmd0aCA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcclxuXHRcdFx0c3RhdGUucG9pbnRTaGFkb3cubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xyXG5cdFx0XHRzdGF0ZS5wb2ludFNoYWRvd01hcC5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XHJcblx0XHRcdHN0YXRlLnNwb3RTaGFkb3cubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3M7XHJcblx0XHRcdHN0YXRlLnNwb3RTaGFkb3dNYXAubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3M7XHJcblx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcclxuXHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXRyaXgubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xyXG5cdFx0XHRzdGF0ZS5zcG90TGlnaHRNYXRyaXgubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3MgKyBudW1TcG90TWFwcyAtIG51bVNwb3RTaGFkb3dzV2l0aE1hcHM7XHJcblx0XHRcdHN0YXRlLnNwb3RMaWdodE1hcC5sZW5ndGggPSBudW1TcG90TWFwcztcclxuXHRcdFx0c3RhdGUubnVtU3BvdExpZ2h0U2hhZG93c1dpdGhNYXBzID0gbnVtU3BvdFNoYWRvd3NXaXRoTWFwcztcclxuXHJcblx0XHRcdGhhc2guZGlyZWN0aW9uYWxMZW5ndGggPSBkaXJlY3Rpb25hbExlbmd0aDtcclxuXHRcdFx0aGFzaC5wb2ludExlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0XHRoYXNoLnNwb3RMZW5ndGggPSBzcG90TGVuZ3RoO1xyXG5cdFx0XHRoYXNoLnJlY3RBcmVhTGVuZ3RoID0gcmVjdEFyZWFMZW5ndGg7XHJcblx0XHRcdGhhc2guaGVtaUxlbmd0aCA9IGhlbWlMZW5ndGg7XHJcblxyXG5cdFx0XHRoYXNoLm51bURpcmVjdGlvbmFsU2hhZG93cyA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcclxuXHRcdFx0aGFzaC5udW1Qb2ludFNoYWRvd3MgPSBudW1Qb2ludFNoYWRvd3M7XHJcblx0XHRcdGhhc2gubnVtU3BvdFNoYWRvd3MgPSBudW1TcG90U2hhZG93cztcclxuXHRcdFx0aGFzaC5udW1TcG90TWFwcyA9IG51bVNwb3RNYXBzO1xyXG5cclxuXHRcdFx0c3RhdGUudmVyc2lvbiA9IG5leHRWZXJzaW9uICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXR1cFZpZXcoIGxpZ2h0cywgY2FtZXJhICkge1xyXG5cclxuXHRcdGxldCBkaXJlY3Rpb25hbExlbmd0aCA9IDA7XHJcblx0XHRsZXQgcG9pbnRMZW5ndGggPSAwO1xyXG5cdFx0bGV0IHNwb3RMZW5ndGggPSAwO1xyXG5cdFx0bGV0IHJlY3RBcmVhTGVuZ3RoID0gMDtcclxuXHRcdGxldCBoZW1pTGVuZ3RoID0gMDtcclxuXHJcblx0XHRjb25zdCB2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LmlzRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5kaXJlY3Rpb25hbFsgZGlyZWN0aW9uYWxMZW5ndGggXTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0ZGlyZWN0aW9uYWxMZW5ndGggKys7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1Nwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5zcG90WyBzcG90TGVuZ3RoIF07XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0c3BvdExlbmd0aCArKztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUmVjdEFyZWFMaWdodCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5yZWN0QXJlYVsgcmVjdEFyZWFMZW5ndGggXTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHQvLyBleHRyYWN0IGxvY2FsIHJvdGF0aW9uIG9mIGxpZ2h0IHRvIGRlcml2ZSB3aWR0aC9oZWlnaHQgaGFsZiB2ZWN0b3JzXHJcblx0XHRcdFx0bWF0cml4NDIuaWRlbnRpdHkoKTtcclxuXHRcdFx0XHRtYXRyaXg0LmNvcHkoIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0bWF0cml4NC5wcmVtdWx0aXBseSggdmlld01hdHJpeCApO1xyXG5cdFx0XHRcdG1hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbiggbWF0cml4NCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguc2V0KCBsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjAgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LnNldCggMC4wLCBsaWdodC5oZWlnaHQgKiAwLjUsIDAuMCApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmhhbGZIZWlnaHQuYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xyXG5cclxuXHRcdFx0XHRyZWN0QXJlYUxlbmd0aCArKztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBzdGF0ZS5wb2ludFsgcG9pbnRMZW5ndGggXTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRwb2ludExlbmd0aCArKztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB1bmlmb3JtcyA9IHN0YXRlLmhlbWlbIGhlbWlMZW5ndGggXTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdGhlbWlMZW5ndGggKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRzZXR1cDogc2V0dXAsXHJcblx0XHRzZXR1cFZpZXc6IHNldHVwVmlldyxcclxuXHRcdHN0YXRlOiBzdGF0ZVxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xMaWdodHMgfTtcclxuIiwiaW1wb3J0IHsgV2ViR0xMaWdodHMgfSBmcm9tICcuL1dlYkdMTGlnaHRzLmpzJztcclxuXHJcbmZ1bmN0aW9uIFdlYkdMUmVuZGVyU3RhdGUoIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0Y29uc3QgbGlnaHRzID0gbmV3IFdlYkdMTGlnaHRzKCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcclxuXHJcblx0Y29uc3QgbGlnaHRzQXJyYXkgPSBbXTtcclxuXHRjb25zdCBzaGFkb3dzQXJyYXkgPSBbXTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcblx0XHRsaWdodHNBcnJheS5sZW5ndGggPSAwO1xyXG5cdFx0c2hhZG93c0FycmF5Lmxlbmd0aCA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHVzaExpZ2h0KCBsaWdodCApIHtcclxuXHJcblx0XHRsaWdodHNBcnJheS5wdXNoKCBsaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHB1c2hTaGFkb3coIHNoYWRvd0xpZ2h0ICkge1xyXG5cclxuXHRcdHNoYWRvd3NBcnJheS5wdXNoKCBzaGFkb3dMaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwTGlnaHRzKCB1c2VMZWdhY3lMaWdodHMgKSB7XHJcblxyXG5cdFx0bGlnaHRzLnNldHVwKCBsaWdodHNBcnJheSwgdXNlTGVnYWN5TGlnaHRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBMaWdodHNWaWV3KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0bGlnaHRzLnNldHVwVmlldyggbGlnaHRzQXJyYXksIGNhbWVyYSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IHN0YXRlID0ge1xyXG5cdFx0bGlnaHRzQXJyYXk6IGxpZ2h0c0FycmF5LFxyXG5cdFx0c2hhZG93c0FycmF5OiBzaGFkb3dzQXJyYXksXHJcblxyXG5cdFx0bGlnaHRzOiBsaWdodHNcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0aW5pdDogaW5pdCxcclxuXHRcdHN0YXRlOiBzdGF0ZSxcclxuXHRcdHNldHVwTGlnaHRzOiBzZXR1cExpZ2h0cyxcclxuXHRcdHNldHVwTGlnaHRzVmlldzogc2V0dXBMaWdodHNWaWV3LFxyXG5cclxuXHRcdHB1c2hMaWdodDogcHVzaExpZ2h0LFxyXG5cdFx0cHVzaFNoYWRvdzogcHVzaFNoYWRvd1xyXG5cdH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBXZWJHTFJlbmRlclN0YXRlcyggZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzICkge1xyXG5cclxuXHRsZXQgcmVuZGVyU3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0KCBzY2VuZSwgcmVuZGVyQ2FsbERlcHRoID0gMCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJTdGF0ZUFycmF5ID0gcmVuZGVyU3RhdGVzLmdldCggc2NlbmUgKTtcclxuXHRcdGxldCByZW5kZXJTdGF0ZTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclN0YXRlQXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApO1xyXG5cdFx0XHRyZW5kZXJTdGF0ZXMuc2V0KCBzY2VuZSwgWyByZW5kZXJTdGF0ZSBdICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ2FsbERlcHRoID49IHJlbmRlclN0YXRlQXJyYXkubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcclxuXHRcdFx0XHRyZW5kZXJTdGF0ZUFycmF5LnB1c2goIHJlbmRlclN0YXRlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlQXJyYXlbIHJlbmRlckNhbGxEZXB0aCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVuZGVyU3RhdGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuXHJcblx0XHRyZW5kZXJTdGF0ZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRnZXQ6IGdldCxcclxuXHRcdGRpc3Bvc2U6IGRpc3Bvc2VcclxuXHR9O1xyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFdlYkdMUmVuZGVyU3RhdGVzIH07XHJcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IEJhc2ljRGVwdGhQYWNraW5nIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmNsYXNzIE1lc2hEZXB0aE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoRGVwdGhNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmRlcHRoUGFja2luZyA9IHNvdXJjZS5kZXB0aFBhY2tpbmc7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgTWVzaERlcHRoTWF0ZXJpYWwgfTtcclxuIiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcclxuXHJcbmNsYXNzIE1lc2hEaXN0YW5jZU1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hEaXN0YW5jZU1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgTWVzaERpc3RhbmNlTWF0ZXJpYWwgfTtcclxuIiwiZXhwb3J0IGNvbnN0IHZlcnRleCA9IC8qIGdsc2wgKi9gXHJcbnZvaWQgbWFpbigpIHtcclxuXHJcblx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XHJcblxyXG59XHJcbmA7XHJcblxyXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSAvKiBnbHNsICovYFxyXG51bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dfcGFzcztcclxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XHJcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xyXG5cclxuI2luY2x1ZGUgPHBhY2tpbmc+XHJcblxyXG52b2lkIG1haW4oKSB7XHJcblxyXG5cdGNvbnN0IGZsb2F0IHNhbXBsZXMgPSBmbG9hdCggVlNNX1NBTVBMRVMgKTtcclxuXHJcblx0ZmxvYXQgbWVhbiA9IDAuMDtcclxuXHRmbG9hdCBzcXVhcmVkX21lYW4gPSAwLjA7XHJcblxyXG5cdGZsb2F0IHV2U3RyaWRlID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAyLjAgLyAoIHNhbXBsZXMgLSAxLjAgKTtcclxuXHRmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDtcclxuXHRmb3IgKCBmbG9hdCBpID0gMC4wOyBpIDwgc2FtcGxlczsgaSArKyApIHtcclxuXHJcblx0XHRmbG9hdCB1dk9mZnNldCA9IHV2U3RhcnQgKyBpICogdXZTdHJpZGU7XHJcblxyXG5cdFx0I2lmZGVmIEhPUklaT05UQUxfUEFTU1xyXG5cclxuXHRcdFx0dmVjMiBkaXN0cmlidXRpb24gPSB1bnBhY2tSR0JBVG8ySGFsZiggdGV4dHVyZTJEKCBzaGFkb3dfcGFzcywgKCBnbF9GcmFnQ29vcmQueHkgKyB2ZWMyKCB1dk9mZnNldCwgMC4wICkgKiByYWRpdXMgKSAvIHJlc29sdXRpb24gKSApO1xyXG5cdFx0XHRtZWFuICs9IGRpc3RyaWJ1dGlvbi54O1xyXG5cdFx0XHRzcXVhcmVkX21lYW4gKz0gZGlzdHJpYnV0aW9uLnkgKiBkaXN0cmlidXRpb24ueSArIGRpc3RyaWJ1dGlvbi54ICogZGlzdHJpYnV0aW9uLng7XHJcblxyXG5cdFx0I2Vsc2VcclxuXHJcblx0XHRcdGZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcclxuXHRcdFx0bWVhbiArPSBkZXB0aDtcclxuXHRcdFx0c3F1YXJlZF9tZWFuICs9IGRlcHRoICogZGVwdGg7XHJcblxyXG5cdFx0I2VuZGlmXHJcblxyXG5cdH1cclxuXHJcblx0bWVhbiA9IG1lYW4gLyBzYW1wbGVzO1xyXG5cdHNxdWFyZWRfbWVhbiA9IHNxdWFyZWRfbWVhbiAvIHNhbXBsZXM7XHJcblxyXG5cdGZsb2F0IHN0ZF9kZXYgPSBzcXJ0KCBzcXVhcmVkX21lYW4gLSBtZWFuICogbWVhbiApO1xyXG5cclxuXHRnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApO1xyXG5cclxufVxyXG5gO1xyXG4iLCJpbXBvcnQgeyBGcm9udFNpZGUsIEJhY2tTaWRlLCBEb3VibGVTaWRlLCBOZWFyZXN0RmlsdGVyLCBQQ0ZTaGFkb3dNYXAsIFZTTVNoYWRvd01hcCwgUkdCQURlcHRoUGFja2luZywgTm9CbGVuZGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vV2ViR0xSZW5kZXJUYXJnZXQuanMnO1xyXG5pbXBvcnQgeyBNZXNoRGVwdGhNYXRlcmlhbCB9IGZyb20gJy4uLy4uL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IE1lc2hEaXN0YW5jZU1hdGVyaWFsIH0gZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL01lc2hEaXN0YW5jZU1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwgfSBmcm9tICcuLi8uLi9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi8uLi9vYmplY3RzL01lc2guanMnO1xyXG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IEZydXN0dW0gfSBmcm9tICcuLi8uLi9tYXRoL0ZydXN0dW0uanMnO1xyXG5cclxuaW1wb3J0ICogYXMgdnNtIGZyb20gJy4uL3NoYWRlcnMvU2hhZGVyTGliL3ZzbS5nbHNsLmpzJztcclxuXHJcbmZ1bmN0aW9uIFdlYkdMU2hhZG93TWFwKCBfcmVuZGVyZXIsIF9vYmplY3RzLCBfY2FwYWJpbGl0aWVzICkge1xyXG5cclxuXHRsZXQgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpO1xyXG5cclxuXHRjb25zdCBfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXHJcblx0XHRfdmlld3BvcnRTaXplID0gbmV3IFZlY3RvcjIoKSxcclxuXHJcblx0XHRfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLFxyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsID0gbmV3IE1lc2hEZXB0aE1hdGVyaWFsKCB7IGRlcHRoUGFja2luZzogUkdCQURlcHRoUGFja2luZyB9ICksXHJcblx0XHRfZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgpLFxyXG5cclxuXHRcdF9tYXRlcmlhbENhY2hlID0ge30sXHJcblxyXG5cdFx0X21heFRleHR1cmVTaXplID0gX2NhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcclxuXHJcblx0Y29uc3Qgc2hhZG93U2lkZSA9IHsgWyBGcm9udFNpZGUgXTogQmFja1NpZGUsIFsgQmFja1NpZGUgXTogRnJvbnRTaWRlLCBbIERvdWJsZVNpZGUgXTogRG91YmxlU2lkZSB9O1xyXG5cclxuXHRjb25zdCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRkZWZpbmVzOiB7XHJcblx0XHRcdFZTTV9TQU1QTEVTOiA4XHJcblx0XHR9LFxyXG5cdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0c2hhZG93X3Bhc3M6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0cmVzb2x1dGlvbjogeyB2YWx1ZTogbmV3IFZlY3RvcjIoKSB9LFxyXG5cdFx0XHRyYWRpdXM6IHsgdmFsdWU6IDQuMCB9XHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogdnNtLnZlcnRleCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiB2c20uZnJhZ21lbnRcclxuXHJcblx0fSApO1xyXG5cclxuXHRjb25zdCBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwgPSBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLmNsb25lKCk7XHJcblx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLmRlZmluZXMuSE9SSVpPTlRBTF9QQVNTID0gMTtcclxuXHJcblx0Y29uc3QgZnVsbFNjcmVlblRyaSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdGZ1bGxTY3JlZW5Ucmkuc2V0QXR0cmlidXRlKFxyXG5cdFx0J3Bvc2l0aW9uJyxcclxuXHRcdG5ldyBCdWZmZXJBdHRyaWJ1dGUoXHJcblx0XHRcdG5ldyBGbG9hdDMyQXJyYXkoIFsgLSAxLCAtIDEsIDAuNSwgMywgLSAxLCAwLjUsIC0gMSwgMywgMC41IF0gKSxcclxuXHRcdFx0M1xyXG5cdFx0KVxyXG5cdCk7XHJcblxyXG5cdGNvbnN0IGZ1bGxTY3JlZW5NZXNoID0gbmV3IE1lc2goIGZ1bGxTY3JlZW5UcmksIHNoYWRvd01hdGVyaWFsVmVydGljYWwgKTtcclxuXHJcblx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMudHlwZSA9IFBDRlNoYWRvd01hcDtcclxuXHRsZXQgX3ByZXZpb3VzVHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIGxpZ2h0cywgc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cdFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCBsaWdodHMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSBfcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblx0XHRjb25zdCBhY3RpdmVDdWJlRmFjZSA9IF9yZW5kZXJlci5nZXRBY3RpdmVDdWJlRmFjZSgpO1xyXG5cdFx0Y29uc3QgYWN0aXZlTWlwbWFwTGV2ZWwgPSBfcmVuZGVyZXIuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwoKTtcclxuXHJcblx0XHRjb25zdCBfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGU7XHJcblxyXG5cdFx0Ly8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXHJcblx0XHRfc3RhdGUuc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcclxuXHRcdF9zdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCAxLCAxLCAxLCAxICk7XHJcblx0XHRfc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XHJcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgZm9yIHNoYWRvdyBtYXAgdHlwZSBjaGFuZ2VzXHJcblxyXG5cdFx0Y29uc3QgdG9WU00gPSAoIF9wcmV2aW91c1R5cGUgIT09IFZTTVNoYWRvd01hcCAmJiB0aGlzLnR5cGUgPT09IFZTTVNoYWRvd01hcCApO1xyXG5cdFx0Y29uc3QgZnJvbVZTTSA9ICggX3ByZXZpb3VzVHlwZSA9PT0gVlNNU2hhZG93TWFwICYmIHRoaXMudHlwZSAhPT0gVlNNU2hhZG93TWFwICk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBsaWdodCA9IGxpZ2h0c1sgaSBdO1xyXG5cdFx0XHRjb25zdCBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XHJcblxyXG5cdFx0XHRpZiAoIHNoYWRvdyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRvd01hcDonLCBsaWdodCwgJ2hhcyBubyBzaGFkb3cuJyApO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzaGFkb3cuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2hhZG93Lm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0X3NoYWRvd01hcFNpemUuY29weSggc2hhZG93Lm1hcFNpemUgKTtcclxuXHJcblx0XHRcdGNvbnN0IHNoYWRvd0ZyYW1lRXh0ZW50cyA9IHNoYWRvdy5nZXRGcmFtZUV4dGVudHMoKTtcclxuXHJcblx0XHRcdF9zaGFkb3dNYXBTaXplLm11bHRpcGx5KCBzaGFkb3dGcmFtZUV4dGVudHMgKTtcclxuXHJcblx0XHRcdF92aWV3cG9ydFNpemUuY29weSggc2hhZG93Lm1hcFNpemUgKTtcclxuXHJcblx0XHRcdGlmICggX3NoYWRvd01hcFNpemUueCA+IF9tYXhUZXh0dXJlU2l6ZSB8fCBfc2hhZG93TWFwU2l6ZS55ID4gX21heFRleHR1cmVTaXplICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS54ID0gTWF0aC5mbG9vciggX21heFRleHR1cmVTaXplIC8gc2hhZG93RnJhbWVFeHRlbnRzLnggKTtcclxuXHRcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnggPSBfdmlld3BvcnRTaXplLnggKiBzaGFkb3dGcmFtZUV4dGVudHMueDtcclxuXHRcdFx0XHRcdHNoYWRvdy5tYXBTaXplLnggPSBfdmlld3BvcnRTaXplLng7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBfc2hhZG93TWFwU2l6ZS55ID4gX21heFRleHR1cmVTaXplICkge1xyXG5cclxuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUueSA9IE1hdGguZmxvb3IoIF9tYXhUZXh0dXJlU2l6ZSAvIHNoYWRvd0ZyYW1lRXh0ZW50cy55ICk7XHJcblx0XHRcdFx0XHRfc2hhZG93TWFwU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55ICogc2hhZG93RnJhbWVFeHRlbnRzLnk7XHJcblx0XHRcdFx0XHRzaGFkb3cubWFwU2l6ZS55ID0gX3ZpZXdwb3J0U2l6ZS55O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgfHwgdG9WU00gPT09IHRydWUgfHwgZnJvbVZTTSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGFycyA9ICggdGhpcy50eXBlICE9PSBWU01TaGFkb3dNYXAgKSA/IHsgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyLCBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIgfSA6IHt9O1xyXG5cclxuXHRcdFx0XHRpZiAoIHNoYWRvdy5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2hhZG93Lm1hcC5kaXNwb3NlKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSwgcGFycyApO1xyXG5cdFx0XHRcdHNoYWRvdy5tYXAudGV4dHVyZS5uYW1lID0gbGlnaHQubmFtZSArICcuc2hhZG93TWFwJztcclxuXHJcblx0XHRcdFx0c2hhZG93LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3cubWFwICk7XHJcblx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xyXG5cclxuXHRcdFx0Y29uc3Qgdmlld3BvcnRDb3VudCA9IHNoYWRvdy5nZXRWaWV3cG9ydENvdW50KCk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgdnAgPSAwOyB2cCA8IHZpZXdwb3J0Q291bnQ7IHZwICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2aWV3cG9ydCA9IHNoYWRvdy5nZXRWaWV3cG9ydCggdnAgKTtcclxuXHJcblx0XHRcdFx0X3ZpZXdwb3J0LnNldChcclxuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0LngsXHJcblx0XHRcdFx0XHRfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC55LFxyXG5cdFx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS54ICogdmlld3BvcnQueixcclxuXHRcdFx0XHRcdF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LndcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRfc3RhdGUudmlld3BvcnQoIF92aWV3cG9ydCApO1xyXG5cclxuXHRcdFx0XHRzaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0LCB2cCApO1xyXG5cclxuXHRcdFx0XHRfZnJ1c3R1bSA9IHNoYWRvdy5nZXRGcnVzdHVtKCk7XHJcblxyXG5cdFx0XHRcdHJlbmRlck9iamVjdCggc2NlbmUsIGNhbWVyYSwgc2hhZG93LmNhbWVyYSwgbGlnaHQsIHRoaXMudHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZG8gYmx1ciBwYXNzIGZvciBWU01cclxuXHJcblx0XHRcdGlmICggc2hhZG93LmlzUG9pbnRMaWdodFNoYWRvdyAhPT0gdHJ1ZSAmJiB0aGlzLnR5cGUgPT09IFZTTVNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdFx0VlNNUGFzcyggc2hhZG93LCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNoYWRvdy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfcHJldmlvdXNUeXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggY3VycmVudFJlbmRlclRhcmdldCwgYWN0aXZlQ3ViZUZhY2UsIGFjdGl2ZU1pcG1hcExldmVsICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFZTTVBhc3MoIHNoYWRvdywgY2FtZXJhICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBmdWxsU2NyZWVuTWVzaCApO1xyXG5cclxuXHRcdGlmICggc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5kZWZpbmVzLlZTTV9TQU1QTEVTICE9PSBzaGFkb3cuYmx1clNhbXBsZXMgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLmRlZmluZXMuVlNNX1NBTVBMRVMgPSBzaGFkb3cuYmx1clNhbXBsZXM7XHJcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLlZTTV9TQU1QTEVTID0gc2hhZG93LmJsdXJTYW1wbGVzO1xyXG5cclxuXHRcdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggc2hhZG93Lm1hcFBhc3MgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3cubWFwUGFzcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB2ZXJ0aWNhbCBwYXNzXHJcblxyXG5cdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHNoYWRvdy5tYXAudGV4dHVyZTtcclxuXHRcdHNoYWRvd01hdGVyaWFsVmVydGljYWwudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZSA9IHNoYWRvdy5tYXBTaXplO1xyXG5cdFx0c2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSBzaGFkb3cucmFkaXVzO1xyXG5cdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93Lm1hcFBhc3MgKTtcclxuXHRcdF9yZW5kZXJlci5jbGVhcigpO1xyXG5cdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwgKTtcclxuXHJcblx0XHQvLyBob3Jpem9udGFsIHBhc3NcclxuXHJcblx0XHRzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwUGFzcy50ZXh0dXJlO1xyXG5cdFx0c2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBzaGFkb3cubWFwU2l6ZTtcclxuXHRcdHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSBzaGFkb3cucmFkaXVzO1xyXG5cdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93Lm1hcCApO1xyXG5cdFx0X3JlbmRlcmVyLmNsZWFyKCk7XHJcblx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwsIGZ1bGxTY3JlZW5NZXNoLCBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgbGlnaHQsIHR5cGUgKSB7XHJcblxyXG5cdFx0bGV0IHJlc3VsdCA9IG51bGw7XHJcblxyXG5cdFx0Y29uc3QgY3VzdG9tTWF0ZXJpYWwgPSAoIGxpZ2h0LmlzUG9pbnRMaWdodCA9PT0gdHJ1ZSApID8gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWwgOiBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIGN1c3RvbU1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHQgPSBjdXN0b21NYXRlcmlhbDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gKCBsaWdodC5pc1BvaW50TGlnaHQgPT09IHRydWUgKSA/IF9kaXN0YW5jZU1hdGVyaWFsIDogX2RlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoICggX3JlbmRlcmVyLmxvY2FsQ2xpcHBpbmdFbmFibGVkICYmIG1hdGVyaWFsLmNsaXBTaGFkb3dzID09PSB0cnVlICYmIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzICkgJiYgbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoICE9PSAwICkgfHxcclxuXHRcdFx0XHQoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCAmJiBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gMCApIHx8XHJcblx0XHRcdFx0KCBtYXRlcmlhbC5hbHBoYU1hcCAmJiBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkgfHxcclxuXHRcdFx0XHQoIG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIGEgdW5pcXVlIG1hdGVyaWFsIGluc3RhbmNlIHJlZmxlY3RpbmcgdGhlXHJcblx0XHRcdFx0Ly8gYXBwcm9wcmlhdGUgc3RhdGVcclxuXHJcblx0XHRcdFx0Y29uc3Qga2V5QSA9IHJlc3VsdC51dWlkLCBrZXlCID0gbWF0ZXJpYWwudXVpZDtcclxuXHJcblx0XHRcdFx0bGV0IG1hdGVyaWFsc0ZvclZhcmlhbnQgPSBfbWF0ZXJpYWxDYWNoZVsga2V5QSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XHJcblx0XHRcdFx0XHRfbWF0ZXJpYWxDYWNoZVsga2V5QSBdID0gbWF0ZXJpYWxzRm9yVmFyaWFudDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbHNGb3JWYXJpYW50WyBrZXlCIF07XHJcblxyXG5cdFx0XHRcdGlmICggY2FjaGVkTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjYWNoZWRNYXRlcmlhbCA9IHJlc3VsdC5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0bWF0ZXJpYWxzRm9yVmFyaWFudFsga2V5QiBdID0gY2FjaGVkTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmVzdWx0ID0gY2FjaGVkTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcclxuXHRcdHJlc3VsdC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XHJcblxyXG5cdFx0aWYgKCB0eXBlID09PSBWU01TaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHQuc2lkZSA9ICggbWF0ZXJpYWwuc2hhZG93U2lkZSAhPT0gbnVsbCApID8gbWF0ZXJpYWwuc2hhZG93U2lkZSA6IG1hdGVyaWFsLnNpZGU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJlc3VsdC5zaWRlID0gKCBtYXRlcmlhbC5zaGFkb3dTaWRlICE9PSBudWxsICkgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogc2hhZG93U2lkZVsgbWF0ZXJpYWwuc2lkZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQuYWxwaGFNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcclxuXHRcdHJlc3VsdC5hbHBoYVRlc3QgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XHJcblx0XHRyZXN1bHQubWFwID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHRcdHJlc3VsdC5jbGlwU2hhZG93cyA9IG1hdGVyaWFsLmNsaXBTaGFkb3dzO1xyXG5cdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XHJcblx0XHRyZXN1bHQuY2xpcEludGVyc2VjdGlvbiA9IG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb247XHJcblxyXG5cdFx0cmVzdWx0LmRpc3BsYWNlbWVudE1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHRcdHJlc3VsdC5kaXNwbGFjZW1lbnRTY2FsZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0cmVzdWx0LmRpc3BsYWNlbWVudEJpYXMgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0XHRyZXN1bHQubGluZXdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xyXG5cclxuXHRcdGlmICggbGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlICYmIHJlc3VsdC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gX3JlbmRlcmVyLnByb3BlcnRpZXMuZ2V0KCByZXN1bHQgKTtcclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0ID0gbGlnaHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBsaWdodCwgdHlwZSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XHJcblxyXG5cdFx0aWYgKCB2aXNpYmxlICYmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApICkge1xyXG5cclxuXHRcdFx0aWYgKCAoIG9iamVjdC5jYXN0U2hhZG93IHx8ICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgdHlwZSA9PT0gVlNNU2hhZG93TWFwICkgKSAmJiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xyXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgayBdO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGxpZ2h0LCB0eXBlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGxpZ2h0LCB0eXBlICk7XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGxpZ2h0LCB0eXBlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xTaGFkb3dNYXAgfTtcclxuIiwiaW1wb3J0IHsgTm90RXF1YWxEZXB0aCwgR3JlYXRlckRlcHRoLCBHcmVhdGVyRXF1YWxEZXB0aCwgRXF1YWxEZXB0aCwgTGVzc0VxdWFsRGVwdGgsIExlc3NEZXB0aCwgQWx3YXlzRGVwdGgsIE5ldmVyRGVwdGgsIEN1bGxGYWNlRnJvbnQsIEN1bGxGYWNlQmFjaywgQ3VsbEZhY2VOb25lLCBEb3VibGVTaWRlLCBCYWNrU2lkZSwgQ3VzdG9tQmxlbmRpbmcsIE11bHRpcGx5QmxlbmRpbmcsIFN1YnRyYWN0aXZlQmxlbmRpbmcsIEFkZGl0aXZlQmxlbmRpbmcsIE5vQmxlbmRpbmcsIE5vcm1hbEJsZW5kaW5nLCBBZGRFcXVhdGlvbiwgU3VidHJhY3RFcXVhdGlvbiwgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24sIE1pbkVxdWF0aW9uLCBNYXhFcXVhdGlvbiwgWmVyb0ZhY3RvciwgT25lRmFjdG9yLCBTcmNDb2xvckZhY3RvciwgU3JjQWxwaGFGYWN0b3IsIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IsIERzdENvbG9yRmFjdG9yLCBEc3RBbHBoYUZhY3RvciwgT25lTWludXNTcmNDb2xvckZhY3RvciwgT25lTWludXNTcmNBbHBoYUZhY3RvciwgT25lTWludXNEc3RDb2xvckZhY3RvciwgT25lTWludXNEc3RBbHBoYUZhY3RvciB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5cclxuZnVuY3Rpb24gV2ViR0xTdGF0ZSggZ2wsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0Y29uc3QgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XHJcblxyXG5cdGZ1bmN0aW9uIENvbG9yQnVmZmVyKCkge1xyXG5cclxuXHRcdGxldCBsb2NrZWQgPSBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBjb2xvciA9IG5ldyBWZWN0b3I0KCk7XHJcblx0XHRsZXQgY3VycmVudENvbG9yTWFzayA9IG51bGw7XHJcblx0XHRjb25zdCBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggY29sb3JNYXNrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvck1hc2sgIT09IGNvbG9yTWFzayAmJiAhIGxvY2tlZCApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5jb2xvck1hc2soIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzayApO1xyXG5cdFx0XHRcdFx0Y3VycmVudENvbG9yTWFzayA9IGNvbG9yTWFzaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xyXG5cclxuXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIHIsIGcsIGIsIGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0ciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXJyZW50Q29sb3JDbGVhci5lcXVhbHMoIGNvbG9yICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcclxuXHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLmNvcHkoIGNvbG9yICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0Y3VycmVudENvbG9yTWFzayA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuc2V0KCAtIDEsIDAsIDAsIDAgKTsgLy8gc2V0IHRvIGludmFsaWQgc3RhdGVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIERlcHRoQnVmZmVyKCkge1xyXG5cclxuXHRcdGxldCBsb2NrZWQgPSBmYWxzZTtcclxuXHJcblx0XHRsZXQgY3VycmVudERlcHRoTWFzayA9IG51bGw7XHJcblx0XHRsZXQgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcblx0XHRsZXQgY3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKCBkZXB0aE1hc2sgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICEgbG9ja2VkICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLmRlcHRoTWFzayggZGVwdGhNYXNrICk7XHJcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgTmV2ZXJEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBBbHdheXNEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgTGVzc0RlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgTGVzc0VxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIEVxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIE5vdEVxdWFsRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcclxuXHJcblx0XHRcdFx0bG9ja2VkID0gbG9jaztcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCBkZXB0aCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhDbGVhciAhPT0gZGVwdGggKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY2xlYXJEZXB0aCggZGVwdGggKTtcclxuXHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRsb2NrZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gU3RlbmNpbEJ1ZmZlcigpIHtcclxuXHJcblx0XHRsZXQgbG9ja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0bGV0IGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XHJcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcclxuXHRcdGxldCBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XHJcblx0XHRsZXQgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcclxuXHRcdGxldCBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHRcdGxldCBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcclxuXHRcdGxldCBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cclxuXHRcdFx0c2V0VGVzdDogZnVuY3Rpb24gKCBzdGVuY2lsVGVzdCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxvY2tlZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZW5hYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0TWFzazogZnVuY3Rpb24gKCBzdGVuY2lsTWFzayApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbE1hc2sgIT09IHN0ZW5jaWxNYXNrICYmICEgbG9ja2VkICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLnN0ZW5jaWxNYXNrKCBzdGVuY2lsTWFzayApO1xyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXRGdW5jOiBmdW5jdGlvbiAoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XHJcblx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFJlZiAhPT0gc3RlbmNpbFJlZiB8fFxyXG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxGdW5jTWFzayAhPT0gc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApO1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IHN0ZW5jaWxNYXNrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0T3A6IGZ1bmN0aW9uICggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsRmFpbCAhPT0gc3RlbmNpbEZhaWwgfHxcclxuXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fFxyXG5cdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLnN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gc3RlbmNpbEZhaWw7XHJcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpGYWlsID0gc3RlbmNpbFpGYWlsO1xyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IHN0ZW5jaWxaUGFzcztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xyXG5cclxuXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxDbGVhciAhPT0gc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5jbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKTtcclxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBzdGVuY2lsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcclxuXHRcdFx0XHRjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcclxuXHRcdFx0XHRjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcclxuXHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGNvbnN0IGNvbG9yQnVmZmVyID0gbmV3IENvbG9yQnVmZmVyKCk7XHJcblx0Y29uc3QgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcclxuXHRjb25zdCBzdGVuY2lsQnVmZmVyID0gbmV3IFN0ZW5jaWxCdWZmZXIoKTtcclxuXHJcblx0Y29uc3QgdWJvQmluZGluZ3MgPSBuZXcgV2Vha01hcCgpO1xyXG5cdGNvbnN0IHVib1Byb2dyYW1NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRsZXQgZW5hYmxlZENhcGFiaWxpdGllcyA9IHt9O1xyXG5cclxuXHRsZXQgY3VycmVudEJvdW5kRnJhbWVidWZmZXJzID0ge307XHJcblx0bGV0IGN1cnJlbnREcmF3YnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XHJcblx0bGV0IGRlZmF1bHREcmF3YnVmZmVycyA9IFtdO1xyXG5cclxuXHRsZXQgY3VycmVudFByb2dyYW0gPSBudWxsO1xyXG5cclxuXHRsZXQgY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG5cdGxldCBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xyXG5cdGxldCBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XHJcblx0bGV0IGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XHJcblx0bGV0IGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcblx0bGV0IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xyXG5cdGxldCBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcblx0bGV0IGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcclxuXHRsZXQgY3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XHJcblxyXG5cdGxldCBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHRsZXQgY3VycmVudEN1bGxGYWNlID0gbnVsbDtcclxuXHJcblx0bGV0IGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cclxuXHRsZXQgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xyXG5cdGxldCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcclxuXHJcblx0Y29uc3QgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XHJcblxyXG5cdGxldCBsaW5lV2lkdGhBdmFpbGFibGUgPSBmYWxzZTtcclxuXHRsZXQgdmVyc2lvbiA9IDA7XHJcblx0Y29uc3QgZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5WRVJTSU9OICk7XHJcblxyXG5cdGlmICggZ2xWZXJzaW9uLmluZGV4T2YoICdXZWJHTCcgKSAhPT0gLSAxICkge1xyXG5cclxuXHRcdHZlcnNpb24gPSBwYXJzZUZsb2F0KCAvXldlYkdMIChcXGQpLy5leGVjKCBnbFZlcnNpb24gKVsgMSBdICk7XHJcblx0XHRsaW5lV2lkdGhBdmFpbGFibGUgPSAoIHZlcnNpb24gPj0gMS4wICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGdsVmVyc2lvbi5pbmRleE9mKCAnT3BlbkdMIEVTJyApICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0dmVyc2lvbiA9IHBhcnNlRmxvYXQoIC9eT3BlbkdMIEVTIChcXGQpLy5leGVjKCBnbFZlcnNpb24gKVsgMSBdICk7XHJcblx0XHRsaW5lV2lkdGhBdmFpbGFibGUgPSAoIHZlcnNpb24gPj0gMi4wICk7XHJcblxyXG5cdH1cclxuXHJcblx0bGV0IGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XHJcblx0bGV0IGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XHJcblxyXG5cdGNvbnN0IHNjaXNzb3JQYXJhbSA9IGdsLmdldFBhcmFtZXRlciggZ2wuU0NJU1NPUl9CT1ggKTtcclxuXHRjb25zdCB2aWV3cG9ydFBhcmFtID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5WSUVXUE9SVCApO1xyXG5cclxuXHRjb25zdCBjdXJyZW50U2Npc3NvciA9IG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KCBzY2lzc29yUGFyYW0gKTtcclxuXHRjb25zdCBjdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLmZyb21BcnJheSggdmlld3BvcnRQYXJhbSApO1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKCB0eXBlLCB0YXJnZXQsIGNvdW50LCBkaW1lbnNpb25zICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSggNCApOyAvLyA0IGlzIHJlcXVpcmVkIHRvIG1hdGNoIGRlZmF1bHQgdW5wYWNrIGFsaWdubWVudCBvZiA0LlxyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRnbC5iaW5kVGV4dHVyZSggdHlwZSwgdGV4dHVyZSApO1xyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggaXNXZWJHTDIgJiYgKCB0eXBlID09PSBnbC5URVhUVVJFXzNEIHx8IHR5cGUgPT09IGdsLlRFWFRVUkVfMkRfQVJSQVkgKSApIHtcclxuXHJcblx0XHRcdFx0Z2wudGV4SW1hZ2UzRCggdGFyZ2V0LCAwLCBnbC5SR0JBLCAxLCAxLCBkaW1lbnNpb25zLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKCB0YXJnZXQgKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IGVtcHR5VGV4dHVyZXMgPSB7fTtcclxuXHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFXzJEIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFXzJELCAxICk7XHJcblx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV9DVUJFX01BUCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCA2ICk7XHJcblxyXG5cdGlmICggaXNXZWJHTDIgKSB7XHJcblxyXG5cdFx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV8yRF9BUlJBWSBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMSwgMSApO1xyXG5cdFx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV8zRCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV8zRCwgZ2wuVEVYVFVSRV8zRCwgMSwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGluaXRcclxuXHJcblx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoIDAsIDAsIDAsIDEgKTtcclxuXHRkZXB0aEJ1ZmZlci5zZXRDbGVhciggMSApO1xyXG5cdHN0ZW5jaWxCdWZmZXIuc2V0Q2xlYXIoIDAgKTtcclxuXHJcblx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggTGVzc0VxdWFsRGVwdGggKTtcclxuXHJcblx0c2V0RmxpcFNpZGVkKCBmYWxzZSApO1xyXG5cdHNldEN1bGxGYWNlKCBDdWxsRmFjZUJhY2sgKTtcclxuXHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRzZXRCbGVuZGluZyggTm9CbGVuZGluZyApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBlbmFibGUoIGlkICkge1xyXG5cclxuXHRcdGlmICggZW5hYmxlZENhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGdsLmVuYWJsZSggaWQgKTtcclxuXHRcdFx0ZW5hYmxlZENhcGFiaWxpdGllc1sgaWQgXSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRpc2FibGUoIGlkICkge1xyXG5cclxuXHRcdGlmICggZW5hYmxlZENhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xyXG5cdFx0XHRlbmFibGVkQ2FwYWJpbGl0aWVzWyBpZCBdID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJpbmRGcmFtZWJ1ZmZlciggdGFyZ2V0LCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgdGFyZ2V0IF0gIT09IGZyYW1lYnVmZmVyICkge1xyXG5cclxuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCB0YXJnZXQsIGZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbIHRhcmdldCBdID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHRpZiAoIGlzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0XHQvLyBnbC5EUkFXX0ZSQU1FQlVGRkVSIGlzIGVxdWl2YWxlbnQgdG8gZ2wuRlJBTUVCVUZGRVJcclxuXHJcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGdsLkRSQVdfRlJBTUVCVUZGRVIgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyBnbC5GUkFNRUJVRkZFUiBdID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGdsLkZSQU1FQlVGRkVSICkge1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgZ2wuRFJBV19GUkFNRUJVRkZFUiBdID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZHJhd0J1ZmZlcnMoIHJlbmRlclRhcmdldCwgZnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0bGV0IGRyYXdCdWZmZXJzID0gZGVmYXVsdERyYXdidWZmZXJzO1xyXG5cclxuXHRcdGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0ZHJhd0J1ZmZlcnMgPSBjdXJyZW50RHJhd2J1ZmZlcnMuZ2V0KCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCBkcmF3QnVmZmVycyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRkcmF3QnVmZmVycyA9IFtdO1xyXG5cdFx0XHRcdGN1cnJlbnREcmF3YnVmZmVycy5zZXQoIGZyYW1lYnVmZmVyLCBkcmF3QnVmZmVycyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdFx0aWYgKCBkcmF3QnVmZmVycy5sZW5ndGggIT09IHRleHR1cmVzLmxlbmd0aCB8fCBkcmF3QnVmZmVyc1sgMCBdICE9PSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkcmF3QnVmZmVyc1sgaSBdID0gZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRkcmF3QnVmZmVycy5sZW5ndGggPSB0ZXh0dXJlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRyYXdCdWZmZXJzWyAwIF0gIT09IGdsLkNPTE9SX0FUVEFDSE1FTlQwICkge1xyXG5cclxuXHRcdFx0XHRcdGRyYXdCdWZmZXJzWyAwIF0gPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMDtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBkcmF3QnVmZmVyc1sgMCBdICE9PSBnbC5CQUNLICkge1xyXG5cclxuXHRcdFx0XHRkcmF3QnVmZmVyc1sgMCBdID0gZ2wuQkFDSztcclxuXHJcblx0XHRcdFx0bmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRyYXdCdWZmZXJzKCBkcmF3QnVmZmVycyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kcmF3X2J1ZmZlcnMnICkuZHJhd0J1ZmZlcnNXRUJHTCggZHJhd0J1ZmZlcnMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVzZVByb2dyYW0oIHByb2dyYW0gKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50UHJvZ3JhbSAhPT0gcHJvZ3JhbSApIHtcclxuXHJcblx0XHRcdGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdGN1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3QgZXF1YXRpb25Ub0dMID0ge1xyXG5cdFx0WyBBZGRFcXVhdGlvbiBdOiBnbC5GVU5DX0FERCxcclxuXHRcdFsgU3VidHJhY3RFcXVhdGlvbiBdOiBnbC5GVU5DX1NVQlRSQUNULFxyXG5cdFx0WyBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiBdOiBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1RcclxuXHR9O1xyXG5cclxuXHRpZiAoIGlzV2ViR0wyICkge1xyXG5cclxuXHRcdGVxdWF0aW9uVG9HTFsgTWluRXF1YXRpb24gXSA9IGdsLk1JTjtcclxuXHRcdGVxdWF0aW9uVG9HTFsgTWF4RXF1YXRpb24gXSA9IGdsLk1BWDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRlcXVhdGlvblRvR0xbIE1pbkVxdWF0aW9uIF0gPSBleHRlbnNpb24uTUlOX0VYVDtcclxuXHRcdFx0ZXF1YXRpb25Ub0dMWyBNYXhFcXVhdGlvbiBdID0gZXh0ZW5zaW9uLk1BWF9FWFQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IGZhY3RvclRvR0wgPSB7XHJcblx0XHRbIFplcm9GYWN0b3IgXTogZ2wuWkVSTyxcclxuXHRcdFsgT25lRmFjdG9yIF06IGdsLk9ORSxcclxuXHRcdFsgU3JjQ29sb3JGYWN0b3IgXTogZ2wuU1JDX0NPTE9SLFxyXG5cdFx0WyBTcmNBbHBoYUZhY3RvciBdOiBnbC5TUkNfQUxQSEEsXHJcblx0XHRbIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgXTogZ2wuU1JDX0FMUEhBX1NBVFVSQVRFLFxyXG5cdFx0WyBEc3RDb2xvckZhY3RvciBdOiBnbC5EU1RfQ09MT1IsXHJcblx0XHRbIERzdEFscGhhRmFjdG9yIF06IGdsLkRTVF9BTFBIQSxcclxuXHRcdFsgT25lTWludXNTcmNDb2xvckZhY3RvciBdOiBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLFxyXG5cdFx0WyBPbmVNaW51c1NyY0FscGhhRmFjdG9yIF06IGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsXHJcblx0XHRbIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgXTogZ2wuT05FX01JTlVTX0RTVF9DT0xPUixcclxuXHRcdFsgT25lTWludXNEc3RBbHBoYUZhY3RvciBdOiBnbC5PTkVfTUlOVVNfRFNUX0FMUEhBXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0QmxlbmRpbmcoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgPT09IE5vQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0XHRjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyAhPT0gQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudEJsZW5kRXF1YXRpb24gIT09IEFkZEVxdWF0aW9uIHx8IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgIT09IEFkZEVxdWF0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcclxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBBZGRFcXVhdGlvbjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBibGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgTm9ybWFsQmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5PTkUsIGdsLk9ORSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxyXG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5PTkUgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgTXVsdGlwbHlCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBOb3JtYWxCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxyXG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAnLCBibGVuZGluZyApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcclxuXHJcblx0XHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblx0XHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjdXN0b20gYmxlbmRpbmdcclxuXHJcblx0XHRibGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGEgfHwgYmxlbmRFcXVhdGlvbjtcclxuXHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xyXG5cdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XHJcblxyXG5cdFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGVxdWF0aW9uVG9HTFsgYmxlbmRFcXVhdGlvbiBdLCBlcXVhdGlvblRvR0xbIGJsZW5kRXF1YXRpb25BbHBoYSBdICk7XHJcblxyXG5cdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XHJcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xyXG5cclxuXHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGZhY3RvclRvR0xbIGJsZW5kU3JjIF0sIGZhY3RvclRvR0xbIGJsZW5kRHN0IF0sIGZhY3RvclRvR0xbIGJsZW5kU3JjQWxwaGEgXSwgZmFjdG9yVG9HTFsgYmxlbmREc3RBbHBoYSBdICk7XHJcblxyXG5cdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcclxuXHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XHJcblx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcclxuXHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcclxuXHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKSB7XHJcblxyXG5cdFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZVxyXG5cdFx0XHQ/IGRpc2FibGUoIGdsLkNVTExfRkFDRSApXHJcblx0XHRcdDogZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRsZXQgZmxpcFNpZGVkID0gKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApO1xyXG5cdFx0aWYgKCBmcm9udEZhY2VDVyApIGZsaXBTaWRlZCA9ICEgZmxpcFNpZGVkO1xyXG5cclxuXHRcdHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICk7XHJcblxyXG5cdFx0KCBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcgJiYgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IGZhbHNlIClcclxuXHRcdFx0PyBzZXRCbGVuZGluZyggTm9CbGVuZGluZyApXHJcblx0XHRcdDogc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSwgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhICk7XHJcblxyXG5cdFx0ZGVwdGhCdWZmZXIuc2V0RnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XHJcblx0XHRkZXB0aEJ1ZmZlci5zZXRUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdGRlcHRoQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuXHRcdGNvbG9yQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcclxuXHJcblx0XHRjb25zdCBzdGVuY2lsV3JpdGUgPSBtYXRlcmlhbC5zdGVuY2lsV3JpdGU7XHJcblx0XHRzdGVuY2lsQnVmZmVyLnNldFRlc3QoIHN0ZW5jaWxXcml0ZSApO1xyXG5cdFx0aWYgKCBzdGVuY2lsV3JpdGUgKSB7XHJcblxyXG5cdFx0XHRzdGVuY2lsQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgKTtcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlci5zZXRGdW5jKCBtYXRlcmlhbC5zdGVuY2lsRnVuYywgbWF0ZXJpYWwuc3RlbmNpbFJlZiwgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrICk7XHJcblx0XHRcdHN0ZW5jaWxCdWZmZXIuc2V0T3AoIG1hdGVyaWFsLnN0ZW5jaWxGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcblx0XHRtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWVcclxuXHRcdFx0PyBlbmFibGUoIGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSApXHJcblx0XHRcdDogZGlzYWJsZSggZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gc2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcclxuXHJcblx0XHRpZiAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUgKSB7XHJcblxyXG5cdFx0XHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdFx0aWYgKCBjdWxsRmFjZSAhPT0gY3VycmVudEN1bGxGYWNlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UX0FORF9CQUNLICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldExpbmVXaWR0aCggd2lkdGggKSB7XHJcblxyXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcclxuXHJcblx0XHRcdGlmICggbGluZVdpZHRoQXZhaWxhYmxlICkgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xyXG5cclxuXHRcdFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0KCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xyXG5cclxuXHRcdGlmICggcG9seWdvbk9mZnNldCApIHtcclxuXHJcblx0XHRcdGVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkge1xyXG5cclxuXHRcdFx0XHRnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xyXG5cdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRTY2lzc29yVGVzdCggc2Npc3NvclRlc3QgKSB7XHJcblxyXG5cdFx0aWYgKCBzY2lzc29yVGVzdCApIHtcclxuXHJcblx0XHRcdGVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyB0ZXh0dXJlXHJcblxyXG5cdGZ1bmN0aW9uIGFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApIHtcclxuXHJcblx0XHRpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcclxuXHJcblx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xyXG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSwgd2ViZ2xTbG90ICkge1xyXG5cclxuXHRcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0d2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR3ZWJnbFNsb3QgPSBjdXJyZW50VGV4dHVyZVNsb3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgd2ViZ2xTbG90IF07XHJcblxyXG5cdFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcclxuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIHdlYmdsU2xvdCBdID0gYm91bmRUZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xyXG5cdFx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzWyB3ZWJnbFR5cGUgXSApO1xyXG5cclxuXHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XHJcblx0XHRcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1bmJpbmRUZXh0dXJlKCkge1xyXG5cclxuXHRcdGNvbnN0IGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIGJvdW5kVGV4dHVyZS50eXBlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggYm91bmRUZXh0dXJlLnR5cGUsIG51bGwgKTtcclxuXHJcblx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlMkQoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XHJcblxyXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlM0QoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTNELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XHJcblxyXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGV4U3ViSW1hZ2UyRCgpIHtcclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRleFN1YkltYWdlM0QoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLnRleFN1YkltYWdlM0QuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCgpIHtcclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCgpIHtcclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlM0QuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXhTdG9yYWdlMkQoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLnRleFN0b3JhZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRleFN0b3JhZ2UzRCgpIHtcclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Z2wudGV4U3RvcmFnZTNELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XHJcblxyXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGV4SW1hZ2UyRCgpIHtcclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRleEltYWdlM0QoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGdsLnRleEltYWdlM0QuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBzY2lzc29yKCBzY2lzc29yICkge1xyXG5cclxuXHRcdGlmICggY3VycmVudFNjaXNzb3IuZXF1YWxzKCBzY2lzc29yICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Z2wuc2Npc3Nvciggc2Npc3Nvci54LCBzY2lzc29yLnksIHNjaXNzb3Iueiwgc2Npc3Nvci53ICk7XHJcblx0XHRcdGN1cnJlbnRTY2lzc29yLmNvcHkoIHNjaXNzb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdmlld3BvcnQoIHZpZXdwb3J0ICkge1xyXG5cclxuXHRcdGlmICggY3VycmVudFZpZXdwb3J0LmVxdWFscyggdmlld3BvcnQgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRnbC52aWV3cG9ydCggdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyApO1xyXG5cdFx0XHRjdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlVUJPTWFwcGluZyggdW5pZm9ybXNHcm91cCwgcHJvZ3JhbSApIHtcclxuXHJcblx0XHRsZXQgbWFwcGluZyA9IHVib1Byb2dyYW1NYXAuZ2V0KCBwcm9ncmFtICk7XHJcblxyXG5cdFx0aWYgKCBtYXBwaW5nID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtYXBwaW5nID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHRcdHVib1Byb2dyYW1NYXAuc2V0KCBwcm9ncmFtLCBtYXBwaW5nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBibG9ja0luZGV4ID0gbWFwcGluZy5nZXQoIHVuaWZvcm1zR3JvdXAgKTtcclxuXHJcblx0XHRpZiAoIGJsb2NrSW5kZXggPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJsb2NrSW5kZXggPSBnbC5nZXRVbmlmb3JtQmxvY2tJbmRleCggcHJvZ3JhbSwgdW5pZm9ybXNHcm91cC5uYW1lICk7XHJcblxyXG5cdFx0XHRtYXBwaW5nLnNldCggdW5pZm9ybXNHcm91cCwgYmxvY2tJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1bmlmb3JtQmxvY2tCaW5kaW5nKCB1bmlmb3Jtc0dyb3VwLCBwcm9ncmFtICkge1xyXG5cclxuXHRcdGNvbnN0IG1hcHBpbmcgPSB1Ym9Qcm9ncmFtTWFwLmdldCggcHJvZ3JhbSApO1xyXG5cdFx0Y29uc3QgYmxvY2tJbmRleCA9IG1hcHBpbmcuZ2V0KCB1bmlmb3Jtc0dyb3VwICk7XHJcblxyXG5cdFx0aWYgKCB1Ym9CaW5kaW5ncy5nZXQoIHByb2dyYW0gKSAhPT0gYmxvY2tJbmRleCApIHtcclxuXHJcblx0XHRcdC8vIGJpbmQgc2hhZGVyIHNwZWNpZmljIGJsb2NrIGluZGV4IHRvIGdsb2JhbCBibG9jayBwb2ludFxyXG5cdFx0XHRnbC51bmlmb3JtQmxvY2tCaW5kaW5nKCBwcm9ncmFtLCBibG9ja0luZGV4LCB1bmlmb3Jtc0dyb3VwLl9fYmluZGluZ1BvaW50SW5kZXggKTtcclxuXHJcblx0XHRcdHVib0JpbmRpbmdzLnNldCggcHJvZ3JhbSwgYmxvY2tJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiByZXNldCgpIHtcclxuXHJcblx0XHQvLyByZXNldCBzdGF0ZVxyXG5cclxuXHRcdGdsLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRnbC5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdGdsLmRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdGdsLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHRcdGdsLmRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xyXG5cdFx0Z2wuZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XHJcblx0XHRnbC5kaXNhYmxlKCBnbC5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UgKTtcclxuXHJcblx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0Z2wuYmxlbmRGdW5jKCBnbC5PTkUsIGdsLlpFUk8gKTtcclxuXHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLlpFUk8sIGdsLk9ORSwgZ2wuWkVSTyApO1xyXG5cclxuXHRcdGdsLmNvbG9yTWFzayggdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSApO1xyXG5cdFx0Z2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMCApO1xyXG5cclxuXHRcdGdsLmRlcHRoTWFzayggdHJ1ZSApO1xyXG5cdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XHJcblx0XHRnbC5jbGVhckRlcHRoKCAxICk7XHJcblxyXG5cdFx0Z2wuc3RlbmNpbE1hc2soIDB4ZmZmZmZmZmYgKTtcclxuXHRcdGdsLnN0ZW5jaWxGdW5jKCBnbC5BTFdBWVMsIDAsIDB4ZmZmZmZmZmYgKTtcclxuXHRcdGdsLnN0ZW5jaWxPcCggZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCApO1xyXG5cdFx0Z2wuY2xlYXJTdGVuY2lsKCAwICk7XHJcblxyXG5cdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcclxuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcblxyXG5cdFx0Z2wucG9seWdvbk9mZnNldCggMCwgMCApO1xyXG5cclxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcblxyXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHRcdGlmICggaXNXZWJHTDIgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5SRUFEX0ZSQU1FQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0oIG51bGwgKTtcclxuXHJcblx0XHRnbC5saW5lV2lkdGgoIDEgKTtcclxuXHJcblx0XHRnbC5zY2lzc29yKCAwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQgKTtcclxuXHRcdGdsLnZpZXdwb3J0KCAwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQgKTtcclxuXHJcblx0XHQvLyByZXNldCBpbnRlcm5hbHNcclxuXHJcblx0XHRlbmFibGVkQ2FwYWJpbGl0aWVzID0ge307XHJcblxyXG5cdFx0Y3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcclxuXHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XHJcblxyXG5cdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzID0ge307XHJcblx0XHRjdXJyZW50RHJhd2J1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xyXG5cdFx0ZGVmYXVsdERyYXdidWZmZXJzID0gW107XHJcblxyXG5cdFx0Y3VycmVudFByb2dyYW0gPSBudWxsO1xyXG5cclxuXHRcdGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcblx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XHJcblx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xyXG5cdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuXHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xyXG5cdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG5cdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XHJcblxyXG5cdFx0Y3VycmVudEZsaXBTaWRlZCA9IG51bGw7XHJcblx0XHRjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xyXG5cclxuXHRcdGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cclxuXHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcclxuXHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xyXG5cclxuXHRcdGN1cnJlbnRTY2lzc29yLnNldCggMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0ICk7XHJcblx0XHRjdXJyZW50Vmlld3BvcnQuc2V0KCAwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQgKTtcclxuXHJcblx0XHRjb2xvckJ1ZmZlci5yZXNldCgpO1xyXG5cdFx0ZGVwdGhCdWZmZXIucmVzZXQoKTtcclxuXHRcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGJ1ZmZlcnM6IHtcclxuXHRcdFx0Y29sb3I6IGNvbG9yQnVmZmVyLFxyXG5cdFx0XHRkZXB0aDogZGVwdGhCdWZmZXIsXHJcblx0XHRcdHN0ZW5jaWw6IHN0ZW5jaWxCdWZmZXJcclxuXHRcdH0sXHJcblxyXG5cdFx0ZW5hYmxlOiBlbmFibGUsXHJcblx0XHRkaXNhYmxlOiBkaXNhYmxlLFxyXG5cclxuXHRcdGJpbmRGcmFtZWJ1ZmZlcjogYmluZEZyYW1lYnVmZmVyLFxyXG5cdFx0ZHJhd0J1ZmZlcnM6IGRyYXdCdWZmZXJzLFxyXG5cclxuXHRcdHVzZVByb2dyYW06IHVzZVByb2dyYW0sXHJcblxyXG5cdFx0c2V0QmxlbmRpbmc6IHNldEJsZW5kaW5nLFxyXG5cdFx0c2V0TWF0ZXJpYWw6IHNldE1hdGVyaWFsLFxyXG5cclxuXHRcdHNldEZsaXBTaWRlZDogc2V0RmxpcFNpZGVkLFxyXG5cdFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxyXG5cclxuXHRcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxyXG5cdFx0c2V0UG9seWdvbk9mZnNldDogc2V0UG9seWdvbk9mZnNldCxcclxuXHJcblx0XHRzZXRTY2lzc29yVGVzdDogc2V0U2Npc3NvclRlc3QsXHJcblxyXG5cdFx0YWN0aXZlVGV4dHVyZTogYWN0aXZlVGV4dHVyZSxcclxuXHRcdGJpbmRUZXh0dXJlOiBiaW5kVGV4dHVyZSxcclxuXHRcdHVuYmluZFRleHR1cmU6IHVuYmluZFRleHR1cmUsXHJcblx0XHRjb21wcmVzc2VkVGV4SW1hZ2UyRDogY29tcHJlc3NlZFRleEltYWdlMkQsXHJcblx0XHRjb21wcmVzc2VkVGV4SW1hZ2UzRDogY29tcHJlc3NlZFRleEltYWdlM0QsXHJcblx0XHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxyXG5cdFx0dGV4SW1hZ2UzRDogdGV4SW1hZ2UzRCxcclxuXHJcblx0XHR1cGRhdGVVQk9NYXBwaW5nOiB1cGRhdGVVQk9NYXBwaW5nLFxyXG5cdFx0dW5pZm9ybUJsb2NrQmluZGluZzogdW5pZm9ybUJsb2NrQmluZGluZyxcclxuXHJcblx0XHR0ZXhTdG9yYWdlMkQ6IHRleFN0b3JhZ2UyRCxcclxuXHRcdHRleFN0b3JhZ2UzRDogdGV4U3RvcmFnZTNELFxyXG5cdFx0dGV4U3ViSW1hZ2UyRDogdGV4U3ViSW1hZ2UyRCxcclxuXHRcdHRleFN1YkltYWdlM0Q6IHRleFN1YkltYWdlM0QsXHJcblx0XHRjb21wcmVzc2VkVGV4U3ViSW1hZ2UyRDogY29tcHJlc3NlZFRleFN1YkltYWdlMkQsXHJcblx0XHRjb21wcmVzc2VkVGV4U3ViSW1hZ2UzRDogY29tcHJlc3NlZFRleFN1YkltYWdlM0QsXHJcblxyXG5cdFx0c2Npc3Nvcjogc2Npc3NvcixcclxuXHRcdHZpZXdwb3J0OiB2aWV3cG9ydCxcclxuXHJcblx0XHRyZXNldDogcmVzZXRcclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMU3RhdGUgfTtcclxuIiwiaW1wb3J0IHsgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBSR0JBRm9ybWF0LCBEZXB0aEZvcm1hdCwgRGVwdGhTdGVuY2lsRm9ybWF0LCBVbnNpZ25lZFNob3J0VHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUsIEZsb2F0VHlwZSwgSGFsZkZsb2F0VHlwZSwgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgUmVwZWF0V3JhcHBpbmcsIFVuc2lnbmVkQnl0ZVR5cGUsIF9TUkdCQUZvcm1hdCwgTm9Db2xvclNwYWNlLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgU1JHQkNvbG9yU3BhY2UsIE5ldmVyQ29tcGFyZSwgQWx3YXlzQ29tcGFyZSwgTGVzc0NvbXBhcmUsIExlc3NFcXVhbENvbXBhcmUsIEVxdWFsQ29tcGFyZSwgR3JlYXRlckVxdWFsQ29tcGFyZSwgR3JlYXRlckNvbXBhcmUsIE5vdEVxdWFsQ29tcGFyZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi8uLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcbmltcG9ydCB7IEltYWdlVXRpbHMgfSBmcm9tICcuLi8uLi9leHRyYXMvSW1hZ2VVdGlscy5qcyc7XHJcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnROUyB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcclxuXHJcbmZ1bmN0aW9uIFdlYkdMVGV4dHVyZXMoIF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8gKSB7XHJcblxyXG5cdGNvbnN0IGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xyXG5cdGNvbnN0IG1heFRleHR1cmVzID0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzO1xyXG5cdGNvbnN0IG1heEN1YmVtYXBTaXplID0gY2FwYWJpbGl0aWVzLm1heEN1YmVtYXBTaXplO1xyXG5cdGNvbnN0IG1heFRleHR1cmVTaXplID0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplO1xyXG5cdGNvbnN0IG1heFNhbXBsZXMgPSBjYXBhYmlsaXRpZXMubWF4U2FtcGxlcztcclxuXHRjb25zdCBtdWx0aXNhbXBsZWRSVFRFeHQgPSBleHRlbnNpb25zLmhhcyggJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScgKSA/IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApIDogbnVsbDtcclxuXHRjb25zdCBzdXBwb3J0c0ludmFsaWRhdGVGcmFtZWJ1ZmZlciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiAvT2N1bHVzQnJvd3Nlci9nLnRlc3QoIG5hdmlnYXRvci51c2VyQWdlbnQgKTtcclxuXHJcblx0Y29uc3QgX3ZpZGVvVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cdGxldCBfY2FudmFzO1xyXG5cclxuXHRjb25zdCBfc291cmNlcyA9IG5ldyBXZWFrTWFwKCk7IC8vIG1hcHMgV2ViZ2xUZXh0dXJlIG9iamVjdHMgdG8gaW5zdGFuY2VzIG9mIFNvdXJjZVxyXG5cclxuXHQvLyBjb3Jkb3ZhIGlPUyAoYXMgb2YgNS4wKSBzdGlsbCB1c2VzIFVJV2ViVmlldywgd2hpY2ggcHJvdmlkZXMgT2Zmc2NyZWVuQ2FudmFzLFxyXG5cdC8vIGFsc28gT2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKSwgYnV0IG5vdCBPZmZzY3JlZW5DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIVxyXG5cdC8vIFNvbWUgaW1wbGVtZW50YXRpb25zIG1heSBvbmx5IGltcGxlbWVudCBPZmZzY3JlZW5DYW52YXMgcGFydGlhbGx5IChlLmcuIGxhY2tpbmcgMmQpLlxyXG5cclxuXHRsZXQgdXNlT2Zmc2NyZWVuQ2FudmFzID0gZmFsc2U7XHJcblxyXG5cdHRyeSB7XHJcblxyXG5cdFx0dXNlT2Zmc2NyZWVuQ2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCdcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcclxuXHRcdFx0JiYgKCBuZXcgT2Zmc2NyZWVuQ2FudmFzKCAxLCAxICkuZ2V0Q29udGV4dCggJzJkJyApICkgIT09IG51bGw7XHJcblxyXG5cdH0gY2F0Y2ggKCBlcnIgKSB7XHJcblxyXG5cdFx0Ly8gSWdub3JlIGFueSBlcnJvcnNcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVDYW52YXMoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0Ly8gVXNlIE9mZnNjcmVlbkNhbnZhcyB3aGVuIGF2YWlsYWJsZS4gU3BlY2lhbGx5IG5lZWRlZCBpbiB3ZWIgd29ya2Vyc1xyXG5cclxuXHRcdHJldHVybiB1c2VPZmZzY3JlZW5DYW52YXMgP1xyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxyXG5cdFx0XHRuZXcgT2Zmc2NyZWVuQ2FudmFzKCB3aWR0aCwgaGVpZ2h0ICkgOiBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVzaXplSW1hZ2UoIGltYWdlLCBuZWVkc1Bvd2VyT2ZUd28sIG5lZWRzTmV3Q2FudmFzLCBtYXhTaXplICkge1xyXG5cclxuXHRcdGxldCBzY2FsZSA9IDE7XHJcblxyXG5cdFx0Ly8gaGFuZGxlIGNhc2UgaWYgdGV4dHVyZSBleGNlZWRzIG1heCBzaXplXHJcblxyXG5cdFx0aWYgKCBpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSApIHtcclxuXHJcblx0XHRcdHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG9ubHkgcGVyZm9ybSByZXNpemUgaWYgbmVjZXNzYXJ5XHJcblxyXG5cdFx0aWYgKCBzY2FsZSA8IDEgfHwgbmVlZHNQb3dlck9mVHdvID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Ly8gb25seSBwZXJmb3JtIHJlc2l6ZSBmb3IgY2VydGFpbiBpbWFnZSB0eXBlc1xyXG5cclxuXHRcdFx0aWYgKCAoIHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB8fFxyXG5cdFx0XHRcdCggdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkgfHxcclxuXHRcdFx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBmbG9vciA9IG5lZWRzUG93ZXJPZlR3byA/IE1hdGhVdGlscy5mbG9vclBvd2VyT2ZUd28gOiBNYXRoLmZsb29yO1xyXG5cclxuXHRcdFx0XHRjb25zdCB3aWR0aCA9IGZsb29yKCBzY2FsZSAqIGltYWdlLndpZHRoICk7XHJcblx0XHRcdFx0Y29uc3QgaGVpZ2h0ID0gZmxvb3IoIHNjYWxlICogaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggX2NhbnZhcyA9PT0gdW5kZWZpbmVkICkgX2NhbnZhcyA9IGNyZWF0ZUNhbnZhcyggd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0XHQvLyBjdWJlIHRleHR1cmVzIGNhbid0IHJldXNlIHRoZSBzYW1lIGNhbnZhc1xyXG5cclxuXHRcdFx0XHRjb25zdCBjYW52YXMgPSBuZWVkc05ld0NhbnZhcyA/IGNyZWF0ZUNhbnZhcyggd2lkdGgsIGhlaWdodCApIDogX2NhbnZhcztcclxuXHJcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRcdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaGFzIGJlZW4gcmVzaXplZCBmcm9tICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKSB0byAoJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJykuJyApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FudmFzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCAnZGF0YScgaW4gaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogSW1hZ2UgaW4gRGF0YVRleHR1cmUgaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGlzUG93ZXJPZlR3byggaW1hZ2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGhVdGlscy5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgTWF0aFV0aWxzLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIGlzV2ViR0wyICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHx8XHJcblx0XHRcdCggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgc3VwcG9ydHNNaXBzICkge1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBzdXBwb3J0c01pcHMgJiZcclxuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICkge1xyXG5cclxuXHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0SW50ZXJuYWxGb3JtYXQoIGludGVybmFsRm9ybWF0TmFtZSwgZ2xGb3JtYXQsIGdsVHlwZSwgY29sb3JTcGFjZSwgZm9yY2VMaW5lYXJUcmFuc2ZlciA9IGZhbHNlICkge1xyXG5cclxuXHRcdGlmICggaXNXZWJHTDIgPT09IGZhbHNlICkgcmV0dXJuIGdsRm9ybWF0O1xyXG5cclxuXHRcdGlmICggaW50ZXJuYWxGb3JtYXROYW1lICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCBfZ2xbIGludGVybmFsRm9ybWF0TmFtZSBdICE9PSB1bmRlZmluZWQgKSByZXR1cm4gX2dsWyBpbnRlcm5hbEZvcm1hdE5hbWUgXTtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gdXNlIG5vbi1leGlzdGluZyBXZWJHTCBpbnRlcm5hbCBmb3JtYXQgXFwnJyArIGludGVybmFsRm9ybWF0TmFtZSArICdcXCcnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBpbnRlcm5hbEZvcm1hdCA9IGdsRm9ybWF0O1xyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SRUQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjMyRjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjE2RjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUjg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IF9nbC5SRyApIHtcclxuXHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SRzMyRjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkcxNkY7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBfZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gX2dsLlJHODtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gX2dsLlJHQkEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTMyRjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCQTE2RjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICYmIGZvcmNlTGluZWFyVHJhbnNmZXIgPT09IGZhbHNlICkgPyBfZ2wuU1JHQjhfQUxQSEE4IDogX2dsLlJHQkE4O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQgKSBpbnRlcm5hbEZvcm1hdCA9IF9nbC5SR0JBNDtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xICkgaW50ZXJuYWxGb3JtYXQgPSBfZ2wuUkdCNV9BMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlIxNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SMzJGIHx8XHJcblx0XHRcdGludGVybmFsRm9ybWF0ID09PSBfZ2wuUkcxNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SRzMyRiB8fFxyXG5cdFx0XHRpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLlJHQkExNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5SR0JBMzJGICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW50ZXJuYWxGb3JtYXQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TWlwTGV2ZWxzKCB0ZXh0dXJlLCBpbWFnZSwgc3VwcG9ydHNNaXBzICkge1xyXG5cclxuXHRcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMgKSA9PT0gdHJ1ZSB8fCAoIHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgubG9nMiggTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKSApICsgMTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLm1pcG1hcHMgIT09IHVuZGVmaW5lZCAmJiB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdC8vIHVzZXItZGVmaW5lZCBtaXBtYXBzXHJcblxyXG5cdFx0XHRyZXR1cm4gdGV4dHVyZS5taXBtYXBzLmxlbmd0aDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgJiYgQXJyYXkuaXNBcnJheSggdGV4dHVyZS5pbWFnZSApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGltYWdlLm1pcG1hcHMubGVuZ3RoO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyB0ZXh0dXJlIHdpdGhvdXQgbWlwbWFwcyAob25seSBiYXNlIGxldmVsKVxyXG5cclxuXHRcdFx0cmV0dXJuIDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrKCBmICkge1xyXG5cclxuXHRcdGlmICggZiA9PT0gTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIF9nbC5ORUFSRVNUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRfdmlkZW9UZXh0dXJlcy5kZWxldGUoIHRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHQvLyBjaGVjayBpZiBpdCdzIG5lY2Vzc2FyeSB0byByZW1vdmUgdGhlIFdlYkdMVGV4dHVyZSBvYmplY3RcclxuXHJcblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcclxuXHRcdGNvbnN0IHdlYmdsVGV4dHVyZXMgPSBfc291cmNlcy5nZXQoIHNvdXJjZSApO1xyXG5cclxuXHRcdGlmICggd2ViZ2xUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHdlYmdsVGV4dHVyZSA9IHdlYmdsVGV4dHVyZXNbIHRleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXkgXTtcclxuXHRcdFx0d2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyAtLTtcclxuXHJcblx0XHRcdC8vIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IGlzIG5vdCB1c2VkIGFueW1vcmUsIHJlbW92ZSBpdFxyXG5cclxuXHRcdFx0aWYgKCB3ZWJnbFRleHR1cmUudXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRkZWxldGVUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZW1vdmUgdGhlIHdlYWsgbWFwIGVudHJ5IGlmIG5vIFdlYkdMVGV4dHVyZSB1c2VzIHRoZSBzb3VyY2UgYW55bW9yZVxyXG5cclxuXHRcdFx0aWYgKCBPYmplY3Qua2V5cyggd2ViZ2xUZXh0dXJlcyApLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0X3NvdXJjZXMuZGVsZXRlKCBzb3VyY2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cHJvcGVydGllcy5yZW1vdmUoIHRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcclxuXHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdGNvbnN0IHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xyXG5cdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlcyA9IF9zb3VyY2VzLmdldCggc291cmNlICk7XHJcblx0XHRkZWxldGUgd2ViZ2xUZXh0dXJlc1sgdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSBdO1xyXG5cclxuXHRcdGluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICkgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZVsgaSBdICk7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0aW5mby5tZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cHJvcGVydGllcy5yZW1vdmUoIHRleHR1cmVbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwcm9wZXJ0aWVzLnJlbW92ZSggdGV4dHVyZSApO1xyXG5cdFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGxldCB0ZXh0dXJlVW5pdHMgPSAwO1xyXG5cclxuXHRmdW5jdGlvbiByZXNldFRleHR1cmVVbml0cygpIHtcclxuXHJcblx0XHR0ZXh0dXJlVW5pdHMgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlVGV4dHVyZVVuaXQoKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZVVuaXQgPSB0ZXh0dXJlVW5pdHM7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlVW5pdCA+PSBtYXhUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMVGV4dHVyZXM6IFRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIG1heFRleHR1cmVzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRleHR1cmVVbml0cyArPSAxO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRUZXh0dXJlQ2FjaGVLZXkoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLndyYXBTICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLndyYXBUICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLndyYXBSIHx8IDAgKTtcclxuXHRcdGFycmF5LnB1c2goIHRleHR1cmUubWFnRmlsdGVyICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLm1pbkZpbHRlciApO1xyXG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5hbmlzb3Ryb3B5ICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmludGVybmFsRm9ybWF0ICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmZvcm1hdCApO1xyXG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS50eXBlICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyApO1xyXG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLmZsaXBZICk7XHJcblx0XHRhcnJheS5wdXNoKCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cdFx0YXJyYXkucHVzaCggdGV4dHVyZS5jb2xvclNwYWNlICk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHVwZGF0ZVZpZGVvVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlICYmIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLicgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEQXJyYXkoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJEX0FSUkFZLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFRleHR1cmUzRCggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfM0QsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHVwbG9hZEN1YmVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdCB3cmFwcGluZ1RvR0wgPSB7XHJcblx0XHRbIFJlcGVhdFdyYXBwaW5nIF06IF9nbC5SRVBFQVQsXHJcblx0XHRbIENsYW1wVG9FZGdlV3JhcHBpbmcgXTogX2dsLkNMQU1QX1RPX0VER0UsXHJcblx0XHRbIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgXTogX2dsLk1JUlJPUkVEX1JFUEVBVFxyXG5cdH07XHJcblxyXG5cdGNvbnN0IGZpbHRlclRvR0wgPSB7XHJcblx0XHRbIE5lYXJlc3RGaWx0ZXIgXTogX2dsLk5FQVJFU1QsXHJcblx0XHRbIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIF06IF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxyXG5cdFx0WyBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIF06IF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXHJcblxyXG5cdFx0WyBMaW5lYXJGaWx0ZXIgXTogX2dsLkxJTkVBUixcclxuXHRcdFsgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciBdOiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxyXG5cdFx0WyBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgXTogX2dsLkxJTkVBUl9NSVBNQVBfTElORUFSXHJcblx0fTtcclxuXHJcblx0Y29uc3QgY29tcGFyZVRvR0wgPSB7XHJcblx0XHRbIE5ldmVyQ29tcGFyZSBdOiBfZ2wuTkVWRVIsXHJcblx0XHRbIEFsd2F5c0NvbXBhcmUgXTogX2dsLkFMV0FZUyxcclxuXHRcdFsgTGVzc0NvbXBhcmUgXTogX2dsLkxFU1MsXHJcblx0XHRbIExlc3NFcXVhbENvbXBhcmUgXTogX2dsLkxFUVVBTCxcclxuXHRcdFsgRXF1YWxDb21wYXJlIF06IF9nbC5FUVVBTCxcclxuXHRcdFsgR3JlYXRlckVxdWFsQ29tcGFyZSBdOiBfZ2wuR0VRVUFMLFxyXG5cdFx0WyBHcmVhdGVyQ29tcGFyZSBdOiBfZ2wuR1JFQVRFUixcclxuXHRcdFsgTm90RXF1YWxDb21wYXJlIF06IF9nbC5OT1RFUVVBTFxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzICkge1xyXG5cclxuXHRcdGlmICggc3VwcG9ydHNNaXBzICkge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBwaW5nVG9HTFsgdGV4dHVyZS53cmFwUyBdICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCB3cmFwcGluZ1RvR0xbIHRleHR1cmUud3JhcFQgXSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUiwgd3JhcHBpbmdUb0dMWyB0ZXh0dXJlLndyYXBSIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyVG9HTFsgdGV4dHVyZS5tYWdGaWx0ZXIgXSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclRvR0xbIHRleHR1cmUubWluRmlsdGVyIF0gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlVHlwZSA9PT0gX2dsLlRFWFRVUkVfM0QgfHwgdGV4dHVyZVR5cGUgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUiwgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uICkge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9DT01QQVJFX01PREUsIF9nbC5DT01QQVJFX1JFRl9UT19URVhUVVJFICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfQ09NUEFSRV9GVU5DLCBjb21wYXJlVG9HTFsgdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUubWFnRmlsdGVyID09PSBOZWFyZXN0RmlsdGVyICkgcmV0dXJuO1xyXG5cdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm47XHJcblx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5oYXMoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IGZhbHNlICkgcmV0dXJuOyAvLyB2ZXJpZnkgZXh0ZW5zaW9uIGZvciBXZWJHTCAxIGFuZCBXZWJHTCAyXHJcblx0XHRcdGlmICggaXNXZWJHTDIgPT09IGZhbHNlICYmICggdGV4dHVyZS50eXBlID09PSBIYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuaGFzKCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IGZhbHNlICkgKSByZXR1cm47IC8vIHZlcmlmeSBleHRlbnNpb24gZm9yIFdlYkdMIDEgb25seVxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xyXG5cdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW5pdFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGxldCBmb3JjZVVwbG9hZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcclxuXHJcblx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNyZWF0ZSBTb3VyY2UgPC0+IFdlYkdMVGV4dHVyZXMgbWFwcGluZyBpZiBuZWNlc3NhcnlcclxuXHJcblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcclxuXHRcdGxldCB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KCBzb3VyY2UgKTtcclxuXHJcblx0XHRpZiAoIHdlYmdsVGV4dHVyZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHdlYmdsVGV4dHVyZXMgPSB7fTtcclxuXHRcdFx0X3NvdXJjZXMuc2V0KCBzb3VyY2UsIHdlYmdsVGV4dHVyZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIFdlYkdMVGV4dHVyZSBvYmplY3QgZm9yIHRoZSBnaXZlbiB0ZXh0dXJlIHBhcmFtZXRlcnNcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlQ2FjaGVLZXkgPSBnZXRUZXh0dXJlQ2FjaGVLZXkoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVDYWNoZUtleSAhPT0gdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSApIHtcclxuXHJcblx0XHRcdC8vIGlmIG5vdCwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIFdlYkdMVGV4dHVyZVxyXG5cclxuXHRcdFx0aWYgKCB3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlQ2FjaGVLZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBjcmVhdGUgbmV3IGVudHJ5XHJcblxyXG5cdFx0XHRcdHdlYmdsVGV4dHVyZXNbIHRleHR1cmVDYWNoZUtleSBdID0ge1xyXG5cdFx0XHRcdFx0dGV4dHVyZTogX2dsLmNyZWF0ZVRleHR1cmUoKSxcclxuXHRcdFx0XHRcdHVzZWRUaW1lczogMFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0XHQvLyB3aGVuIGEgbmV3IGluc3RhbmNlIG9mIFdlYkdMVGV4dHVyZSB3YXMgY3JlYXRlZCwgYSB0ZXh0dXJlIHVwbG9hZCBpcyByZXF1aXJlZFxyXG5cdFx0XHRcdC8vIGV2ZW4gaWYgdGhlIGltYWdlIGNvbnRlbnRzIGFyZSBpZGVudGljYWxcclxuXHJcblx0XHRcdFx0Zm9yY2VVcGxvYWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2ViZ2xUZXh0dXJlc1sgdGV4dHVyZUNhY2hlS2V5IF0udXNlZFRpbWVzICsrO1xyXG5cclxuXHRcdFx0Ly8gZXZlcnkgdGltZSB0aGUgdGV4dHVyZSBjYWNoZSBrZXkgY2hhbmdlcywgaXQncyBuZWNlc3NhcnkgdG8gY2hlY2sgaWYgYW4gaW5zdGFuY2Ugb2ZcclxuXHRcdFx0Ly8gV2ViR0xUZXh0dXJlIGNhbiBiZSBkZWxldGVkIGluIG9yZGVyIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsuXHJcblxyXG5cdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSB3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5IF07XHJcblxyXG5cdFx0XHRpZiAoIHdlYmdsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5IF0udXNlZFRpbWVzIC0tO1xyXG5cclxuXHRcdFx0XHRpZiAoIHdlYmdsVGV4dHVyZS51c2VkVGltZXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGVsZXRlVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzdG9yZSByZWZlcmVuY2VzIHRvIGNhY2hlIGtleSBhbmQgV2ViR0xUZXh0dXJlIG9iamVjdFxyXG5cclxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSA9IHRleHR1cmVDYWNoZUtleTtcclxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSB3ZWJnbFRleHR1cmVzWyB0ZXh0dXJlQ2FjaGVLZXkgXS50ZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm9yY2VVcGxvYWQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0bGV0IHRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfMkQ7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfMkRfQVJSQVk7XHJcblx0XHRpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkgdGV4dHVyZVR5cGUgPSBfZ2wuVEVYVFVSRV8zRDtcclxuXHJcblx0XHRjb25zdCBmb3JjZVVwbG9hZCA9IGluaXRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSApO1xyXG5cdFx0Y29uc3Qgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XHJcblxyXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRleHR1cmVUeXBlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cclxuXHRcdGNvbnN0IHNvdXJjZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggc291cmNlICk7XHJcblxyXG5cdFx0aWYgKCBzb3VyY2UudmVyc2lvbiAhPT0gc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gfHwgZm9yY2VVcGxvYWQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblxyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIF9nbC5OT05FICk7XHJcblxyXG5cdFx0XHRjb25zdCBuZWVkc1Bvd2VyT2ZUd28gPSB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkgJiYgaXNQb3dlck9mVHdvKCB0ZXh0dXJlLmltYWdlICkgPT09IGZhbHNlO1xyXG5cdFx0XHRsZXQgaW1hZ2UgPSByZXNpemVJbWFnZSggdGV4dHVyZS5pbWFnZSwgbmVlZHNQb3dlck9mVHdvLCBmYWxzZSwgbWF4VGV4dHVyZVNpemUgKTtcclxuXHRcdFx0aW1hZ2UgPSB2ZXJpZnlDb2xvclNwYWNlKCB0ZXh0dXJlLCBpbWFnZSApO1xyXG5cclxuXHRcdFx0Y29uc3Qgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvKCBpbWFnZSApIHx8IGlzV2ViR0wyLFxyXG5cdFx0XHRcdGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdFx0bGV0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApLFxyXG5cdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCggdGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5jb2xvclNwYWNlICk7XHJcblxyXG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyApO1xyXG5cclxuXHRcdFx0bGV0IG1pcG1hcDtcclxuXHRcdFx0Y29uc3QgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcclxuXHJcblx0XHRcdGNvbnN0IHVzZVRleFN0b3JhZ2UgPSAoIGlzV2ViR0wyICYmIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgIT09IHRydWUgKTtcclxuXHRcdFx0Y29uc3QgYWxsb2NhdGVNZW1vcnkgPSAoIHNvdXJjZVByb3BlcnRpZXMuX192ZXJzaW9uID09PSB1bmRlZmluZWQgKSB8fCAoIGZvcmNlVXBsb2FkID09PSB0cnVlICk7XHJcblx0XHRcdGNvbnN0IGxldmVscyA9IGdldE1pcExldmVscyggdGV4dHVyZSwgaW1hZ2UsIHN1cHBvcnRzTWlwcyApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHQvLyBwb3B1bGF0ZSBkZXB0aCB0ZXh0dXJlIHdpdGggZHVtbXkgZGF0YVxyXG5cclxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDtcclxuXHJcblx0XHRcdFx0aWYgKCBpc1dlYkdMMiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQzMkY7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS50eXBlID09PSBVbnNpZ25lZEludFR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDI0O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUudHlwZSA9PT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSDI0X1NURU5DSUw4O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2OyAvLyBXZWJHTDIgcmVxdWlyZXMgc2l6ZWQgaW50ZXJuYWxmb3JtYXQgZm9yIGdsVGV4SW1hZ2UyRFxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdMUmVuZGVyZXI6IEZsb2F0aW5nIHBvaW50IGRlcHRoIHRleHR1cmUgcmVxdWlyZXMgV2ViR0wyLicgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdmFsaWRhdGlvbiBjaGVja3MgZm9yIFdlYkdMIDFcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgJiYgZ2xJbnRlcm5hbEZvcm1hdCA9PT0gX2dsLkRFUFRIX0NPTVBPTkVOVCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcclxuXHRcdFx0XHRcdC8vIERFUFRIX0NPTVBPTkVOVCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfU0hPUlQgb3IgVU5TSUdORURfSU5UXHJcblx0XHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZFNob3J0VHlwZSAmJiB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50VHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZFNob3J0VHlwZSBvciBVbnNpZ25lZEludFR5cGUgZm9yIERlcHRoRm9ybWF0IERlcHRoVGV4dHVyZS4nICk7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludFR5cGU7XHJcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgJiYgZ2xJbnRlcm5hbEZvcm1hdCA9PT0gX2dsLkRFUFRIX0NPTVBPTkVOVCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBEZXB0aCBzdGVuY2lsIHRleHR1cmVzIG5lZWQgdGhlIERFUFRIX1NURU5DSUwgaW50ZXJuYWwgZm9ybWF0XHJcblx0XHRcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcclxuXHRcdFx0XHRcdGdsSW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfU1RFTkNJTDtcclxuXHJcblx0XHRcdFx0XHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcclxuXHRcdFx0XHRcdC8vIERFUFRIX1NURU5DSUwgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX0lOVF8yNF84X1dFQkdMLlxyXG5cdFx0XHRcdFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkSW50MjQ4VHlwZSBmb3IgRGVwdGhTdGVuY2lsRm9ybWF0IERlcHRoVGV4dHVyZS4nICk7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XHJcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDEsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcclxuXHJcblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgc3VwcG9ydHNNaXBzICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1sgMCBdLndpZHRoLCBtaXBtYXBzWyAwIF0uaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBzWyAwIF0ud2lkdGgsIG1pcG1hcHNbIDAgXS5oZWlnaHQsIGltYWdlLmRlcHRoICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBnbEZvcm1hdCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIGksIDAsIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBtaXBtYXAuZGF0YSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UzRCggX2dsLlRFWFRVUkVfMkRfQVJSQVksIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIG1pcG1hcC5kYXRhLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCknICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgMCwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcHNbIDAgXS53aWR0aCwgbWlwbWFwc1sgMCBdLmhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZ2xGb3JtYXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGdsRm9ybWF0LCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKScgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgMCwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKCBfZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGFsbG9jYXRlTWVtb3J5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTNEKCBfZ2wuVEVYVFVSRV8zRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTNEKCBfZ2wuVEVYVFVSRV8zRCwgMCwgMCwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKCBfZ2wuVEVYVFVSRV8zRCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhbGxvY2F0ZU1lbW9yeSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0bGV0IHdpZHRoID0gaW1hZ2Uud2lkdGgsIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxldmVsczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsSW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0d2lkdGggPj49IDE7XHJcblx0XHRcdFx0XHRcdFx0aGVpZ2h0ID4+PSAxO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcclxuXHJcblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcclxuXHJcblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgc3VwcG9ydHNNaXBzICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHN0YXRlLnRleFN0b3JhZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1sgMCBdLndpZHRoLCBtaXBtYXBzWyAwIF0uaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhbGxvY2F0ZU1lbW9yeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3RvcmFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgc3VwcG9ydHNNaXBzICkgKSB7XHJcblxyXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCB0ZXh0dXJlVHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPSBzb3VyY2UudmVyc2lvbjtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwbG9hZEN1YmVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoICE9PSA2ICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGZvcmNlVXBsb2FkID0gaW5pdFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlICk7XHJcblx0XHRjb25zdCBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblxyXG5cdFx0Y29uc3Qgc291cmNlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBzb3VyY2UgKTtcclxuXHJcblx0XHRpZiAoIHNvdXJjZS52ZXJzaW9uICE9PSBzb3VyY2VQcm9wZXJ0aWVzLl9fdmVyc2lvbiB8fCBmb3JjZVVwbG9hZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgX2dsLk5PTkUgKTtcclxuXHJcblx0XHRcdGNvbnN0IGlzQ29tcHJlc3NlZCA9ICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlIHx8IHRleHR1cmUuaW1hZ2VbIDAgXS5pc0NvbXByZXNzZWRUZXh0dXJlICk7XHJcblx0XHRcdGNvbnN0IGlzRGF0YVRleHR1cmUgPSAoIHRleHR1cmUuaW1hZ2VbIDAgXSAmJiB0ZXh0dXJlLmltYWdlWyAwIF0uaXNEYXRhVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0Y29uc3QgY3ViZUltYWdlID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IHJlc2l6ZUltYWdlKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGZhbHNlLCB0cnVlLCBtYXhDdWJlbWFwU2l6ZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IHZlcmlmeUNvbG9yU3BhY2UoIHRleHR1cmUsIGN1YmVJbWFnZVsgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxyXG5cdFx0XHRcdHN1cHBvcnRzTWlwcyA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSB8fCBpc1dlYkdMMixcclxuXHRcdFx0XHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmNvbG9yU3BhY2UgKSxcclxuXHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKSxcclxuXHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdFx0Y29uc3QgdXNlVGV4U3RvcmFnZSA9ICggaXNXZWJHTDIgJiYgdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSAhPT0gdHJ1ZSApO1xyXG5cdFx0XHRjb25zdCBhbGxvY2F0ZU1lbW9yeSA9ICggc291cmNlUHJvcGVydGllcy5fX3ZlcnNpb24gPT09IHVuZGVmaW5lZCApIHx8ICggZm9yY2VVcGxvYWQgPT09IHRydWUgKTtcclxuXHRcdFx0bGV0IGxldmVscyA9IGdldE1pcExldmVscyggdGV4dHVyZSwgaW1hZ2UsIHN1cHBvcnRzTWlwcyApO1xyXG5cclxuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMgKTtcclxuXHJcblx0XHRcdGxldCBtaXBtYXBzO1xyXG5cclxuXHRcdFx0aWYgKCBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG1pcG1hcHMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBnbEZvcm1hdCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKScgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcclxuXHJcblx0XHRcdFx0aWYgKCB1c2VUZXhTdG9yYWdlICYmIGFsbG9jYXRlTWVtb3J5ICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE86IFVuaWZvcm1seSBoYW5kbGUgbWlwbWFwIGRlZmluaXRpb25zXHJcblx0XHRcdFx0XHQvLyBOb3JtYWwgdGV4dHVyZXMgYW5kIGNvbXByZXNzZWQgY3ViZSB0ZXh0dXJlcyBkZWZpbmUgYmFzZSBsZXZlbCArIG1pcHMgd2l0aCB0aGVpciBtaXBtYXAgYXJyYXlcclxuXHRcdFx0XHRcdC8vIFVuY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIHVzZSB0aGVpciBtaXBtYXAgYXJyYXkgb25seSBmb3IgbWlwcyAobm8gYmFzZSBsZXZlbClcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCApIGxldmVscyArKztcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhTdG9yYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGN1YmVJbWFnZVsgMCBdLndpZHRoLCBjdWJlSW1hZ2VbIDAgXS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIDAsIDAsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEludGVybmFsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBtaXBtYXBzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1pcG1hcEltYWdlID0gbWlwbWFwLmltYWdlWyBpIF0uaW1hZ2U7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlVGV4U3RvcmFnZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhTdWJJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIDAsIDAsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiArIDEsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCAwLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBtaXBtYXBzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZVRleFN0b3JhZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGogKyAxLCAwLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuaW1hZ2VbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqICsgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmltYWdlWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIHN1cHBvcnRzTWlwcyApICkge1xyXG5cclxuXHRcdFx0XHQvLyBXZSBhc3N1bWUgaW1hZ2VzIGZvciBjdWJlIG1hcCBoYXZlIHRoZSBzYW1lIHNpemUuXHJcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzb3VyY2VQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHNvdXJjZS52ZXJzaW9uO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gUmVuZGVyIHRhcmdldHNcclxuXHJcblx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxyXG5cdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuY29sb3JTcGFjZSApO1xyXG5cdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XHJcblx0XHRjb25zdCBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoIHRleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuY29sb3JTcGFjZSApO1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2hhc0V4dGVybmFsVGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzNEIHx8IHRleHR1cmVUYXJnZXQgPT09IF9nbC5URVhUVVJFXzJEX0FSUkFZICkge1xyXG5cclxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTNEKCB0ZXh0dXJlVGFyZ2V0LCAwLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIHJlbmRlclRhcmdldC5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggdGV4dHVyZVRhcmdldCwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcclxuXHJcblx0XHRcdG11bHRpc2FtcGxlZFJUVEV4dC5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKCBfZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAsIGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZVRhcmdldCA9PT0gX2dsLlRFWFRVUkVfMkQgfHwgKCB0ZXh0dXJlVGFyZ2V0ID49IF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggJiYgdGV4dHVyZVRhcmdldCA8PSBfZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aICkgKSB7IC8vIHNlZSAjMjQ3NTNcclxuXHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIGludGVybmFsIGRlcHRoL3N0ZW5jaWwgYnVmZmVycyBhbmQgYmluZCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXHJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCwgaXNNdWx0aXNhbXBsZSApIHtcclxuXHJcblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGxldCBnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2O1xyXG5cclxuXHRcdFx0aWYgKCBpc011bHRpc2FtcGxlIHx8IHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRlcHRoVGV4dHVyZSA9IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmU7XHJcblxyXG5cdFx0XHRcdGlmICggZGVwdGhUZXh0dXJlICYmIGRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRlcHRoVGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbEludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkZXB0aFRleHR1cmUudHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQyNDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZUVYVCggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSggX2dsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0aWYgKCBpc011bHRpc2FtcGxlICYmIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBfZ2wuREVQVEgyNF9TVEVOQ0lMOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApICkge1xyXG5cclxuXHRcdFx0XHRtdWx0aXNhbXBsZWRSVFRFeHQucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBfZ2wuREVQVEgyNF9TVEVOQ0lMOCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZSA/IHJlbmRlclRhcmdldC50ZXh0dXJlIDogWyByZW5kZXJUYXJnZXQudGV4dHVyZSBdO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5jb2xvclNwYWNlICk7XHJcblx0XHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XHJcblx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KCB0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmNvbG9yU3BhY2UgKTtcclxuXHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNNdWx0aXNhbXBsZSAmJiB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRtdWx0aXNhbXBsZWRSVFRFeHQucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTZXR1cCByZXNvdXJjZXMgZm9yIGEgRGVwdGggVGV4dHVyZSBmb3IgYSBGQk8gKG5lZWRzIGFuIGV4dGVuc2lvbilcclxuXHRmdW5jdGlvbiBzZXR1cERlcHRoVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRjb25zdCBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgKTtcclxuXHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAnRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCcgKTtcclxuXHJcblx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHJcblx0XHRpZiAoICEgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwbG9hZCBhbiBlbXB0eSBkZXB0aCB0ZXh0dXJlIHdpdGggZnJhbWVidWZmZXIgc2l6ZVxyXG5cdFx0aWYgKCAhIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgfHxcclxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHxcclxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCAhPT0gcmVuZGVyVGFyZ2V0LmhlaWdodCApIHtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNldFRleHR1cmUyRCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdGNvbnN0IHdlYmdsRGVwdGhUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcclxuXHRcdGNvbnN0IHNhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHtcclxuXHJcblx0XHRcdGlmICggdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSApIHtcclxuXHJcblx0XHRcdFx0bXVsdGlzYW1wbGVkUlRURXh0LmZyYW1lYnVmZmVyVGV4dHVyZTJETXVsdGlzYW1wbGVFWFQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5URVhUVVJFXzJELCB3ZWJnbERlcHRoVGV4dHVyZSwgMCwgc2FtcGxlcyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApICkge1xyXG5cclxuXHRcdFx0XHRtdWx0aXNhbXBsZWRSVFRFeHQuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAsIHNhbXBsZXMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biBkZXB0aFRleHR1cmUgZm9ybWF0JyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXHJcblx0ZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRjb25zdCBpc0N1YmUgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9PT0gdHJ1ZSApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiAhIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19hdXRvQWxsb2NhdGVEZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnICk7XHJcblxyXG5cdFx0XHRzZXR1cERlcHRoVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBmYWxzZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcclxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyLCByZW5kZXJUYXJnZXQsIGZhbHNlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gcmViaW5kIGZyYW1lYnVmZmVyIHdpdGggZXh0ZXJuYWwgdGV4dHVyZXNcclxuXHRmdW5jdGlvbiByZWJpbmRUZXh0dXJlcyggcmVuZGVyVGFyZ2V0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdGlmICggY29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBTZXQgdXAgR0wgcmVzb3VyY2VzIGZvciB0aGUgcmVuZGVyIHRhcmdldFxyXG5cdGZ1bmN0aW9uIHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cdFx0XHRpbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09IHRydWUgKTtcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZSApO1xyXG5cdFx0Y29uc3Qgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKSB8fCBpc1dlYkdMMjtcclxuXHJcblx0XHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxyXG5cclxuXHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmRyYXdCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wyIG9yIFdFQkdMX2RyYXdfYnVmZmVycyBleHRlbnNpb24uJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICggaXNXZWJHTDIgJiYgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAwICkgJiYgdXNlTXVsdGlzYW1wbGVkUlRUKCByZW5kZXJUYXJnZXQgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPyB0ZXh0dXJlIDogWyB0ZXh0dXJlIF07XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbIGkgXTtcclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmNvbG9yU3BhY2UgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xyXG5cdFx0XHRcdFx0Y29uc3QgZ2xJbnRlcm5hbEZvcm1hdCA9IGdldEludGVybmFsRm9ybWF0KCB0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmNvbG9yU3BhY2UsIHJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlICk7XHJcblx0XHRcdFx0XHRjb25zdCBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKCBfZ2wuUkVOREVSQlVGRkVSLCBzYW1wbGVzLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXHJcblxyXG5cdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgc3VwcG9ydHNNaXBzICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgc3VwcG9ydHNNaXBzICkgKSB7XHJcblxyXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXR0YWNobWVudCA9IHRleHR1cmVzWyBpIF07XHJcblx0XHRcdFx0Y29uc3QgYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggYXR0YWNobWVudCApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCBhdHRhY2htZW50LCBzdXBwb3J0c01pcHMgKTtcclxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIGF0dGFjaG1lbnQsIHN1cHBvcnRzTWlwcyApICkge1xyXG5cclxuXHRcdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGxldCBnbFRleHR1cmVUeXBlID0gX2dsLlRFWFRVUkVfMkQ7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMM0RSZW5kZXJUYXJnZXQgfHwgcmVuZGVyVGFyZ2V0LmlzV2ViR0xBcnJheVJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpc1dlYkdMMiApIHtcclxuXHJcblx0XHRcdFx0XHRnbFRleHR1cmVUeXBlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0wzRFJlbmRlclRhcmdldCA/IF9nbC5URVhUVVJFXzNEIDogX2dsLlRFWFRVUkVfMkRfQVJSQVk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMVGV4dHVyZXM6IFRIUkVFLkRhdGEzRFRleHR1cmUgYW5kIFRIUkVFLkRhdGFBcnJheVRleHR1cmUgb25seSBzdXBwb3J0ZWQgd2l0aCBXZWJHTDIuJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmUsIHN1cHBvcnRzTWlwcyApO1xyXG5cdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbFRleHR1cmVUeXBlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgc3VwcG9ydHNNaXBzICkgKSB7XHJcblxyXG5cdFx0XHRcdGdlbmVyYXRlTWlwbWFwKCBnbFRleHR1cmVUeXBlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRjb25zdCBzdXBwb3J0c01pcHMgPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApIHx8IGlzV2ViR0wyO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPT09IHRydWUgPyByZW5kZXJUYXJnZXQudGV4dHVyZSA6IFsgcmVuZGVyVGFyZ2V0LnRleHR1cmUgXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGV4dHVyZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcclxuXHRcdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCB3ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0XHRnZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XHJcblx0XHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggKCBpc1dlYkdMMiAmJiByZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDAgKSAmJiB1c2VNdWx0aXNhbXBsZWRSVFQoIHJlbmRlclRhcmdldCApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPyByZW5kZXJUYXJnZXQudGV4dHVyZSA6IFsgcmVuZGVyVGFyZ2V0LnRleHR1cmUgXTtcclxuXHRcdFx0Y29uc3Qgd2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcblx0XHRcdGNvbnN0IGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XHJcblx0XHRcdGxldCBtYXNrID0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XHJcblx0XHRcdGNvbnN0IGludmFsaWRhdGlvbkFycmF5ID0gW107XHJcblx0XHRcdGNvbnN0IGRlcHRoU3R5bGUgPSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA/IF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQgOiBfZ2wuREVQVEhfQVRUQUNITUVOVDtcclxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdFx0Y29uc3QgaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID09PSB0cnVlICk7XHJcblxyXG5cdFx0XHQvLyBJZiBNUlQgd2UgbmVlZCB0byByZW1vdmUgRkJPIGF0dGFjaG1lbnRzXHJcblx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIgKTtcclxuXHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XHJcblx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheS5wdXNoKCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICk7XHJcblxyXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdGludmFsaWRhdGlvbkFycmF5LnB1c2goIGRlcHRoU3R5bGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBpZ25vcmVEZXB0aFZhbHVlcyA9ICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2lnbm9yZURlcHRoVmFsdWVzICE9PSB1bmRlZmluZWQgKSA/IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19pZ25vcmVEZXB0aFZhbHVlcyA6IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGlnbm9yZURlcHRoVmFsdWVzID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIG1hc2sgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XHJcblx0XHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkgbWFzayB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlclsgaSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBpZ25vcmVEZXB0aFZhbHVlcyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKCBfZ2wuUkVBRF9GUkFNRUJVRkZFUiwgWyBkZXB0aFN0eWxlIF0gKTtcclxuXHRcdFx0XHRcdF9nbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCBbIGRlcHRoU3R5bGUgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaXNNdWx0aXBsZVJlbmRlclRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmVzWyBpIF0gKS5fX3dlYmdsVGV4dHVyZTtcclxuXHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5ibGl0RnJhbWVidWZmZXIoIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIG1hc2ssIF9nbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0XHRcdGlmICggc3VwcG9ydHNJbnZhbGlkYXRlRnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlciggX2dsLlJFQURfRlJBTUVCVUZGRVIsIGludmFsaWRhdGlvbkFycmF5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5SRUFEX0ZSQU1FQlVGRkVSLCBudWxsICk7XHJcblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkRSQVdfRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHRcdC8vIElmIE1SVCBzaW5jZSBwcmUtYmxpdCB3ZSByZW1vdmVkIHRoZSBGQk8gd2UgbmVlZCB0byByZWNvbnN0cnVjdCB0aGUgYXR0YWNobWVudHNcclxuXHRcdFx0aWYgKCBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZXNbIGkgXSApLl9fd2ViZ2xUZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRFJBV19GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIF9nbC5EUkFXX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGgubWluKCBtYXhTYW1wbGVzLCByZW5kZXJUYXJnZXQuc2FtcGxlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCAmJiBleHRlbnNpb25zLmhhcyggJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScgKSA9PT0gdHJ1ZSAmJiByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlUmVuZGVyVG9UZXh0dXJlICE9PSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVWaWRlb1RleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcclxuXHJcblx0XHQvLyBDaGVjayB0aGUgbGFzdCBmcmFtZSB3ZSB1cGRhdGVkIHRoZSBWaWRlb1RleHR1cmVcclxuXHJcblx0XHRpZiAoIF92aWRlb1RleHR1cmVzLmdldCggdGV4dHVyZSApICE9PSBmcmFtZSApIHtcclxuXHJcblx0XHRcdF92aWRlb1RleHR1cmVzLnNldCggdGV4dHVyZSwgZnJhbWUgKTtcclxuXHRcdFx0dGV4dHVyZS51cGRhdGUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdmVyaWZ5Q29sb3JTcGFjZSggdGV4dHVyZSwgaW1hZ2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgY29sb3JTcGFjZSA9IHRleHR1cmUuY29sb3JTcGFjZTtcclxuXHRcdGNvbnN0IGZvcm1hdCA9IHRleHR1cmUuZm9ybWF0O1xyXG5cdFx0Y29uc3QgdHlwZSA9IHRleHR1cmUudHlwZTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmZvcm1hdCA9PT0gX1NSR0JBRm9ybWF0ICkgcmV0dXJuIGltYWdlO1xyXG5cclxuXHRcdGlmICggY29sb3JTcGFjZSAhPT0gTGluZWFyU1JHQkNvbG9yU3BhY2UgJiYgY29sb3JTcGFjZSAhPT0gTm9Db2xvclNwYWNlICkge1xyXG5cclxuXHRcdFx0Ly8gc1JHQlxyXG5cclxuXHRcdFx0aWYgKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpc1dlYkdMMiA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaW4gV2ViR0wgMSwgdHJ5IHRvIHVzZSBFWFRfc1JHQiBleHRlbnNpb24gYW5kIHVuc2l6ZWQgZm9ybWF0c1xyXG5cclxuXHRcdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5oYXMoICdFWFRfc1JHQicgKSA9PT0gdHJ1ZSAmJiBmb3JtYXQgPT09IFJHQkFGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IF9TUkdCQUZvcm1hdDtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGdlbmVyYXRlIG1pcHMgaW4gV2ViR0wgMSB3aXRoIHRoaXMgZXh0ZW5zaW9uXHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc2xvdyBmYWxsYmFjayAoQ1BVIGRlY29kZSlcclxuXHJcblx0XHRcdFx0XHRcdGltYWdlID0gSW1hZ2VVdGlscy5zUkdCVG9MaW5lYXIoIGltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIGluIFdlYkdMIDIgdW5jb21wcmVzc2VkIHRleHR1cmVzIGNhbiBvbmx5IGJlIHNSR0IgZW5jb2RlZCBpZiB0aGV5IGhhdmUgdGhlIFJHQkE4IGZvcm1hdFxyXG5cclxuXHRcdFx0XHRcdGlmICggZm9ybWF0ICE9PSBSR0JBRm9ybWF0IHx8IHR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFRleHR1cmVzOiBzUkdCIGVuY29kZWQgdGV4dHVyZXMgaGF2ZSB0byB1c2UgUkdCQUZvcm1hdCBhbmQgVW5zaWduZWRCeXRlVHlwZS4nICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xUZXh0dXJlczogVW5zdXBwb3J0ZWQgdGV4dHVyZSBjb2xvciBzcGFjZTonLCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLmFsbG9jYXRlVGV4dHVyZVVuaXQgPSBhbGxvY2F0ZVRleHR1cmVVbml0O1xyXG5cdHRoaXMucmVzZXRUZXh0dXJlVW5pdHMgPSByZXNldFRleHR1cmVVbml0cztcclxuXHJcblx0dGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XHJcblx0dGhpcy5zZXRUZXh0dXJlMkRBcnJheSA9IHNldFRleHR1cmUyREFycmF5O1xyXG5cdHRoaXMuc2V0VGV4dHVyZTNEID0gc2V0VGV4dHVyZTNEO1xyXG5cdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcclxuXHR0aGlzLnJlYmluZFRleHR1cmVzID0gcmViaW5kVGV4dHVyZXM7XHJcblx0dGhpcy5zZXR1cFJlbmRlclRhcmdldCA9IHNldHVwUmVuZGVyVGFyZ2V0O1xyXG5cdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xyXG5cdHRoaXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgPSB1cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldDtcclxuXHR0aGlzLnNldHVwRGVwdGhSZW5kZXJidWZmZXIgPSBzZXR1cERlcHRoUmVuZGVyYnVmZmVyO1xyXG5cdHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUgPSBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZTtcclxuXHR0aGlzLnVzZU11bHRpc2FtcGxlZFJUVCA9IHVzZU11bHRpc2FtcGxlZFJUVDtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMVGV4dHVyZXMgfTtcclxuIiwiaW1wb3J0IHsgUkdCQV9BU1RDXzR4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDhfRm9ybWF0LCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDhfRm9ybWF0LCBSR0JBX0FTVENfMTB4MTBfRm9ybWF0LCBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0LCBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0LCBSR0JfRVRDMV9Gb3JtYXQsIFJHQl9FVEMyX0Zvcm1hdCwgUkdCQV9FVEMyX0VBQ19Gb3JtYXQsIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDNfRm9ybWF0LCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQsIFJHQl9TM1RDX0RYVDFfRm9ybWF0LCBEZXB0aEZvcm1hdCwgRGVwdGhTdGVuY2lsRm9ybWF0LCBMdW1pbmFuY2VBbHBoYUZvcm1hdCwgTHVtaW5hbmNlRm9ybWF0LCBSZWRGb3JtYXQsIFJHQkFGb3JtYXQsIEFscGhhRm9ybWF0LCBSZWRJbnRlZ2VyRm9ybWF0LCBSR0Zvcm1hdCwgUkdJbnRlZ2VyRm9ybWF0LCBSR0JBSW50ZWdlckZvcm1hdCwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBVbnNpZ25lZEludFR5cGUsIEludFR5cGUsIFVuc2lnbmVkU2hvcnRUeXBlLCBTaG9ydFR5cGUsIEJ5dGVUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUsIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSwgVW5zaWduZWRTaG9ydDQ0NDRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlLCBSR0JBX0JQVENfRm9ybWF0LCBfU1JHQkFGb3JtYXQsIFJFRF9SR1RDMV9Gb3JtYXQsIFNJR05FRF9SRURfUkdUQzFfRm9ybWF0LCBSRURfR1JFRU5fUkdUQzJfRm9ybWF0LCBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCwgU1JHQkNvbG9yU3BhY2UsIE5vQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5mdW5jdGlvbiBXZWJHTFV0aWxzKCBnbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzICkge1xyXG5cclxuXHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcclxuXHJcblx0ZnVuY3Rpb24gY29udmVydCggcCwgY29sb3JTcGFjZSA9IE5vQ29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRsZXQgZXh0ZW5zaW9uO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xyXG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcclxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XHJcblxyXG5cdFx0aWYgKCBwID09PSBCeXRlVHlwZSApIHJldHVybiBnbC5CWVRFO1xyXG5cdFx0aWYgKCBwID09PSBTaG9ydFR5cGUgKSByZXR1cm4gZ2wuU0hPUlQ7XHJcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUO1xyXG5cdFx0aWYgKCBwID09PSBJbnRUeXBlICkgcmV0dXJuIGdsLklOVDtcclxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVDtcclxuXHRcdGlmICggcCA9PT0gRmxvYXRUeXBlICkgcmV0dXJuIGdsLkZMT0FUO1xyXG5cclxuXHRcdGlmICggcCA9PT0gSGFsZkZsb2F0VHlwZSApIHtcclxuXHJcblx0XHRcdGlmICggaXNXZWJHTDIgKSByZXR1cm4gZ2wuSEFMRl9GTE9BVDtcclxuXHJcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFJHQkFGb3JtYXQgKSByZXR1cm4gZ2wuUkdCQTtcclxuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRTtcclxuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuTFVNSU5BTkNFX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBEZXB0aEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9DT01QT05FTlQ7XHJcblx0XHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9TVEVOQ0lMO1xyXG5cclxuXHRcdC8vIFdlYkdMIDEgc1JHQiBmYWxsYmFja1xyXG5cclxuXHRcdGlmICggcCA9PT0gX1NSR0JBRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfc1JHQicgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLlNSR0JfQUxQSEFfRVhUO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdlYkdMMiBmb3JtYXRzLlxyXG5cclxuXHRcdGlmICggcCA9PT0gUmVkRm9ybWF0ICkgcmV0dXJuIGdsLlJFRDtcclxuXHRcdGlmICggcCA9PT0gUmVkSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SRURfSU5URUdFUjtcclxuXHRcdGlmICggcCA9PT0gUkdGb3JtYXQgKSByZXR1cm4gZ2wuUkc7XHJcblx0XHRpZiAoIHAgPT09IFJHSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SR19JTlRFR0VSO1xyXG5cdFx0aWYgKCBwID09PSBSR0JBSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SR0JBX0lOVEVHRVI7XHJcblxyXG5cdFx0Ly8gUzNUQ1xyXG5cclxuXHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InICk7XHJcblxyXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFBWUlRDXHJcblxyXG5cdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcclxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcclxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRVRDMVxyXG5cclxuXHRcdGlmICggcCA9PT0gUkdCX0VUQzFfRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0w7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRVRDMlxyXG5cclxuXHRcdGlmICggcCA9PT0gUkdCX0VUQzJfRm9ybWF0IHx8IHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX0VUQzJfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0VUQzIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0I4X0VUQzI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0VUQzJfRUFDX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUMgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBU1RDXHJcblxyXG5cdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNHg0X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNXg0X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNXg1X0Zvcm1hdCB8fFxyXG5cdFx0XHRwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfNng2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfOHg1X0Zvcm1hdCB8fFxyXG5cdFx0XHRwID09PSBSR0JBX0FTVENfOHg2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfOHg4X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQgfHxcclxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzEweDZfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0IHx8XHJcblx0XHRcdHAgPT09IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCApIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2FzdGMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNHg0X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNXg0X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NF9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNXg1X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NV9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4NV9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfNng2X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4Nl9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg1X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4NV9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg2X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4Nl9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfOHg4X0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDhfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4OF9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4NV9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4Nl9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4OF9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHgxMF9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMF9LSFI7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMl9LSFI7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQlBUQ1xyXG5cclxuXHRcdGlmICggcCA9PT0gUkdCQV9CUFRDX0Zvcm1hdCApIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0YycgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9CUFRDX1VOT1JNX0VYVCA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STV9FWFQ7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUkdUQ1xyXG5cclxuXHRcdGlmICggcCA9PT0gUkVEX1JHVEMxX0Zvcm1hdCB8fCBwID09PSBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCB8fCBwID09PSBSRURfR1JFRU5fUkdUQzJfRm9ybWF0IHx8IHAgPT09IFNJR05FRF9SRURfR1JFRU5fUkdUQzJfRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9yZ3RjJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9CUFRDX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SRURfUkdUQzFfRVhUO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9SR1RDMV9FWFQ7XHJcblx0XHRcdFx0aWYgKCBwID09PSBSRURfR1JFRU5fUkdUQzJfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7XHJcblx0XHRcdFx0aWYgKCBwID09PSBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TSUdORURfUkVEX0dSRUVOX1JHVEMyX0VYVDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRJbnQyNDhUeXBlICkge1xyXG5cclxuXHRcdFx0aWYgKCBpc1dlYkdMMiApIHJldHVybiBnbC5VTlNJR05FRF9JTlRfMjRfODtcclxuXHJcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9uLlVOU0lHTkVEX0lOVF8yNF84X1dFQkdMO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIFwicFwiIGNhbid0IGJlIHJlc29sdmVkLCBhc3N1bWUgdGhlIHVzZXIgZGVmaW5lcyBhIFdlYkdMIGNvbnN0YW50IGFzIGEgc3RyaW5nIChmYWxsYmFjay93b3JrYXJvdW5kIGZvciBwYWNrZWQgUkdCIGZvcm1hdHMpXHJcblxyXG5cdFx0cmV0dXJuICggZ2xbIHAgXSAhPT0gdW5kZWZpbmVkICkgPyBnbFsgcCBdIDogbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4geyBjb252ZXJ0OiBjb252ZXJ0IH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xVdGlscyB9O1xyXG4iLCJpbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4vUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xyXG5cclxuY2xhc3MgQXJyYXlDYW1lcmEgZXh0ZW5kcyBQZXJzcGVjdGl2ZUNhbWVyYSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSA9IFtdICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0FycmF5Q2FtZXJhID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmNhbWVyYXMgPSBhcnJheTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQXJyYXlDYW1lcmEgfTtcclxuIiwiaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuXHJcbmNsYXNzIEdyb3VwIGV4dGVuZHMgT2JqZWN0M0Qge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNHcm91cCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0dyb3VwJztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgR3JvdXAgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnLi4vLi4vb2JqZWN0cy9Hcm91cC5qcyc7XHJcblxyXG5jb25zdCBfbW92ZUV2ZW50ID0geyB0eXBlOiAnbW92ZScgfTtcclxuXHJcbmNsYXNzIFdlYlhSQ29udHJvbGxlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHRoaXMuX3RhcmdldFJheSA9IG51bGw7XHJcblx0XHR0aGlzLl9ncmlwID0gbnVsbDtcclxuXHRcdHRoaXMuX2hhbmQgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhbmRTcGFjZSgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2hhbmQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9oYW5kID0gbmV3IEdyb3VwKCk7XHJcblx0XHRcdHRoaXMuX2hhbmQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9oYW5kLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdHRoaXMuX2hhbmQuam9pbnRzID0ge307XHJcblx0XHRcdHRoaXMuX2hhbmQuaW5wdXRTdGF0ZSA9IHsgcGluY2hpbmc6IGZhbHNlIH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9oYW5kO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFRhcmdldFJheVNwYWNlKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5ID0gbmV3IEdyb3VwKCk7XHJcblx0XHRcdHRoaXMuX3RhcmdldFJheS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3RhcmdldFJheS52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3RhcmdldFJheS5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkubGluZWFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR0aGlzLl90YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX3RhcmdldFJheS5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0UmF5O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEdyaXBTcGFjZSgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2dyaXAgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9ncmlwID0gbmV3IEdyb3VwKCk7XHJcblx0XHRcdHRoaXMuX2dyaXAubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fZ3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLl9ncmlwLmxpbmVhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dGhpcy5fZ3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fZ3JpcC5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZ3JpcDtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwYXRjaEV2ZW50KCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3RhcmdldFJheSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3RhcmdldFJheS5kaXNwYXRjaEV2ZW50KCBldmVudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuX2dyaXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9ncmlwLmRpc3BhdGNoRXZlbnQoIGV2ZW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5faGFuZCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2hhbmQuZGlzcGF0Y2hFdmVudCggZXZlbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29ubmVjdCggaW5wdXRTb3VyY2UgKSB7XHJcblxyXG5cdFx0aWYgKCBpbnB1dFNvdXJjZSAmJiBpbnB1dFNvdXJjZS5oYW5kICkge1xyXG5cclxuXHRcdFx0Y29uc3QgaGFuZCA9IHRoaXMuX2hhbmQ7XHJcblxyXG5cdFx0XHRpZiAoIGhhbmQgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGNvbnN0IGlucHV0am9pbnQgb2YgaW5wdXRTb3VyY2UuaGFuZC52YWx1ZXMoKSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBJbml0aWFsaXplIGhhbmQgd2l0aCBqb2ludHMgd2hlbiBjb25uZWN0ZWRcclxuXHRcdFx0XHRcdHRoaXMuX2dldEhhbmRKb2ludCggaGFuZCwgaW5wdXRqb2ludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnY29ubmVjdGVkJywgZGF0YTogaW5wdXRTb3VyY2UgfSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc2Nvbm5lY3QoIGlucHV0U291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzY29ubmVjdGVkJywgZGF0YTogaW5wdXRTb3VyY2UgfSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5fdGFyZ2V0UmF5ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdGFyZ2V0UmF5LnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9ncmlwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5fZ3JpcC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5faGFuZCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2hhbmQudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoIGlucHV0U291cmNlLCBmcmFtZSwgcmVmZXJlbmNlU3BhY2UgKSB7XHJcblxyXG5cdFx0bGV0IGlucHV0UG9zZSA9IG51bGw7XHJcblx0XHRsZXQgZ3JpcFBvc2UgPSBudWxsO1xyXG5cdFx0bGV0IGhhbmRQb3NlID0gbnVsbDtcclxuXHJcblx0XHRjb25zdCB0YXJnZXRSYXkgPSB0aGlzLl90YXJnZXRSYXk7XHJcblx0XHRjb25zdCBncmlwID0gdGhpcy5fZ3JpcDtcclxuXHRcdGNvbnN0IGhhbmQgPSB0aGlzLl9oYW5kO1xyXG5cclxuXHRcdGlmICggaW5wdXRTb3VyY2UgJiYgZnJhbWUuc2Vzc2lvbi52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlLWJsdXJyZWQnICkge1xyXG5cclxuXHRcdFx0aWYgKCBoYW5kICYmIGlucHV0U291cmNlLmhhbmQgKSB7XHJcblxyXG5cdFx0XHRcdGhhbmRQb3NlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggY29uc3QgaW5wdXRqb2ludCBvZiBpbnB1dFNvdXJjZS5oYW5kLnZhbHVlcygpICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFVwZGF0ZSB0aGUgam9pbnRzIGdyb3VwcyB3aXRoIHRoZSBYUkpvaW50IHBvc2VzXHJcblx0XHRcdFx0XHRjb25zdCBqb2ludFBvc2UgPSBmcmFtZS5nZXRKb2ludFBvc2UoIGlucHV0am9pbnQsIHJlZmVyZW5jZVNwYWNlICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlIHRyYW5zZm9ybSBvZiB0aGlzIGpvaW50IHdpbGwgYmUgdXBkYXRlZCB3aXRoIHRoZSBqb2ludCBwb3NlIG9uIGVhY2ggZnJhbWVcclxuXHRcdFx0XHRcdGNvbnN0IGpvaW50ID0gdGhpcy5fZ2V0SGFuZEpvaW50KCBoYW5kLCBpbnB1dGpvaW50ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqb2ludFBvc2UgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRqb2ludC5tYXRyaXguZnJvbUFycmF5KCBqb2ludFBvc2UudHJhbnNmb3JtLm1hdHJpeCApO1xyXG5cdFx0XHRcdFx0XHRqb2ludC5tYXRyaXguZGVjb21wb3NlKCBqb2ludC5wb3NpdGlvbiwgam9pbnQucm90YXRpb24sIGpvaW50LnNjYWxlICk7XHJcblx0XHRcdFx0XHRcdGpvaW50Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRqb2ludC5qb2ludFJhZGl1cyA9IGpvaW50UG9zZS5yYWRpdXM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGpvaW50LnZpc2libGUgPSBqb2ludFBvc2UgIT09IG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQ3VzdG9tIGV2ZW50c1xyXG5cclxuXHRcdFx0XHQvLyBDaGVjayBwaW5jaHpcclxuXHRcdFx0XHRjb25zdCBpbmRleFRpcCA9IGhhbmQuam9pbnRzWyAnaW5kZXgtZmluZ2VyLXRpcCcgXTtcclxuXHRcdFx0XHRjb25zdCB0aHVtYlRpcCA9IGhhbmQuam9pbnRzWyAndGh1bWItdGlwJyBdO1xyXG5cdFx0XHRcdGNvbnN0IGRpc3RhbmNlID0gaW5kZXhUaXAucG9zaXRpb24uZGlzdGFuY2VUbyggdGh1bWJUaXAucG9zaXRpb24gKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2VUb1BpbmNoID0gMC4wMjtcclxuXHRcdFx0XHRjb25zdCB0aHJlc2hvbGQgPSAwLjAwNTtcclxuXHJcblx0XHRcdFx0aWYgKCBoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgJiYgZGlzdGFuY2UgPiBkaXN0YW5jZVRvUGluY2ggKyB0aHJlc2hvbGQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nID0gZmFsc2U7XHJcblx0XHRcdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHtcclxuXHRcdFx0XHRcdFx0dHlwZTogJ3BpbmNoZW5kJyxcclxuXHRcdFx0XHRcdFx0aGFuZGVkbmVzczogaW5wdXRTb3VyY2UuaGFuZGVkbmVzcyxcclxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoICEgaGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nICYmIGRpc3RhbmNlIDw9IGRpc3RhbmNlVG9QaW5jaCAtIHRocmVzaG9sZCApIHtcclxuXHJcblx0XHRcdFx0XHRoYW5kLmlucHV0U3RhdGUucGluY2hpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHRcdHR5cGU6ICdwaW5jaHN0YXJ0JyxcclxuXHRcdFx0XHRcdFx0aGFuZGVkbmVzczogaW5wdXRTb3VyY2UuaGFuZGVkbmVzcyxcclxuXHRcdFx0XHRcdFx0dGFyZ2V0OiB0aGlzXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ3JpcCAhPT0gbnVsbCAmJiBpbnB1dFNvdXJjZS5ncmlwU3BhY2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z3JpcFBvc2UgPSBmcmFtZS5nZXRQb3NlKCBpbnB1dFNvdXJjZS5ncmlwU3BhY2UsIHJlZmVyZW5jZVNwYWNlICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBncmlwUG9zZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdyaXAubWF0cml4LmZyb21BcnJheSggZ3JpcFBvc2UudHJhbnNmb3JtLm1hdHJpeCApO1xyXG5cdFx0XHRcdFx0XHRncmlwLm1hdHJpeC5kZWNvbXBvc2UoIGdyaXAucG9zaXRpb24sIGdyaXAucm90YXRpb24sIGdyaXAuc2NhbGUgKTtcclxuXHRcdFx0XHRcdFx0Z3JpcC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ3JpcFBvc2UubGluZWFyVmVsb2NpdHkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdyaXAubGluZWFyVmVsb2NpdHkuY29weSggZ3JpcFBvc2UubGluZWFyVmVsb2NpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdyaXAuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0Z3JpcC5hbmd1bGFyVmVsb2NpdHkuY29weSggZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXRSYXkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlucHV0UG9zZSA9IGZyYW1lLmdldFBvc2UoIGlucHV0U291cmNlLnRhcmdldFJheVNwYWNlLCByZWZlcmVuY2VTcGFjZSApO1xyXG5cclxuXHRcdFx0XHQvLyBTb21lIHJ1bnRpbWVzIChuYW1lbHkgVml2ZSBDb3Ntb3Mgd2l0aCBWaXZlIE9wZW5YUiBSdW50aW1lKSBoYXZlIG9ubHkgZ3JpcCBzcGFjZSBhbmQgcmF5IHNwYWNlIGlzIGVxdWFsIHRvIGl0XHJcblx0XHRcdFx0aWYgKCBpbnB1dFBvc2UgPT09IG51bGwgJiYgZ3JpcFBvc2UgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0aW5wdXRQb3NlID0gZ3JpcFBvc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBpbnB1dFBvc2UgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGFyZ2V0UmF5Lm1hdHJpeC5mcm9tQXJyYXkoIGlucHV0UG9zZS50cmFuc2Zvcm0ubWF0cml4ICk7XHJcblx0XHRcdFx0XHR0YXJnZXRSYXkubWF0cml4LmRlY29tcG9zZSggdGFyZ2V0UmF5LnBvc2l0aW9uLCB0YXJnZXRSYXkucm90YXRpb24sIHRhcmdldFJheS5zY2FsZSApO1xyXG5cdFx0XHRcdFx0dGFyZ2V0UmF5Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW5wdXRQb3NlLmxpbmVhclZlbG9jaXR5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5LmxpbmVhclZlbG9jaXR5LmNvcHkoIGlucHV0UG9zZS5saW5lYXJWZWxvY2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbnB1dFBvc2UuYW5ndWxhclZlbG9jaXR5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGFyZ2V0UmF5Lmhhc0FuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHRhcmdldFJheS5hbmd1bGFyVmVsb2NpdHkuY29weSggaW5wdXRQb3NlLmFuZ3VsYXJWZWxvY2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggX21vdmVFdmVudCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRhcmdldFJheSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRhcmdldFJheS52aXNpYmxlID0gKCBpbnB1dFBvc2UgIT09IG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBncmlwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Z3JpcC52aXNpYmxlID0gKCBncmlwUG9zZSAhPT0gbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGhhbmQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRoYW5kLnZpc2libGUgPSAoIGhhbmRQb3NlICE9PSBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kXHJcblxyXG5cdF9nZXRIYW5kSm9pbnQoIGhhbmQsIGlucHV0am9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBoYW5kLmpvaW50c1sgaW5wdXRqb2ludC5qb2ludE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgam9pbnQgPSBuZXcgR3JvdXAoKTtcclxuXHRcdFx0am9pbnQubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRqb2ludC52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdGhhbmQuam9pbnRzWyBpbnB1dGpvaW50LmpvaW50TmFtZSBdID0gam9pbnQ7XHJcblxyXG5cdFx0XHRoYW5kLmFkZCggam9pbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhhbmQuam9pbnRzWyBpbnB1dGpvaW50LmpvaW50TmFtZSBdO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViWFJDb250cm9sbGVyIH07XHJcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBOZWFyZXN0RmlsdGVyLCBVbnNpZ25lZEludFR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgRGVwdGhGb3JtYXQsIERlcHRoU3RlbmNpbEZvcm1hdCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBEZXB0aFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCApIHtcclxuXHJcblx0XHRmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xyXG5cclxuXHRcdGlmICggZm9ybWF0ICE9PSBEZXB0aEZvcm1hdCAmJiBmb3JtYXQgIT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcclxuXHRcdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcclxuXHJcblx0XHRzdXBlciggbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdFx0dGhpcy5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cclxuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmNvbXBhcmVGdW5jdGlvbiA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmNvbXBhcmVGdW5jdGlvbiA9IHNvdXJjZS5jb21wYXJlRnVuY3Rpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuY29tcGFyZUZ1bmN0aW9uICE9PSBudWxsICkgZGF0YS5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLmNvbXBhcmVGdW5jdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgRGVwdGhUZXh0dXJlIH07XHJcbiIsImltcG9ydCB7IEFycmF5Q2FtZXJhIH0gZnJvbSAnLi4vLi4vY2FtZXJhcy9BcnJheUNhbWVyYS5qcyc7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uLy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICcuLi8uLi9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5pbXBvcnQgeyBSQUQyREVHIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEFuaW1hdGlvbiB9IGZyb20gJy4uL3dlYmdsL1dlYkdMQW5pbWF0aW9uLmpzJztcclxuaW1wb3J0IHsgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi9XZWJHTFJlbmRlclRhcmdldC5qcyc7XHJcbmltcG9ydCB7IFdlYlhSQ29udHJvbGxlciB9IGZyb20gJy4vV2ViWFJDb250cm9sbGVyLmpzJztcclxuaW1wb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRGVwdGhUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgRGVwdGhGb3JtYXQsIERlcHRoU3RlbmNpbEZvcm1hdCwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgV2ViWFJNYW5hZ2VyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyLCBnbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRsZXQgc2Vzc2lvbiA9IG51bGw7XHJcblxyXG5cdFx0bGV0IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSAxLjA7XHJcblxyXG5cdFx0bGV0IHJlZmVyZW5jZVNwYWNlID0gbnVsbDtcclxuXHRcdGxldCByZWZlcmVuY2VTcGFjZVR5cGUgPSAnbG9jYWwtZmxvb3InO1xyXG5cdFx0Ly8gU2V0IGRlZmF1bHQgZm92ZWF0aW9uIHRvIG1heGltdW0uXHJcblx0XHRsZXQgZm92ZWF0aW9uID0gMS4wO1xyXG5cdFx0bGV0IGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gbnVsbDtcclxuXHJcblx0XHRsZXQgcG9zZSA9IG51bGw7XHJcblx0XHRsZXQgZ2xCaW5kaW5nID0gbnVsbDtcclxuXHRcdGxldCBnbFByb2pMYXllciA9IG51bGw7XHJcblx0XHRsZXQgZ2xCYXNlTGF5ZXIgPSBudWxsO1xyXG5cdFx0bGV0IHhyRnJhbWUgPSBudWxsO1xyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XHJcblx0XHRsZXQgaW5pdGlhbFJlbmRlclRhcmdldCA9IG51bGw7XHJcblx0XHRsZXQgbmV3UmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuXHJcblx0XHRjb25zdCBjb250cm9sbGVycyA9IFtdO1xyXG5cdFx0Y29uc3QgY29udHJvbGxlcklucHV0U291cmNlcyA9IFtdO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdFx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XHJcblx0XHRjYW1lcmFMLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcclxuXHJcblx0XHRjb25zdCBjYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XHJcblx0XHRjYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcclxuXHRcdGNhbWVyYVIudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdGNvbnN0IGNhbWVyYXMgPSBbIGNhbWVyYUwsIGNhbWVyYVIgXTtcclxuXHJcblx0XHRjb25zdCBjYW1lcmFYUiA9IG5ldyBBcnJheUNhbWVyYSgpO1xyXG5cdFx0Y2FtZXJhWFIubGF5ZXJzLmVuYWJsZSggMSApO1xyXG5cdFx0Y2FtZXJhWFIubGF5ZXJzLmVuYWJsZSggMiApO1xyXG5cclxuXHRcdGxldCBfY3VycmVudERlcHRoTmVhciA9IG51bGw7XHJcblx0XHRsZXQgX2N1cnJlbnREZXB0aEZhciA9IG51bGw7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLmNhbWVyYUF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmdldENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0bGV0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgaW5kZXggXTtcclxuXHJcblx0XHRcdGlmICggY29udHJvbGxlciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb250cm9sbGVyID0gbmV3IFdlYlhSQ29udHJvbGxlcigpO1xyXG5cdFx0XHRcdGNvbnRyb2xsZXJzWyBpbmRleCBdID0gY29udHJvbGxlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjb250cm9sbGVyLmdldFRhcmdldFJheVNwYWNlKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldENvbnRyb2xsZXJHcmlwID0gZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGxldCBjb250cm9sbGVyID0gY29udHJvbGxlcnNbIGluZGV4IF07XHJcblxyXG5cdFx0XHRpZiAoIGNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcclxuXHRcdFx0XHRjb250cm9sbGVyc1sgaW5kZXggXSA9IGNvbnRyb2xsZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY29udHJvbGxlci5nZXRHcmlwU3BhY2UoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0SGFuZCA9IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRsZXQgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0aWYgKCBjb250cm9sbGVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnRyb2xsZXIgPSBuZXcgV2ViWFJDb250cm9sbGVyKCk7XHJcblx0XHRcdFx0Y29udHJvbGxlcnNbIGluZGV4IF0gPSBjb250cm9sbGVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIuZ2V0SGFuZFNwYWNlKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uU2Vzc2lvbkV2ZW50KCBldmVudCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXJJbmRleCA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMuaW5kZXhPZiggZXZlbnQuaW5wdXRTb3VyY2UgKTtcclxuXHJcblx0XHRcdGlmICggY29udHJvbGxlckluZGV4ID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgY29udHJvbGxlckluZGV4IF07XHJcblxyXG5cdFx0XHRpZiAoIGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29udHJvbGxlci51cGRhdGUoIGV2ZW50LmlucHV0U291cmNlLCBldmVudC5mcmFtZSwgY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UgKTtcclxuXHRcdFx0XHRjb250cm9sbGVyLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogZXZlbnQudHlwZSwgZGF0YTogZXZlbnQuaW5wdXRTb3VyY2UgfSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvblNlc3Npb25FbmQoKSB7XHJcblxyXG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZWxlY3QnLCBvblNlc3Npb25FdmVudCApO1xyXG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZWxlY3RzdGFydCcsIG9uU2Vzc2lvbkV2ZW50ICk7XHJcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3NlbGVjdGVuZCcsIG9uU2Vzc2lvbkV2ZW50ICk7XHJcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3NxdWVlemUnLCBvblNlc3Npb25FdmVudCApO1xyXG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzcXVlZXplc3RhcnQnLCBvblNlc3Npb25FdmVudCApO1xyXG5cdFx0XHRzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzcXVlZXplZW5kJywgb25TZXNzaW9uRXZlbnQgKTtcclxuXHRcdFx0c2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCAnZW5kJywgb25TZXNzaW9uRW5kICk7XHJcblx0XHRcdHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0c291cmNlc2NoYW5nZScsIG9uSW5wdXRTb3VyY2VzQ2hhbmdlICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gY29udHJvbGxlcklucHV0U291cmNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGlucHV0U291cmNlID09PSBudWxsICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGkgXSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGNvbnRyb2xsZXJzWyBpIF0uZGlzY29ubmVjdCggaW5wdXRTb3VyY2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9jdXJyZW50RGVwdGhOZWFyID0gbnVsbDtcclxuXHRcdFx0X2N1cnJlbnREZXB0aEZhciA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyByZXN0b3JlIGZyYW1lYnVmZmVyL3JlbmRlcmluZyBzdGF0ZVxyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBpbml0aWFsUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRnbEJhc2VMYXllciA9IG51bGw7XHJcblx0XHRcdGdsUHJvakxheWVyID0gbnVsbDtcclxuXHRcdFx0Z2xCaW5kaW5nID0gbnVsbDtcclxuXHRcdFx0c2Vzc2lvbiA9IG51bGw7XHJcblx0XHRcdG5ld1JlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcclxuXHJcblx0XHRcdHNjb3BlLmlzUHJlc2VudGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnc2Vzc2lvbmVuZCcgfSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0ZnJhbWVidWZmZXJTY2FsZUZhY3RvciA9IHZhbHVlO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0UmVmZXJlbmNlU3BhY2VUeXBlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHJlZmVyZW5jZVNwYWNlVHlwZSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSByZWZlcmVuY2Ugc3BhY2UgdHlwZSB3aGlsZSBwcmVzZW50aW5nLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0UmVmZXJlbmNlU3BhY2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2U7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFJlZmVyZW5jZVNwYWNlID0gZnVuY3Rpb24gKCBzcGFjZSApIHtcclxuXHJcblx0XHRcdGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gc3BhY2U7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldEJhc2VMYXllciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBnbFByb2pMYXllciAhPT0gbnVsbCA/IGdsUHJvakxheWVyIDogZ2xCYXNlTGF5ZXI7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldEJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2xCaW5kaW5nO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB4ckZyYW1lO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRTZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHNlc3Npb247XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFNlc3Npb24gPSBhc3luYyBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0c2Vzc2lvbiA9IHZhbHVlO1xyXG5cclxuXHRcdFx0aWYgKCBzZXNzaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpbml0aWFsUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ3NlbGVjdCcsIG9uU2Vzc2lvbkV2ZW50ICk7XHJcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc2VsZWN0c3RhcnQnLCBvblNlc3Npb25FdmVudCApO1xyXG5cdFx0XHRcdHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lciggJ3NlbGVjdGVuZCcsIG9uU2Vzc2lvbkV2ZW50ICk7XHJcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZScsIG9uU2Vzc2lvbkV2ZW50ICk7XHJcblx0XHRcdFx0c2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCAnc3F1ZWV6ZXN0YXJ0Jywgb25TZXNzaW9uRXZlbnQgKTtcclxuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdzcXVlZXplZW5kJywgb25TZXNzaW9uRXZlbnQgKTtcclxuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdlbmQnLCBvblNlc3Npb25FbmQgKTtcclxuXHRcdFx0XHRzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dHNvdXJjZXNjaGFuZ2UnLCBvbklucHV0U291cmNlc0NoYW5nZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMueHJDb21wYXRpYmxlICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGF3YWl0IGdsLm1ha2VYUkNvbXBhdGlibGUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoICggc2Vzc2lvbi5yZW5kZXJTdGF0ZS5sYXllcnMgPT09IHVuZGVmaW5lZCApIHx8ICggcmVuZGVyZXIuY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSBmYWxzZSApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGxheWVySW5pdCA9IHtcclxuXHRcdFx0XHRcdFx0YW50aWFsaWFzOiAoIHNlc3Npb24ucmVuZGVyU3RhdGUubGF5ZXJzID09PSB1bmRlZmluZWQgKSA/IGF0dHJpYnV0ZXMuYW50aWFsaWFzIDogdHJ1ZSxcclxuXHRcdFx0XHRcdFx0YWxwaGE6IHRydWUsXHJcblx0XHRcdFx0XHRcdGRlcHRoOiBhdHRyaWJ1dGVzLmRlcHRoLFxyXG5cdFx0XHRcdFx0XHRzdGVuY2lsOiBhdHRyaWJ1dGVzLnN0ZW5jaWwsXHJcblx0XHRcdFx0XHRcdGZyYW1lYnVmZmVyU2NhbGVGYWN0b3I6IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3JcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0Z2xCYXNlTGF5ZXIgPSBuZXcgWFJXZWJHTExheWVyKCBzZXNzaW9uLCBnbCwgbGF5ZXJJbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0c2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSggeyBiYXNlTGF5ZXI6IGdsQmFzZUxheWVyIH0gKTtcclxuXHJcblx0XHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoXHJcblx0XHRcdFx0XHRcdGdsQmFzZUxheWVyLmZyYW1lYnVmZmVyV2lkdGgsXHJcblx0XHRcdFx0XHRcdGdsQmFzZUxheWVyLmZyYW1lYnVmZmVySGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdFx0Zm9ybWF0OiBSR0JBRm9ybWF0LFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JTcGFjZTogcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSxcclxuXHRcdFx0XHRcdFx0XHRzdGVuY2lsQnVmZmVyOiBhdHRyaWJ1dGVzLnN0ZW5jaWxcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRsZXQgZGVwdGhGb3JtYXQgPSBudWxsO1xyXG5cdFx0XHRcdFx0bGV0IGRlcHRoVHlwZSA9IG51bGw7XHJcblx0XHRcdFx0XHRsZXQgZ2xEZXB0aEZvcm1hdCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmRlcHRoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2xEZXB0aEZvcm1hdCA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IGdsLkRFUFRIMjRfU1RFTkNJTDggOiBnbC5ERVBUSF9DT01QT05FTlQyNDtcclxuXHRcdFx0XHRcdFx0ZGVwdGhGb3JtYXQgPSBhdHRyaWJ1dGVzLnN0ZW5jaWwgPyBEZXB0aFN0ZW5jaWxGb3JtYXQgOiBEZXB0aEZvcm1hdDtcclxuXHRcdFx0XHRcdFx0ZGVwdGhUeXBlID0gYXR0cmlidXRlcy5zdGVuY2lsID8gVW5zaWduZWRJbnQyNDhUeXBlIDogVW5zaWduZWRJbnRUeXBlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCBwcm9qZWN0aW9ubGF5ZXJJbml0ID0ge1xyXG5cdFx0XHRcdFx0XHRjb2xvckZvcm1hdDogZ2wuUkdCQTgsXHJcblx0XHRcdFx0XHRcdGRlcHRoRm9ybWF0OiBnbERlcHRoRm9ybWF0LFxyXG5cdFx0XHRcdFx0XHRzY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRnbEJpbmRpbmcgPSBuZXcgWFJXZWJHTEJpbmRpbmcoIHNlc3Npb24sIGdsICk7XHJcblxyXG5cdFx0XHRcdFx0Z2xQcm9qTGF5ZXIgPSBnbEJpbmRpbmcuY3JlYXRlUHJvamVjdGlvbkxheWVyKCBwcm9qZWN0aW9ubGF5ZXJJbml0ICk7XHJcblxyXG5cdFx0XHRcdFx0c2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSggeyBsYXllcnM6IFsgZ2xQcm9qTGF5ZXIgXSB9ICk7XHJcblxyXG5cdFx0XHRcdFx0bmV3UmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KFxyXG5cdFx0XHRcdFx0XHRnbFByb2pMYXllci50ZXh0dXJlV2lkdGgsXHJcblx0XHRcdFx0XHRcdGdsUHJvakxheWVyLnRleHR1cmVIZWlnaHQsXHJcblx0XHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVW5zaWduZWRCeXRlVHlwZSxcclxuXHRcdFx0XHRcdFx0XHRkZXB0aFRleHR1cmU6IG5ldyBEZXB0aFRleHR1cmUoIGdsUHJvakxheWVyLnRleHR1cmVXaWR0aCwgZ2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCwgZGVwdGhUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXB0aEZvcm1hdCApLFxyXG5cdFx0XHRcdFx0XHRcdHN0ZW5jaWxCdWZmZXI6IGF0dHJpYnV0ZXMuc3RlbmNpbCxcclxuXHRcdFx0XHRcdFx0XHRjb2xvclNwYWNlOiByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlLFxyXG5cdFx0XHRcdFx0XHRcdHNhbXBsZXM6IGF0dHJpYnV0ZXMuYW50aWFsaWFzID8gNCA6IDBcclxuXHRcdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSByZW5kZXJlci5wcm9wZXJ0aWVzLmdldCggbmV3UmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faWdub3JlRGVwdGhWYWx1ZXMgPSBnbFByb2pMYXllci5pZ25vcmVEZXB0aFZhbHVlcztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9IHRydWU7IC8vIFRPRE8gUmVtb3ZlIHRoaXMgd2hlbiBwb3NzaWJsZSwgc2VlICMyMzI3OFxyXG5cclxuXHRcdFx0XHR0aGlzLnNldEZvdmVhdGlvbiggZm92ZWF0aW9uICk7XHJcblxyXG5cdFx0XHRcdGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gbnVsbDtcclxuXHRcdFx0XHRyZWZlcmVuY2VTcGFjZSA9IGF3YWl0IHNlc3Npb24ucmVxdWVzdFJlZmVyZW5jZVNwYWNlKCByZWZlcmVuY2VTcGFjZVR5cGUgKTtcclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uLnNldENvbnRleHQoIHNlc3Npb24gKTtcclxuXHRcdFx0XHRhbmltYXRpb24uc3RhcnQoKTtcclxuXHJcblx0XHRcdFx0c2NvcGUuaXNQcmVzZW50aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnc2Vzc2lvbnN0YXJ0JyB9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldEVudmlyb25tZW50QmxlbmRNb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCBzZXNzaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2Vzc2lvbi5lbnZpcm9ubWVudEJsZW5kTW9kZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uSW5wdXRTb3VyY2VzQ2hhbmdlKCBldmVudCApIHtcclxuXHJcblx0XHRcdC8vIE5vdGlmeSBkaXNjb25uZWN0ZWRcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGV2ZW50LnJlbW92ZWQubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGV2ZW50LnJlbW92ZWRbIGkgXTtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGNvbnRyb2xsZXJJbnB1dFNvdXJjZXMuaW5kZXhPZiggaW5wdXRTb3VyY2UgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGluZGV4IF0gPSBudWxsO1xyXG5cdFx0XHRcdFx0Y29udHJvbGxlcnNbIGluZGV4IF0uZGlzY29ubmVjdCggaW5wdXRTb3VyY2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTm90aWZ5IGNvbm5lY3RlZFxyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZXZlbnQuYWRkZWQubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbnB1dFNvdXJjZSA9IGV2ZW50LmFkZGVkWyBpIF07XHJcblxyXG5cdFx0XHRcdGxldCBjb250cm9sbGVySW5kZXggPSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmluZGV4T2YoIGlucHV0U291cmNlICk7XHJcblxyXG5cdFx0XHRcdGlmICggY29udHJvbGxlckluZGV4ID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQXNzaWduIGlucHV0IHNvdXJjZSBhIGNvbnRyb2xsZXIgdGhhdCBjdXJyZW50bHkgaGFzIG5vIGlucHV0IHNvdXJjZVxyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaSA+PSBjb250cm9sbGVySW5wdXRTb3VyY2VzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlcklucHV0U291cmNlcy5wdXNoKCBpbnB1dFNvdXJjZSApO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb250cm9sbGVySW5wdXRTb3VyY2VzWyBpIF0gPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbnB1dFNvdXJjZXNbIGkgXSA9IGlucHV0U291cmNlO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXJJbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIElmIGFsbCBjb250cm9sbGVycyBkbyBjdXJyZW50bHkgcmVjZWl2ZSBpbnB1dCB3ZSBpZ25vcmUgbmV3IG9uZXNcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbnRyb2xsZXJJbmRleCA9PT0gLSAxICkgYnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgY29udHJvbGxlciA9IGNvbnRyb2xsZXJzWyBjb250cm9sbGVySW5kZXggXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjb250cm9sbGVyICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY29ubmVjdCggaW5wdXRTb3VyY2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IGNhbWVyYUxQb3MgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3QgY2FtZXJhUlBvcyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBc3N1bWVzIDIgY2FtZXJhcyB0aGF0IGFyZSBwYXJhbGxlbCBhbmQgc2hhcmUgYW4gWC1heGlzLCBhbmQgdGhhdFxyXG5cdFx0ICogdGhlIGNhbWVyYXMnIHByb2plY3Rpb24gYW5kIHdvcmxkIG1hdHJpY2VzIGhhdmUgYWxyZWFkeSBiZWVuIHNldC5cclxuXHRcdCAqIEFuZCB0aGF0IG5lYXIgYW5kIGZhciBwbGFuZXMgYXJlIGlkZW50aWNhbCBmb3IgYm90aCBjYW1lcmFzLlxyXG5cdFx0ICogVmlzdWFsaXphdGlvbiBvZiB0aGlzIHRlY2huaXF1ZTogaHR0cHM6Ly9jb21wdXRlcmdyYXBoaWNzLnN0YWNrZXhjaGFuZ2UuY29tL2EvNDc2NVxyXG5cdFx0ICovXHJcblx0XHRmdW5jdGlvbiBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKCBjYW1lcmEsIGNhbWVyYUwsIGNhbWVyYVIgKSB7XHJcblxyXG5cdFx0XHRjYW1lcmFMUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhTC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRjYW1lcmFSUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhUi5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0Y29uc3QgaXBkID0gY2FtZXJhTFBvcy5kaXN0YW5jZVRvKCBjYW1lcmFSUG9zICk7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9qTCA9IGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cztcclxuXHRcdFx0Y29uc3QgcHJvalIgPSBjYW1lcmFSLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0XHQvLyBWUiBzeXN0ZW1zIHdpbGwgaGF2ZSBpZGVudGljYWwgZmFyIGFuZCBuZWFyIHBsYW5lcywgYW5kXHJcblx0XHRcdC8vIG1vc3QgbGlrZWx5IGlkZW50aWNhbCB0b3AgYW5kIGJvdHRvbSBmcnVzdHVtIGV4dGVudHMuXHJcblx0XHRcdC8vIFVzZSB0aGUgbGVmdCBjYW1lcmEgZm9yIHRoZXNlIHZhbHVlcy5cclxuXHRcdFx0Y29uc3QgbmVhciA9IHByb2pMWyAxNCBdIC8gKCBwcm9qTFsgMTAgXSAtIDEgKTtcclxuXHRcdFx0Y29uc3QgZmFyID0gcHJvakxbIDE0IF0gLyAoIHByb2pMWyAxMCBdICsgMSApO1xyXG5cdFx0XHRjb25zdCB0b3BGb3YgPSAoIHByb2pMWyA5IF0gKyAxICkgLyBwcm9qTFsgNSBdO1xyXG5cdFx0XHRjb25zdCBib3R0b21Gb3YgPSAoIHByb2pMWyA5IF0gLSAxICkgLyBwcm9qTFsgNSBdO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVmdEZvdiA9ICggcHJvakxbIDggXSAtIDEgKSAvIHByb2pMWyAwIF07XHJcblx0XHRcdGNvbnN0IHJpZ2h0Rm92ID0gKCBwcm9qUlsgOCBdICsgMSApIC8gcHJvalJbIDAgXTtcclxuXHRcdFx0Y29uc3QgbGVmdCA9IG5lYXIgKiBsZWZ0Rm92O1xyXG5cdFx0XHRjb25zdCByaWdodCA9IG5lYXIgKiByaWdodEZvdjtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgbmV3IGNhbWVyYSdzIHBvc2l0aW9uIG9mZnNldCBmcm9tIHRoZVxyXG5cdFx0XHQvLyBsZWZ0IGNhbWVyYS4geE9mZnNldCBzaG91bGQgYmUgcm91Z2hseSBoYWxmIGBpcGRgLlxyXG5cdFx0XHRjb25zdCB6T2Zmc2V0ID0gaXBkIC8gKCAtIGxlZnRGb3YgKyByaWdodEZvdiApO1xyXG5cdFx0XHRjb25zdCB4T2Zmc2V0ID0gek9mZnNldCAqIC0gbGVmdEZvdjtcclxuXHJcblx0XHRcdC8vIFRPRE86IEJldHRlciB3YXkgdG8gYXBwbHkgdGhpcyBvZmZzZXQ/XHJcblx0XHRcdGNhbWVyYUwubWF0cml4V29ybGQuZGVjb21wb3NlKCBjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUgKTtcclxuXHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVgoIHhPZmZzZXQgKTtcclxuXHRcdFx0Y2FtZXJhLnRyYW5zbGF0ZVooIHpPZmZzZXQgKTtcclxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmNvbXBvc2UoIGNhbWVyYS5wb3NpdGlvbiwgY2FtZXJhLnF1YXRlcm5pb24sIGNhbWVyYS5zY2FsZSApO1xyXG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLmludmVydCgpO1xyXG5cclxuXHRcdFx0Ly8gRmluZCB0aGUgdW5pb24gb2YgdGhlIGZydXN0dW0gdmFsdWVzIG9mIHRoZSBjYW1lcmFzIGFuZCBzY2FsZVxyXG5cdFx0XHQvLyB0aGUgdmFsdWVzIHNvIHRoYXQgdGhlIG5lYXIgcGxhbmUncyBwb3NpdGlvbiBkb2VzIG5vdCBjaGFuZ2UgaW4gd29ybGQgc3BhY2UsXHJcblx0XHRcdC8vIGFsdGhvdWdoIG11c3Qgbm93IGJlIHJlbGF0aXZlIHRvIHRoZSBuZXcgdW5pb24gY2FtZXJhLlxyXG5cdFx0XHRjb25zdCBuZWFyMiA9IG5lYXIgKyB6T2Zmc2V0O1xyXG5cdFx0XHRjb25zdCBmYXIyID0gZmFyICsgek9mZnNldDtcclxuXHRcdFx0Y29uc3QgbGVmdDIgPSBsZWZ0IC0geE9mZnNldDtcclxuXHRcdFx0Y29uc3QgcmlnaHQyID0gcmlnaHQgKyAoIGlwZCAtIHhPZmZzZXQgKTtcclxuXHRcdFx0Y29uc3QgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcclxuXHRcdFx0Y29uc3QgYm90dG9tMiA9IGJvdHRvbUZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcclxuXHJcblx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggbGVmdDIsIHJpZ2h0MiwgdG9wMiwgYm90dG9tMiwgbmVhcjIsIGZhcjIgKTtcclxuXHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICkuaW52ZXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUNhbWVyYSggY2FtZXJhLCBwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBhcmVudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXggKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNhbWVyYS5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCBwYXJlbnQubWF0cml4V29ybGQsIGNhbWVyYS5tYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlQ2FtZXJhID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNlc3Npb24gPT09IG51bGwgKSByZXR1cm47XHJcblxyXG5cdFx0XHRjYW1lcmFYUi5uZWFyID0gY2FtZXJhUi5uZWFyID0gY2FtZXJhTC5uZWFyID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdGNhbWVyYVhSLmZhciA9IGNhbWVyYVIuZmFyID0gY2FtZXJhTC5mYXIgPSBjYW1lcmEuZmFyO1xyXG5cclxuXHRcdFx0aWYgKCBfY3VycmVudERlcHRoTmVhciAhPT0gY2FtZXJhWFIubmVhciB8fCBfY3VycmVudERlcHRoRmFyICE9PSBjYW1lcmFYUi5mYXIgKSB7XHJcblxyXG5cdFx0XHRcdC8vIE5vdGUgdGhhdCB0aGUgbmV3IHJlbmRlclN0YXRlIHdvbid0IGFwcGx5IHVudGlsIHRoZSBuZXh0IGZyYW1lLiBTZWUgIzE4MzIwXHJcblxyXG5cdFx0XHRcdHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoIHtcclxuXHRcdFx0XHRcdGRlcHRoTmVhcjogY2FtZXJhWFIubmVhcixcclxuXHRcdFx0XHRcdGRlcHRoRmFyOiBjYW1lcmFYUi5mYXJcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdF9jdXJyZW50RGVwdGhOZWFyID0gY2FtZXJhWFIubmVhcjtcclxuXHRcdFx0XHRfY3VycmVudERlcHRoRmFyID0gY2FtZXJhWFIuZmFyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgcGFyZW50ID0gY2FtZXJhLnBhcmVudDtcclxuXHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYVhSLmNhbWVyYXM7XHJcblxyXG5cdFx0XHR1cGRhdGVDYW1lcmEoIGNhbWVyYVhSLCBwYXJlbnQgKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNhbWVyYXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR1cGRhdGVDYW1lcmEoIGNhbWVyYXNbIGkgXSwgcGFyZW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgcHJvamVjdGlvbiBtYXRyaXggZm9yIHByb3BlciB2aWV3IGZydXN0dW0gY3VsbGluZ1xyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmFzLmxlbmd0aCA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0c2V0UHJvamVjdGlvbkZyb21VbmlvbiggY2FtZXJhWFIsIGNhbWVyYUwsIGNhbWVyYVIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIGFzc3VtZSBzaW5nbGUgY2FtZXJhIHNldHVwIChBUilcclxuXHJcblx0XHRcdFx0Y2FtZXJhWFIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHVwZGF0ZSB1c2VyIGNhbWVyYSBhbmQgaXRzIGNoaWxkcmVuXHJcblxyXG5cdFx0XHR1cGRhdGVVc2VyQ2FtZXJhKCBjYW1lcmEsIGNhbWVyYVhSLCBwYXJlbnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVVzZXJDYW1lcmEoIGNhbWVyYSwgY2FtZXJhWFIsIHBhcmVudCApIHtcclxuXHJcblx0XHRcdGlmICggcGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRjYW1lcmEubWF0cml4LmNvcHkoIGNhbWVyYVhSLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjYW1lcmEubWF0cml4LmNvcHkoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdGNhbWVyYS5tYXRyaXguaW52ZXJ0KCk7XHJcblx0XHRcdFx0Y2FtZXJhLm1hdHJpeC5tdWx0aXBseSggY2FtZXJhWFIubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNhbWVyYS5tYXRyaXguZGVjb21wb3NlKCBjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUgKTtcclxuXHRcdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IGNhbWVyYS5jaGlsZHJlbjtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYVhSLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkoIGNhbWVyYVhSLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRjYW1lcmEuZm92ID0gUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIDEgLyBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgNSBdICk7XHJcblx0XHRcdFx0Y2FtZXJhLnpvb20gPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldENhbWVyYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBjYW1lcmFYUjtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCBnbFByb2pMYXllciA9PT0gbnVsbCAmJiBnbEJhc2VMYXllciA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmb3ZlYXRpb247XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldEZvdmVhdGlvbiA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHQvLyAwID0gbm8gZm92ZWF0aW9uID0gZnVsbCByZXNvbHV0aW9uXHJcblx0XHRcdC8vIDEgPSBtYXhpbXVtIGZvdmVhdGlvbiA9IHRoZSBlZGdlcyByZW5kZXIgYXQgbG93ZXIgcmVzb2x1dGlvblxyXG5cclxuXHRcdFx0Zm92ZWF0aW9uID0gdmFsdWU7XHJcblxyXG5cdFx0XHRpZiAoIGdsUHJvakxheWVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRnbFByb2pMYXllci5maXhlZEZvdmVhdGlvbiA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnbEJhc2VMYXllciAhPT0gbnVsbCAmJiBnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQW5pbWF0aW9uIExvb3BcclxuXHJcblx0XHRsZXQgb25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gbnVsbDtcclxuXHJcblx0XHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lLCBmcmFtZSApIHtcclxuXHJcblx0XHRcdHBvc2UgPSBmcmFtZS5nZXRWaWV3ZXJQb3NlKCBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZSApO1xyXG5cdFx0XHR4ckZyYW1lID0gZnJhbWU7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2UgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZpZXdzID0gcG9zZS52aWV3cztcclxuXHJcblx0XHRcdFx0aWYgKCBnbEJhc2VMYXllciAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXRGcmFtZWJ1ZmZlciggbmV3UmVuZGVyVGFyZ2V0LCBnbEJhc2VMYXllci5mcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBuZXdSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgY2FtZXJhWFJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHQvLyBjaGVjayBpZiBpdCdzIG5lY2Vzc2FyeSB0byByZWJ1aWxkIGNhbWVyYVhSJ3MgY2FtZXJhIGxpc3RcclxuXHJcblx0XHRcdFx0aWYgKCB2aWV3cy5sZW5ndGggIT09IGNhbWVyYVhSLmNhbWVyYXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdGNhbWVyYVhSLmNhbWVyYXMubGVuZ3RoID0gMDtcclxuXHRcdFx0XHRcdGNhbWVyYVhSTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZpZXdzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB2aWV3ID0gdmlld3NbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRsZXQgdmlld3BvcnQgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2xCYXNlTGF5ZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2aWV3cG9ydCA9IGdsQmFzZUxheWVyLmdldFZpZXdwb3J0KCB2aWV3ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGdsU3ViSW1hZ2UgPSBnbEJpbmRpbmcuZ2V0Vmlld1N1YkltYWdlKCBnbFByb2pMYXllciwgdmlldyApO1xyXG5cdFx0XHRcdFx0XHR2aWV3cG9ydCA9IGdsU3ViSW1hZ2Uudmlld3BvcnQ7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBGb3Igc2lkZS1ieS1zaWRlIHByb2plY3Rpb24sIHdlIG9ubHkgcHJvZHVjZSBhIHNpbmdsZSB0ZXh0dXJlIGZvciBib3RoIGV5ZXMuXHJcblx0XHRcdFx0XHRcdGlmICggaSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMoXHJcblx0XHRcdFx0XHRcdFx0XHRuZXdSZW5kZXJUYXJnZXQsXHJcblx0XHRcdFx0XHRcdFx0XHRnbFN1YkltYWdlLmNvbG9yVGV4dHVyZSxcclxuXHRcdFx0XHRcdFx0XHRcdGdsUHJvakxheWVyLmlnbm9yZURlcHRoVmFsdWVzID8gdW5kZWZpbmVkIDogZ2xTdWJJbWFnZS5kZXB0aFN0ZW5jaWxUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbmV3UmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBjYW1lcmEgPSBjYW1lcmFzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjYW1lcmEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdFx0XHRcdFx0XHRjYW1lcmEubGF5ZXJzLmVuYWJsZSggaSApO1xyXG5cdFx0XHRcdFx0XHRjYW1lcmEudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xyXG5cdFx0XHRcdFx0XHRjYW1lcmFzWyBpIF0gPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNhbWVyYS5tYXRyaXguZnJvbUFycmF5KCB2aWV3LnRyYW5zZm9ybS5tYXRyaXggKTtcclxuXHRcdFx0XHRcdGNhbWVyYS5tYXRyaXguZGVjb21wb3NlKCBjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUgKTtcclxuXHRcdFx0XHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmZyb21BcnJheSggdmlldy5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdFx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKS5pbnZlcnQoKTtcclxuXHRcdFx0XHRcdGNhbWVyYS52aWV3cG9ydC5zZXQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYW1lcmFYUi5tYXRyaXguY29weSggY2FtZXJhLm1hdHJpeCApO1xyXG5cdFx0XHRcdFx0XHRjYW1lcmFYUi5tYXRyaXguZGVjb21wb3NlKCBjYW1lcmFYUi5wb3NpdGlvbiwgY2FtZXJhWFIucXVhdGVybmlvbiwgY2FtZXJhWFIuc2NhbGUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjYW1lcmFYUk5lZWRzVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FtZXJhWFIuY2FtZXJhcy5wdXNoKCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb250cm9sbGVycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGlucHV0U291cmNlID0gY29udHJvbGxlcklucHV0U291cmNlc1sgaSBdO1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGlucHV0U291cmNlICE9PSBudWxsICYmIGNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb250cm9sbGVyLnVwZGF0ZSggaW5wdXRTb3VyY2UsIGZyYW1lLCBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayApIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayggdGltZSwgZnJhbWUgKTtcclxuXHJcblx0XHRcdGlmICggZnJhbWUuZGV0ZWN0ZWRQbGFuZXMgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3BsYW5lc2RldGVjdGVkJywgZGF0YTogZnJhbWUgfSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eHJGcmFtZSA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xyXG5cclxuXHRcdGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKCBvbkFuaW1hdGlvbkZyYW1lICk7XHJcblxyXG5cdFx0dGhpcy5zZXRBbmltYXRpb25Mb29wID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRcdG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYlhSTWFuYWdlciB9O1xyXG4iLCJpbXBvcnQgeyBCYWNrU2lkZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IGdldFVubGl0VW5pZm9ybUNvbG9yU3BhY2UgfSBmcm9tICcuLi9zaGFkZXJzL1VuaWZvcm1zVXRpbHMuanMnO1xyXG5cclxuZnVuY3Rpb24gV2ViR0xNYXRlcmlhbHMoIHJlbmRlcmVyLCBwcm9wZXJ0aWVzICkge1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWFwLCB1bmlmb3JtICkge1xyXG5cclxuXHRcdGlmICggbWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRtYXAudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm0udmFsdWUuY29weSggbWFwLm1hdHJpeCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hGb2dVbmlmb3JtcyggdW5pZm9ybXMsIGZvZyApIHtcclxuXHJcblx0XHRmb2cuY29sb3IuZ2V0UkdCKCB1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSwgZ2V0VW5saXRVbmlmb3JtQ29sb3JTcGFjZSggcmVuZGVyZXIgKSApO1xyXG5cclxuXHRcdGlmICggZm9nLmlzRm9nICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xyXG5cdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGZvZy5pc0ZvZ0V4cDIgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNUb29uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaE1hdGNhcE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zTWF0Y2FwKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc0xpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTGluZURhc2hlZE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEYXNoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1BvaW50c01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zUG9pbnRzKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU3ByaXRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTcHJpdGVzKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuY29sb3IudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHRcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlOyAvLyAjMTU1ODFcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5jb2xvciApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLm1hcCwgdW5pZm9ybXMubWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmFscGhhTWFwLCB1bmlmb3Jtcy5hbHBoYU1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5idW1wTWFwLCB1bmlmb3Jtcy5idW1wTWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgKj0gLSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5ub3JtYWxNYXAsIHVuaWZvcm1zLm5vcm1hbE1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsIHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xyXG5cclxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmVtaXNzaXZlTWFwLCB1bmlmb3Jtcy5lbWlzc2l2ZU1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zcGVjdWxhck1hcCwgdW5pZm9ybXMuc3BlY3VsYXJNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBlbnZNYXAgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5lbnZNYXA7XHJcblxyXG5cdFx0aWYgKCBlbnZNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBlbnZNYXA7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBlbnZNYXAuaXNDdWJlVGV4dHVyZSAmJiBlbnZNYXAuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSApID8gLSAxIDogMTtcclxuXHJcblx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuXHRcdFx0dW5pZm9ybXMuaW9yLnZhbHVlID0gbWF0ZXJpYWwuaW9yO1xyXG5cdFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xyXG5cclxuXHRcdFx0Ly8gYXJ0aXN0LWZyaWVuZGx5IGxpZ2h0IGludGVuc2l0eSBzY2FsaW5nIGZhY3RvclxyXG5cdFx0XHRjb25zdCBzY2FsZUZhY3RvciA9ICggcmVuZGVyZXIudXNlTGVnYWN5TGlnaHRzID09PSB0cnVlICkgPyBNYXRoLlBJIDogMTtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgKiBzY2FsZUZhY3RvcjtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5saWdodE1hcCwgdW5pZm9ybXMubGlnaHRNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5hb01hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XHJcblx0XHRcdHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuYW9NYXAsIHVuaWZvcm1zLmFvTWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5tYXAsIHVuaWZvcm1zLm1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcclxuXHRcdHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcclxuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUG9pbnRzKCB1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogcGl4ZWxSYXRpbztcclxuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gaGVpZ2h0ICogMC41O1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLm1hcCwgdW5pZm9ybXMudXZUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XHJcblxyXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuYWxwaGFNYXAsIHVuaWZvcm1zLmFscGhhTWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFscGhhVGVzdC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhVGVzdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3ByaXRlcyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cdFx0dW5pZm9ybXMucm90YXRpb24udmFsdWUgPSBtYXRlcmlhbC5yb3RhdGlvbjtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5tYXAsIHVuaWZvcm1zLm1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5hbHBoYU1hcCwgdW5pZm9ybXMuYWxwaGFNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5hbHBoYVRlc3QgPiAwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlLmNvcHkoIG1hdGVyaWFsLnNwZWN1bGFyICk7XHJcblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zVG9vbiggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuZ3JhZGllbnRNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5ncmFkaWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmdyYWRpZW50TWFwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLm1ldGFsbmVzcy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzcztcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1ldGFsbmVzc01hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAsIHVuaWZvcm1zLm1ldGFsbmVzc01hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwucm91Z2huZXNzTWFwLCB1bmlmb3Jtcy5yb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZW52TWFwID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkuZW52TWFwO1xyXG5cclxuXHRcdGlmICggZW52TWFwICkge1xyXG5cclxuXHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXHJcblx0XHRcdHVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcEludGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwoIHVuaWZvcm1zLCBtYXRlcmlhbCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmlvci52YWx1ZSA9IG1hdGVyaWFsLmlvcjsgLy8gYWxzbyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuc2hlZW4gPiAwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuc2hlZW5Db2xvci52YWx1ZS5jb3B5KCBtYXRlcmlhbC5zaGVlbkNvbG9yICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLnNoZWVuICk7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5zaGVlblJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5zaGVlbkNvbG9yTWFwLnZhbHVlID0gbWF0ZXJpYWwuc2hlZW5Db2xvck1hcDtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAsIHVuaWZvcm1zLnNoZWVuQ29sb3JNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnNoZWVuUm91Z2huZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCwgdW5pZm9ybXMuc2hlZW5Sb3VnaG5lc3NNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXQgPiAwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0O1xyXG5cdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXRSb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3M7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmNsZWFyY29hdE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0TWFwLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0TWFwO1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwuY2xlYXJjb2F0TWFwLCB1bmlmb3Jtcy5jbGVhcmNvYXRNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsIHVuaWZvcm1zLmNsZWFyY29hdFJvdWdobmVzc01hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcDtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCwgdW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsTWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUubmVnYXRlKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZS52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlO1xyXG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZUlPUi52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SO1xyXG5cdFx0XHR1bmlmb3Jtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0udmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWyAwIF07XHJcblx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bS52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbIDEgXTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlTWFwLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXA7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCwgdW5pZm9ybXMuaXJpZGVzY2VuY2VNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdW5pZm9ybXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMudHJhbnNtaXNzaW9uLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uO1xyXG5cdFx0XHR1bmlmb3Jtcy50cmFuc21pc3Npb25TYW1wbGVyTWFwLnZhbHVlID0gdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblx0XHRcdHVuaWZvcm1zLnRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnZhbHVlLnNldCggdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LndpZHRoLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMudHJhbnNtaXNzaW9uTWFwLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwO1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVHJhbnNmb3JtVW5pZm9ybSggbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwLCB1bmlmb3Jtcy50cmFuc21pc3Npb25NYXBUcmFuc2Zvcm0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVuaWZvcm1zLnRoaWNrbmVzcy52YWx1ZSA9IG1hdGVyaWFsLnRoaWNrbmVzcztcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudGhpY2tuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy50aGlja25lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC50aGlja25lc3NNYXA7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC50aGlja25lc3NNYXAsIHVuaWZvcm1zLnRoaWNrbmVzc01hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dW5pZm9ybXMuYXR0ZW51YXRpb25EaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2U7XHJcblx0XHRcdHVuaWZvcm1zLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weSggbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmFuaXNvdHJvcHkgPiAwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW5pc290cm9weVZlY3Rvci52YWx1ZS5zZXQoIG1hdGVyaWFsLmFuaXNvdHJvcHkgKiBNYXRoLmNvcyggbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uICksIG1hdGVyaWFsLmFuaXNvdHJvcHkgKiBNYXRoLnNpbiggbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uICkgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuYW5pc290cm9weU1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuYW5pc290cm9weU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFuaXNvdHJvcHlNYXA7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwLCB1bmlmb3Jtcy5hbmlzb3Ryb3B5TWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFySW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHk7XHJcblx0XHR1bmlmb3Jtcy5zcGVjdWxhckNvbG9yLnZhbHVlLmNvcHkoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhckNvbG9yTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcDtcclxuXHJcblx0XHRcdHJlZnJlc2hUcmFuc2Zvcm1Vbmlmb3JtKCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwLCB1bmlmb3Jtcy5zcGVjdWxhckNvbG9yTWFwVHJhbnNmb3JtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eU1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xyXG5cclxuXHRcdFx0cmVmcmVzaFRyYW5zZm9ybVVuaWZvcm0oIG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwLCB1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eU1hcFRyYW5zZm9ybSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNNYXRjYXAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hdGNhcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm1hdGNhcC52YWx1ZSA9IG1hdGVyaWFsLm1hdGNhcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRjb25zdCBsaWdodCA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLmxpZ2h0O1xyXG5cclxuXHRcdHVuaWZvcm1zLnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdHVuaWZvcm1zLm5lYXJEaXN0YW5jZS52YWx1ZSA9IGxpZ2h0LnNoYWRvdy5jYW1lcmEubmVhcjtcclxuXHRcdHVuaWZvcm1zLmZhckRpc3RhbmNlLnZhbHVlID0gbGlnaHQuc2hhZG93LmNhbWVyYS5mYXI7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHJlZnJlc2hGb2dVbmlmb3JtczogcmVmcmVzaEZvZ1VuaWZvcm1zLFxyXG5cdFx0cmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6IHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFdlYkdMTWF0ZXJpYWxzIH07XHJcbiIsImZ1bmN0aW9uIFdlYkdMVW5pZm9ybXNHcm91cHMoIGdsLCBpbmZvLCBjYXBhYmlsaXRpZXMsIHN0YXRlICkge1xyXG5cclxuXHRsZXQgYnVmZmVycyA9IHt9O1xyXG5cdGxldCB1cGRhdGVMaXN0ID0ge307XHJcblx0bGV0IGFsbG9jYXRlZEJpbmRpbmdQb2ludHMgPSBbXTtcclxuXHJcblx0Y29uc3QgbWF4QmluZGluZ1BvaW50cyA9ICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyICkgPyBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9VTklGT1JNX0JVRkZFUl9CSU5ESU5HUyApIDogMDsgLy8gYmluZGluZyBwb2ludHMgYXJlIGdsb2JhbCB3aGVyZWFzIGJsb2NrIGluZGljZXMgYXJlIHBlciBzaGFkZXIgcHJvZ3JhbVxyXG5cclxuXHRmdW5jdGlvbiBiaW5kKCB1bmlmb3Jtc0dyb3VwLCBwcm9ncmFtICkge1xyXG5cclxuXHRcdGNvbnN0IHdlYmdsUHJvZ3JhbSA9IHByb2dyYW0ucHJvZ3JhbTtcclxuXHRcdHN0YXRlLnVuaWZvcm1CbG9ja0JpbmRpbmcoIHVuaWZvcm1zR3JvdXAsIHdlYmdsUHJvZ3JhbSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZSggdW5pZm9ybXNHcm91cCwgcHJvZ3JhbSApIHtcclxuXHJcblx0XHRsZXQgYnVmZmVyID0gYnVmZmVyc1sgdW5pZm9ybXNHcm91cC5pZCBdO1xyXG5cclxuXHRcdGlmICggYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwcmVwYXJlVW5pZm9ybXNHcm91cCggdW5pZm9ybXNHcm91cCApO1xyXG5cclxuXHRcdFx0YnVmZmVyID0gY3JlYXRlQnVmZmVyKCB1bmlmb3Jtc0dyb3VwICk7XHJcblx0XHRcdGJ1ZmZlcnNbIHVuaWZvcm1zR3JvdXAuaWQgXSA9IGJ1ZmZlcjtcclxuXHJcblx0XHRcdHVuaWZvcm1zR3JvdXAuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblVuaWZvcm1zR3JvdXBzRGlzcG9zZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBlbnN1cmUgdG8gdXBkYXRlIHRoZSBiaW5kaW5nIHBvaW50cy9ibG9jayBpbmRpY2VzIG1hcHBpbmcgZm9yIHRoaXMgcHJvZ3JhbVxyXG5cclxuXHRcdGNvbnN0IHdlYmdsUHJvZ3JhbSA9IHByb2dyYW0ucHJvZ3JhbTtcclxuXHRcdHN0YXRlLnVwZGF0ZVVCT01hcHBpbmcoIHVuaWZvcm1zR3JvdXAsIHdlYmdsUHJvZ3JhbSApO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBVQk8gb25jZSBwZXIgZnJhbWVcclxuXHJcblx0XHRjb25zdCBmcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xyXG5cclxuXHRcdGlmICggdXBkYXRlTGlzdFsgdW5pZm9ybXNHcm91cC5pZCBdICE9PSBmcmFtZSApIHtcclxuXHJcblx0XHRcdHVwZGF0ZUJ1ZmZlckRhdGEoIHVuaWZvcm1zR3JvdXAgKTtcclxuXHJcblx0XHRcdHVwZGF0ZUxpc3RbIHVuaWZvcm1zR3JvdXAuaWQgXSA9IGZyYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIHVuaWZvcm1zR3JvdXAgKSB7XHJcblxyXG5cdFx0Ly8gdGhlIHNldHVwIG9mIGFuIFVCTyBpcyBpbmRlcGVuZGVudCBvZiBhIHBhcnRpY3VsYXIgc2hhZGVyIHByb2dyYW0gYnV0IGdsb2JhbFxyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmdQb2ludEluZGV4ID0gYWxsb2NhdGVCaW5kaW5nUG9pbnRJbmRleCgpO1xyXG5cdFx0dW5pZm9ybXNHcm91cC5fX2JpbmRpbmdQb2ludEluZGV4ID0gYmluZGluZ1BvaW50SW5kZXg7XHJcblxyXG5cdFx0Y29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRjb25zdCBzaXplID0gdW5pZm9ybXNHcm91cC5fX3NpemU7XHJcblx0XHRjb25zdCB1c2FnZSA9IHVuaWZvcm1zR3JvdXAudXNhZ2U7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuVU5JRk9STV9CVUZGRVIsIGJ1ZmZlciApO1xyXG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuVU5JRk9STV9CVUZGRVIsIHNpemUsIHVzYWdlICk7XHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5VTklGT1JNX0JVRkZFUiwgbnVsbCApO1xyXG5cdFx0Z2wuYmluZEJ1ZmZlckJhc2UoIGdsLlVOSUZPUk1fQlVGRkVSLCBiaW5kaW5nUG9pbnRJbmRleCwgYnVmZmVyICk7XHJcblxyXG5cdFx0cmV0dXJuIGJ1ZmZlcjtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhbGxvY2F0ZUJpbmRpbmdQb2ludEluZGV4KCkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1heEJpbmRpbmdQb2ludHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFsbG9jYXRlZEJpbmRpbmdQb2ludHMuaW5kZXhPZiggaSApID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdGFsbG9jYXRlZEJpbmRpbmdQb2ludHMucHVzaCggaSApO1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogTWF4aW11bSBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzbHkgdXNhYmxlIHVuaWZvcm1zIGdyb3VwcyByZWFjaGVkLicgKTtcclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXJEYXRhKCB1bmlmb3Jtc0dyb3VwICkge1xyXG5cclxuXHRcdGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbIHVuaWZvcm1zR3JvdXAuaWQgXTtcclxuXHRcdGNvbnN0IHVuaWZvcm1zID0gdW5pZm9ybXNHcm91cC51bmlmb3JtcztcclxuXHRcdGNvbnN0IGNhY2hlID0gdW5pZm9ybXNHcm91cC5fX2NhY2hlO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlVOSUZPUk1fQlVGRkVSLCBidWZmZXIgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdW5pZm9ybXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNbIGkgXTtcclxuXHJcblx0XHRcdC8vIHBhcnRseSB1cGRhdGUgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnlcclxuXHJcblx0XHRcdGlmICggaGFzVW5pZm9ybUNoYW5nZWQoIHVuaWZvcm0sIGksIGNhY2hlICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IHVuaWZvcm0uX19vZmZzZXQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkoIHVuaWZvcm0udmFsdWUgKSA/IHVuaWZvcm0udmFsdWUgOiBbIHVuaWZvcm0udmFsdWUgXTtcclxuXHJcblx0XHRcdFx0bGV0IGFycmF5T2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGluZm8gPSBnZXRVbmlmb3JtU2l6ZSggdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMCBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGdsLlVOSUZPUk1fQlVGRkVSLCBvZmZzZXQgKyBhcnJheU9mZnNldCwgdW5pZm9ybS5fX2RhdGEgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc01hdHJpeDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBtYW51YWxseSBjb252ZXJ0aW5nIDN4MyB0byAzeDRcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAwIF0gPSB2YWx1ZS5lbGVtZW50c1sgMCBdO1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMSBdID0gdmFsdWUuZWxlbWVudHNbIDEgXTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDIgXSA9IHZhbHVlLmVsZW1lbnRzWyAyIF07XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAzIF0gPSB2YWx1ZS5lbGVtZW50c1sgMCBdO1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgNCBdID0gdmFsdWUuZWxlbWVudHNbIDMgXTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDUgXSA9IHZhbHVlLmVsZW1lbnRzWyA0IF07XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyA2IF0gPSB2YWx1ZS5lbGVtZW50c1sgNSBdO1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgNyBdID0gdmFsdWUuZWxlbWVudHNbIDAgXTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fX2RhdGFbIDggXSA9IHZhbHVlLmVsZW1lbnRzWyA2IF07XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyA5IF0gPSB2YWx1ZS5lbGVtZW50c1sgNyBdO1xyXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9fZGF0YVsgMTAgXSA9IHZhbHVlLmVsZW1lbnRzWyA4IF07XHJcblx0XHRcdFx0XHRcdHVuaWZvcm0uX19kYXRhWyAxMSBdID0gdmFsdWUuZWxlbWVudHNbIDAgXTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWUudG9BcnJheSggdW5pZm9ybS5fX2RhdGEsIGFycmF5T2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRhcnJheU9mZnNldCArPSBpbmZvLnN0b3JhZ2UgLyBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGdsLlVOSUZPUk1fQlVGRkVSLCBvZmZzZXQsIHVuaWZvcm0uX19kYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlVOSUZPUk1fQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFzVW5pZm9ybUNoYW5nZWQoIHVuaWZvcm0sIGluZGV4LCBjYWNoZSApIHtcclxuXHJcblx0XHRjb25zdCB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XHJcblxyXG5cdFx0aWYgKCBjYWNoZVsgaW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gY2FjaGUgZW50cnkgZG9lcyBub3QgZXhpc3Qgc28gZmFyXHJcblxyXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XHJcblxyXG5cdFx0XHRcdGNhY2hlWyBpbmRleCBdID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KCB2YWx1ZSApID8gdmFsdWUgOiBbIHZhbHVlIF07XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRlbXBWYWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0ZW1wVmFsdWVzLnB1c2goIHZhbHVlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjYWNoZVsgaW5kZXggXSA9IHRlbXBWYWx1ZXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gY29tcGFyZSBjdXJyZW50IHZhbHVlIHdpdGggY2FjaGVkIGVudHJ5XHJcblxyXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY2FjaGVbIGluZGV4IF0gIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhY2hlWyBpbmRleCBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2FjaGVkT2JqZWN0cyA9IEFycmF5LmlzQXJyYXkoIGNhY2hlWyBpbmRleCBdICkgPyBjYWNoZVsgaW5kZXggXSA6IFsgY2FjaGVbIGluZGV4IF0gXTtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KCB2YWx1ZSApID8gdmFsdWUgOiBbIHZhbHVlIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNhY2hlZE9iamVjdHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGNhY2hlZE9iamVjdCA9IGNhY2hlZE9iamVjdHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNhY2hlZE9iamVjdC5lcXVhbHMoIHZhbHVlc1sgaSBdICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FjaGVkT2JqZWN0LmNvcHkoIHZhbHVlc1sgaSBdICk7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZVVuaWZvcm1zR3JvdXAoIHVuaWZvcm1zR3JvdXAgKSB7XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIHRvdGFsIGJ1ZmZlciBzaXplIGFjY29yZGluZyB0byB0aGUgU1REMTQwIGxheW91dFxyXG5cdFx0Ly8gSGludDogU1REMTQwIGlzIHRoZSBvbmx5IHN1cHBvcnRlZCBsYXlvdXQgaW4gV2ViR0wgMlxyXG5cclxuXHRcdGNvbnN0IHVuaWZvcm1zID0gdW5pZm9ybXNHcm91cC51bmlmb3JtcztcclxuXHJcblx0XHRsZXQgb2Zmc2V0ID0gMDsgLy8gZ2xvYmFsIGJ1ZmZlciBvZmZzZXQgaW4gYnl0ZXNcclxuXHRcdGNvbnN0IGNodW5rU2l6ZSA9IDE2OyAvLyBzaXplIG9mIGEgY2h1bmsgaW4gYnl0ZXNcclxuXHRcdGxldCBjaHVua09mZnNldCA9IDA7IC8vIG9mZnNldCB3aXRoaW4gYSBzaW5nbGUgY2h1bmsgaW4gYnl0ZXNcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB1bmlmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdW5pZm9ybSA9IHVuaWZvcm1zWyBpIF07XHJcblxyXG5cdFx0XHRjb25zdCBpbmZvcyA9IHtcclxuXHRcdFx0XHRib3VuZGFyeTogMCwgLy8gYnl0ZXNcclxuXHRcdFx0XHRzdG9yYWdlOiAwIC8vIGJ5dGVzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KCB1bmlmb3JtLnZhbHVlICkgPyB1bmlmb3JtLnZhbHVlIDogWyB1bmlmb3JtLnZhbHVlIF07XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdmFsdWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbmZvID0gZ2V0VW5pZm9ybVNpemUoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdGluZm9zLmJvdW5kYXJ5ICs9IGluZm8uYm91bmRhcnk7XHJcblx0XHRcdFx0aW5mb3Muc3RvcmFnZSArPSBpbmZvLnN0b3JhZ2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0aGUgZm9sbG93aW5nIHR3byBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCBmb3IgcGFydGlhbCBidWZmZXIgdXBkYXRlc1xyXG5cclxuXHRcdFx0dW5pZm9ybS5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCBpbmZvcy5zdG9yYWdlIC8gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICk7XHJcblx0XHRcdHVuaWZvcm0uX19vZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0aWYgKCBpID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y2h1bmtPZmZzZXQgPSBvZmZzZXQgJSBjaHVua1NpemU7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlbWFpbmluZ1NpemVJbkNodW5rID0gY2h1bmtTaXplIC0gY2h1bmtPZmZzZXQ7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBjaHVuayBvdmVyZmxvd1xyXG5cclxuXHRcdFx0XHRpZiAoIGNodW5rT2Zmc2V0ICE9PSAwICYmICggcmVtYWluaW5nU2l6ZUluQ2h1bmsgLSBpbmZvcy5ib3VuZGFyeSApIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBhZGQgcGFkZGluZyBhbmQgYWRqdXN0IG9mZnNldFxyXG5cclxuXHRcdFx0XHRcdG9mZnNldCArPSAoIGNodW5rU2l6ZSAtIGNodW5rT2Zmc2V0ICk7XHJcblx0XHRcdFx0XHR1bmlmb3JtLl9fb2Zmc2V0ID0gb2Zmc2V0O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvZmZzZXQgKz0gaW5mb3Muc3RvcmFnZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZW5zdXJlIGNvcnJlY3QgZmluYWwgcGFkZGluZ1xyXG5cclxuXHRcdGNodW5rT2Zmc2V0ID0gb2Zmc2V0ICUgY2h1bmtTaXplO1xyXG5cclxuXHRcdGlmICggY2h1bmtPZmZzZXQgPiAwICkgb2Zmc2V0ICs9ICggY2h1bmtTaXplIC0gY2h1bmtPZmZzZXQgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHVuaWZvcm1zR3JvdXAuX19zaXplID0gb2Zmc2V0O1xyXG5cdFx0dW5pZm9ybXNHcm91cC5fX2NhY2hlID0ge307XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0VW5pZm9ybVNpemUoIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnN0IGluZm8gPSB7XHJcblx0XHRcdGJvdW5kYXJ5OiAwLCAvLyBieXRlc1xyXG5cdFx0XHRzdG9yYWdlOiAwIC8vIGJ5dGVzXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGRldGVybWluZSBzaXplcyBhY2NvcmRpbmcgdG8gU1REMTQwXHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0Ly8gZmxvYXQvaW50XHJcblxyXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gNDtcclxuXHRcdFx0aW5mby5zdG9yYWdlID0gNDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjIgKSB7XHJcblxyXG5cdFx0XHQvLyB2ZWMyXHJcblxyXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gODtcclxuXHRcdFx0aW5mby5zdG9yYWdlID0gODtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjMgfHwgdmFsdWUuaXNDb2xvciApIHtcclxuXHJcblx0XHRcdC8vIHZlYzNcclxuXHJcblx0XHRcdGluZm8uYm91bmRhcnkgPSAxNjtcclxuXHRcdFx0aW5mby5zdG9yYWdlID0gMTI7IC8vIGV2aWw6IHZlYzMgbXVzdCBzdGFydCBvbiBhIDE2LWJ5dGUgYm91bmRhcnkgYnV0IGl0IG9ubHkgY29uc3VtZXMgMTIgYnl0ZXNcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjQgKSB7XHJcblxyXG5cdFx0XHQvLyB2ZWM0XHJcblxyXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gMTY7XHJcblx0XHRcdGluZm8uc3RvcmFnZSA9IDE2O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzTWF0cml4MyApIHtcclxuXHJcblx0XHRcdC8vIG1hdDMgKGluIFNURDE0MCBhIDN4MyBtYXRyaXggaXMgcmVwcmVzZW50ZWQgYXMgM3g0KVxyXG5cclxuXHRcdFx0aW5mby5ib3VuZGFyeSA9IDQ4O1xyXG5cdFx0XHRpbmZvLnN0b3JhZ2UgPSA0ODtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZS5pc01hdHJpeDQgKSB7XHJcblxyXG5cdFx0XHQvLyBtYXQ0XHJcblxyXG5cdFx0XHRpbmZvLmJvdW5kYXJ5ID0gNjQ7XHJcblx0XHRcdGluZm8uc3RvcmFnZSA9IDY0O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgc2FtcGxlcnMgY2FuIG5vdCBiZSBwYXJ0IG9mIGFuIHVuaWZvcm1zIGdyb3VwLicgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdW5pZm9ybSB2YWx1ZSB0eXBlLicsIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVW5pZm9ybXNHcm91cHNEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRjb25zdCB1bmlmb3Jtc0dyb3VwID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdHVuaWZvcm1zR3JvdXAucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblVuaWZvcm1zR3JvdXBzRGlzcG9zZSApO1xyXG5cclxuXHRcdGNvbnN0IGluZGV4ID0gYWxsb2NhdGVkQmluZGluZ1BvaW50cy5pbmRleE9mKCB1bmlmb3Jtc0dyb3VwLl9fYmluZGluZ1BvaW50SW5kZXggKTtcclxuXHRcdGFsbG9jYXRlZEJpbmRpbmdQb2ludHMuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyc1sgdW5pZm9ybXNHcm91cC5pZCBdICk7XHJcblxyXG5cdFx0ZGVsZXRlIGJ1ZmZlcnNbIHVuaWZvcm1zR3JvdXAuaWQgXTtcclxuXHRcdGRlbGV0ZSB1cGRhdGVMaXN0WyB1bmlmb3Jtc0dyb3VwLmlkIF07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBpZCBpbiBidWZmZXJzICkge1xyXG5cclxuXHRcdFx0Z2wuZGVsZXRlQnVmZmVyKCBidWZmZXJzWyBpZCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGFsbG9jYXRlZEJpbmRpbmdQb2ludHMgPSBbXTtcclxuXHRcdGJ1ZmZlcnMgPSB7fTtcclxuXHRcdHVwZGF0ZUxpc3QgPSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdGJpbmQ6IGJpbmQsXHJcblx0XHR1cGRhdGU6IHVwZGF0ZSxcclxuXHJcblx0XHRkaXNwb3NlOiBkaXNwb3NlXHJcblxyXG5cdH07XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgV2ViR0xVbmlmb3Jtc0dyb3VwcyB9O1xyXG4iLCJpbXBvcnQge1xyXG5cdFJFVklTSU9OLFxyXG5cdEJhY2tTaWRlLFxyXG5cdEZyb250U2lkZSxcclxuXHREb3VibGVTaWRlLFxyXG5cdFJHQkFGb3JtYXQsXHJcblx0SGFsZkZsb2F0VHlwZSxcclxuXHRGbG9hdFR5cGUsXHJcblx0VW5zaWduZWRCeXRlVHlwZSxcclxuXHROb1RvbmVNYXBwaW5nLFxyXG5cdExpbmVhck1pcG1hcExpbmVhckZpbHRlcixcclxuXHRTUkdCQ29sb3JTcGFjZSxcclxuXHRMaW5lYXJTUkdCQ29sb3JTcGFjZSxcclxuXHRzUkdCRW5jb2RpbmcsXHJcblx0TGluZWFyRW5jb2RpbmcsXHJcblx0UkdCQUludGVnZXJGb3JtYXQsXHJcblx0UkdJbnRlZ2VyRm9ybWF0LFxyXG5cdFJlZEludGVnZXJGb3JtYXQsXHJcblx0VW5zaWduZWRJbnRUeXBlLFxyXG5cdFVuc2lnbmVkU2hvcnRUeXBlLFxyXG5cdFVuc2lnbmVkSW50MjQ4VHlwZSxcclxuXHRVbnNpZ25lZFNob3J0NDQ0NFR5cGUsXHJcblx0VW5zaWduZWRTaG9ydDU1NTFUeXBlLFxyXG5cdFdlYkdMQ29vcmRpbmF0ZVN5c3RlbVxyXG59IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IEZydXN0dW0gfSBmcm9tICcuLi9tYXRoL0ZydXN0dW0uanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuaW1wb3J0IHsgZmxvb3JQb3dlck9mVHdvIH0gZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEFuaW1hdGlvbiB9IGZyb20gJy4vd2ViZ2wvV2ViR0xBbmltYXRpb24uanMnO1xyXG5pbXBvcnQgeyBXZWJHTEF0dHJpYnV0ZXMgfSBmcm9tICcuL3dlYmdsL1dlYkdMQXR0cmlidXRlcy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMQmFja2dyb3VuZCB9IGZyb20gJy4vd2ViZ2wvV2ViR0xCYWNrZ3JvdW5kLmpzJztcclxuaW1wb3J0IHsgV2ViR0xCaW5kaW5nU3RhdGVzIH0gZnJvbSAnLi93ZWJnbC9XZWJHTEJpbmRpbmdTdGF0ZXMuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEJ1ZmZlclJlbmRlcmVyIH0gZnJvbSAnLi93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzJztcclxuaW1wb3J0IHsgV2ViR0xDYXBhYmlsaXRpZXMgfSBmcm9tICcuL3dlYmdsL1dlYkdMQ2FwYWJpbGl0aWVzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xDbGlwcGluZyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xDbGlwcGluZy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMQ3ViZU1hcHMgfSBmcm9tICcuL3dlYmdsL1dlYkdMQ3ViZU1hcHMuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEN1YmVVVk1hcHMgfSBmcm9tICcuL3dlYmdsL1dlYkdMQ3ViZVVWTWFwcy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMRXh0ZW5zaW9ucyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzJztcclxuaW1wb3J0IHsgV2ViR0xHZW9tZXRyaWVzIH0gZnJvbSAnLi93ZWJnbC9XZWJHTEdlb21ldHJpZXMuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciB9IGZyb20gJy4vd2ViZ2wvV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIuanMnO1xyXG5pbXBvcnQgeyBXZWJHTEluZm8gfSBmcm9tICcuL3dlYmdsL1dlYkdMSW5mby5qcyc7XHJcbmltcG9ydCB7IFdlYkdMTW9ycGh0YXJnZXRzIH0gZnJvbSAnLi93ZWJnbC9XZWJHTE1vcnBodGFyZ2V0cy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMT2JqZWN0cyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xPYmplY3RzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xQcm9ncmFtcyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xQcm9ncmFtcy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMUHJvcGVydGllcyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xQcm9wZXJ0aWVzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xSZW5kZXJMaXN0cyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xSZW5kZXJMaXN0cy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMUmVuZGVyU3RhdGVzIH0gZnJvbSAnLi93ZWJnbC9XZWJHTFJlbmRlclN0YXRlcy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9XZWJHTFJlbmRlclRhcmdldC5qcyc7XHJcbmltcG9ydCB7IFdlYkdMU2hhZG93TWFwIH0gZnJvbSAnLi93ZWJnbC9XZWJHTFNoYWRvd01hcC5qcyc7XHJcbmltcG9ydCB7IFdlYkdMU3RhdGUgfSBmcm9tICcuL3dlYmdsL1dlYkdMU3RhdGUuanMnO1xyXG5pbXBvcnQgeyBXZWJHTFRleHR1cmVzIH0gZnJvbSAnLi93ZWJnbC9XZWJHTFRleHR1cmVzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xVbmlmb3JtcyB9IGZyb20gJy4vd2ViZ2wvV2ViR0xVbmlmb3Jtcy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMVXRpbHMgfSBmcm9tICcuL3dlYmdsL1dlYkdMVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBXZWJYUk1hbmFnZXIgfSBmcm9tICcuL3dlYnhyL1dlYlhSTWFuYWdlci5qcyc7XHJcbmltcG9ydCB7IFdlYkdMTWF0ZXJpYWxzIH0gZnJvbSAnLi93ZWJnbC9XZWJHTE1hdGVyaWFscy5qcyc7XHJcbmltcG9ydCB7IFdlYkdMVW5pZm9ybXNHcm91cHMgfSBmcm9tICcuL3dlYmdsL1dlYkdMVW5pZm9ybXNHcm91cHMuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50TlMgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDYW52YXNFbGVtZW50KCkge1xyXG5cclxuXHRjb25zdCBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoICdjYW52YXMnICk7XHJcblx0Y2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cdHJldHVybiBjYW52YXM7XHJcblxyXG59XHJcblxyXG5jbGFzcyBXZWJHTFJlbmRlcmVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgPSB7fSApIHtcclxuXHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGNhbnZhcyA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcclxuXHRcdFx0Y29udGV4dCA9IG51bGwsXHJcblx0XHRcdGRlcHRoID0gdHJ1ZSxcclxuXHRcdFx0c3RlbmNpbCA9IHRydWUsXHJcblx0XHRcdGFscGhhID0gZmFsc2UsXHJcblx0XHRcdGFudGlhbGlhcyA9IGZhbHNlLFxyXG5cdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlLFxyXG5cdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBmYWxzZSxcclxuXHRcdFx0cG93ZXJQcmVmZXJlbmNlID0gJ2RlZmF1bHQnLFxyXG5cdFx0XHRmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0ID0gZmFsc2UsXHJcblx0XHR9ID0gcGFyYW1ldGVycztcclxuXHJcblx0XHR0aGlzLmlzV2ViR0xSZW5kZXJlciA9IHRydWU7XHJcblxyXG5cdFx0bGV0IF9hbHBoYTtcclxuXHJcblx0XHRpZiAoIGNvbnRleHQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRfYWxwaGEgPSBjb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9hbHBoYSA9IGFscGhhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB1aW50Q2xlYXJDb2xvciA9IG5ldyBVaW50MzJBcnJheSggNCApO1xyXG5cdFx0Y29uc3QgaW50Q2xlYXJDb2xvciA9IG5ldyBJbnQzMkFycmF5KCA0ICk7XHJcblxyXG5cdFx0bGV0IGN1cnJlbnRSZW5kZXJMaXN0ID0gbnVsbDtcclxuXHRcdGxldCBjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xyXG5cclxuXHRcdC8vIHJlbmRlcigpIGNhbiBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBjYWxsYmFjayB0cmlnZ2VyZWQgYnkgYW5vdGhlciByZW5kZXIuXHJcblx0XHQvLyBXZSB0cmFjayB0aGlzIHNvIHRoYXQgdGhlIG5lc3RlZCByZW5kZXIgY2FsbCBnZXRzIGl0cyBsaXN0IGFuZCBzdGF0ZSBpc29sYXRlZCBmcm9tIHRoZSBwYXJlbnQgcmVuZGVyIGNhbGwuXHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyTGlzdFN0YWNrID0gW107XHJcblx0XHRjb25zdCByZW5kZXJTdGF0ZVN0YWNrID0gW107XHJcblxyXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcclxuXHJcblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBjYW52YXM7XHJcblxyXG5cdFx0Ly8gRGVidWcgY29uZmlndXJhdGlvbiBjb250YWluZXJcclxuXHRcdHRoaXMuZGVidWcgPSB7XHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogRW5hYmxlcyBlcnJvciBjaGVja2luZyBhbmQgcmVwb3J0aW5nIHdoZW4gc2hhZGVyIHByb2dyYW1zIGFyZSBiZWluZyBjb21waWxlZFxyXG5cdFx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHRcdFx0ICovXHJcblx0XHRcdGNoZWNrU2hhZGVyRXJyb3JzOiB0cnVlLFxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogQ2FsbGJhY2sgZm9yIGN1c3RvbSBlcnJvciByZXBvcnRpbmcuXHJcblx0XHRcdCAqIEB0eXBlIHs/RnVuY3Rpb259XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvblNoYWRlckVycm9yOiBudWxsXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNsZWFyaW5nXHJcblxyXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XHJcblx0XHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcclxuXHRcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG5cdFx0Ly8gc2NlbmUgZ3JhcGhcclxuXHJcblx0XHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcclxuXHJcblx0XHQvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcclxuXHJcblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gW107XHJcblx0XHR0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXHJcblxyXG5cdFx0dGhpcy5vdXRwdXRDb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XHJcblxyXG5cdFx0Ly8gcGh5c2ljYWwgbGlnaHRzXHJcblxyXG5cdFx0dGhpcy51c2VMZWdhY3lMaWdodHMgPSB0cnVlO1xyXG5cclxuXHRcdC8vIHRvbmUgbWFwcGluZ1xyXG5cclxuXHRcdHRoaXMudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xyXG5cdFx0dGhpcy50b25lTWFwcGluZ0V4cG9zdXJlID0gMS4wO1xyXG5cclxuXHRcdC8vIGludGVybmFsIHByb3BlcnRpZXNcclxuXHJcblx0XHRjb25zdCBfdGhpcyA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcclxuXHJcblx0XHRsZXQgX2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IDA7XHJcblx0XHRsZXQgX2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XHJcblx0XHRsZXQgX2N1cnJlbnRSZW5kZXJUYXJnZXQgPSBudWxsO1xyXG5cdFx0bGV0IF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcclxuXHJcblx0XHRsZXQgX2N1cnJlbnRDYW1lcmEgPSBudWxsO1xyXG5cclxuXHRcdGNvbnN0IF9jdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xyXG5cdFx0Y29uc3QgX2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKTtcclxuXHRcdGxldCBfY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbDtcclxuXHJcblx0XHRjb25zdCBfY3VycmVudENsZWFyQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0XHRsZXQgX2N1cnJlbnRDbGVhckFscGhhID0gMDtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCBfd2lkdGggPSBjYW52YXMud2lkdGg7XHJcblx0XHRsZXQgX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcblxyXG5cdFx0bGV0IF9waXhlbFJhdGlvID0gMTtcclxuXHRcdGxldCBfb3BhcXVlU29ydCA9IG51bGw7XHJcblx0XHRsZXQgX3RyYW5zcGFyZW50U29ydCA9IG51bGw7XHJcblxyXG5cdFx0Y29uc3QgX3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApO1xyXG5cdFx0Y29uc3QgX3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICk7XHJcblx0XHRsZXQgX3NjaXNzb3JUZXN0ID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gZnJ1c3R1bVxyXG5cclxuXHRcdGNvbnN0IF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcclxuXHJcblx0XHQvLyBjbGlwcGluZ1xyXG5cclxuXHRcdGxldCBfY2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XHJcblx0XHRsZXQgX2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gdHJhbnNtaXNzaW9uXHJcblxyXG5cdFx0bGV0IF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgPSBudWxsO1xyXG5cclxuXHRcdC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxyXG5cclxuXHRcdGNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRjb25zdCBfdmVjdG9yMiA9IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRjb25zdCBfdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Y29uc3QgX2VtcHR5U2NlbmUgPSB7IGJhY2tncm91bmQ6IG51bGwsIGZvZzogbnVsbCwgZW52aXJvbm1lbnQ6IG51bGwsIG92ZXJyaWRlTWF0ZXJpYWw6IG51bGwsIGlzU2NlbmU6IHRydWUgfTtcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpbml0aWFsaXplXHJcblxyXG5cdFx0bGV0IF9nbCA9IGNvbnRleHQ7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0Q29udGV4dCggY29udGV4dE5hbWVzLCBjb250ZXh0QXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRleHROYW1lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNvbnRleHROYW1lID0gY29udGV4dE5hbWVzWyBpIF07XHJcblx0XHRcdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCBjb250ZXh0TmFtZSwgY29udGV4dEF0dHJpYnV0ZXMgKTtcclxuXHRcdFx0XHRpZiAoIGNvbnRleHQgIT09IG51bGwgKSByZXR1cm4gY29udGV4dDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Y29uc3QgY29udGV4dEF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdFx0YWxwaGE6IHRydWUsXHJcblx0XHRcdFx0ZGVwdGgsXHJcblx0XHRcdFx0c3RlbmNpbCxcclxuXHRcdFx0XHRhbnRpYWxpYXMsXHJcblx0XHRcdFx0cHJlbXVsdGlwbGllZEFscGhhLFxyXG5cdFx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcixcclxuXHRcdFx0XHRwb3dlclByZWZlcmVuY2UsXHJcblx0XHRcdFx0ZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIE9mZnNjcmVlbkNhbnZhcyBkb2VzIG5vdCBoYXZlIHNldEF0dHJpYnV0ZSwgc2VlICMyMjgxMVxyXG5cdFx0XHRpZiAoICdzZXRBdHRyaWJ1dGUnIGluIGNhbnZhcyApIGNhbnZhcy5zZXRBdHRyaWJ1dGUoICdkYXRhLWVuZ2luZScsIGB0aHJlZS5qcyByJHtSRVZJU0lPTn1gICk7XHJcblxyXG5cdFx0XHQvLyBldmVudCBsaXN0ZW5lcnMgbXVzdCBiZSByZWdpc3RlcmVkIGJlZm9yZSBXZWJHTCBjb250ZXh0IGlzIGNyZWF0ZWQsIHNlZSAjMTI3NTNcclxuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHRcdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIG9uQ29udGV4dFJlc3RvcmUsIGZhbHNlICk7XHJcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIG9uQ29udGV4dENyZWF0aW9uRXJyb3IsIGZhbHNlICk7XHJcblxyXG5cdFx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY29udGV4dE5hbWVzID0gWyAnd2ViZ2wyJywgJ3dlYmdsJywgJ2V4cGVyaW1lbnRhbC13ZWJnbCcgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5pc1dlYkdMMVJlbmRlcmVyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnRleHROYW1lcy5zaGlmdCgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbCA9IGdldENvbnRleHQoIGNvbnRleHROYW1lcywgY29udGV4dEF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBfZ2wgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZXRDb250ZXh0KCBjb250ZXh0TmFtZXMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LicgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdHlwZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgX2dsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICkgeyAvLyBAZGVwcmVjYXRlZCwgcjE1M1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTCAxIHN1cHBvcnQgd2FzIGRlcHJlY2F0ZWQgaW4gcjE1MyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHIxNjMuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxyXG5cclxuXHRcdFx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHsgJ3JhbmdlTWluJzogMSwgJ3JhbmdlTWF4JzogMSwgJ3ByZWNpc2lvbic6IDEgfTtcclxuXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yLm1lc3NhZ2UgKTtcclxuXHRcdFx0dGhyb3cgZXJyb3I7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIHN0YXRlLCBpbmZvO1xyXG5cdFx0bGV0IHByb3BlcnRpZXMsIHRleHR1cmVzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgYXR0cmlidXRlcywgZ2VvbWV0cmllcywgb2JqZWN0cztcclxuXHRcdGxldCBwcm9ncmFtQ2FjaGUsIG1hdGVyaWFscywgcmVuZGVyTGlzdHMsIHJlbmRlclN0YXRlcywgY2xpcHBpbmcsIHNoYWRvd01hcDtcclxuXHJcblx0XHRsZXQgYmFja2dyb3VuZCwgbW9ycGh0YXJnZXRzLCBidWZmZXJSZW5kZXJlciwgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xyXG5cclxuXHRcdGxldCB1dGlscywgYmluZGluZ1N0YXRlcywgdW5pZm9ybXNHcm91cHM7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaW5pdEdMQ29udGV4dCgpIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbnMgPSBuZXcgV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcclxuXHJcblx0XHRcdGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyggX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0XHRleHRlbnNpb25zLmluaXQoIGNhcGFiaWxpdGllcyApO1xyXG5cclxuXHRcdFx0dXRpbHMgPSBuZXcgV2ViR0xVdGlscyggX2dsLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcclxuXHJcblx0XHRcdHN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIF9nbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzICk7XHJcblxyXG5cdFx0XHRpbmZvID0gbmV3IFdlYkdMSW5mbyggX2dsICk7XHJcblx0XHRcdHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XHJcblx0XHRcdHRleHR1cmVzID0gbmV3IFdlYkdMVGV4dHVyZXMoIF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8gKTtcclxuXHRcdFx0Y3ViZW1hcHMgPSBuZXcgV2ViR0xDdWJlTWFwcyggX3RoaXMgKTtcclxuXHRcdFx0Y3ViZXV2bWFwcyA9IG5ldyBXZWJHTEN1YmVVVk1hcHMoIF90aGlzICk7XHJcblx0XHRcdGF0dHJpYnV0ZXMgPSBuZXcgV2ViR0xBdHRyaWJ1dGVzKCBfZ2wsIGNhcGFiaWxpdGllcyApO1xyXG5cdFx0XHRiaW5kaW5nU3RhdGVzID0gbmV3IFdlYkdMQmluZGluZ1N0YXRlcyggX2dsLCBleHRlbnNpb25zLCBhdHRyaWJ1dGVzLCBjYXBhYmlsaXRpZXMgKTtcclxuXHRcdFx0Z2VvbWV0cmllcyA9IG5ldyBXZWJHTEdlb21ldHJpZXMoIF9nbCwgYXR0cmlidXRlcywgaW5mbywgYmluZGluZ1N0YXRlcyApO1xyXG5cdFx0XHRvYmplY3RzID0gbmV3IFdlYkdMT2JqZWN0cyggX2dsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvICk7XHJcblx0XHRcdG1vcnBodGFyZ2V0cyA9IG5ldyBXZWJHTE1vcnBodGFyZ2V0cyggX2dsLCBjYXBhYmlsaXRpZXMsIHRleHR1cmVzICk7XHJcblx0XHRcdGNsaXBwaW5nID0gbmV3IFdlYkdMQ2xpcHBpbmcoIHByb3BlcnRpZXMgKTtcclxuXHRcdFx0cHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIF90aGlzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzLCBiaW5kaW5nU3RhdGVzLCBjbGlwcGluZyApO1xyXG5cdFx0XHRtYXRlcmlhbHMgPSBuZXcgV2ViR0xNYXRlcmlhbHMoIF90aGlzLCBwcm9wZXJ0aWVzICk7XHJcblx0XHRcdHJlbmRlckxpc3RzID0gbmV3IFdlYkdMUmVuZGVyTGlzdHMoKTtcclxuXHRcdFx0cmVuZGVyU3RhdGVzID0gbmV3IFdlYkdMUmVuZGVyU3RhdGVzKCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcclxuXHRcdFx0YmFja2dyb3VuZCA9IG5ldyBXZWJHTEJhY2tncm91bmQoIF90aGlzLCBjdWJlbWFwcywgY3ViZXV2bWFwcywgc3RhdGUsIG9iamVjdHMsIF9hbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICk7XHJcblx0XHRcdHNoYWRvd01hcCA9IG5ldyBXZWJHTFNoYWRvd01hcCggX3RoaXMsIG9iamVjdHMsIGNhcGFiaWxpdGllcyApO1xyXG5cdFx0XHR1bmlmb3Jtc0dyb3VwcyA9IG5ldyBXZWJHTFVuaWZvcm1zR3JvdXBzKCBfZ2wsIGluZm8sIGNhcGFiaWxpdGllcywgc3RhdGUgKTtcclxuXHJcblx0XHRcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgaW5mbywgY2FwYWJpbGl0aWVzICk7XHJcblx0XHRcdGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMgKTtcclxuXHJcblx0XHRcdGluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XHJcblxyXG5cdFx0XHRfdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XHJcblx0XHRcdF90aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG5cdFx0XHRfdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHRcdFx0X3RoaXMucmVuZGVyTGlzdHMgPSByZW5kZXJMaXN0cztcclxuXHRcdFx0X3RoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xyXG5cdFx0XHRfdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG5cdFx0XHRfdGhpcy5pbmZvID0gaW5mbztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW5pdEdMQ29udGV4dCgpO1xyXG5cclxuXHRcdC8vIHhyXHJcblxyXG5cdFx0Y29uc3QgeHIgPSBuZXcgV2ViWFJNYW5hZ2VyKCBfdGhpcywgX2dsICk7XHJcblxyXG5cdFx0dGhpcy54ciA9IHhyO1xyXG5cclxuXHRcdC8vIEFQSVxyXG5cclxuXHRcdHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBfZ2w7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICk7XHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICkgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZvcmNlQ29udGV4dFJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcclxuXHRcdFx0aWYgKCBleHRlbnNpb24gKSBleHRlbnNpb24ucmVzdG9yZUNvbnRleHQoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBfcGl4ZWxSYXRpbztcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRfcGl4ZWxSYXRpbyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRTaXplKCBfd2lkdGgsIF9oZWlnaHQsIGZhbHNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KCBfd2lkdGgsIF9oZWlnaHQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgPSB0cnVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB4ci5pc1ByZXNlbnRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENhblxcJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuJyApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF93aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRfaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdFx0Y2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggd2lkdGggKiBfcGl4ZWxSYXRpbyApO1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaGVpZ2h0ICogX3BpeGVsUmF0aW8gKTtcclxuXHJcblx0XHRcdGlmICggdXBkYXRlU3R5bGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQuc2V0KCBfd2lkdGggKiBfcGl4ZWxSYXRpbywgX2hlaWdodCAqIF9waXhlbFJhdGlvICkuZmxvb3IoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gKSB7XHJcblxyXG5cdFx0XHRfd2lkdGggPSB3aWR0aDtcclxuXHRcdFx0X2hlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRcdF9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcclxuXHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIHdpZHRoICogcGl4ZWxSYXRpbyApO1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaGVpZ2h0ICogcGl4ZWxSYXRpbyApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRDdXJyZW50Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggX2N1cnJlbnRWaWV3cG9ydCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBfdmlld3BvcnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHguaXNWZWN0b3I0ICkge1xyXG5cclxuXHRcdFx0XHRfdmlld3BvcnQuc2V0KCB4LngsIHgueSwgeC56LCB4LncgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF92aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApLmZsb29yKCkgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0U2Npc3NvciA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBfc2Npc3NvciApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB4LmlzVmVjdG9yNCApIHtcclxuXHJcblx0XHRcdFx0X3NjaXNzb3Iuc2V0KCB4LngsIHgueSwgeC56LCB4LncgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9zY2lzc29yLnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkuZmxvb3IoKSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBfc2Npc3NvclRlc3Q7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9zY2lzc29yVGVzdCA9IGJvb2xlYW4gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0T3BhcXVlU29ydCA9IGZ1bmN0aW9uICggbWV0aG9kICkge1xyXG5cclxuXHRcdFx0X29wYXF1ZVNvcnQgPSBtZXRob2Q7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFRyYW5zcGFyZW50U29ydCA9IGZ1bmN0aW9uICggbWV0aG9kICkge1xyXG5cclxuXHRcdFx0X3RyYW5zcGFyZW50U29ydCA9IG1ldGhvZDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIENsZWFyaW5nXHJcblxyXG5cdFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGJhY2tncm91bmQuZ2V0Q2xlYXJDb2xvcigpICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRiYWNrZ3JvdW5kLnNldENsZWFyQ29sb3IuYXBwbHkoIGJhY2tncm91bmQsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJhY2tncm91bmQuZ2V0Q2xlYXJBbHBoYSgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0YmFja2dyb3VuZC5zZXRDbGVhckFscGhhLmFwcGx5KCBiYWNrZ3JvdW5kLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGxldCBiaXRzID0gMDtcclxuXHJcblx0XHRcdGlmICggY29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHdlJ3JlIHRyeWluZyB0byBjbGVhciBhbiBpbnRlZ2VyIHRhcmdldFxyXG5cdFx0XHRcdGxldCBpc0ludGVnZXJGb3JtYXQgPSBmYWxzZTtcclxuXHRcdFx0XHRpZiAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHRhcmdldEZvcm1hdCA9IF9jdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0O1xyXG5cdFx0XHRcdFx0aXNJbnRlZ2VyRm9ybWF0ID0gdGFyZ2V0Rm9ybWF0ID09PSBSR0JBSW50ZWdlckZvcm1hdCB8fFxyXG5cdFx0XHRcdFx0XHR0YXJnZXRGb3JtYXQgPT09IFJHSW50ZWdlckZvcm1hdCB8fFxyXG5cdFx0XHRcdFx0XHR0YXJnZXRGb3JtYXQgPT09IFJlZEludGVnZXJGb3JtYXQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdXNlIHRoZSBhcHByb3ByaWF0ZSBjbGVhciBmdW5jdGlvbnMgdG8gY2xlYXIgdGhlIHRhcmdldCBpZiBpdCdzIGEgc2lnbmVkXHJcblx0XHRcdFx0Ly8gb3IgdW5zaWduZWQgaW50ZWdlciB0YXJnZXRcclxuXHRcdFx0XHRpZiAoIGlzSW50ZWdlckZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0YXJnZXRUeXBlID0gX2N1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNVbnNpZ25lZFR5cGUgPSB0YXJnZXRUeXBlID09PSBVbnNpZ25lZEJ5dGVUeXBlIHx8XHJcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSB8fFxyXG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID09PSBVbnNpZ25lZFNob3J0VHlwZSB8fFxyXG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID09PSBVbnNpZ25lZEludDI0OFR5cGUgfHxcclxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlIHx8XHJcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjbGVhckNvbG9yID0gYmFja2dyb3VuZC5nZXRDbGVhckNvbG9yKCk7XHJcblx0XHRcdFx0XHRjb25zdCBhID0gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XHJcblx0XHRcdFx0XHRjb25zdCByID0gY2xlYXJDb2xvci5yO1xyXG5cdFx0XHRcdFx0Y29uc3QgZyA9IGNsZWFyQ29sb3IuZztcclxuXHRcdFx0XHRcdGNvbnN0IGIgPSBjbGVhckNvbG9yLmI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpc1Vuc2lnbmVkVHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVpbnRDbGVhckNvbG9yWyAwIF0gPSByO1xyXG5cdFx0XHRcdFx0XHR1aW50Q2xlYXJDb2xvclsgMSBdID0gZztcclxuXHRcdFx0XHRcdFx0dWludENsZWFyQ29sb3JbIDIgXSA9IGI7XHJcblx0XHRcdFx0XHRcdHVpbnRDbGVhckNvbG9yWyAzIF0gPSBhO1xyXG5cdFx0XHRcdFx0XHRfZ2wuY2xlYXJCdWZmZXJ1aXYoIF9nbC5DT0xPUiwgMCwgdWludENsZWFyQ29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMCBdID0gcjtcclxuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMSBdID0gZztcclxuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMiBdID0gYjtcclxuXHRcdFx0XHRcdFx0aW50Q2xlYXJDb2xvclsgMyBdID0gYTtcclxuXHRcdFx0XHRcdFx0X2dsLmNsZWFyQnVmZmVyaXYoIF9nbC5DT0xPUiwgMCwgaW50Q2xlYXJDb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcclxuXHRcdFx0aWYgKCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdFx0X2dsLmNsZWFyKCBiaXRzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuY2xlYXIoIGZhbHNlLCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHRcdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIG9uQ29udGV4dFJlc3RvcmUsIGZhbHNlICk7XHJcblx0XHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcicsIG9uQ29udGV4dENyZWF0aW9uRXJyb3IsIGZhbHNlICk7XHJcblxyXG5cdFx0XHRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XHJcblx0XHRcdHJlbmRlclN0YXRlcy5kaXNwb3NlKCk7XHJcblx0XHRcdHByb3BlcnRpZXMuZGlzcG9zZSgpO1xyXG5cdFx0XHRjdWJlbWFwcy5kaXNwb3NlKCk7XHJcblx0XHRcdGN1YmV1dm1hcHMuZGlzcG9zZSgpO1xyXG5cdFx0XHRvYmplY3RzLmRpc3Bvc2UoKTtcclxuXHRcdFx0YmluZGluZ1N0YXRlcy5kaXNwb3NlKCk7XHJcblx0XHRcdHVuaWZvcm1zR3JvdXBzLmRpc3Bvc2UoKTtcclxuXHRcdFx0cHJvZ3JhbUNhY2hlLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRcdHhyLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRcdHhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZXNzaW9uc3RhcnQnLCBvblhSU2Vzc2lvblN0YXJ0ICk7XHJcblx0XHRcdHhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQgKTtcclxuXHJcblx0XHRcdGlmICggX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldC5kaXNwb3NlKCk7XHJcblx0XHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhbmltYXRpb24uc3RvcCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRXZlbnRzXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDb250ZXh0IExvc3QuJyApO1xyXG5cclxuXHRcdFx0X2lzQ29udGV4dExvc3QgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbkNvbnRleHRSZXN0b3JlKCAvKiBldmVudCAqLyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nICk7XHJcblxyXG5cdFx0XHRfaXNDb250ZXh0TG9zdCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Y29uc3QgaW5mb0F1dG9SZXNldCA9IGluZm8uYXV0b1Jlc2V0O1xyXG5cdFx0XHRjb25zdCBzaGFkb3dNYXBFbmFibGVkID0gc2hhZG93TWFwLmVuYWJsZWQ7XHJcblx0XHRcdGNvbnN0IHNoYWRvd01hcEF1dG9VcGRhdGUgPSBzaGFkb3dNYXAuYXV0b1VwZGF0ZTtcclxuXHRcdFx0Y29uc3Qgc2hhZG93TWFwTmVlZHNVcGRhdGUgPSBzaGFkb3dNYXAubmVlZHNVcGRhdGU7XHJcblx0XHRcdGNvbnN0IHNoYWRvd01hcFR5cGUgPSBzaGFkb3dNYXAudHlwZTtcclxuXHJcblx0XHRcdGluaXRHTENvbnRleHQoKTtcclxuXHJcblx0XHRcdGluZm8uYXV0b1Jlc2V0ID0gaW5mb0F1dG9SZXNldDtcclxuXHRcdFx0c2hhZG93TWFwLmVuYWJsZWQgPSBzaGFkb3dNYXBFbmFibGVkO1xyXG5cdFx0XHRzaGFkb3dNYXAuYXV0b1VwZGF0ZSA9IHNoYWRvd01hcEF1dG9VcGRhdGU7XHJcblx0XHRcdHNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHNoYWRvd01hcE5lZWRzVXBkYXRlO1xyXG5cdFx0XHRzaGFkb3dNYXAudHlwZSA9IHNoYWRvd01hcFR5cGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dENyZWF0aW9uRXJyb3IoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEEgV2ViR0wgY29udGV4dCBjb3VsZCBub3QgYmUgY3JlYXRlZC4gUmVhc29uOiAnLCBldmVudC5zdGF0dXNNZXNzYWdlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2VzKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW1zO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9ncmFtcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRwcm9ncmFtcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRcdFx0cHJvZ3JhbUNhY2hlLnJlbGVhc2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlU2hhZGVyQ2FjaGUoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xyXG5cclxuXHRcdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lID09PSBudWxsICkgc2NlbmUgPSBfZW1wdHlTY2VuZTsgLy8gcmVuZGVyQnVmZmVyRGlyZWN0IHNlY29uZCBwYXJhbWV0ZXIgdXNlZCB0byBiZSBmb2cgKGNvdWxkIGJlIG51bGwpXHJcblxyXG5cdFx0XHRjb25zdCBmcm9udEZhY2VDVyA9ICggb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAgKTtcclxuXHJcblx0XHRcdGNvbnN0IHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmcm9udEZhY2VDVyApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGxldCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0XHRsZXQgcmFuZ2VGYWN0b3IgPSAxO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gZ2VvbWV0cmllcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICk7XHJcblx0XHRcdFx0cmFuZ2VGYWN0b3IgPSAyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcclxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0bGV0IGRyYXdTdGFydCA9IGRyYXdSYW5nZS5zdGFydCAqIHJhbmdlRmFjdG9yO1xyXG5cdFx0XHRsZXQgZHJhd0VuZCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKiByYW5nZUZhY3RvcjtcclxuXHJcblx0XHRcdGlmICggZ3JvdXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGRyYXdTdGFydCA9IE1hdGgubWF4KCBkcmF3U3RhcnQsIGdyb3VwLnN0YXJ0ICogcmFuZ2VGYWN0b3IgKTtcclxuXHRcdFx0XHRkcmF3RW5kID0gTWF0aC5taW4oIGRyYXdFbmQsICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApICogcmFuZ2VGYWN0b3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGRyYXdTdGFydCA9IE1hdGgubWF4KCBkcmF3U3RhcnQsIDAgKTtcclxuXHRcdFx0XHRkcmF3RW5kID0gTWF0aC5taW4oIGRyYXdFbmQsIGluZGV4LmNvdW50ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRkcmF3U3RhcnQgPSBNYXRoLm1heCggZHJhd1N0YXJ0LCAwICk7XHJcblx0XHRcdFx0ZHJhd0VuZCA9IE1hdGgubWluKCBkcmF3RW5kLCBwb3NpdGlvbi5jb3VudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZHJhd0NvdW50ID0gZHJhd0VuZCAtIGRyYXdTdGFydDtcclxuXHJcblx0XHRcdGlmICggZHJhd0NvdW50IDwgMCB8fCBkcmF3Q291bnQgPT09IEluZmluaXR5ICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGJpbmRpbmdTdGF0ZXMuc2V0dXAoIG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBpbmRleCApO1xyXG5cclxuXHRcdFx0bGV0IGF0dHJpYnV0ZTtcclxuXHRcdFx0bGV0IHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldCggaW5kZXggKTtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcclxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZSApIHtcclxuXHJcblx0XHRcdFx0bGV0IGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcclxuXHJcblx0XHRcdFx0aWYgKCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCApIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXHJcblxyXG5cdFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmlzTGluZVNlZ21lbnRzICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lTG9vcCApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9MT09QICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfU1RSSVAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzUG9pbnRzICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuUE9JTlRTICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmlzSW5zdGFuY2VkTWVzaCApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBkcmF3U3RhcnQsIGRyYXdDb3VudCwgb2JqZWN0LmNvdW50ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBtYXhJbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50IDogSW5maW5pdHk7XHJcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb3VudCA9IE1hdGgubWluKCBnZW9tZXRyeS5pbnN0YW5jZUNvdW50LCBtYXhJbnN0YW5jZUNvdW50ICk7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZHJhd1N0YXJ0LCBkcmF3Q291bnQsIGluc3RhbmNlQ291bnQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIENvbXBpbGVcclxuXHJcblx0XHR0aGlzLmNvbXBpbGUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBwcmVwYXJlKCBtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlICYmIG1hdGVyaWFsLmZvcmNlU2luZ2xlUGFzcyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRnZXRQcm9ncmFtKCBtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KCBzY2VuZSApO1xyXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCgpO1xyXG5cclxuXHRcdFx0cmVuZGVyU3RhdGVTdGFjay5wdXNoKCBjdXJyZW50UmVuZGVyU3RhdGUgKTtcclxuXHJcblx0XHRcdHNjZW5lLnRyYXZlcnNlVmlzaWJsZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmlzTGlnaHQgJiYgb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hMaWdodCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5wdXNoU2hhZG93KCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cyggX3RoaXMudXNlTGVnYWN5TGlnaHRzICk7XHJcblxyXG5cdFx0XHRzY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1hdGVyaWFsLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwyID0gbWF0ZXJpYWxbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHJlcGFyZSggbWF0ZXJpYWwyLCBzY2VuZSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHByZXBhcmUoIG1hdGVyaWFsLCBzY2VuZSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnBvcCgpO1xyXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQW5pbWF0aW9uIExvb3BcclxuXHJcblx0XHRsZXQgb25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gbnVsbDtcclxuXHJcblx0XHRmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2soIHRpbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25YUlNlc3Npb25TdGFydCgpIHtcclxuXHJcblx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uWFJTZXNzaW9uRW5kKCkge1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLnN0YXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xyXG5cdFx0YW5pbWF0aW9uLnNldEFuaW1hdGlvbkxvb3AoIG9uQW5pbWF0aW9uRnJhbWUgKTtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyApIGFuaW1hdGlvbi5zZXRDb250ZXh0KCBzZWxmICk7XHJcblxyXG5cdFx0dGhpcy5zZXRBbmltYXRpb25Mb29wID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRcdG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdFx0XHR4ci5zZXRBbmltYXRpb25Mb29wKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdFx0KCBjYWxsYmFjayA9PT0gbnVsbCApID8gYW5pbWF0aW9uLnN0b3AoKSA6IGFuaW1hdGlvbi5zdGFydCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0eHIuYWRkRXZlbnRMaXN0ZW5lciggJ3Nlc3Npb25zdGFydCcsIG9uWFJTZXNzaW9uU3RhcnQgKTtcclxuXHRcdHhyLmFkZEV2ZW50TGlzdGVuZXIoICdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQgKTtcclxuXHJcblx0XHQvLyBSZW5kZXJpbmdcclxuXHJcblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGlmICggY2FtZXJhICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhLmlzQ2FtZXJhICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIF9pc0NvbnRleHRMb3N0ID09PSB0cnVlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IG51bGwgJiYgY2FtZXJhLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdFx0aWYgKCB4ci5lbmFibGVkID09PSB0cnVlICYmIHhyLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB4ci5jYW1lcmFBdXRvVXBkYXRlID09PSB0cnVlICkgeHIudXBkYXRlQ2FtZXJhKCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0Y2FtZXJhID0geHIuZ2V0Q2FtZXJhKCk7IC8vIHVzZSBYUiBjYW1lcmEgZm9yIHJlbmRlcmluZ1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHRcdFx0aWYgKCBzY2VuZS5pc1NjZW5lID09PSB0cnVlICkgc2NlbmUub25CZWZvcmVSZW5kZXIoIF90aGlzLCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVzLmdldCggc2NlbmUsIHJlbmRlclN0YXRlU3RhY2subGVuZ3RoICk7XHJcblx0XHRcdGN1cnJlbnRSZW5kZXJTdGF0ZS5pbml0KCk7XHJcblxyXG5cdFx0XHRyZW5kZXJTdGF0ZVN0YWNrLnB1c2goIGN1cnJlbnRSZW5kZXJTdGF0ZSApO1xyXG5cclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0XHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xyXG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gY2xpcHBpbmcuaW5pdCggdGhpcy5jbGlwcGluZ1BsYW5lcywgX2xvY2FsQ2xpcHBpbmdFbmFibGVkICk7XHJcblxyXG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdCA9IHJlbmRlckxpc3RzLmdldCggc2NlbmUsIHJlbmRlckxpc3RTdGFjay5sZW5ndGggKTtcclxuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuaW5pdCgpO1xyXG5cclxuXHRcdFx0cmVuZGVyTGlzdFN0YWNrLnB1c2goIGN1cnJlbnRSZW5kZXJMaXN0ICk7XHJcblxyXG5cdFx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhLCAwLCBfdGhpcy5zb3J0T2JqZWN0cyApO1xyXG5cclxuXHRcdFx0Y3VycmVudFJlbmRlckxpc3QuZmluaXNoKCk7XHJcblxyXG5cdFx0XHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5zb3J0KCBfb3BhcXVlU29ydCwgX3RyYW5zcGFyZW50U29ydCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHRoaXMuaW5mby5yZW5kZXIuZnJhbWUgKys7XHJcblxyXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSBjbGlwcGluZy5iZWdpblNoYWRvd3MoKTtcclxuXHJcblx0XHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXAucmVuZGVyKCBzaGFkb3dzQXJyYXksIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCA9PT0gdHJ1ZSApIGNsaXBwaW5nLmVuZFNoYWRvd3MoKTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaW5mby5hdXRvUmVzZXQgPT09IHRydWUgKSB0aGlzLmluZm8ucmVzZXQoKTtcclxuXHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0YmFja2dyb3VuZC5yZW5kZXIoIGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSApO1xyXG5cclxuXHRcdFx0Ly8gcmVuZGVyIHNjZW5lXHJcblxyXG5cdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUuc2V0dXBMaWdodHMoIF90aGlzLnVzZUxlZ2FjeUxpZ2h0cyApO1xyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmEuaXNBcnJheUNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYS5jYW1lcmFzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjYW1lcmFzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgY2FtZXJhMiA9IGNhbWVyYXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJTY2VuZSggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEyLCBjYW1lcmEyLnZpZXdwb3J0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclNjZW5lKCBjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGlmICggX2N1cnJlbnRSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlc29sdmUgbXVsdGlzYW1wbGUgcmVuZGVyYnVmZmVycyB0byBhIHNpbmdsZS1zYW1wbGUgdGV4dHVyZSBpZiBuZWNlc3NhcnlcclxuXHJcblx0XHRcdFx0dGV4dHVyZXMudXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXHJcblxyXG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggX2N1cnJlbnRSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgPT09IHRydWUgKSBzY2VuZS5vbkFmdGVyUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0Ly8gX2dsLmZpbmlzaCgpO1xyXG5cclxuXHRcdFx0YmluZGluZ1N0YXRlcy5yZXNldERlZmF1bHRTdGF0ZSgpO1xyXG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XHJcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRcdHJlbmRlclN0YXRlU3RhY2sucG9wKCk7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclN0YXRlU3RhY2subGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVTdGFja1sgcmVuZGVyU3RhdGVTdGFjay5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUgPSBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVuZGVyTGlzdFN0YWNrLnBvcCgpO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJMaXN0U3RhY2subGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QgPSByZW5kZXJMaXN0U3RhY2tbIHJlbmRlckxpc3RTdGFjay5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdGNvbnN0IHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKTtcclxuXHJcblx0XHRcdGlmICggdmlzaWJsZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QuaXNHcm91cCApIHtcclxuXHJcblx0XHRcdFx0XHRncm91cE9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMT0QgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIG9iamVjdC51cGRhdGUoIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50UmVuZGVyU3RhdGUucHVzaExpZ2h0KCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3coIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU3ByaXRlICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzU3ByaXRlKCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggc29ydE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkIClcclxuXHRcdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggc29ydE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggb2JqZWN0LmJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBvYmplY3QuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5jb3B5KCBvYmplY3QuYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjNcclxuXHRcdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApXHJcblx0XHRcdFx0XHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgZ3JvdXBPcmRlciwgc29ydE9iamVjdHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyU2NlbmUoIGN1cnJlbnRSZW5kZXJMaXN0LCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydCApIHtcclxuXHJcblx0XHRcdGNvbnN0IG9wYXF1ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC5vcGFxdWU7XHJcblx0XHRcdGNvbnN0IHRyYW5zbWlzc2l2ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc21pc3NpdmU7XHJcblx0XHRcdGNvbnN0IHRyYW5zcGFyZW50T2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0LnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdFx0Y3VycmVudFJlbmRlclN0YXRlLnNldHVwTGlnaHRzVmlldyggY2FtZXJhICk7XHJcblxyXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSBjbGlwcGluZy5zZXRHbG9iYWxTdGF0ZSggX3RoaXMuY2xpcHBpbmdQbGFuZXMsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0aWYgKCB0cmFuc21pc3NpdmVPYmplY3RzLmxlbmd0aCA+IDAgKSByZW5kZXJUcmFuc21pc3Npb25QYXNzKCBvcGFxdWVPYmplY3RzLCB0cmFuc21pc3NpdmVPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRpZiAoIHZpZXdwb3J0ICkgc3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBvcGFxdWVPYmplY3RzLmxlbmd0aCA+IDAgKSByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XHJcblx0XHRcdGlmICggdHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyT2JqZWN0cyggdHJhbnNtaXNzaXZlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xyXG5cdFx0XHRpZiAoIHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPiAwICkgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxyXG5cclxuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XHJcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggdHJ1ZSApO1xyXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2soIHRydWUgKTtcclxuXHJcblx0XHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlclRyYW5zbWlzc2lvblBhc3MoIG9wYXF1ZU9iamVjdHMsIHRyYW5zbWlzc2l2ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcclxuXHJcblx0XHRcdGlmICggX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0X3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCggMSwgMSwge1xyXG5cdFx0XHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZTogZXh0ZW5zaW9ucy5oYXMoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgPyBIYWxmRmxvYXRUeXBlIDogVW5zaWduZWRCeXRlVHlwZSxcclxuXHRcdFx0XHRcdG1pbkZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRcdFx0c2FtcGxlczogKCBpc1dlYkdMMiApID8gNCA6IDBcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdC8vIGRlYnVnXHJcblxyXG5cdFx0XHRcdC8qXHJcblx0XHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeSgpO1xyXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IG1hcDogX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldC50ZXh0dXJlIH0gKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbWVzaCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0XHRzY2VuZS5hZGQoIG1lc2ggKTtcclxuXHRcdFx0XHQqL1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3RoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUoIF92ZWN0b3IyICk7XHJcblxyXG5cdFx0XHRpZiAoIGlzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0XHRfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LnNldFNpemUoIF92ZWN0b3IyLngsIF92ZWN0b3IyLnkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQuc2V0U2l6ZSggZmxvb3JQb3dlck9mVHdvKCBfdmVjdG9yMi54ICksIGZsb29yUG93ZXJPZlR3byggX3ZlY3RvcjIueSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0Y29uc3QgY3VycmVudFJlbmRlclRhcmdldCA9IF90aGlzLmdldFJlbmRlclRhcmdldCgpO1xyXG5cdFx0XHRfdGhpcy5zZXRSZW5kZXJUYXJnZXQoIF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdF90aGlzLmdldENsZWFyQ29sb3IoIF9jdXJyZW50Q2xlYXJDb2xvciApO1xyXG5cdFx0XHRfY3VycmVudENsZWFyQWxwaGEgPSBfdGhpcy5nZXRDbGVhckFscGhhKCk7XHJcblx0XHRcdGlmICggX2N1cnJlbnRDbGVhckFscGhhIDwgMSApIF90aGlzLnNldENsZWFyQ29sb3IoIDB4ZmZmZmZmLCAwLjUgKTtcclxuXHJcblx0XHRcdF90aGlzLmNsZWFyKCk7XHJcblxyXG5cdFx0XHQvLyBUdXJuIG9mZiB0aGUgZmVhdHVyZXMgd2hpY2ggY2FuIGFmZmVjdCB0aGUgZnJhZyBjb2xvciBmb3Igb3BhcXVlIG9iamVjdHMgcGFzcy5cclxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHRoZXkgYXJlIGFwcGxpZWQgdHdpY2UgaW4gb3BhcXVlIG9iamVjdHMgcGFzcyBhbmQgdHJhbnNtaXNzaW9uIG9iamVjdHMgcGFzcy5cclxuXHRcdFx0Y29uc3QgY3VycmVudFRvbmVNYXBwaW5nID0gX3RoaXMudG9uZU1hcHBpbmc7XHJcblx0XHRcdF90aGlzLnRvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdHRleHR1cmVzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KCBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0bGV0IHJlbmRlclRhcmdldE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0cmFuc21pc3NpdmVPYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSB0cmFuc21pc3NpdmVPYmplY3RzWyBpIF07XHJcblxyXG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xyXG5cdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcclxuXHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IHJlbmRlckl0ZW0ubWF0ZXJpYWw7XHJcblx0XHRcdFx0Y29uc3QgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgJiYgb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudFNpZGUgPSBtYXRlcmlhbC5zaWRlO1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcclxuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBjdXJyZW50U2lkZTtcclxuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0TmVlZHNVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KCBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdFx0dGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfdGhpcy5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdF90aGlzLnNldENsZWFyQ29sb3IoIF9jdXJyZW50Q2xlYXJDb2xvciwgX2N1cnJlbnRDbGVhckFscGhhICk7XHJcblxyXG5cdFx0XHRfdGhpcy50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGNvbnN0IG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5pc1NjZW5lID09PSB0cnVlID8gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XHJcblxyXG5cdFx0XHRcdGNvbnN0IG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xyXG5cdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcclxuXHRcdFx0XHRjb25zdCBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IG51bGwgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHRcdFx0XHRjb25zdCBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApIHtcclxuXHJcblx0XHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgJiYgbWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xyXG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xyXG5cdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvYmplY3Qub25BZnRlclJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgIT09IHRydWUgKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXHJcblxyXG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdGNvbnN0IGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XHJcblx0XHRcdGNvbnN0IHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XHJcblxyXG5cdFx0XHRjb25zdCBsaWdodHNTdGF0ZVZlcnNpb24gPSBsaWdodHMuc3RhdGUudmVyc2lvbjtcclxuXHJcblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyggbWF0ZXJpYWwsIGxpZ2h0cy5zdGF0ZSwgc2hhZG93c0FycmF5LCBzY2VuZSwgb2JqZWN0ICk7XHJcblx0XHRcdGNvbnN0IHByb2dyYW1DYWNoZUtleSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ2FjaGVLZXkoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRcdGxldCBwcm9ncmFtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtcztcclxuXHJcblx0XHRcdC8vIGFsd2F5cyB1cGRhdGUgZW52aXJvbm1lbnQgYW5kIGZvZyAtIGNoYW5naW5nIHRoZXNlIHRyaWdnZXIgYW4gZ2V0UHJvZ3JhbSBjYWxsLCBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBwcm9ncmFtIGRvZXNuJ3QgY2hhbmdlXHJcblxyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52aXJvbm1lbnQgPSBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gc2NlbmUuZW52aXJvbm1lbnQgOiBudWxsO1xyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZm9nID0gc2NlbmUuZm9nO1xyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwID0gKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gY3ViZXV2bWFwcyA6IGN1YmVtYXBzICkuZ2V0KCBtYXRlcmlhbC5lbnZNYXAgfHwgbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ICk7XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW1zID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5ldyBtYXRlcmlhbFxyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdHByb2dyYW1zID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHByb2dyYW0gPSBwcm9ncmFtcy5nZXQoIHByb2dyYW1DYWNoZUtleSApO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9ncmFtICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGVhcmx5IG91dCBpZiBwcm9ncmFtIGFuZCBsaWdodCBzdGF0ZSBpcyBpZGVudGljYWxcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0gPT09IHByb2dyYW0gJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9PT0gbGlnaHRzU3RhdGVWZXJzaW9uICkge1xyXG5cclxuXHRcdFx0XHRcdHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy51bmlmb3JtcyA9IHByb2dyYW1DYWNoZS5nZXRVbmlmb3JtcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwub25CdWlsZCggb2JqZWN0LCBwYXJhbWV0ZXJzLCBfdGhpcyApO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUoIHBhcmFtZXRlcnMsIF90aGlzICk7XHJcblxyXG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIHBhcmFtZXRlcnMsIHByb2dyYW1DYWNoZUtleSApO1xyXG5cdFx0XHRcdHByb2dyYW1zLnNldCggcHJvZ3JhbUNhY2hlS2V5LCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcyA9IHBhcmFtZXRlcnMudW5pZm9ybXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcztcclxuXHJcblx0XHRcdGlmICggKCAhIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgISBtYXRlcmlhbC5pc1Jhd1NoYWRlck1hdGVyaWFsICkgfHwgbWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmNsaXBwaW5nUGxhbmVzID0gY2xpcHBpbmcudW5pZm9ybTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRcdC8vIHN0b3JlIHRoZSBsaWdodCBzZXR1cCBpdCB3YXMgY3JlYXRlZCBmb3JcclxuXHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyA9IG1hdGVyaWFsTmVlZHNMaWdodHMoIG1hdGVyaWFsICk7XHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNTdGF0ZVZlcnNpb24gPSBsaWdodHNTdGF0ZVZlcnNpb247XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gd2lyZSB1cCB0aGUgbWF0ZXJpYWwgdG8gdGhpcyByZW5kZXJlcidzIGxpZ2h0aW5nIHN0YXRlXHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnN0YXRlLmFtYmllbnQ7XHJcblx0XHRcdFx0dW5pZm9ybXMubGlnaHRQcm9iZS52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wcm9iZTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdztcclxuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XHJcblx0XHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0U2hhZG93cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90U2hhZG93O1xyXG5cdFx0XHRcdHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmx0Y18xLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhTFRDMTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5sdGNfMi52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5yZWN0QXJlYUxUQzI7XHJcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnQ7XHJcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3c7XHJcblx0XHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5oZW1pO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RMaWdodE1hdHJpeDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdExpZ2h0TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4O1xyXG5cdFx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBhZGQgYXJlYSBsaWdodHMgc2hhZG93IGluZm8gdG8gdW5pZm9ybXNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHByb2dVbmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcclxuXHRcdFx0Y29uc3QgdW5pZm9ybXNMaXN0ID0gV2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUoIHByb2dVbmlmb3Jtcy5zZXEsIHVuaWZvcm1zICk7XHJcblxyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0gPSBwcm9ncmFtO1xyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0ID0gdW5pZm9ybXNMaXN0O1xyXG5cclxuXHRcdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5vdXRwdXRDb2xvclNwYWNlID0gcGFyYW1ldGVycy5vdXRwdXRDb2xvclNwYWNlO1xyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9IHBhcmFtZXRlcnMuaW5zdGFuY2luZztcclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID0gcGFyYW1ldGVycy5za2lubmluZztcclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0cyA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzO1xyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhOb3JtYWxzID0gcGFyYW1ldGVycy5tb3JwaE5vcm1hbHM7XHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaENvbG9ycyA9IHBhcmFtZXRlcnMubW9ycGhDb2xvcnM7XHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHNDb3VudCA9IHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQ7XHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyA9IHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXM7XHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gPSBwYXJhbWV0ZXJzLm51bUNsaXBJbnRlcnNlY3Rpb247XHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhBbHBoYXMgPSBwYXJhbWV0ZXJzLnZlcnRleEFscGhhcztcclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleFRhbmdlbnRzID0gcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cztcclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnRvbmVNYXBwaW5nID0gcGFyYW1ldGVycy50b25lTWFwcGluZztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lLmlzU2NlbmUgIT09IHRydWUgKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXHJcblxyXG5cdFx0XHR0ZXh0dXJlcy5yZXNldFRleHR1cmVVbml0cygpO1xyXG5cclxuXHRcdFx0Y29uc3QgZm9nID0gc2NlbmUuZm9nO1xyXG5cdFx0XHRjb25zdCBlbnZpcm9ubWVudCA9IG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBzY2VuZS5lbnZpcm9ubWVudCA6IG51bGw7XHJcblx0XHRcdGNvbnN0IGNvbG9yU3BhY2UgPSAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsICkgPyBfdGhpcy5vdXRwdXRDb2xvclNwYWNlIDogKCBfY3VycmVudFJlbmRlclRhcmdldC5pc1hSUmVuZGVyVGFyZ2V0ID09PSB0cnVlID8gX2N1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZS5jb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2UgKTtcclxuXHRcdFx0Y29uc3QgZW52TWFwID0gKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gY3ViZXV2bWFwcyA6IGN1YmVtYXBzICkuZ2V0KCBtYXRlcmlhbC5lbnZNYXAgfHwgZW52aXJvbm1lbnQgKTtcclxuXHRcdFx0Y29uc3QgdmVydGV4QWxwaGFzID0gbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSB0cnVlICYmICEhIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNDtcclxuXHRcdFx0Y29uc3QgdmVydGV4VGFuZ2VudHMgPSAhISBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgJiYgKCAhISBtYXRlcmlhbC5ub3JtYWxNYXAgfHwgbWF0ZXJpYWwuYW5pc290cm9weSA+IDAgKTtcclxuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzID0gISEgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0XHRjb25zdCBtb3JwaE5vcm1hbHMgPSAhISBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cdFx0XHRjb25zdCBtb3JwaENvbG9ycyA9ICEhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcclxuXHRcdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSBtYXRlcmlhbC50b25lTWFwcGVkID8gX3RoaXMudG9uZU1hcHBpbmcgOiBOb1RvbmVNYXBwaW5nO1xyXG5cclxuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XHJcblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xyXG5cclxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XHJcblx0XHRcdGNvbnN0IGxpZ2h0cyA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5saWdodHM7XHJcblxyXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX2xvY2FsQ2xpcHBpbmdFbmFibGVkID09PSB0cnVlIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXNlQ2FjaGUgPVxyXG5cdFx0XHRcdFx0XHRjYW1lcmEgPT09IF9jdXJyZW50Q2FtZXJhICYmXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID09PSBfY3VycmVudE1hdGVyaWFsSWQ7XHJcblxyXG5cdFx0XHRcdFx0Ly8gd2UgbWlnaHQgd2FudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCBzb21lIENsaXBwaW5nR3JvdXBcclxuXHRcdFx0XHRcdC8vIG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBtYXRlcmlhbCwgb25jZSBpdCBiZWNvbWVzIGZlYXNpYmxlXHJcblx0XHRcdFx0XHQvLyAoIzg0NjUsICM4Mzc5KVxyXG5cdFx0XHRcdFx0Y2xpcHBpbmcuc2V0U3RhdGUoIG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRsZXQgbmVlZHNQcm9ncmFtQ2hhbmdlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnZlcnNpb24gPT09IG1hdGVyaWFsUHJvcGVydGllcy5fX3ZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzICYmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiAhPT0gbGlnaHRzLnN0YXRlLnZlcnNpb24gKSApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMub3V0cHV0Q29sb3JTcGFjZSAhPT0gY29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbnN0YW5jZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5pbnN0YW5jaW5nID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhIG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsUHJvcGVydGllcy5za2lubmluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMuZW52TWFwICE9PSBlbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZm9nID09PSB0cnVlICYmIG1hdGVyaWFsUHJvcGVydGllcy5mb2cgIT09IGZvZyApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IHVuZGVmaW5lZCAmJlxyXG5cdFx0XHRcdFx0KCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IGNsaXBwaW5nLm51bVBsYW5lcyB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiAhPT0gY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleEFscGhhcyAhPT0gdmVydGV4QWxwaGFzICkge1xyXG5cclxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhUYW5nZW50cyAhPT0gdmVydGV4VGFuZ2VudHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoVGFyZ2V0cyAhPT0gbW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaE5vcm1hbHMgIT09IG1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhDb2xvcnMgIT09IG1vcnBoQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy50b25lTWFwcGluZyAhPT0gdG9uZU1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlICYmIG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHNDb3VudCAhPT0gbW9ycGhUYXJnZXRzQ291bnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX192ZXJzaW9uID0gbWF0ZXJpYWwudmVyc2lvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRsZXQgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbTtcclxuXHJcblx0XHRcdGlmICggbmVlZHNQcm9ncmFtQ2hhbmdlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRwcm9ncmFtID0gZ2V0UHJvZ3JhbSggbWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xyXG5cdFx0XHRsZXQgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XHJcblx0XHRcdGxldCByZWZyZXNoTGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRjb25zdCBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxyXG5cdFx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXM7XHJcblxyXG5cdFx0XHRpZiAoIHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoUHJvZ3JhbSA9IHRydWU7XHJcblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcclxuXHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcclxuXHJcblx0XHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHJlZnJlc2hQcm9ncmFtIHx8IF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3Byb2plY3Rpb25NYXRyaXgnLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxyXG5cdFx0XHRcdFx0XHQyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBfY3VycmVudENhbWVyYSAhPT0gY2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRcdF9jdXJyZW50Q2FtZXJhID0gY2FtZXJhO1xyXG5cclxuXHRcdFx0XHRcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXHJcblx0XHRcdFx0XHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxyXG5cdFx0XHRcdFx0Ly8gdGhlIG5leHQgbWF0ZXJpYWwgdGhhdCBkb2VzIGdldHMgYWN0aXZhdGVkOlxyXG5cclxuXHRcdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHRcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxyXG5cdFx0XHRcdFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XHRcdC8vIHJlbWFpbnMgc2V0IHVudGlsIHVwZGF0ZSBkb25lXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cdFx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdUNhbVBvcyA9IHBfdW5pZm9ybXMubWFwLmNhbWVyYVBvc2l0aW9uO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdUNhbVBvcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dUNhbVBvcy5zZXRWYWx1ZSggX2dsLFxyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdpc09ydGhvZ3JhcGhpYycsIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9PT0gdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRcdG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRcdG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xyXG5cclxuXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3ZpZXdNYXRyaXgnLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNraW5uaW5nIGFuZCBtb3JwaCB0YXJnZXQgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXHJcblx0XHRcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgYW5kIG1vcnBoIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcclxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHRleHR1cmVzIHVzZWQgZm9yIHNraW5uaW5nIGFuZCBtb3JwaGluZyBjYW4gdGFrZSBvdmVyIHRleHR1cmUgdW5pdHMgcmVzZXJ2ZWQgZm9yIG90aGVyIG1hdGVyaWFsIHRleHR1cmVzXHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xyXG5cclxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXgnICk7XHJcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XHJcblxyXG5cdFx0XHRcdGlmICggc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggc2tlbGV0b24uYm9uZVRleHR1cmUgPT09IG51bGwgKSBza2VsZXRvbi5jb21wdXRlQm9uZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2JvbmVUZXh0dXJlJywgc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVzICk7XHJcblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2JvbmVUZXh0dXJlU2l6ZScsIHNrZWxldG9uLmJvbmVUZXh0dXJlU2l6ZSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBTa2lubmVkTWVzaCBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wgMi4gV2l0aCBXZWJHTCAxIE9FU190ZXh0dXJlX2Zsb2F0IGFuZCB2ZXJ0ZXggdGV4dHVyZXMgc3VwcG9ydCBpcyByZXF1aXJlZC4nICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkIHx8IG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCB8fCAoIG1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICYmIGNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gdHJ1ZSApICkge1xyXG5cclxuXHRcdFx0XHRtb3JwaHRhcmdldHMudXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCB8fCBtYXRlcmlhbFByb3BlcnRpZXMucmVjZWl2ZVNoYWRvdyAhPT0gb2JqZWN0LnJlY2VpdmVTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5yZWNlaXZlU2hhZG93ID0gb2JqZWN0LnJlY2VpdmVTaGFkb3c7XHJcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAncmVjZWl2ZVNoYWRvdycsIG9iamVjdC5yZWNlaXZlU2hhZG93ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjQ0NjcjaXNzdWVjb21tZW50LTEyMDkwMzE1MTJcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoR291cmF1ZE1hdGVyaWFsICYmIG1hdGVyaWFsLmVudk1hcCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0bV91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBlbnZNYXA7XHJcblxyXG5cdFx0XHRcdG1fdW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggZW52TWFwLmlzQ3ViZVRleHR1cmUgJiYgZW52TWFwLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UgKSA/IC0gMSA6IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndG9uZU1hcHBpbmdFeHBvc3VyZScsIF90aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubmVlZHNMaWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xyXG5cclxuXHRcdFx0XHRcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcclxuXHRcdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcclxuXHRcdFx0XHRcdC8vIHZhbHVlc1xyXG5cdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcclxuXHRcdFx0XHRcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXHJcblxyXG5cdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHJlZnJlc2hMaWdodHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xyXG5cclxuXHRcdFx0XHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWxzLnJlZnJlc2hGb2dVbmlmb3JtcyggbV91bmlmb3JtcywgZm9nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxzLnJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCwgX3BpeGVsUmF0aW8sIF9oZWlnaHQsIF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQoIF9nbCwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCwgbV91bmlmb3JtcywgdGV4dHVyZXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiBtYXRlcmlhbC51bmlmb3Jtc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKCBfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIHRleHR1cmVzICk7XHJcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzU3ByaXRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2NlbnRlcicsIG9iamVjdC5jZW50ZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNvbW1vbiBtYXRyaWNlc1xyXG5cclxuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xyXG5cdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdub3JtYWxNYXRyaXgnLCBvYmplY3Qubm9ybWFsTWF0cml4ICk7XHJcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHQvLyBVQk9zXHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gbWF0ZXJpYWwudW5pZm9ybXNHcm91cHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zR3JvdXBzLnVwZGF0ZSggZ3JvdXAsIHByb2dyYW0gKTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXNHcm91cHMuYmluZCggZ3JvdXAsIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5pZm9ybSBCdWZmZXIgT2JqZWN0cyBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wgMi4nICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxyXG5cclxuXHRcdGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCB1bmlmb3JtcywgdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0XHR1bmlmb3Jtcy5saWdodFByb2JlLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBtYXRlcmlhbE5lZWRzTGlnaHRzKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgbWF0ZXJpYWwubGlnaHRzID09PSB0cnVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0QWN0aXZlQ3ViZUZhY2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRBY3RpdmVDdWJlRmFjZTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXRUZXh0dXJlcyA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlID0gY29sb3JUZXh0dXJlO1xyXG5cdFx0XHRwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlID0gZGVwdGhUZXh0dXJlO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2hhc0V4dGVybmFsVGV4dHVyZXMgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2F1dG9BbGxvY2F0ZURlcHRoQnVmZmVyID0gZGVwdGhUZXh0dXJlID09PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdGlmICggISByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlIG11bHRpc2FtcGxlX3JlbmRlcl90b190ZXh0dXJlIGV4dGVuc2lvbiBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaWYgdGhlcmVcclxuXHRcdFx0XHRcdC8vIGFyZSBtaWRmcmFtZSBmbHVzaGVzIGFuZCBhbiBleHRlcm5hbCBkZXB0aCBidWZmZXIuIERpc2FibGUgdXNlIG9mIHRoZSBleHRlbnNpb24uXHJcblx0XHRcdFx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogUmVuZGVyLXRvLXRleHR1cmUgZXh0ZW5zaW9uIHdhcyBkaXNhYmxlZCBiZWNhdXNlIGFuIGV4dGVybmFsIHRleHR1cmUgd2FzIHByb3ZpZGVkJyApO1xyXG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlUmVuZGVyVG9UZXh0dXJlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldEZyYW1lYnVmZmVyID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGRlZmF1bHRGcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gZGVmYXVsdEZyYW1lYnVmZmVyO1xyXG5cdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyID0gZGVmYXVsdEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSA9IDAsIGFjdGl2ZU1pcG1hcExldmVsID0gMCApIHtcclxuXHJcblx0XHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG5cdFx0XHRfY3VycmVudEFjdGl2ZUN1YmVGYWNlID0gYWN0aXZlQ3ViZUZhY2U7XHJcblx0XHRcdF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSBhY3RpdmVNaXBtYXBMZXZlbDtcclxuXHJcblx0XHRcdGxldCB1c2VEZWZhdWx0RnJhbWVidWZmZXIgPSB0cnVlO1xyXG5cdFx0XHRsZXQgZnJhbWVidWZmZXIgPSBudWxsO1xyXG5cdFx0XHRsZXQgaXNDdWJlID0gZmFsc2U7XHJcblx0XHRcdGxldCBpc1JlbmRlclRhcmdldDNEID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fdXNlRGVmYXVsdEZyYW1lYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmViaW5kIHRoZSBmcmFtZWJ1ZmZlci5cclxuXHRcdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XHJcblx0XHRcdFx0XHR1c2VEZWZhdWx0RnJhbWVidWZmZXIgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIENvbG9yIGFuZCBkZXB0aCB0ZXh0dXJlIG11c3QgYmUgcmVib3VuZCBpbiBvcmRlciBmb3IgdGhlIHN3YXBjaGFpbiB0byB1cGRhdGUuXHJcblx0XHRcdFx0XHR0ZXh0dXJlcy5yZWJpbmRUZXh0dXJlcyggcmVuZGVyVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSB8fCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRpc1JlbmRlclRhcmdldDNEID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBfX3dlYmdsRnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlclsgYWN0aXZlQ3ViZUZhY2UgXTtcclxuXHRcdFx0XHRcdGlzQ3ViZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCApICYmIHRleHR1cmVzLnVzZU11bHRpc2FtcGxlZFJUVCggcmVuZGVyVGFyZ2V0ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRcdGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIHJlbmRlclRhcmdldC52aWV3cG9ydCApO1xyXG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xyXG5cdFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApLmZsb29yKCk7XHJcblx0XHRcdFx0X2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkuZmxvb3IoKTtcclxuXHRcdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlckJvdW5kICYmIGNhcGFiaWxpdGllcy5kcmF3QnVmZmVycyAmJiB1c2VEZWZhdWx0RnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmRyYXdCdWZmZXJzKCByZW5kZXJUYXJnZXQsIGZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydCApO1xyXG5cdFx0XHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IgKTtcclxuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9jdXJyZW50U2Npc3NvclRlc3QgKTtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBhY3RpdmVDdWJlRmFjZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIGFjdGl2ZU1pcG1hcExldmVsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBpc1JlbmRlclRhcmdldDNEICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cdFx0XHRcdGNvbnN0IGxheWVyID0gYWN0aXZlQ3ViZUZhY2UgfHwgMDtcclxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwgfHwgMCwgbGF5ZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTsgLy8gcmVzZXQgY3VycmVudCBtYXRlcmlhbCB0byBlbnN1cmUgY29ycmVjdCB1bmlmb3JtIGJpbmRpbmdzXHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyLCBhY3RpdmVDdWJlRmFjZUluZGV4ICkge1xyXG5cclxuXHRcdFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCAmJiBhY3RpdmVDdWJlRmFjZUluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXJbIGFjdGl2ZUN1YmVGYWNlSW5kZXggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcclxuXHRcdFx0XHRcdGNvbnN0IHRleHR1cmVUeXBlID0gdGV4dHVyZS50eXBlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZUZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlRm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LicgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCBoYWxmRmxvYXRTdXBwb3J0ZWRCeUV4dCA9ICggdGV4dHVyZVR5cGUgPT09IEhhbGZGbG9hdFR5cGUgKSAmJiAoIGV4dGVuc2lvbnMuaGFzKCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApIHx8ICggY2FwYWJpbGl0aWVzLmlzV2ViR0wyICYmIGV4dGVuc2lvbnMuaGFzKCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFICkgJiYgLy8gRWRnZSBhbmQgQ2hyb21lIE1hYyA8IDUyICgjOTUxMylcclxuXHRcdFx0XHRcdFx0ISAoIHRleHR1cmVUeXBlID09PSBGbG9hdFR5cGUgJiYgKCBjYXBhYmlsaXRpZXMuaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoICdPRVNfdGV4dHVyZV9mbG9hdCcgKSB8fCBleHRlbnNpb25zLmhhcyggJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApICkgJiYgLy8gQ2hyb21lIE1hYyA+PSA1MiBhbmQgRmlyZWZveFxyXG5cdFx0XHRcdFx0XHQhIGhhbGZGbG9hdFN1cHBvcnRlZEJ5RXh0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnQgZW5zdXJlcyB2YWxpZCByZWFkIHJlcXVlc3RzIChubyBvdXQtb2YtYm91bmRzIHBpeGVscywgc2VlICM4NjA0KVxyXG5cclxuXHRcdFx0XHRcdGlmICggKCB4ID49IDAgJiYgeCA8PSAoIHJlbmRlclRhcmdldC53aWR0aCAtIHdpZHRoICkgKSAmJiAoIHkgPj0gMCAmJiB5IDw9ICggcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCApICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApLCBidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZmluYWxseSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVzdG9yZSBmcmFtZWJ1ZmZlciBvZiBjdXJyZW50IHJlbmRlciB0YXJnZXQgaWYgbmVjZXNzYXJ5XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZnJhbWVidWZmZXIgPSAoIF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsICkgPyBwcm9wZXJ0aWVzLmdldCggX2N1cnJlbnRSZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXIgOiBudWxsO1xyXG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlID0gZnVuY3Rpb24gKCBwb3NpdGlvbiwgdGV4dHVyZSwgbGV2ZWwgPSAwICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbGV2ZWxTY2FsZSA9IE1hdGgucG93KCAyLCAtIGxldmVsICk7XHJcblx0XHRcdGNvbnN0IHdpZHRoID0gTWF0aC5mbG9vciggdGV4dHVyZS5pbWFnZS53aWR0aCAqIGxldmVsU2NhbGUgKTtcclxuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gTWF0aC5mbG9vciggdGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBsZXZlbFNjYWxlICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdF9nbC5jb3B5VGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVsLCAwLCAwLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlID0gZnVuY3Rpb24gKCBwb3NpdGlvbiwgc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgbGV2ZWwgPSAwICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBzcmNUZXh0dXJlLmltYWdlLndpZHRoO1xyXG5cdFx0XHRjb25zdCBoZWlnaHQgPSBzcmNUZXh0dXJlLmltYWdlLmhlaWdodDtcclxuXHRcdFx0Y29uc3QgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCBkc3RUZXh0dXJlLmZvcm1hdCApO1xyXG5cdFx0XHRjb25zdCBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCBkc3RUZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggZHN0VGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdFx0Ly8gQXMgYW5vdGhlciB0ZXh0dXJlIHVwbG9hZCBtYXkgaGF2ZSBjaGFuZ2VkIHBpeGVsU3RvcmVpXHJcblx0XHRcdC8vIHBhcmFtZXRlcnMsIG1ha2Ugc3VyZSB0aGV5IGFyZSBjb3JyZWN0IGZvciB0aGUgZHN0VGV4dHVyZVxyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBkc3RUZXh0dXJlLmZsaXBZICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIGRzdFRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XHJcblxyXG5cdFx0XHRpZiAoIHNyY1RleHR1cmUuaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0X2dsLnRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgc3JjVGV4dHVyZS5pbWFnZS5kYXRhICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBsZXZlbCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc3JjVGV4dHVyZS5taXBtYXBzWyAwIF0ud2lkdGgsIHNyY1RleHR1cmUubWlwbWFwc1sgMCBdLmhlaWdodCwgZ2xGb3JtYXQsIHNyY1RleHR1cmUubWlwbWFwc1sgMCBdLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBnbEZvcm1hdCwgZ2xUeXBlLCBzcmNUZXh0dXJlLmltYWdlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEdlbmVyYXRlIG1pcG1hcHMgb25seSB3aGVuIGNvcHlpbmcgbGV2ZWwgMFxyXG5cdFx0XHRpZiAoIGxldmVsID09PSAwICYmIGRzdFRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdFx0c3RhdGUudW5iaW5kVGV4dHVyZSgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEID0gZnVuY3Rpb24gKCBzb3VyY2VCb3gsIHBvc2l0aW9uLCBzcmNUZXh0dXJlLCBkc3RUZXh0dXJlLCBsZXZlbCA9IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIF90aGlzLmlzV2ViR0wxUmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMMi4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBzb3VyY2VCb3gubWF4LnggLSBzb3VyY2VCb3gubWluLnggKyAxO1xyXG5cdFx0XHRjb25zdCBoZWlnaHQgPSBzb3VyY2VCb3gubWF4LnkgLSBzb3VyY2VCb3gubWluLnkgKyAxO1xyXG5cdFx0XHRjb25zdCBkZXB0aCA9IHNvdXJjZUJveC5tYXgueiAtIHNvdXJjZUJveC5taW4ueiArIDE7XHJcblx0XHRcdGNvbnN0IGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggZHN0VGV4dHVyZS5mb3JtYXQgKTtcclxuXHRcdFx0Y29uc3QgZ2xUeXBlID0gdXRpbHMuY29udmVydCggZHN0VGV4dHVyZS50eXBlICk7XHJcblx0XHRcdGxldCBnbFRhcmdldDtcclxuXHJcblx0XHRcdGlmICggZHN0VGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUzRCggZHN0VGV4dHVyZSwgMCApO1xyXG5cdFx0XHRcdGdsVGFyZ2V0ID0gX2dsLlRFWFRVUkVfM0Q7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBkc3RUZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkoIGRzdFRleHR1cmUsIDAgKTtcclxuXHRcdFx0XHRnbFRhcmdldCA9IF9nbC5URVhUVVJFXzJEX0FSUkFZO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5jb3B5VGV4dHVyZVRvVGV4dHVyZTNEOiBvbmx5IHN1cHBvcnRzIFRIUkVFLkRhdGFUZXh0dXJlM0QgYW5kIFRIUkVFLkRhdGFUZXh0dXJlMkRBcnJheS4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZHN0VGV4dHVyZS5mbGlwWSApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGRzdFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cclxuXHRcdFx0Y29uc3QgdW5wYWNrUm93TGVuID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19ST1dfTEVOR1RIICk7XHJcblx0XHRcdGNvbnN0IHVucGFja0ltYWdlSGVpZ2h0ID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19JTUFHRV9IRUlHSFQgKTtcclxuXHRcdFx0Y29uc3QgdW5wYWNrU2tpcFBpeGVscyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMgKTtcclxuXHRcdFx0Y29uc3QgdW5wYWNrU2tpcFJvd3MgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuVU5QQUNLX1NLSVBfUk9XUyApO1xyXG5cdFx0XHRjb25zdCB1bnBhY2tTa2lwSW1hZ2VzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLlVOUEFDS19TS0lQX0lNQUdFUyApO1xyXG5cclxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPyBzcmNUZXh0dXJlLm1pcG1hcHNbIDAgXSA6IHNyY1RleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUk9XX0xFTkdUSCwgaW1hZ2Uud2lkdGggKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1BJWEVMUywgc291cmNlQm94Lm1pbi54ICk7XHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19TS0lQX1JPV1MsIHNvdXJjZUJveC5taW4ueSApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfU0tJUF9JTUFHRVMsIHNvdXJjZUJveC5taW4ueiApO1xyXG5cclxuXHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUgfHwgc3JjVGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhTdWJJbWFnZTNEKCBnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHNyY1RleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogdW50ZXN0ZWQgc3VwcG9ydCBmb3IgY29tcHJlc3NlZCBzcmNUZXh0dXJlLicgKTtcclxuXHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCggZ2xUYXJnZXQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudGV4U3ViSW1hZ2UzRCggZ2xUYXJnZXQsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1JPV19MRU5HVEgsIHVucGFja1Jvd0xlbiApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCB1bnBhY2tJbWFnZUhlaWdodCApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIHVucGFja1NraXBQaXhlbHMgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1NLSVBfUk9XUywgdW5wYWNrU2tpcFJvd3MgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1NLSVBfSU1BR0VTLCB1bnBhY2tTa2lwSW1hZ2VzICk7XHJcblxyXG5cdFx0XHQvLyBHZW5lcmF0ZSBtaXBtYXBzIG9ubHkgd2hlbiBjb3B5aW5nIGxldmVsIDBcclxuXHRcdFx0aWYgKCBsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyApIF9nbC5nZW5lcmF0ZU1pcG1hcCggZ2xUYXJnZXQgKTtcclxuXHJcblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuaW5pdFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNDdWJlVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlM0QoIHRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkRBcnJheSggdGV4dHVyZSwgMCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnJlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRfY3VycmVudEFjdGl2ZUN1YmVGYWNlID0gMDtcclxuXHRcdFx0X2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XHJcblx0XHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuXHJcblx0XHRcdHN0YXRlLnJlc2V0KCk7XHJcblx0XHRcdGJpbmRpbmdTdGF0ZXMucmVzZXQoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblxyXG5cdFx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCAnb2JzZXJ2ZScsIHsgZGV0YWlsOiB0aGlzIH0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXQgY29vcmRpbmF0ZVN5c3RlbSgpIHtcclxuXHJcblx0XHRyZXR1cm4gV2ViR0xDb29yZGluYXRlU3lzdGVtO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cygpIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNTBcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiB0aGUgcHJvcGVydHkgLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzIGhhcyBiZWVuIHJlbW92ZWQuIFNldCByZW5kZXJlci51c2VMZWdhY3lMaWdodHMgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gISB0aGlzLnVzZUxlZ2FjeUxpZ2h0cztcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgcGh5c2ljYWxseUNvcnJlY3RMaWdodHMoIHZhbHVlICkgeyAvLyBAZGVwcmVjYXRlZCwgcjE1MFxyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IHRoZSBwcm9wZXJ0eSAucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgaGFzIGJlZW4gcmVtb3ZlZC4gU2V0IHJlbmRlcmVyLnVzZUxlZ2FjeUxpZ2h0cyBpbnN0ZWFkLicgKTtcclxuXHRcdHRoaXMudXNlTGVnYWN5TGlnaHRzID0gISB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgb3V0cHV0RW5jb2RpbmcoKSB7IC8vIEBkZXByZWNhdGVkLCByMTUyXHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogUHJvcGVydHkgLm91dHB1dEVuY29kaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAub3V0cHV0Q29sb3JTcGFjZSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB0aGlzLm91dHB1dENvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlID8gc1JHQkVuY29kaW5nIDogTGluZWFyRW5jb2Rpbmc7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IG91dHB1dEVuY29kaW5nKCBlbmNvZGluZyApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNTJcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBQcm9wZXJ0eSAub3V0cHV0RW5jb2RpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5vdXRwdXRDb2xvclNwYWNlIGluc3RlYWQuJyApO1xyXG5cdFx0dGhpcy5vdXRwdXRDb2xvclNwYWNlID0gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXZWJHTFJlbmRlcmVyIH07XHJcbiIsImltcG9ydCB7IFdlYkdMUmVuZGVyZXIgfSBmcm9tICcuL1dlYkdMUmVuZGVyZXIuanMnO1xyXG5cclxuY2xhc3MgV2ViR0wxUmVuZGVyZXIgZXh0ZW5kcyBXZWJHTFJlbmRlcmVyIHt9XHJcblxyXG5XZWJHTDFSZW5kZXJlci5wcm90b3R5cGUuaXNXZWJHTDFSZW5kZXJlciA9IHRydWU7XHJcblxyXG5leHBvcnQgeyBXZWJHTDFSZW5kZXJlciB9O1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgRm9nRXhwMiB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgZGVuc2l0eSA9IDAuMDAwMjUgKSB7XHJcblxyXG5cdFx0dGhpcy5pc0ZvZ0V4cDIgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XHJcblx0XHR0aGlzLmRlbnNpdHkgPSBkZW5zaXR5O1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgRm9nRXhwMiggdGhpcy5jb2xvciwgdGhpcy5kZW5zaXR5ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCAvKiBtZXRhICovICkge1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGb2dFeHAyJyxcclxuXHRcdFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXHJcblx0XHRcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgRm9nRXhwMiB9O1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgRm9nIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGNvbG9yLCBuZWFyID0gMSwgZmFyID0gMTAwMCApIHtcclxuXHJcblx0XHR0aGlzLmlzRm9nID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xyXG5cclxuXHRcdHRoaXMubmVhciA9IG5lYXI7XHJcblx0XHR0aGlzLmZhciA9IGZhcjtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEZvZyggdGhpcy5jb2xvciwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggLyogbWV0YSAqLyApIHtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0eXBlOiAnRm9nJyxcclxuXHRcdFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXHJcblx0XHRcdG5lYXI6IHRoaXMubmVhcixcclxuXHRcdFx0ZmFyOiB0aGlzLmZhclxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgRm9nIH07XHJcbiIsImltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcblxyXG5jbGFzcyBTY2VuZSBleHRlbmRzIE9iamVjdDNEIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzU2NlbmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTY2VuZSc7XHJcblxyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcclxuXHRcdHRoaXMuZW52aXJvbm1lbnQgPSBudWxsO1xyXG5cdFx0dGhpcy5mb2cgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSAwO1xyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gMTtcclxuXHJcblx0XHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHRcdGlmICggdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblxyXG5cdFx0XHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCAnb2JzZXJ2ZScsIHsgZGV0YWlsOiB0aGlzIH0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdGlmICggc291cmNlLmJhY2tncm91bmQgIT09IG51bGwgKSB0aGlzLmJhY2tncm91bmQgPSBzb3VyY2UuYmFja2dyb3VuZC5jbG9uZSgpO1xyXG5cdFx0aWYgKCBzb3VyY2UuZW52aXJvbm1lbnQgIT09IG51bGwgKSB0aGlzLmVudmlyb25tZW50ID0gc291cmNlLmVudmlyb25tZW50LmNsb25lKCk7XHJcblx0XHRpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcclxuXHJcblx0XHR0aGlzLmJhY2tncm91bmRCbHVycmluZXNzID0gc291cmNlLmJhY2tncm91bmRCbHVycmluZXNzO1xyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gc291cmNlLmJhY2tncm91bmRJbnRlbnNpdHk7XHJcblxyXG5cdFx0aWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuZm9nICE9PSBudWxsICkgZGF0YS5vYmplY3QuZm9nID0gdGhpcy5mb2cudG9KU09OKCk7XHJcblx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwICkgZGF0YS5vYmplY3QuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSB0aGlzLmJhY2tncm91bmRCbHVycmluZXNzO1xyXG5cdFx0aWYgKCB0aGlzLmJhY2tncm91bmRJbnRlbnNpdHkgIT09IDEgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gdGhpcy5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTY2VuZSB9O1xyXG4iLCJpbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgSW50ZXJsZWF2ZWRCdWZmZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXJyYXksIHN0cmlkZSApIHtcclxuXHJcblx0XHR0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXIgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcclxuXHRcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xyXG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xyXG5cclxuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XHJcblx0XHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcclxuXHJcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0fVxyXG5cclxuXHRvblVwbG9hZENhbGxiYWNrKCkge31cclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFVzYWdlKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnVzYWdlID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcclxuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XHJcblx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XHJcblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRpbmRleDEgKj0gdGhpcy5zdHJpZGU7XHJcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCB2YWx1ZSwgb2Zmc2V0ID0gMCApIHtcclxuXHJcblx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCBkYXRhICkge1xyXG5cclxuXHRcdGlmICggZGF0YS5hcnJheUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRkYXRhLmFycmF5QnVmZmVyc1sgdGhpcy5hcnJheS5idWZmZXIuX3V1aWQgXSA9IHRoaXMuYXJyYXkuc2xpY2UoIDAgKS5idWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGFycmF5ID0gbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIGRhdGEuYXJyYXlCdWZmZXJzWyB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCBdICk7XHJcblxyXG5cdFx0Y29uc3QgaWIgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvciggYXJyYXksIHRoaXMuc3RyaWRlICk7XHJcblx0XHRpYi5zZXRVc2FnZSggdGhpcy51c2FnZSApO1xyXG5cclxuXHRcdHJldHVybiBpYjtcclxuXHJcblx0fVxyXG5cclxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBkYXRhICkge1xyXG5cclxuXHRcdGlmICggZGF0YS5hcnJheUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGRhdGEuYXJyYXlCdWZmZXJzID0ge307XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdlbmVyYXRlIFVVSUQgZm9yIGFycmF5IGJ1ZmZlciBpZiBuZWNlc3NhcnlcclxuXHJcblx0XHRpZiAoIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCA9IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkYXRhLmFycmF5QnVmZmVyc1sgdGhpcy5hcnJheS5idWZmZXIuX3V1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZGF0YS5hcnJheUJ1ZmZlcnNbIHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkIF0gPSBBcnJheS5mcm9tKCBuZXcgVWludDMyQXJyYXkoIHRoaXMuYXJyYXkuYnVmZmVyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXHJcblx0XHRcdGJ1ZmZlcjogdGhpcy5hcnJheS5idWZmZXIuX3V1aWQsXHJcblx0XHRcdHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcclxuXHRcdFx0c3RyaWRlOiB0aGlzLnN0cmlkZVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXIgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgZGVub3JtYWxpemUsIG5vcm1hbGl6ZSB9IGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuXHJcbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jbGFzcyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCwgbm9ybWFsaXplZCA9IGZhbHNlICkge1xyXG5cclxuXHRcdHRoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdFx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XHJcblx0XHR0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuXHJcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBjb3VudCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBhcnJheSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5kYXRhLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXg0KCBtICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuZGF0YS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRoaXMsIGkgKTtcclxuXHJcblx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXg0KCBtICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldFhZWiggaSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3IueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xyXG5cclxuXHRcdFx0X3ZlY3Rvci5hcHBseU5vcm1hbE1hdHJpeCggbSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dHJhbnNmb3JtRGlyZWN0aW9uKCBtICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XHJcblxyXG5cdFx0XHRfdmVjdG9yLnRyYW5zZm9ybURpcmVjdGlvbiggbSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WCggaW5kZXgsIHggKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRZKCBpbmRleCwgeSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRaKCBpbmRleCwgeiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRXKCBpbmRleCwgdyApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRYKCBpbmRleCApIHtcclxuXHJcblx0XHRsZXQgeCA9IHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBkZW5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB4O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFkoIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB5ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBkZW5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB5O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFooIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB6ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHogPSBkZW5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB6O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFcoIGluZGV4ICkge1xyXG5cclxuXHRcdGxldCB3ID0gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBkZW5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xyXG5cclxuXHRcdHJldHVybiB3O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0WFlaKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XHJcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFhZWlcoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XHJcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcclxuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xyXG5cdFx0XHR3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCBkYXRhICkge1xyXG5cclxuXHRcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5jbG9uZSgpOiBDbG9uaW5nIGFuIGludGVybGVhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZS1pbnRlcmxlYXZlIGJ1ZmZlciBkYXRhLicgKTtcclxuXHJcblx0XHRcdGNvbnN0IGFycmF5ID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIGogXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIGFycmF5ICksIHRoaXMuaXRlbVNpemUsIHRoaXMubm9ybWFsaXplZCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID0ge307XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdID0gdGhpcy5kYXRhLmNsb25lKCBkYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBkYXRhLmludGVybGVhdmVkQnVmZmVyc1sgdGhpcy5kYXRhLnV1aWQgXSwgdGhpcy5pdGVtU2l6ZSwgdGhpcy5vZmZzZXQsIHRoaXMubm9ybWFsaXplZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnRvSlNPTigpOiBTZXJpYWxpemluZyBhbiBpbnRlcmxlYXZlZCBidWZmZXIgYXR0cmlidXRlIHdpbGwgZGUtaW50ZXJsZWF2ZSBidWZmZXIgZGF0YS4nICk7XHJcblxyXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCB0aGlzLml0ZW1TaXplOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyBqIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGUtaW50ZXJsZWF2ZSBkYXRhIGFuZCBzYXZlIGl0IGFzIGFuIG9yZGluYXJ5IGJ1ZmZlciBhdHRyaWJ1dGUgZm9yIG5vd1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcclxuXHRcdFx0XHR0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0YXJyYXk6IGFycmF5LFxyXG5cdFx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBzYXZlIGFzIHRydWUgaW50ZXJsZWF2ZWQgYXR0cmlidXRlXHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID0ge307XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzWyB0aGlzLmRhdGEudXVpZCBdID0gdGhpcy5kYXRhLnRvSlNPTiggZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxyXG5cdFx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxyXG5cdFx0XHRcdGRhdGE6IHRoaXMuZGF0YS51dWlkLFxyXG5cdFx0XHRcdG9mZnNldDogdGhpcy5vZmZzZXQsXHJcblx0XHRcdFx0bm9ybWFsaXplZDogdGhpcy5ub3JtYWxpemVkXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfTtcclxuIiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbmNsYXNzIFNwcml0ZU1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNTcHJpdGVNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcclxuXHJcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTcHJpdGVNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvVHJpYW5nbGUuanMnO1xyXG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlciB9IGZyb20gJy4uL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xyXG5pbXBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBTcHJpdGVNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9TcHJpdGVNYXRlcmlhbC5qcyc7XHJcblxyXG5sZXQgX2dlb21ldHJ5O1xyXG5cclxuY29uc3QgX2ludGVyc2VjdFBvaW50ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfd29ybGRTY2FsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX212UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jb25zdCBfYWxpZ25lZFBvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xyXG5jb25zdCBfcm90YXRlZFBvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xyXG5jb25zdCBfdmlld1dvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5cclxuY29uc3QgX3ZBID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfdkIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF92QyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNvbnN0IF91dkEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcbmNvbnN0IF91dkIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcbmNvbnN0IF91dkMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcblxyXG5jbGFzcyBTcHJpdGUgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNTcHJpdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xyXG5cclxuXHRcdGlmICggX2dlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHRcdGNvbnN0IGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdFx0XHQtIDAuNSwgLSAwLjUsIDAsIDAsIDAsXHJcblx0XHRcdFx0MC41LCAtIDAuNSwgMCwgMSwgMCxcclxuXHRcdFx0XHQwLjUsIDAuNSwgMCwgMSwgMSxcclxuXHRcdFx0XHQtIDAuNSwgMC41LCAwLCAwLCAxXHJcblx0XHRcdF0gKTtcclxuXHJcblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gbmV3IEludGVybGVhdmVkQnVmZmVyKCBmbG9hdDMyQXJyYXksIDUgKTtcclxuXHJcblx0XHRcdF9nZW9tZXRyeS5zZXRJbmRleCggWyAwLCAxLCAyLFx0MCwgMiwgMyBdICk7XHJcblx0XHRcdF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIDMsIDAsIGZhbHNlICkgKTtcclxuXHRcdFx0X2dlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKCBpbnRlcmxlYXZlZEJ1ZmZlciwgMiwgMywgZmFsc2UgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gX2dlb21ldHJ5O1xyXG5cdFx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKCAwLjUsIDAuNSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRpZiAoIHJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3ByaXRlOiBcIlJheWNhc3Rlci5jYW1lcmFcIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfd29ybGRTY2FsZS5zZXRGcm9tTWF0cml4U2NhbGUoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfdmlld1dvcmxkTWF0cml4LmNvcHkoIHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdHRoaXMubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0X212UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1vZGVsVmlld01hdHJpeCApO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLmNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICYmIHRoaXMubWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdF93b3JsZFNjYWxlLm11bHRpcGx5U2NhbGFyKCAtIF9tdlBvc2l0aW9uLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgcm90YXRpb24gPSB0aGlzLm1hdGVyaWFsLnJvdGF0aW9uO1xyXG5cdFx0bGV0IHNpbiwgY29zO1xyXG5cclxuXHRcdGlmICggcm90YXRpb24gIT09IDAgKSB7XHJcblxyXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyggcm90YXRpb24gKTtcclxuXHRcdFx0c2luID0gTWF0aC5zaW4oIHJvdGF0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNlbnRlciA9IHRoaXMuY2VudGVyO1xyXG5cclxuXHRcdHRyYW5zZm9ybVZlcnRleCggX3ZBLnNldCggLSAwLjUsIC0gMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xyXG5cdFx0dHJhbnNmb3JtVmVydGV4KCBfdkIuc2V0KCAwLjUsIC0gMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xyXG5cdFx0dHJhbnNmb3JtVmVydGV4KCBfdkMuc2V0KCAwLjUsIDAuNSwgMCApLCBfbXZQb3NpdGlvbiwgY2VudGVyLCBfd29ybGRTY2FsZSwgc2luLCBjb3MgKTtcclxuXHJcblx0XHRfdXZBLnNldCggMCwgMCApO1xyXG5cdFx0X3V2Qi5zZXQoIDEsIDAgKTtcclxuXHRcdF91dkMuc2V0KCAxLCAxICk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgZmlyc3QgdHJpYW5nbGVcclxuXHRcdGxldCBpbnRlcnNlY3QgPSByYXljYXN0ZXIucmF5LmludGVyc2VjdFRyaWFuZ2xlKCBfdkEsIF92QiwgX3ZDLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50ICk7XHJcblxyXG5cdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBzZWNvbmQgdHJpYW5nbGVcclxuXHRcdFx0dHJhbnNmb3JtVmVydGV4KCBfdkIuc2V0KCAtIDAuNSwgMC41LCAwICksIF9tdlBvc2l0aW9uLCBjZW50ZXIsIF93b3JsZFNjYWxlLCBzaW4sIGNvcyApO1xyXG5cdFx0XHRfdXZCLnNldCggMCwgMSApO1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0ID0gcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RUcmlhbmdsZSggX3ZBLCBfdkMsIF92QiwgZmFsc2UsIF9pbnRlcnNlY3RQb2ludCApO1xyXG5cdFx0XHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIF9pbnRlcnNlY3RQb2ludCApO1xyXG5cclxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdHBvaW50OiBfaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0dXY6IFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3RQb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSApLFxyXG5cdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRpZiAoIHNvdXJjZS5jZW50ZXIgIT09IHVuZGVmaW5lZCApIHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1WZXJ0ZXgoIHZlcnRleFBvc2l0aW9uLCBtdlBvc2l0aW9uLCBjZW50ZXIsIHNjYWxlLCBzaW4sIGNvcyApIHtcclxuXHJcblx0Ly8gY29tcHV0ZSBwb3NpdGlvbiBpbiBjYW1lcmEgc3BhY2VcclxuXHRfYWxpZ25lZFBvc2l0aW9uLnN1YlZlY3RvcnMoIHZlcnRleFBvc2l0aW9uLCBjZW50ZXIgKS5hZGRTY2FsYXIoIDAuNSApLm11bHRpcGx5KCBzY2FsZSApO1xyXG5cclxuXHQvLyB0byBjaGVjayBpZiByb3RhdGlvbiBpcyBub3QgemVyb1xyXG5cdGlmICggc2luICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0X3JvdGF0ZWRQb3NpdGlvbi54ID0gKCBjb3MgKiBfYWxpZ25lZFBvc2l0aW9uLnggKSAtICggc2luICogX2FsaWduZWRQb3NpdGlvbi55ICk7XHJcblx0XHRfcm90YXRlZFBvc2l0aW9uLnkgPSAoIHNpbiAqIF9hbGlnbmVkUG9zaXRpb24ueCApICsgKCBjb3MgKiBfYWxpZ25lZFBvc2l0aW9uLnkgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRfcm90YXRlZFBvc2l0aW9uLmNvcHkoIF9hbGlnbmVkUG9zaXRpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0dmVydGV4UG9zaXRpb24uY29weSggbXZQb3NpdGlvbiApO1xyXG5cdHZlcnRleFBvc2l0aW9uLnggKz0gX3JvdGF0ZWRQb3NpdGlvbi54O1xyXG5cdHZlcnRleFBvc2l0aW9uLnkgKz0gX3JvdGF0ZWRQb3NpdGlvbi55O1xyXG5cclxuXHQvLyB0cmFuc2Zvcm0gdG8gd29ybGQgc3BhY2VcclxuXHR2ZXJ0ZXhQb3NpdGlvbi5hcHBseU1hdHJpeDQoIF92aWV3V29ybGRNYXRyaXggKTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNwcml0ZSB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuXHJcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY2xhc3MgTE9EIGV4dGVuZHMgT2JqZWN0M0Qge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRMZXZlbCA9IDA7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xPRCc7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcclxuXHRcdFx0bGV2ZWxzOiB7XHJcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0XHR2YWx1ZTogW11cclxuXHRcdFx0fSxcclxuXHRcdFx0aXNMT0Q6IHtcclxuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgZmFsc2UgKTtcclxuXHJcblx0XHRjb25zdCBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSwgbGV2ZWwuaHlzdGVyZXNpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhZGRMZXZlbCggb2JqZWN0LCBkaXN0YW5jZSA9IDAsIGh5c3RlcmVzaXMgPSAwICkge1xyXG5cclxuXHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0bGV0IGw7XHJcblxyXG5cdFx0Zm9yICggbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgbCBdLmRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV2ZWxzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIGh5c3RlcmVzaXM6IGh5c3RlcmVzaXMsIG9iamVjdDogb2JqZWN0IH0gKTtcclxuXHJcblx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q3VycmVudExldmVsKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50TGV2ZWw7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cclxuXHRnZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGxldCBpLCBsO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bGV0IGxldmVsRGlzdGFuY2UgPSBsZXZlbHNbIGkgXS5kaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0aWYgKCBsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSApIHtcclxuXHJcblx0XHRcdFx0XHRsZXZlbERpc3RhbmNlIC09IGxldmVsRGlzdGFuY2UgKiBsZXZlbHNbIGkgXS5oeXN0ZXJlc2lzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbERpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuXHRcdGlmICggbGV2ZWxzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRfdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIF92MSApO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdF92MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRfdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRjb25zdCBkaXN0YW5jZSA9IF92MS5kaXN0YW5jZVRvKCBfdjIgKSAvIGNhbWVyYS56b29tO1xyXG5cclxuXHRcdFx0bGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0bGV0IGksIGw7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRsZXQgbGV2ZWxEaXN0YW5jZSA9IGxldmVsc1sgaSBdLmRpc3RhbmNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRcdGxldmVsRGlzdGFuY2UgLT0gbGV2ZWxEaXN0YW5jZSAqIGxldmVsc1sgaSBdLmh5c3RlcmVzaXM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA+PSBsZXZlbERpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9jdXJyZW50TGV2ZWwgPSBpIC0gMTtcclxuXHJcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggbWV0YSApIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9VcGRhdGUgPT09IGZhbHNlICkgZGF0YS5vYmplY3QuYXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcclxuXHJcblx0XHRcdGRhdGEub2JqZWN0LmxldmVscy5wdXNoKCB7XHJcblx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcclxuXHRcdFx0XHRkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2UsXHJcblx0XHRcdFx0aHlzdGVyZXNpczogbGV2ZWwuaHlzdGVyZXNpc1xyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgTE9EIH07XHJcbiIsImltcG9ydCB7IE1lc2ggfSBmcm9tICcuL01lc2guanMnO1xyXG5pbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5pbXBvcnQgeyBSYXkgfSBmcm9tICcuLi9tYXRoL1JheS5qcyc7XHJcblxyXG5jb25zdCBfYmFzZVBvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcclxuY29uc3QgX3NraW5XZWlnaHQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3I0KCk7XHJcblxyXG5jb25zdCBfdmVjdG9yMyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX21hdHJpeDQgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF92ZXJ0ZXggPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jb25zdCBfc3BoZXJlID0gLypAX19QVVJFX18qLyBuZXcgU3BoZXJlKCk7XHJcbmNvbnN0IF9pbnZlcnNlTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfcmF5ID0gLypAX19QVVJFX18qLyBuZXcgUmF5KCk7XHJcblxyXG5jbGFzcyBTa2lubmVkTWVzaCBleHRlbmRzIE1lc2gge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLmlzU2tpbm5lZE1lc2ggPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XHJcblxyXG5cdFx0dGhpcy5iaW5kTW9kZSA9ICdhdHRhY2hlZCc7XHJcblx0XHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRfdmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XHJcblx0XHRcdHRoaXMuYXBwbHlCb25lVHJhbnNmb3JtKCBpLCBfdmVydGV4ICk7XHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX3ZlcnRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdF92ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKTtcclxuXHRcdFx0dGhpcy5hcHBseUJvbmVUcmFuc2Zvcm0oIGksIF92ZXJ0ZXggKTtcclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5leHBhbmRCeVBvaW50KCBfdmVydGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0dGhpcy5iaW5kTW9kZSA9IHNvdXJjZS5iaW5kTW9kZTtcclxuXHRcdHRoaXMuYmluZE1hdHJpeC5jb3B5KCBzb3VyY2UuYmluZE1hdHJpeCApO1xyXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCBzb3VyY2UuYmluZE1hdHJpeEludmVyc2UgKTtcclxuXHJcblx0XHR0aGlzLnNrZWxldG9uID0gc291cmNlLnNrZWxldG9uO1xyXG5cclxuXHRcdGlmICggc291cmNlLmJvdW5kaW5nQm94ICE9PSBudWxsICkgdGhpcy5ib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveC5jbG9uZSgpO1xyXG5cdFx0aWYgKCBzb3VyY2UuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB0aGlzLmJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIHNwaGVyZSBpbiB3b3JsZCBzcGFjZVxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0X3NwaGVyZS5jb3B5KCB0aGlzLmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHQvLyBjb252ZXJ0IHJheSB0byBsb2NhbCBzcGFjZSBvZiBza2lubmVkIG1lc2hcclxuXHJcblx0XHRfaW52ZXJzZU1hdHJpeC5jb3B5KCBtYXRyaXhXb3JsZCApLmludmVydCgpO1xyXG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBfaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdC8vIHRlc3Qgd2l0aCBib3VuZGluZyBib3ggaW4gbG9jYWwgc3BhY2VcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIF9yYXkuaW50ZXJzZWN0c0JveCggdGhpcy5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGVzdCBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbnMoIHJheWNhc3RlciwgaW50ZXJzZWN0cywgX3JheSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFZlcnRleFBvc2l0aW9uKCBpbmRleCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdHN1cGVyLmdldFZlcnRleFBvc2l0aW9uKCBpbmRleCwgdGFyZ2V0ICk7XHJcblxyXG5cdFx0dGhpcy5hcHBseUJvbmVUcmFuc2Zvcm0oIGluZGV4LCB0YXJnZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cclxuXHR9XHJcblxyXG5cdGJpbmQoIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xyXG5cclxuXHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcclxuXHJcblx0XHRpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcblx0XHRcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xyXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCBiaW5kTWF0cml4ICkuaW52ZXJ0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0cG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcclxuXHJcblx0fVxyXG5cclxuXHRub3JtYWxpemVTa2luV2VpZ2h0cygpIHtcclxuXHJcblx0XHRjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdGNvbnN0IHNraW5XZWlnaHQgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBza2luV2VpZ2h0LmNvdW50OyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBza2luV2VpZ2h0LCBpICk7XHJcblxyXG5cdFx0XHRjb25zdCBzY2FsZSA9IDEuMCAvIHZlY3Rvci5tYW5oYXR0YW5MZW5ndGgoKTtcclxuXHJcblx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xyXG5cclxuXHRcdFx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2ZWN0b3Iuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRza2luV2VpZ2h0LnNldFhZWlcoIGksIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnosIHZlY3Rvci53ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYmluZE1vZGUgPT09ICdhdHRhY2hlZCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSAnZGV0YWNoZWQnICkge1xyXG5cclxuXHRcdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLmJpbmRNYXRyaXggKS5pbnZlcnQoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2g6IFVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlCb25lVHJhbnNmb3JtKCBpbmRleCwgdmVjdG9yICkge1xyXG5cclxuXHRcdGNvbnN0IHNrZWxldG9uID0gdGhpcy5za2VsZXRvbjtcclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0XHRfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbkluZGV4LCBpbmRleCApO1xyXG5cdFx0X3NraW5XZWlnaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0LCBpbmRleCApO1xyXG5cclxuXHRcdF9iYXNlUG9zaXRpb24uY29weSggdmVjdG9yICkuYXBwbHlNYXRyaXg0KCB0aGlzLmJpbmRNYXRyaXggKTtcclxuXHJcblx0XHR2ZWN0b3Iuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHdlaWdodCA9IF9za2luV2VpZ2h0LmdldENvbXBvbmVudCggaSApO1xyXG5cclxuXHRcdFx0aWYgKCB3ZWlnaHQgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJvbmVJbmRleCA9IF9za2luSW5kZXguZ2V0Q29tcG9uZW50KCBpICk7XHJcblxyXG5cdFx0XHRcdF9tYXRyaXg0Lm11bHRpcGx5TWF0cmljZXMoIHNrZWxldG9uLmJvbmVzWyBib25lSW5kZXggXS5tYXRyaXhXb3JsZCwgc2tlbGV0b24uYm9uZUludmVyc2VzWyBib25lSW5kZXggXSApO1xyXG5cclxuXHRcdFx0XHR2ZWN0b3IuYWRkU2NhbGVkVmVjdG9yKCBfdmVjdG9yMy5jb3B5KCBfYmFzZVBvc2l0aW9uICkuYXBwbHlNYXRyaXg0KCBfbWF0cml4NCApLCB3ZWlnaHQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMuYmluZE1hdHJpeEludmVyc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRib25lVHJhbnNmb3JtKCBpbmRleCwgdmVjdG9yICkgeyAvLyBAZGVwcmVjYXRlZCwgcjE1MVxyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNraW5uZWRNZXNoOiAuYm9uZVRyYW5zZm9ybSgpIHdhcyByZW5hbWVkIHRvIC5hcHBseUJvbmVUcmFuc2Zvcm0oKSBpbiByMTUxLicgKTtcclxuXHRcdHJldHVybiB0aGlzLmFwcGx5Qm9uZVRyYW5zZm9ybSggaW5kZXgsIHZlY3RvciApO1xyXG5cclxuXHR9XHJcblxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgU2tpbm5lZE1lc2ggfTtcclxuIiwiaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuXHJcbmNsYXNzIEJvbmUgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0JvbmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdCb25lJztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQm9uZSB9O1xyXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi9UZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgTmVhcmVzdEZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBEYXRhVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZGF0YSA9IG51bGwsIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXIsIG1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXIsIGFuaXNvdHJvcHksIGNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgY29sb3JTcGFjZSApO1xyXG5cclxuXHRcdHRoaXMuaXNEYXRhVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IERhdGFUZXh0dXJlIH07XHJcbiIsImltcG9ydCB7XHJcblx0UkdCQUZvcm1hdCxcclxuXHRGbG9hdFR5cGVcclxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBCb25lIH0gZnJvbSAnLi9Cb25lLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xyXG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5cclxuY29uc3QgX29mZnNldE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcclxuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5cclxuY2xhc3MgU2tlbGV0b24ge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYm9uZXMgPSBbXSwgYm9uZUludmVyc2VzID0gW10gKSB7XHJcblxyXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMuYm9uZXMgPSBib25lcy5zbGljZSggMCApO1xyXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXM7XHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5ib25lVGV4dHVyZSA9IG51bGw7XHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlU2l6ZSA9IDA7XHJcblxyXG5cdFx0dGhpcy5pbml0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0aW5pdCgpIHtcclxuXHJcblx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XHJcblx0XHRjb25zdCBib25lSW52ZXJzZXMgPSB0aGlzLmJvbmVJbnZlcnNlcztcclxuXHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGJvbmVzLmxlbmd0aCAqIDE2ICk7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIGludmVyc2UgYm9uZSBtYXRyaWNlcyBpZiBuZWNlc3NhcnlcclxuXHJcblx0XHRpZiAoIGJvbmVJbnZlcnNlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2VcclxuXHJcblx0XHRcdGlmICggYm9uZXMubGVuZ3RoICE9PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogTnVtYmVyIG9mIGludmVyc2UgYm9uZSBtYXRyaWNlcyBkb2VzIG5vdCBtYXRjaCBhbW91bnQgb2YgYm9uZXMuJyApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y2FsY3VsYXRlSW52ZXJzZXMoKSB7XHJcblxyXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMubGVuZ3RoID0gMDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvbmVzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdGludmVyc2UuY29weSggdGhpcy5ib25lc1sgaSBdLm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHBvc2UoKSB7XHJcblxyXG5cdFx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBib25lID0gdGhpcy5ib25lc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBib25lICkge1xyXG5cclxuXHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMuYm9uZUludmVyc2VzWyBpIF0gKS5pbnZlcnQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xyXG5cclxuXHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICkuaW52ZXJ0KCk7XHJcblx0XHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0Y29uc3QgYm9uZXMgPSB0aGlzLmJvbmVzO1xyXG5cdFx0Y29uc3QgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XHJcblx0XHRjb25zdCBib25lTWF0cmljZXMgPSB0aGlzLmJvbmVNYXRyaWNlcztcclxuXHRcdGNvbnN0IGJvbmVUZXh0dXJlID0gdGhpcy5ib25lVGV4dHVyZTtcclxuXHJcblx0XHQvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxyXG5cclxuXHRcdFx0Y29uc3QgbWF0cml4ID0gYm9uZXNbIGkgXSA/IGJvbmVzWyBpIF0ubWF0cml4V29ybGQgOiBfaWRlbnRpdHlNYXRyaXg7XHJcblxyXG5cdFx0XHRfb2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgYm9uZUludmVyc2VzWyBpIF0gKTtcclxuXHRcdFx0X29mZnNldE1hdHJpeC50b0FycmF5KCBib25lTWF0cmljZXMsIGkgKiAxNiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJvbmVUZXh0dXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Ym9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbXB1dGVCb25lVGV4dHVyZSgpIHtcclxuXHJcblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXHJcblx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXHJcblx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxyXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXHJcblx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcclxuXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxyXG5cclxuXHRcdGxldCBzaXplID0gTWF0aC5zcXJ0KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxyXG5cdFx0c2l6ZSA9IE1hdGhVdGlscy5jZWlsUG93ZXJPZlR3byggc2l6ZSApO1xyXG5cdFx0c2l6ZSA9IE1hdGgubWF4KCBzaXplLCA0ICk7XHJcblxyXG5cdFx0Y29uc3QgYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggc2l6ZSAqIHNpemUgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXHJcblx0XHRib25lTWF0cmljZXMuc2V0KCB0aGlzLmJvbmVNYXRyaWNlcyApOyAvLyBjb3B5IGN1cnJlbnQgdmFsdWVzXHJcblxyXG5cdFx0Y29uc3QgYm9uZVRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIGJvbmVNYXRyaWNlcywgc2l6ZSwgc2l6ZSwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlICk7XHJcblx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5ib25lTWF0cmljZXMgPSBib25lTWF0cmljZXM7XHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlU2l6ZSA9IHNpemU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Qm9uZUJ5TmFtZSggbmFtZSApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUubmFtZSA9PT0gbmFtZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJvbmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSggKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvbmVUZXh0dXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCk7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24sIGJvbmVzICkge1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmJvbmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1dWlkID0ganNvbi5ib25lc1sgaSBdO1xyXG5cdFx0XHRsZXQgYm9uZSA9IGJvbmVzWyB1dWlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b246IE5vIGJvbmUgZm91bmQgd2l0aCBVVUlEOicsIHV1aWQgKTtcclxuXHRcdFx0XHRib25lID0gbmV3IEJvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYm9uZXMucHVzaCggYm9uZSApO1xyXG5cdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpLmZyb21BcnJheSgganNvbi5ib25lSW52ZXJzZXNbIGkgXSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaW5pdCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNixcclxuXHRcdFx0XHR0eXBlOiAnU2tlbGV0b24nLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ1NrZWxldG9uLnRvSlNPTidcclxuXHRcdFx0fSxcclxuXHRcdFx0Ym9uZXM6IFtdLFxyXG5cdFx0XHRib25lSW52ZXJzZXM6IFtdXHJcblx0XHR9O1xyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHJcblx0XHRjb25zdCBib25lcyA9IHRoaXMuYm9uZXM7XHJcblx0XHRjb25zdCBib25lSW52ZXJzZXMgPSB0aGlzLmJvbmVJbnZlcnNlcztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBib25lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYm9uZSA9IGJvbmVzWyBpIF07XHJcblx0XHRcdGRhdGEuYm9uZXMucHVzaCggYm9uZS51dWlkICk7XHJcblxyXG5cdFx0XHRjb25zdCBib25lSW52ZXJzZSA9IGJvbmVJbnZlcnNlc1sgaSBdO1xyXG5cdFx0XHRkYXRhLmJvbmVJbnZlcnNlcy5wdXNoKCBib25lSW52ZXJzZS50b0FycmF5KCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNrZWxldG9uIH07XHJcbiIsImltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlLmpzJztcclxuXHJcbmNsYXNzIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQsIG1lc2hQZXJBdHRyaWJ1dGUgPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0XHR0aGlzLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGRhdGEubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0XHRkYXRhLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIH07XHJcbiIsImltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4vTWVzaC5qcyc7XHJcbmltcG9ydCB7IEJveDMgfSBmcm9tICcuLi9tYXRoL0JveDMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi4vbWF0aC9TcGhlcmUuanMnO1xyXG5cclxuY29uc3QgX2luc3RhbmNlTG9jYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF9pbnN0YW5jZVdvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5cclxuY29uc3QgX2luc3RhbmNlSW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuY29uc3QgX2JveDMgPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XHJcbmNvbnN0IF9pZGVudGl0eSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcclxuY29uc3QgX21lc2ggPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoKCk7XHJcbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcclxuXHJcbmNsYXNzIEluc3RhbmNlZE1lc2ggZXh0ZW5kcyBNZXNoIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5LCBtYXRlcmlhbCwgY291bnQgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdHRoaXMuaXNJbnN0YW5jZWRNZXNoID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggY291bnQgKiAxNiApLCAxNiApO1xyXG5cdFx0dGhpcy5pbnN0YW5jZUNvbG9yID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0TWF0cml4QXQoIGksIF9pZGVudGl0eSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3goKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0Y29uc3QgY291bnQgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldE1hdHJpeEF0KCBpLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xyXG5cclxuXHRcdFx0X2JveDMuY29weSggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKS5hcHBseU1hdHJpeDQoIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94LnVuaW9uKCBfYm94MyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0Y29uc3QgY291bnQgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XHJcblxyXG5cdFx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkuYXBwbHlNYXRyaXg0KCBfaW5zdGFuY2VMb2NhbE1hdHJpeCApO1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS51bmlvbiggX3NwaGVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdHRoaXMuaW5zdGFuY2VNYXRyaXguY29weSggc291cmNlLmluc3RhbmNlTWF0cml4ICk7XHJcblxyXG5cdFx0aWYgKCBzb3VyY2UuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCApIHRoaXMuaW5zdGFuY2VDb2xvciA9IHNvdXJjZS5pbnN0YW5jZUNvbG9yLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcclxuXHJcblx0XHRpZiAoIHNvdXJjZS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHRoaXMuYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHRcdGlmICggc291cmNlLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENvbG9yQXQoIGluZGV4LCBjb2xvciApIHtcclxuXHJcblx0XHRjb2xvci5mcm9tQXJyYXkoIHRoaXMuaW5zdGFuY2VDb2xvci5hcnJheSwgaW5kZXggKiAzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TWF0cml4QXQoIGluZGV4LCBtYXRyaXggKSB7XHJcblxyXG5cdFx0bWF0cml4LmZyb21BcnJheSggdGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblx0XHRjb25zdCByYXljYXN0VGltZXMgPSB0aGlzLmNvdW50O1xyXG5cclxuXHRcdF9tZXNoLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIF9tZXNoLm1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0Ly8gdGVzdCB3aXRoIGJvdW5kaW5nIHNwaGVyZSBmaXJzdFxyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0X3NwaGVyZS5jb3B5KCB0aGlzLmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRfc3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggX3NwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHQvLyBub3cgdGVzdCBlYWNoIGluc3RhbmNlXHJcblxyXG5cdFx0Zm9yICggbGV0IGluc3RhbmNlSWQgPSAwOyBpbnN0YW5jZUlkIDwgcmF5Y2FzdFRpbWVzOyBpbnN0YW5jZUlkICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSB3b3JsZCBtYXRyaXggZm9yIGVhY2ggaW5zdGFuY2VcclxuXHJcblx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGluc3RhbmNlSWQsIF9pbnN0YW5jZUxvY2FsTWF0cml4ICk7XHJcblxyXG5cdFx0XHRfaW5zdGFuY2VXb3JsZE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIHRoZSBtZXNoIHJlcHJlc2VudHMgdGhpcyBzaW5nbGUgaW5zdGFuY2VcclxuXHJcblx0XHRcdF9tZXNoLm1hdHJpeFdvcmxkID0gX2luc3RhbmNlV29ybGRNYXRyaXg7XHJcblxyXG5cdFx0XHRfbWVzaC5yYXljYXN0KCByYXljYXN0ZXIsIF9pbnN0YW5jZUludGVyc2VjdHMgKTtcclxuXHJcblx0XHRcdC8vIHByb2Nlc3MgdGhlIHJlc3VsdCBvZiByYXljYXN0XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBfaW5zdGFuY2VJbnRlcnNlY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdCA9IF9pbnN0YW5jZUludGVyc2VjdHNbIGkgXTtcclxuXHRcdFx0XHRpbnRlcnNlY3QuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XHJcblx0XHRcdFx0aW50ZXJzZWN0Lm9iamVjdCA9IHRoaXM7XHJcblx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Q29sb3JBdCggaW5kZXgsIGNvbG9yICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5pbnN0YW5jZUNvbG9yID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3VudCAqIDMgKSwgMyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb2xvci50b0FycmF5KCB0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE1hdHJpeEF0KCBpbmRleCwgbWF0cml4ICkge1xyXG5cclxuXHRcdG1hdHJpeC50b0FycmF5KCB0aGlzLmluc3RhbmNlTWF0cml4LmFycmF5LCBpbmRleCAqIDE2ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTW9ycGhUYXJnZXRzKCkge1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEluc3RhbmNlZE1lc2ggfTtcclxuIiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbmNsYXNzIExpbmVCYXNpY01hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNMaW5lQmFzaWNNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblx0XHR0aGlzLmxpbmVjYXAgPSAncm91bmQnO1xyXG5cdFx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XHJcblx0XHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcclxuXHRcdHRoaXMubGluZWpvaW4gPSBzb3VyY2UubGluZWpvaW47XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XHJcbmltcG9ydCB7IFJheSB9IGZyb20gJy4uL21hdGgvUmF5LmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcblxyXG5jb25zdCBfc3RhcnQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9lbmQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9pbnZlcnNlTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfcmF5ID0gLypAX19QVVJFX18qLyBuZXcgUmF5KCk7XHJcbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcclxuXHJcbmNsYXNzIExpbmUgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0xpbmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lJztcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0XHRjb25zdCBsaW5lRGlzdGFuY2VzID0gWyAwIF07XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9zdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSAtIDEgKTtcclxuXHRcdFx0XHRfZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XHJcblxyXG5cdFx0XHRcdGxpbmVEaXN0YW5jZXNbIGkgXSA9IGxpbmVEaXN0YW5jZXNbIGkgLSAxIF07XHJcblx0XHRcdFx0bGluZURpc3RhbmNlc1sgaSBdICs9IF9zdGFydC5kaXN0YW5jZVRvKCBfZW5kICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbGluZURpc3RhbmNlcywgMSApICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmUuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTogQ29tcHV0YXRpb24gb25seSBwb3NzaWJsZSB3aXRoIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5LicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHRcdGNvbnN0IHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuTGluZS50aHJlc2hvbGQ7XHJcblx0XHRjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XHJcblxyXG5cdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdF9zcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdF9zcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cdFx0X3NwaGVyZS5yYWRpdXMgKz0gdGhyZXNob2xkO1xyXG5cclxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBfc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0X2ludmVyc2VNYXRyaXguY29weSggbWF0cml4V29ybGQgKS5pbnZlcnQoKTtcclxuXHRcdF9yYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggX2ludmVyc2VNYXRyaXggKTtcclxuXHJcblx0XHRjb25zdCBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcclxuXHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xyXG5cclxuXHRcdGNvbnN0IHZTdGFydCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCB2RW5kID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdGNvbnN0IGludGVyU2VnbWVudCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBpbnRlclJheSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xyXG5cclxuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XHJcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBpbmRleC5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydCwgbCA9IGVuZCAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGEgPSBpbmRleC5nZXRYKCBpICk7XHJcblx0XHRcdFx0Y29uc3QgYiA9IGluZGV4LmdldFgoIGkgKyAxICk7XHJcblxyXG5cdFx0XHRcdHZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgYSApO1xyXG5cdFx0XHRcdHZFbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGIgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdFNxID0gX3JheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0U3EgPiBsb2NhbFRocmVzaG9sZFNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcblx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcblx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXHJcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBsID0gZW5kIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdFx0dlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XHJcblx0XHRcdFx0dkVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdFNxID0gX3JheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0U3EgPiBsb2NhbFRocmVzaG9sZFNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcblx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcblx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXHJcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcclxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggbW9ycGhBdHRyaWJ1dGVzICk7XHJcblxyXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sga2V5c1sgMCBdIF07XHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVsgbSBdLm5hbWUgfHwgU3RyaW5nKCBtICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IExpbmUgfTtcclxuIiwiaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vTGluZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5cclxuY29uc3QgX3N0YXJ0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfZW5kID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY2xhc3MgTGluZVNlZ21lbnRzIGV4dGVuZHMgTGluZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdHRoaXMuaXNMaW5lU2VnbWVudHMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbXB1dGVMaW5lRGlzdGFuY2VzKCkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0XHQvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0XHRjb25zdCBsaW5lRGlzdGFuY2VzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0X3N0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpICk7XHJcblx0XHRcdFx0X2VuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSArIDEgKTtcclxuXHJcblx0XHRcdFx0bGluZURpc3RhbmNlc1sgaSBdID0gKCBpID09PSAwICkgPyAwIDogbGluZURpc3RhbmNlc1sgaSAtIDEgXTtcclxuXHRcdFx0XHRsaW5lRGlzdGFuY2VzWyBpICsgMSBdID0gbGluZURpc3RhbmNlc1sgaSBdICsgX3N0YXJ0LmRpc3RhbmNlVG8oIF9lbmQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBsaW5lRGlzdGFuY2VzLCAxICkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZVNlZ21lbnRzLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk6IENvbXB1dGF0aW9uIG9ubHkgcG9zc2libGUgd2l0aCBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeS4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBMaW5lU2VnbWVudHMgfTtcclxuIiwiaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vTGluZS5qcyc7XHJcblxyXG5jbGFzcyBMaW5lTG9vcCBleHRlbmRzIExpbmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLmlzTGluZUxvb3AgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lTG9vcCc7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IExpbmVMb29wIH07XHJcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcblxyXG5jbGFzcyBQb2ludHNNYXRlcmlhbCBleHRlbmRzIE1hdGVyaWFsIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzUG9pbnRzTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5zaXplID0gMTtcclxuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcblx0XHR0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcclxuXHRcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFBvaW50c01hdGVyaWFsIH07XHJcbiIsImltcG9ydCB7IFNwaGVyZSB9IGZyb20gJy4uL21hdGgvU3BoZXJlLmpzJztcclxuaW1wb3J0IHsgUmF5IH0gZnJvbSAnLi4vbWF0aC9SYXkuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFBvaW50c01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuXHJcbmNvbnN0IF9pbnZlcnNlTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfcmF5ID0gLypAX19QVVJFX18qLyBuZXcgUmF5KCk7XHJcbmNvbnN0IF9zcGhlcmUgPSAvKkBfX1BVUkVfXyovIG5ldyBTcGhlcmUoKTtcclxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5cclxuY2xhc3MgUG9pbnRzIGV4dGVuZHMgT2JqZWN0M0Qge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgbWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNQb2ludHMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdQb2ludHMnO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IHNvdXJjZS5tYXRlcmlhbDtcclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdGNvbnN0IG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHRcdGNvbnN0IHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcclxuXHJcblx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xyXG5cdFx0X3NwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRfc3BoZXJlLnJhZGl1cyArPSB0aHJlc2hvbGQ7XHJcblxyXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIF9zcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRfaW52ZXJzZU1hdHJpeC5jb3B5KCBtYXRyaXhXb3JsZCApLmludmVydCgpO1xyXG5cdFx0X3JheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBfaW52ZXJzZU1hdHJpeCApO1xyXG5cclxuXHRcdGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xyXG5cdFx0Y29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzdGFydCA9IE1hdGgubWF4KCAwLCBkcmF3UmFuZ2Uuc3RhcnQgKTtcclxuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4oIGluZGV4LmNvdW50LCAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhID0gaW5kZXguZ2V0WCggaSApO1xyXG5cclxuXHRcdFx0XHRfcG9zaXRpb24uZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGEgKTtcclxuXHJcblx0XHRcdFx0dGVzdFBvaW50KCBfcG9zaXRpb24sIGEsIGxvY2FsVGhyZXNob2xkU3EsIG1hdHJpeFdvcmxkLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRoaXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBNYXRoLm1heCggMCwgZHJhd1JhbmdlLnN0YXJ0ICk7XHJcblx0XHRcdGNvbnN0IGVuZCA9IE1hdGgubWluKCBwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCwgKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydCwgbCA9IGVuZDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9wb3NpdGlvbi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaSApO1xyXG5cclxuXHRcdFx0XHR0ZXN0UG9pbnQoIF9wb3NpdGlvbiwgaSwgbG9jYWxUaHJlc2hvbGRTcSwgbWF0cml4V29ybGQsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgdGhpcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVNb3JwaFRhcmdldHMoKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cclxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcclxuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggbW9ycGhBdHRyaWJ1dGVzICk7XHJcblxyXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sga2V5c1sgMCBdIF07XHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVsgbSBdLm5hbWUgfHwgU3RyaW5nKCBtICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4LCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBvYmplY3QgKSB7XHJcblxyXG5cdGNvbnN0IHJheVBvaW50RGlzdGFuY2VTcSA9IF9yYXkuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICk7XHJcblxyXG5cdGlmICggcmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSApIHtcclxuXHJcblx0XHRjb25zdCBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0X3JheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgaW50ZXJzZWN0UG9pbnQgKTtcclxuXHRcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRjb25zdCBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XHJcblxyXG5cdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcclxuXHJcblx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0ZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KCByYXlQb2ludERpc3RhbmNlU3EgKSxcclxuXHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LFxyXG5cdFx0XHRpbmRleDogaW5kZXgsXHJcblx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdG9iamVjdDogb2JqZWN0XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBQb2ludHMgfTtcclxuIiwiaW1wb3J0IHsgTGluZWFyRmlsdGVyIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XHJcblxyXG5jbGFzcyBWaWRlb1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0XHR0aGlzLmlzVmlkZW9UZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xyXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcclxuXHJcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiB1cGRhdGVWaWRlbygpIHtcclxuXHJcblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0dmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayggdXBkYXRlVmlkZW8gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW8gKSB7XHJcblxyXG5cdFx0XHR2aWRlby5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKCB1cGRhdGVWaWRlbyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuaW1hZ2UgKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCkge1xyXG5cclxuXHRcdGNvbnN0IHZpZGVvID0gdGhpcy5pbWFnZTtcclxuXHRcdGNvbnN0IGhhc1ZpZGVvRnJhbWVDYWxsYmFjayA9ICdyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrJyBpbiB2aWRlbztcclxuXHJcblx0XHRpZiAoIGhhc1ZpZGVvRnJhbWVDYWxsYmFjayA9PT0gZmFsc2UgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSApIHtcclxuXHJcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgVmlkZW9UZXh0dXJlIH07XHJcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBOZWFyZXN0RmlsdGVyIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmNsYXNzIEZyYW1lYnVmZmVyVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRzdXBlciggeyB3aWR0aCwgaGVpZ2h0IH0gKTtcclxuXHJcblx0XHR0aGlzLmlzRnJhbWVidWZmZXJUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcblx0XHR0aGlzLm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgRnJhbWVidWZmZXJUZXh0dXJlIH07XHJcbiIsImltcG9ydCB7IFRleHR1cmUgfSBmcm9tICcuL1RleHR1cmUuanMnO1xyXG5cclxuY2xhc3MgQ29tcHJlc3NlZFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgY29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRzdXBlciggbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBjb2xvclNwYWNlICk7XHJcblxyXG5cdFx0dGhpcy5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcblx0XHR0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xyXG5cclxuXHRcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXHJcblx0XHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxyXG5cclxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXHJcblx0XHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXHJcblxyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmUgfTtcclxuIiwiaW1wb3J0IHsgQ2xhbXBUb0VkZ2VXcmFwcGluZyB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IENvbXByZXNzZWRUZXh0dXJlIH0gZnJvbSAnLi9Db21wcmVzc2VkVGV4dHVyZS5qcyc7XHJcblxyXG5jbGFzcyBDb21wcmVzc2VkQXJyYXlUZXh0dXJlIGV4dGVuZHMgQ29tcHJlc3NlZFRleHR1cmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGZvcm1hdCwgdHlwZSApIHtcclxuXHJcblx0XHRzdXBlciggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlICk7XHJcblxyXG5cdFx0dGhpcy5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgPSB0cnVlO1xyXG5cdFx0dGhpcy5pbWFnZS5kZXB0aCA9IGRlcHRoO1xyXG5cdFx0dGhpcy53cmFwUiA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IENvbXByZXNzZWRBcnJheVRleHR1cmUgfTtcclxuIiwiaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gJy4vVGV4dHVyZS5qcyc7XHJcblxyXG5jbGFzcyBDYW52YXNUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcclxuXHJcblx0XHRzdXBlciggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0XHR0aGlzLmlzQ2FudmFzVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IENhbnZhc1RleHR1cmUgfTtcclxuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uLy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuXHJcbi8qKlxyXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdC5cclxuICpcclxuICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcclxuICogLmdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKVxyXG4gKiAuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKVxyXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxyXG4gKiAuZ2V0TGVuZ3RoKClcclxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxyXG4gKlxyXG4gKiBUaGlzIGZvbGxvd2luZyBjdXJ2ZXMgaW5oZXJpdCBmcm9tIFRIUkVFLkN1cnZlOlxyXG4gKlxyXG4gKiAtLSAyRCBjdXJ2ZXMgLS1cclxuICogVEhSRUUuQXJjQ3VydmVcclxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxyXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcclxuICogVEhSRUUuTGluZUN1cnZlXHJcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlXHJcbiAqXHJcbiAqIC0tIDNEIGN1cnZlcyAtLVxyXG4gKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcclxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXHJcbiAqXHJcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGguXHJcbiAqXHJcbiAqKi9cclxuXHJcbmNsYXNzIEN1cnZlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0N1cnZlJztcclxuXHJcblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcclxuXHQvL1x0LSB0IFswIC4uIDFdXHJcblxyXG5cdGdldFBvaW50KCAvKiB0LCBvcHRpb25hbFRhcmdldCAqLyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxyXG5cdC8vIC0gdSBbMCAuLiAxXVxyXG5cclxuXHRnZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRjb25zdCB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5cdGdldFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcclxuXHJcblx0XHRjb25zdCBwb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXHJcblxyXG5cdGdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcclxuXHJcblx0XHRjb25zdCBwb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcblx0Z2V0TGVuZ3RoKCkge1xyXG5cclxuXHRcdGNvbnN0IGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHRcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xyXG5cclxuXHRnZXRMZW5ndGhzKCBkaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXHJcblx0XHRcdCggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxICkgJiZcclxuXHRcdFx0ISB0aGlzLm5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3QgY2FjaGUgPSBbXTtcclxuXHRcdGxldCBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG5cdFx0bGV0IHN1bSA9IDA7XHJcblxyXG5cdFx0Y2FjaGUucHVzaCggMCApO1xyXG5cclxuXHRcdGZvciAoIGxldCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XHJcblxyXG5cdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xyXG5cdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xyXG5cdFx0XHRsYXN0ID0gY3VycmVudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcclxuXHJcblx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUFyY0xlbmd0aHMoKSB7XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XHJcblxyXG5cdGdldFV0b1RtYXBwaW5nKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRjb25zdCBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG5cdFx0bGV0IGkgPSAwO1xyXG5cdFx0Y29uc3QgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcclxuXHJcblx0XHRsZXQgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcblx0XHRpZiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcclxuXHJcblx0XHRsZXQgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcclxuXHJcblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xyXG5cclxuXHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXHJcblxyXG5cdFx0XHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcclxuXHJcblx0XHRcdFx0bG93ID0gaSArIDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcclxuXHJcblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aGlnaCA9IGk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdC8vIERPTkVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aSA9IGhpZ2g7XHJcblxyXG5cdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcclxuXHJcblx0XHRcdHJldHVybiBpIC8gKCBpbCAtIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHJcblx0XHRjb25zdCBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XHJcblx0XHRjb25zdCBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XHJcblxyXG5cdFx0Y29uc3Qgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xyXG5cclxuXHRcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXHJcblxyXG5cdFx0Y29uc3Qgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG5cdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuXHRcdGNvbnN0IHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxyXG5cdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcclxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxyXG5cdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cclxuXHJcblx0Z2V0VGFuZ2VudCggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGVsdGEgPSAwLjAwMDE7XHJcblx0XHRsZXQgdDEgPSB0IC0gZGVsdGE7XHJcblx0XHRsZXQgdDIgPSB0ICsgZGVsdGE7XHJcblxyXG5cdFx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxyXG5cclxuXHRcdGlmICggdDEgPCAwICkgdDEgPSAwO1xyXG5cdFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XHJcblxyXG5cdFx0Y29uc3QgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcclxuXHRcdGNvbnN0IHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XHJcblxyXG5cdFx0Y29uc3QgdGFuZ2VudCA9IG9wdGlvbmFsVGFyZ2V0IHx8ICggKCBwdDEuaXNWZWN0b3IyICkgPyBuZXcgVmVjdG9yMigpIDogbmV3IFZlY3RvcjMoKSApO1xyXG5cclxuXHRcdHRhbmdlbnQuY29weSggcHQyICkuc3ViKCBwdDEgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGFuZ2VudDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUYW5nZW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbXB1dGVGcmVuZXRGcmFtZXMoIHNlZ21lbnRzLCBjbG9zZWQgKSB7XHJcblxyXG5cdFx0Ly8gc2VlIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxyXG5cclxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Y29uc3QgdGFuZ2VudHMgPSBbXTtcclxuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuXHRcdGNvbnN0IGJpbm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHUgPSBpIC8gc2VnbWVudHM7XHJcblxyXG5cdFx0XHR0YW5nZW50c1sgaSBdID0gdGhpcy5nZXRUYW5nZW50QXQoIHUsIG5ldyBWZWN0b3IzKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcclxuXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxyXG5cclxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHRcdGNvbnN0IHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xyXG5cdFx0Y29uc3QgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XHJcblx0XHRjb25zdCB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcclxuXHJcblx0XHRpZiAoIHR4IDw9IG1pbiApIHtcclxuXHJcblx0XHRcdG1pbiA9IHR4O1xyXG5cdFx0XHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHkgPD0gbWluICkge1xyXG5cclxuXHRcdFx0bWluID0gdHk7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eiA8PSBtaW4gKSB7XHJcblxyXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIHZlYyApO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcclxuXHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XHJcblxyXG5cdFx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHR2ZWMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXHJcblxyXG5cdFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcclxuXHJcblx0XHRpZiAoIGNsb3NlZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGxldCB0aGV0YSA9IE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XHJcblx0XHRcdHRoZXRhIC89IHNlZ21lbnRzO1xyXG5cclxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoZXRhID0gLSB0aGV0YTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cclxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcclxuXHRcdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0YW5nZW50czogdGFuZ2VudHMsXHJcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXHJcblx0XHRcdGJpbm9ybWFsczogYmlub3JtYWxzXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBzb3VyY2UuYXJjTGVuZ3RoRGl2aXNpb25zO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0ge1xyXG5cdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdHZlcnNpb246IDQuNixcclxuXHRcdFx0XHR0eXBlOiAnQ3VydmUnLFxyXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0N1cnZlLnRvSlNPTidcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xyXG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21KU09OKCBqc29uICkge1xyXG5cclxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBDdXJ2ZSB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuXHJcbmNsYXNzIEVsbGlwc2VDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGFYID0gMCwgYVkgPSAwLCB4UmFkaXVzID0gMSwgeVJhZGl1cyA9IDEsIGFTdGFydEFuZ2xlID0gMCwgYUVuZEFuZ2xlID0gTWF0aC5QSSAqIDIsIGFDbG9ja3dpc2UgPSBmYWxzZSwgYVJvdGF0aW9uID0gMCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNFbGxpcHNlQ3VydmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdFbGxpcHNlQ3VydmUnO1xyXG5cclxuXHRcdHRoaXMuYVggPSBhWDtcclxuXHRcdHRoaXMuYVkgPSBhWTtcclxuXHJcblx0XHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xyXG5cdFx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcclxuXHJcblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XHJcblx0XHR0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcclxuXHJcblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xyXG5cclxuXHRcdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0Y29uc3QgdHdvUGkgPSBNYXRoLlBJICogMjtcclxuXHRcdGxldCBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xyXG5cdFx0Y29uc3Qgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcclxuXHJcblx0XHQvLyBlbnN1cmVzIHRoYXQgZGVsdGFBbmdsZSBpcyAwIC4uIDIgUElcclxuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xyXG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xyXG5cclxuXHRcdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0aWYgKCBzYW1lUG9pbnRzICkge1xyXG5cclxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gMDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGRlbHRhQW5nbGUgPSB0d29QaTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgISBzYW1lUG9pbnRzICkge1xyXG5cclxuXHRcdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcclxuXHJcblx0XHRcdFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHRcdGxldCB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0bGV0IHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xyXG5cdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcclxuXHJcblx0XHRcdGNvbnN0IHR4ID0geCAtIHRoaXMuYVg7XHJcblx0XHRcdGNvbnN0IHR5ID0geSAtIHRoaXMuYVk7XHJcblxyXG5cdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXHJcblx0XHRcdHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcclxuXHRcdFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuYVggPSBzb3VyY2UuYVg7XHJcblx0XHR0aGlzLmFZID0gc291cmNlLmFZO1xyXG5cclxuXHRcdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xyXG5cdFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XHJcblxyXG5cdFx0dGhpcy5hU3RhcnRBbmdsZSA9IHNvdXJjZS5hU3RhcnRBbmdsZTtcclxuXHRcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcclxuXHJcblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBzb3VyY2UuYUNsb2Nrd2lzZTtcclxuXHJcblx0XHR0aGlzLmFSb3RhdGlvbiA9IHNvdXJjZS5hUm90YXRpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcclxuXHJcblx0XHRkYXRhLmFYID0gdGhpcy5hWDtcclxuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xyXG5cclxuXHRcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcclxuXHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcclxuXHJcblx0XHRkYXRhLmFTdGFydEFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZTtcclxuXHRcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XHJcblxyXG5cdFx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xyXG5cclxuXHRcdGRhdGEuYVJvdGF0aW9uID0gdGhpcy5hUm90YXRpb247XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLmFYID0ganNvbi5hWDtcclxuXHRcdHRoaXMuYVkgPSBqc29uLmFZO1xyXG5cclxuXHRcdHRoaXMueFJhZGl1cyA9IGpzb24ueFJhZGl1cztcclxuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcclxuXHJcblx0XHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcclxuXHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XHJcblxyXG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xyXG5cclxuXHRcdHRoaXMuYVJvdGF0aW9uID0ganNvbi5hUm90YXRpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEVsbGlwc2VDdXJ2ZSB9O1xyXG4iLCJpbXBvcnQgeyBFbGxpcHNlQ3VydmUgfSBmcm9tICcuL0VsbGlwc2VDdXJ2ZS5qcyc7XHJcblxyXG5jbGFzcyBBcmNDdXJ2ZSBleHRlbmRzIEVsbGlwc2VDdXJ2ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuXHRcdHRoaXMuaXNBcmNDdXJ2ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0FyY0N1cnZlJztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQXJjQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XHJcblxyXG4vKipcclxuICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcclxuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXHJcbiAqIGh0dHA6Ly93d3cuY2VteXVrc2VsLmNvbS9yZXNlYXJjaC9jYXRtdWxscm9tX3BhcmFtL2NhdG11bGxyb20ucGRmXHJcbiAqXHJcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxyXG4gKiBjdXJ2ZS50ZW5zaW9uIGlzIHVzZWQgZm9yIGNhdG11bGxyb20gd2hpY2ggZGVmYXVsdHMgdG8gMC41XHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbkJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cclxuIC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cclxuIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXHJcblxyXG5UaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXHJcbmJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxyXG53aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXHJcbiovXHJcblxyXG5mdW5jdGlvbiBDdWJpY1BvbHkoKSB7XHJcblxyXG5cdGxldCBjMCA9IDAsIGMxID0gMCwgYzIgPSAwLCBjMyA9IDA7XHJcblxyXG5cdC8qXHJcblx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxyXG5cdCAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xyXG5cdCAqIHN1Y2ggdGhhdFxyXG5cdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcclxuXHQgKiAgYW5kXHJcblx0ICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGluaXQoIHgwLCB4MSwgdDAsIHQxICkge1xyXG5cclxuXHRcdGMwID0geDA7XHJcblx0XHRjMSA9IHQwO1xyXG5cdFx0YzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xyXG5cdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7XHJcblxyXG5cdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XHJcblxyXG5cdFx0XHRpbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXHJcblx0XHRcdGxldCB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XHJcblx0XHRcdGxldCB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XHJcblxyXG5cdFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cclxuXHRcdFx0dDEgKj0gZHQxO1xyXG5cdFx0XHR0MiAqPSBkdDE7XHJcblxyXG5cdFx0XHRpbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2FsYzogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdDIgPSB0ICogdDtcclxuXHRcdFx0Y29uc3QgdDMgPSB0MiAqIHQ7XHJcblx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5jb25zdCB0bXAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IHB4ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XHJcbmNvbnN0IHB5ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XHJcbmNvbnN0IHB6ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XHJcblxyXG5jbGFzcyBDYXRtdWxsUm9tQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gW10sIGNsb3NlZCA9IGZhbHNlLCBjdXJ2ZVR5cGUgPSAnY2VudHJpcGV0YWwnLCB0ZW5zaW9uID0gMC41ICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cztcclxuXHRcdHRoaXMuY2xvc2VkID0gY2xvc2VkO1xyXG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGU7XHJcblx0XHR0aGlzLnRlbnNpb24gPSB0ZW5zaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XHJcblxyXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcclxuXHJcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuXHRcdGNvbnN0IGwgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRcdGNvbnN0IHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcclxuXHRcdGxldCBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcclxuXHRcdGxldCB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcclxuXHJcblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gbCApICsgMSApICogbDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xyXG5cclxuXHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcclxuXHRcdFx0d2VpZ2h0ID0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcclxuXHJcblx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCApIHtcclxuXHJcblx0XHRcdHAwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgbCBdO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxyXG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xyXG5cdFx0XHRwMCA9IHRtcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcDEgPSBwb2ludHNbIGludFBvaW50ICUgbCBdO1xyXG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsICkge1xyXG5cclxuXHRcdFx0cDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBsIF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcclxuXHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcclxuXHRcdFx0cDMgPSB0bXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyApIHtcclxuXHJcblx0XHRcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXHJcblx0XHRcdGNvbnN0IHBvdyA9IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xyXG5cdFx0XHRsZXQgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcclxuXHRcdFx0bGV0IGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XHJcblx0XHRcdGxldCBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xyXG5cclxuXHRcdFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcclxuXHRcdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xyXG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XHJcblx0XHRcdGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcclxuXHJcblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcclxuXHRcdFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcclxuXHJcblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcclxuXHRcdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRoaXMudGVuc2lvbiApO1xyXG5cdFx0XHRwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0cHguY2FsYyggd2VpZ2h0ICksXHJcblx0XHRcdHB5LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcclxuXHRcdHRoaXMuY3VydmVUeXBlID0gc291cmNlLmN1cnZlVHlwZTtcclxuXHRcdHRoaXMudGVuc2lvbiA9IHNvdXJjZS50ZW5zaW9uO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XHJcblxyXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG5cdFx0XHRkYXRhLnBvaW50cy5wdXNoKCBwb2ludC50b0FycmF5KCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcclxuXHRcdGRhdGEuY3VydmVUeXBlID0gdGhpcy5jdXJ2ZVR5cGU7XHJcblx0XHRkYXRhLnRlbnNpb24gPSB0aGlzLnRlbnNpb247XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XHJcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBwb2ludCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XHJcblx0XHR0aGlzLmN1cnZlVHlwZSA9IGpzb24uY3VydmVUeXBlO1xyXG5cdFx0dGhpcy50ZW5zaW9uID0ganNvbi50ZW5zaW9uO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDYXRtdWxsUm9tQ3VydmUzIH07XHJcbiIsIi8qKlxyXG4gKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcclxuICovXHJcblxyXG5mdW5jdGlvbiBDYXRtdWxsUm9tKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcblx0Y29uc3QgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcclxuXHRjb25zdCB2MSA9ICggcDMgLSBwMSApICogMC41O1xyXG5cdGNvbnN0IHQyID0gdCAqIHQ7XHJcblx0Y29uc3QgdDMgPSB0ICogdDI7XHJcblx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAgKSB7XHJcblxyXG5cdGNvbnN0IGsgPSAxIC0gdDtcclxuXHRyZXR1cm4gayAqIGsgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAgKSB7XHJcblxyXG5cdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMiggdCwgcCApIHtcclxuXHJcblx0cmV0dXJuIHQgKiB0ICogcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllciggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcblx0cmV0dXJuIFF1YWRyYXRpY0JlemllclAwKCB0LCBwMCApICsgUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAxICkgK1xyXG5cdFx0UXVhZHJhdGljQmV6aWVyUDIoIHQsIHAyICk7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMCggdCwgcCApIHtcclxuXHJcblx0Y29uc3QgayA9IDEgLSB0O1xyXG5cdHJldHVybiBrICogayAqIGsgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMSggdCwgcCApIHtcclxuXHJcblx0Y29uc3QgayA9IDEgLSB0O1xyXG5cdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDIoIHQsIHAgKSB7XHJcblxyXG5cdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMyggdCwgcCApIHtcclxuXHJcblx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBDdWJpY0JlemllciggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdHJldHVybiBDdWJpY0JlemllclAwKCB0LCBwMCApICsgQ3ViaWNCZXppZXJQMSggdCwgcDEgKSArIEN1YmljQmV6aWVyUDIoIHQsIHAyICkgK1xyXG5cdFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IENhdG11bGxSb20sIFF1YWRyYXRpY0JlemllciwgQ3ViaWNCZXppZXIgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgQ3ViaWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcblxyXG5jbGFzcyBDdWJpY0JlemllckN1cnZlIGV4dGVuZHMgQ3VydmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSwgdjMgPSBuZXcgVmVjdG9yMigpICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcclxuXHJcblx0XHR0aGlzLnYwID0gdjA7XHJcblx0XHR0aGlzLnYxID0gdjE7XHJcblx0XHR0aGlzLnYyID0gdjI7XHJcblx0XHR0aGlzLnYzID0gdjM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcclxuXHJcblx0XHRjb25zdCBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xyXG5cclxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcclxuXHJcblx0XHRwb2ludC5zZXQoXHJcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXHJcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55LCB2My55IClcclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblx0XHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XHJcblxyXG5cdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xyXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xyXG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cdFx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21KU09OKCBqc29uICkge1xyXG5cclxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQ3ViaWNCZXppZXJDdXJ2ZSB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBDdWJpY0JlemllciB9IGZyb20gJy4uL2NvcmUvSW50ZXJwb2xhdGlvbnMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuXHJcbmNsYXNzIEN1YmljQmV6aWVyQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSwgdjMgPSBuZXcgVmVjdG9yMygpICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0N1YmljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHRcdHRoaXMudjMgPSB2MztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XHJcblxyXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKSxcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XHJcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHRcdHRoaXMudjMuY29weSggc291cmNlLnYzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcclxuXHJcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xyXG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblx0XHR0aGlzLnYzLmZyb21BcnJheSgganNvbi52MyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlMyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuXHJcbmNsYXNzIExpbmVDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0xpbmVDdXJ2ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVDdXJ2ZSc7XHJcblxyXG5cdFx0dGhpcy52MSA9IHYxO1xyXG5cdFx0dGhpcy52MiA9IHYyO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkgKSB7XHJcblxyXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcclxuXHJcblx0XHRpZiAoIHQgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcclxuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcclxuXHJcblx0XHRyZXR1cm4gb3B0aW9uYWxUYXJnZXQuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcclxuXHJcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgTGluZUN1cnZlIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5cclxuY2xhc3MgTGluZUN1cnZlMyBleHRlbmRzIEN1cnZlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0xpbmVDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcclxuXHJcblx0XHR0aGlzLnYxID0gdjE7XHJcblx0XHR0aGlzLnYyID0gdjI7XHJcblxyXG5cdH1cclxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XHJcblxyXG5cdFx0aWYgKCB0ID09PSAxICkge1xyXG5cclxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICkuc3ViKCB0aGlzLnYxICk7XHJcblx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludDtcclxuXHJcblx0fVxyXG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cdGdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcclxuXHJcblx0XHRyZXR1cm4gb3B0aW9uYWxUYXJnZXQuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cdGZyb21KU09OKCBqc29uICkge1xyXG5cclxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IExpbmVDdXJ2ZTMgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgUXVhZHJhdGljQmV6aWVyQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCB2MCA9IG5ldyBWZWN0b3IyKCksIHYxID0gbmV3IFZlY3RvcjIoKSwgdjIgPSBuZXcgVmVjdG9yMigpICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUnO1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XHJcblxyXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcclxuXHJcblx0XHRwb2ludC5zZXQoXHJcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxyXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XHJcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tSlNPTigganNvbiApIHtcclxuXHJcblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xyXG5cclxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XHJcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcclxuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuY2xhc3MgUXVhZHJhdGljQmV6aWVyQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZTMnO1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XHJcblxyXG5cdFx0Y29uc3QgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcclxuXHJcblx0XHRwb2ludC5zZXQoXHJcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxyXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKSxcclxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcclxuXHJcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xyXG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlMyB9O1xyXG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBDYXRtdWxsUm9tIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgU3BsaW5lQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNTcGxpbmVDdXJ2ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMigpICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XHJcblxyXG5cdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblx0XHRjb25zdCBwID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0XHRjb25zdCBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcclxuXHRcdGNvbnN0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcclxuXHJcblx0XHRjb25zdCBwMCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xyXG5cdFx0Y29uc3QgcDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcblx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XHJcblx0XHRjb25zdCBwMyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XHJcblxyXG5cdFx0cG9pbnQuc2V0KFxyXG5cdFx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLngsIHAxLngsIHAyLngsIHAzLnggKSxcclxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC55LCBwMS55LCBwMi55LCBwMy55IClcclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggcG9pbnQuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGRhdGEucG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcclxuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21KU09OKCBqc29uICkge1xyXG5cclxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xyXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggcG9pbnQgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgU3BsaW5lQ3VydmUgfTtcclxuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuL0N1cnZlLmpzJztcclxuaW1wb3J0ICogYXMgQ3VydmVzIGZyb20gJy4uL2N1cnZlcy9DdXJ2ZXMuanMnO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcclxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmNsYXNzIEN1cnZlUGF0aCBleHRlbmRzIEN1cnZlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ3VydmVQYXRoJztcclxuXHJcblx0XHR0aGlzLmN1cnZlcyA9IFtdO1xyXG5cdFx0dGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcclxuXHJcblx0fVxyXG5cclxuXHRhZGQoIGN1cnZlICkge1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvc2VQYXRoKCkge1xyXG5cclxuXHRcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxyXG5cdFx0Y29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcclxuXHRcdGNvbnN0IGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xyXG5cclxuXHRcdGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcclxuXHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbICdMaW5lQ3VydmUnIF0oIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXHJcblx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxyXG5cdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcclxuXHJcblx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxyXG5cdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxyXG5cdC8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcclxuXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcclxuXHJcblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcclxuXHRcdGNvbnN0IGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblx0XHRsZXQgaSA9IDA7XHJcblxyXG5cdFx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXHJcblxyXG5cdFx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuXHRcdFx0XHRjb25zdCBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHRcdFx0XHRjb25zdCB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aSArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXHJcblxyXG5cdH1cclxuXHJcblx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxyXG5cdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxyXG5cdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcclxuXHJcblx0Z2V0TGVuZ3RoKCkge1xyXG5cclxuXHRcdGNvbnN0IGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNhY2hlTGVuZ3RocyBtdXN0IGJlIHJlY2FsY3VsYXRlZC5cclxuXHR1cGRhdGVBcmNMZW5ndGhzKCkge1xyXG5cclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xyXG5cdFx0dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cclxuXHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxyXG5cclxuXHRnZXRDdXJ2ZUxlbmd0aHMoKSB7XHJcblxyXG5cdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxyXG5cclxuXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXHJcblx0XHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcclxuXHJcblx0XHRjb25zdCBsZW5ndGhzID0gW107XHJcblx0XHRsZXQgc3VtcyA9IDA7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcclxuXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcblx0XHRyZXR1cm4gbGVuZ3RocztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyA9IDQwICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQb2ludHMoIGRpdmlzaW9ucyA9IDEyICkge1xyXG5cclxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xyXG5cdFx0bGV0IGxhc3Q7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBjdXJ2ZXMgPSB0aGlzLmN1cnZlczsgaSA8IGN1cnZlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IGN1cnZlc1sgaSBdO1xyXG5cdFx0XHRjb25zdCByZXNvbHV0aW9uID0gY3VydmUuaXNFbGxpcHNlQ3VydmUgPyBkaXZpc2lvbnMgKiAyXHJcblx0XHRcdFx0OiAoIGN1cnZlLmlzTGluZUN1cnZlIHx8IGN1cnZlLmlzTGluZUN1cnZlMyApID8gMVxyXG5cdFx0XHRcdFx0OiBjdXJ2ZS5pc1NwbGluZUN1cnZlID8gZGl2aXNpb25zICogY3VydmUucG9pbnRzLmxlbmd0aFxyXG5cdFx0XHRcdFx0XHQ6IGRpdmlzaW9ucztcclxuXHJcblx0XHRcdGNvbnN0IHB0cyA9IGN1cnZlLmdldFBvaW50cyggcmVzb2x1dGlvbiApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBwdHNbIGogXTtcclxuXHJcblx0XHRcdFx0aWYgKCBsYXN0ICYmIGxhc3QuZXF1YWxzKCBwb2ludCApICkgY29udGludWU7IC8vIGVuc3VyZXMgbm8gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBkdXBsaWNhdGVzXHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xyXG5cdFx0XHRcdGxhc3QgPSBwb2ludDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiAhIHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50cztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzb3VyY2UuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IHNvdXJjZS5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdXRvQ2xvc2UgPSBzb3VyY2UuYXV0b0Nsb3NlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XHJcblxyXG5cdFx0ZGF0YS5hdXRvQ2xvc2UgPSB0aGlzLmF1dG9DbG9zZTtcclxuXHRcdGRhdGEuY3VydmVzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHRcdFx0ZGF0YS5jdXJ2ZXMucHVzaCggY3VydmUudG9KU09OKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLmF1dG9DbG9zZSA9IGpzb24uYXV0b0Nsb3NlO1xyXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY3VydmUgPSBqc29uLmN1cnZlc1sgaSBdO1xyXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyBjdXJ2ZS50eXBlIF0oKS5mcm9tSlNPTiggY3VydmUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEN1cnZlUGF0aCB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ3VydmVQYXRoIH0gZnJvbSAnLi9DdXJ2ZVBhdGguanMnO1xyXG5pbXBvcnQgeyBFbGxpcHNlQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvRWxsaXBzZUN1cnZlLmpzJztcclxuaW1wb3J0IHsgU3BsaW5lQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvU3BsaW5lQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBDdWJpY0JlemllckN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanMnO1xyXG5pbXBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qcyc7XHJcbmltcG9ydCB7IExpbmVDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9MaW5lQ3VydmUuanMnO1xyXG5cclxuY2xhc3MgUGF0aCBleHRlbmRzIEN1cnZlUGF0aCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUGF0aCc7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdGlmICggcG9pbnRzICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVBvaW50cyggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMubW92ZVRvKCBwb2ludHNbIDAgXS54LCBwb2ludHNbIDAgXS55ICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmxpbmVUbyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRtb3ZlVG8oIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7IC8vIFRPRE8gY29uc2lkZXIgcmVmZXJlbmNpbmcgdmVjdG9ycyBpbnN0ZWFkIG9mIGNvcHlpbmc/XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0bGluZVRvKCB4LCB5ICkge1xyXG5cclxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IExpbmVDdXJ2ZSggdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xyXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XHJcblxyXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUoXHJcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcclxuXHJcblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKFxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxyXG5cdFx0XHRuZXcgVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzcGxpbmVUaHJ1KCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcclxuXHJcblx0XHRjb25zdCBucHRzID0gWyB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpIF0uY29uY2F0KCBwdHMgKTtcclxuXHJcblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZSggbnB0cyApO1xyXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBwdHNbIHB0cy5sZW5ndGggLSAxIF0gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhcmMoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XHJcblx0XHRjb25zdCB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XHJcblxyXG5cdFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXHJcblx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRhYnNhcmMoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGVsbGlwc2UoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRcdGNvbnN0IHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcclxuXHRcdGNvbnN0IHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcclxuXHJcblx0XHR0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFic2VsbGlwc2UoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuY3VydmVzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBpZiBhIHByZXZpb3VzIGN1cnZlIGlzIHByZXNlbnQsIGF0dGVtcHQgdG8gam9pblxyXG5cdFx0XHRjb25zdCBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDAgKTtcclxuXHJcblx0XHRcdGlmICggISBmaXJzdFBvaW50LmVxdWFscyggdGhpcy5jdXJyZW50UG9pbnQgKSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5saW5lVG8oIGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0Y29uc3QgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcclxuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIGxhc3RQb2ludCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBzb3VyY2UuY3VycmVudFBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcclxuXHJcblx0XHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tSlNPTigganNvbiApIHtcclxuXHJcblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50LmZyb21BcnJheSgganNvbi5jdXJyZW50UG9pbnQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFBhdGggfTtcclxuIiwiaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5cclxuY2xhc3MgTGF0aGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBvaW50cyA9IFsgbmV3IFZlY3RvcjIoIDAsIC0gMC41ICksIG5ldyBWZWN0b3IyKCAwLjUsIDAgKSwgbmV3IFZlY3RvcjIoIDAsIDAuNSApIF0sIHNlZ21lbnRzID0gMTIsIHBoaVN0YXJ0ID0gMCwgcGhpTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRwb2ludHM6IHBvaW50cyxcclxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXHJcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdHNlZ21lbnRzID0gTWF0aC5mbG9vciggc2VnbWVudHMgKTtcclxuXHJcblx0XHQvLyBjbGFtcCBwaGlMZW5ndGggc28gaXQncyBpbiByYW5nZSBvZiBbIDAsIDJQSSBdXHJcblxyXG5cdFx0cGhpTGVuZ3RoID0gTWF0aFV0aWxzLmNsYW1wKCBwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XHJcblx0XHRjb25zdCB1dnMgPSBbXTtcclxuXHRcdGNvbnN0IGluaXROb3JtYWxzID0gW107XHJcblx0XHRjb25zdCBub3JtYWxzID0gW107XHJcblxyXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xyXG5cclxuXHRcdGNvbnN0IGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xyXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBjdXJOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3QgcHJldk5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRsZXQgZHggPSAwO1xyXG5cdFx0bGV0IGR5ID0gMDtcclxuXHJcblx0XHQvLyBwcmUtY29tcHV0ZSBub3JtYWxzIGZvciBpbml0aWFsIFwibWVyaWRpYW5cIlxyXG5cclxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBqICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIDA6XHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAxc3QgdmVydGV4IG9uIHBhdGhcclxuXHJcblx0XHRcdFx0XHRkeCA9IHBvaW50c1sgaiArIDEgXS54IC0gcG9pbnRzWyBqIF0ueDtcclxuXHRcdFx0XHRcdGR5ID0gcG9pbnRzWyBqICsgMSBdLnkgLSBwb2ludHNbIGogXS55O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC54ID0gZHkgKiAxLjA7XHJcblx0XHRcdFx0XHRub3JtYWwueSA9IC0gZHg7XHJcblx0XHRcdFx0XHRub3JtYWwueiA9IGR5ICogMC4wO1xyXG5cclxuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weSggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAoIHBvaW50cy5sZW5ndGggLSAxICk6XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBsYXN0IFZlcnRleCBvbiBwYXRoXHJcblxyXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaCggcHJldk5vcm1hbC54LCBwcmV2Tm9ybWFsLnksIHByZXZOb3JtYWwueiApO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0Olx0XHRcdC8vIGRlZmF1bHQgaGFuZGxpbmcgZm9yIGFsbCB2ZXJ0aWNlcyBpbiBiZXR3ZWVuXHJcblxyXG5cdFx0XHRcdFx0ZHggPSBwb2ludHNbIGogKyAxIF0ueCAtIHBvaW50c1sgaiBdLng7XHJcblx0XHRcdFx0XHRkeSA9IHBvaW50c1sgaiArIDEgXS55IC0gcG9pbnRzWyBqIF0ueTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwueCA9IGR5ICogMS4wO1xyXG5cdFx0XHRcdFx0bm9ybWFsLnkgPSAtIGR4O1xyXG5cdFx0XHRcdFx0bm9ybWFsLnogPSBkeSAqIDAuMDtcclxuXHJcblx0XHRcdFx0XHRjdXJOb3JtYWwuY29weSggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsLnggKz0gcHJldk5vcm1hbC54O1xyXG5cdFx0XHRcdFx0bm9ybWFsLnkgKz0gcHJldk5vcm1hbC55O1xyXG5cdFx0XHRcdFx0bm9ybWFsLnogKz0gcHJldk5vcm1hbC56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRcdFx0cHJldk5vcm1hbC5jb3B5KCBjdXJOb3JtYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIHV2cyBhbmQgbm9ybWFsc1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcclxuXHJcblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCBwaGkgKTtcclxuXHRcdFx0Y29uc3QgY29zID0gTWF0aC5jb3MoIHBoaSApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gcG9pbnRzWyBqIF0ueCAqIHNpbjtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHBvaW50c1sgaiBdLnk7XHJcblx0XHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIHV2XHJcblxyXG5cdFx0XHRcdHV2LnggPSBpIC8gc2VnbWVudHM7XHJcblx0XHRcdFx0dXYueSA9IGogLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbFxyXG5cclxuXHRcdFx0XHRjb25zdCB4ID0gaW5pdE5vcm1hbHNbIDMgKiBqICsgMCBdICogc2luO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSBpbml0Tm9ybWFsc1sgMyAqIGogKyAxIF07XHJcblx0XHRcdFx0Y29uc3QgeiA9IGluaXROb3JtYWxzWyAzICogaiArIDAgXSAqIGNvcztcclxuXHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYmFzZSA9IGogKyBpICogcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Y29uc3QgYSA9IGJhc2U7XHJcblx0XHRcdFx0Y29uc3QgYiA9IGJhc2UgKyBwb2ludHMubGVuZ3RoO1xyXG5cdFx0XHRcdGNvbnN0IGMgPSBiYXNlICsgcG9pbnRzLmxlbmd0aCArIDE7XHJcblx0XHRcdFx0Y29uc3QgZCA9IGJhc2UgKyAxO1xyXG5cclxuXHRcdFx0XHQvLyBmYWNlc1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYXRoZUdlb21ldHJ5KCBkYXRhLnBvaW50cywgZGF0YS5zZWdtZW50cywgZGF0YS5waGlTdGFydCwgZGF0YS5waGlMZW5ndGggKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IExhdGhlR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2V4dHJhcy9jb3JlL1BhdGguanMnO1xyXG5pbXBvcnQgeyBMYXRoZUdlb21ldHJ5IH0gZnJvbSAnLi9MYXRoZUdlb21ldHJ5LmpzJztcclxuXHJcbmNsYXNzIENhcHN1bGVHZW9tZXRyeSBleHRlbmRzIExhdGhlR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgbGVuZ3RoID0gMSwgY2FwU2VnbWVudHMgPSA0LCByYWRpYWxTZWdtZW50cyA9IDggKSB7XHJcblxyXG5cdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoKCk7XHJcblx0XHRwYXRoLmFic2FyYyggMCwgLSBsZW5ndGggLyAyLCByYWRpdXMsIE1hdGguUEkgKiAxLjUsIDAgKTtcclxuXHRcdHBhdGguYWJzYXJjKCAwLCBsZW5ndGggLyAyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAwLjUgKTtcclxuXHJcblx0XHRzdXBlciggcGF0aC5nZXRQb2ludHMoIGNhcFNlZ21lbnRzICksIHJhZGlhbFNlZ21lbnRzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0NhcHN1bGVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0aGVpZ2h0OiBsZW5ndGgsXHJcblx0XHRcdGNhcFNlZ21lbnRzOiBjYXBTZWdtZW50cyxcclxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBDYXBzdWxlR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmxlbmd0aCwgZGF0YS5jYXBTZWdtZW50cywgZGF0YS5yYWRpYWxTZWdtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDYXBzdWxlR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgQ2lyY2xlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBzZWdtZW50cyA9IDMyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMiApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0c2VnbWVudHMgPSBNYXRoLm1heCggMywgc2VnbWVudHMgKTtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuXHRcdGNvbnN0IHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdC8vIGNlbnRlciBwb2ludFxyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcclxuXHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xyXG5cdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IHMgPSAwLCBpID0gMzsgcyA8PSBzZWdtZW50czsgcyArKywgaSArPSAzICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcclxuXHJcblx0XHRcdC8vIHZlcnRleFxyXG5cclxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHQvLyBub3JtYWxcclxuXHJcblx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xyXG5cclxuXHRcdFx0Ly8gdXZzXHJcblxyXG5cdFx0XHR1di54ID0gKCB2ZXJ0aWNlc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcclxuXHRcdFx0dXYueSA9ICggdmVydGljZXNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xyXG5cclxuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBDaXJjbGVHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuc2VnbWVudHMsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgQ2lyY2xlR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgQ3lsaW5kZXJHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJhZGl1c1RvcCA9IDEsIHJhZGl1c0JvdHRvbSA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXHJcblx0XHRcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxyXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcclxuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKTtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuXHRcdGNvbnN0IHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHRsZXQgaW5kZXggPSAwO1xyXG5cdFx0Y29uc3QgaW5kZXhBcnJheSA9IFtdO1xyXG5cdFx0Y29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XHJcblx0XHRsZXQgZ3JvdXBTdGFydCA9IDA7XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnlcclxuXHJcblx0XHRnZW5lcmF0ZVRvcnNvKCk7XHJcblxyXG5cdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0aWYgKCByYWRpdXNUb3AgPiAwICkgZ2VuZXJhdGVDYXAoIHRydWUgKTtcclxuXHRcdFx0aWYgKCByYWRpdXNCb3R0b20gPiAwICkgZ2VuZXJhdGVDYXAoIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcclxuXHJcblx0XHRcdC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXHJcblx0XHRcdGNvbnN0IHNsb3BlID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuXHJcblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5kZXhSb3cgPSBbXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3MoIHRoZXRhICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcclxuXHRcdFx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGFsZkhlaWdodDtcclxuXHRcdFx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsLnNldCggc2luVGhldGEsIHNsb3BlLCBjb3NUaGV0YSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXZcclxuXHJcblx0XHRcdFx0XHR1dnMucHVzaCggdSwgMSAtIHYgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBzYXZlIGluZGV4IG9mIHZlcnRleCBpbiByZXNwZWN0aXZlIHJvd1xyXG5cclxuXHRcdFx0XHRcdGluZGV4Um93LnB1c2goIGluZGV4ICsrICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gbm93IHNhdmUgdmVydGljZXMgb2YgdGhlIHJvdyBpbiBvdXIgaW5kZXggYXJyYXlcclxuXHJcblx0XHRcdFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleFJvdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHdlIHVzZSB0aGUgaW5kZXggYXJyYXkgdG8gYWNjZXNzIHRoZSBjb3JyZWN0IGluZGljZXNcclxuXHJcblx0XHRcdFx0XHRjb25zdCBhID0gaW5kZXhBcnJheVsgeSBdWyB4IF07XHJcblx0XHRcdFx0XHRjb25zdCBiID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XHJcblx0XHRcdFx0XHRjb25zdCBkID0gaW5kZXhBcnJheVsgeSBdWyB4ICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdFx0XHQvLyB1cGRhdGUgZ3JvdXAgY291bnRlclxyXG5cclxuXHRcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcclxuXHJcblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCAwICk7XHJcblxyXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcclxuXHJcblx0XHRcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVDYXAoIHRvcCApIHtcclxuXHJcblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XHJcblx0XHRcdGNvbnN0IGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcclxuXHJcblx0XHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGxldCBncm91cENvdW50ID0gMDtcclxuXHJcblx0XHRcdGNvbnN0IHJhZGl1cyA9ICggdG9wID09PSB0cnVlICkgPyByYWRpdXNUb3AgOiByYWRpdXNCb3R0b207XHJcblx0XHRcdGNvbnN0IHNpZ24gPSAoIHRvcCA9PT0gdHJ1ZSApID8gMSA6IC0gMTtcclxuXHJcblx0XHRcdC8vIGZpcnN0IHdlIGdlbmVyYXRlIHRoZSBjZW50ZXIgdmVydGV4IGRhdGEgb2YgdGhlIGNhcC5cclxuXHRcdFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXHJcblx0XHRcdC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcclxuXHJcblx0XHRcdGZvciAoIGxldCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIDAsIGhhbGZIZWlnaHQgKiBzaWduLCAwICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbFxyXG5cclxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcclxuXHJcblx0XHRcdFx0Ly8gdXZcclxuXHJcblx0XHRcdFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XHJcblxyXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XHJcblxyXG5cdFx0XHRcdGluZGV4ICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxyXG5cdFx0XHRjb25zdCBjZW50ZXJJbmRleEVuZCA9IGluZGV4O1xyXG5cclxuXHRcdFx0Ly8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XHJcblx0XHRcdFx0Y29uc3QgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xyXG5cdFx0XHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRleFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xyXG5cdFx0XHRcdHZlcnRleC55ID0gaGFsZkhlaWdodCAqIHNpZ247XHJcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbFxyXG5cclxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcclxuXHJcblx0XHRcdFx0Ly8gdXZcclxuXHJcblx0XHRcdFx0dXYueCA9ICggY29zVGhldGEgKiAwLjUgKSArIDAuNTtcclxuXHRcdFx0XHR1di55ID0gKCBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKSArIDAuNTtcclxuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xyXG5cclxuXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxyXG5cclxuXHRcdFx0XHRpbmRleCArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGdlbmVyYXRlIGluZGljZXNcclxuXHJcblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjID0gY2VudGVySW5kZXhTdGFydCArIHg7XHJcblx0XHRcdFx0Y29uc3QgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcclxuXHJcblx0XHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmFjZSB0b3BcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBjICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmFjZSBib3R0b21cclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkgKyAxLCBpLCBjICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcclxuXHJcblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMiApO1xyXG5cclxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXHJcblxyXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KCBkYXRhLnJhZGl1c1RvcCwgZGF0YS5yYWRpdXNCb3R0b20sIGRhdGEuaGVpZ2h0LCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLm9wZW5FbmRlZCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBDeWxpbmRlckdlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IEN5bGluZGVyR2VvbWV0cnkgfSBmcm9tICcuL0N5bGluZGVyR2VvbWV0cnkuanMnO1xyXG5cclxuY2xhc3MgQ29uZUdlb21ldHJ5IGV4dGVuZHMgQ3lsaW5kZXJHZW9tZXRyeSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBoZWlnaHQgPSAxLCByYWRpYWxTZWdtZW50cyA9IDMyLCBoZWlnaHRTZWdtZW50cyA9IDEsIG9wZW5FbmRlZCA9IGZhbHNlLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICogMiApIHtcclxuXHJcblx0XHRzdXBlciggMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDb25lR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXHJcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBDb25lR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDb25lR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgUG9seWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggdmVydGljZXMgPSBbXSwgaW5kaWNlcyA9IFtdLCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXHJcblx0XHRcdGluZGljZXM6IGluZGljZXMsXHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXHJcblxyXG5cdFx0Y29uc3QgdmVydGV4QnVmZmVyID0gW107XHJcblx0XHRjb25zdCB1dkJ1ZmZlciA9IFtdO1xyXG5cclxuXHRcdC8vIHRoZSBzdWJkaXZpc2lvbiBjcmVhdGVzIHRoZSB2ZXJ0ZXggYnVmZmVyIGRhdGFcclxuXHJcblx0XHRzdWJkaXZpZGUoIGRldGFpbCApO1xyXG5cclxuXHRcdC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xyXG5cclxuXHRcdGFwcGx5UmFkaXVzKCByYWRpdXMgKTtcclxuXHJcblx0XHQvLyBmaW5hbGx5LCBjcmVhdGUgdGhlIHV2IGRhdGFcclxuXHJcblx0XHRnZW5lcmF0ZVVWcygpO1xyXG5cclxuXHRcdC8vIGJ1aWxkIG5vbi1pbmRleGVkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLnNsaWNlKCksIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XHJcblxyXG5cdFx0aWYgKCBkZXRhaWwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7IC8vIGZsYXQgbm9ybWFsc1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTsgLy8gc21vb3RoIG5vcm1hbHNcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xyXG5cclxuXHRcdGZ1bmN0aW9uIHN1YmRpdmlkZSggZGV0YWlsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdGNvbnN0IGIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgZmFjZXMgYW5kIGFwcGx5IGEgc3ViZGl2aXNpb24gd2l0aCB0aGUgZ2l2ZW4gZGV0YWlsIHZhbHVlXHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHQvLyBnZXQgdGhlIHZlcnRpY2VzIG9mIHRoZSBmYWNlXHJcblxyXG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAwIF0sIGEgKTtcclxuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMSBdLCBiICk7XHJcblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDIgXSwgYyApO1xyXG5cclxuXHRcdFx0XHQvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXHJcblxyXG5cdFx0XHRcdHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjb2xzID0gZGV0YWlsICsgMTtcclxuXHJcblx0XHRcdC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXHJcblxyXG5cdFx0XHRjb25zdCB2ID0gW107XHJcblxyXG5cdFx0XHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvblxyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZbIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBhaiA9IGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApO1xyXG5cdFx0XHRcdGNvbnN0IGJqID0gYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJvd3MgPSBjb2xzIC0gaTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IGFqO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2WyBpIF1bIGogXSA9IGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29sczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqICUgMiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xyXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcclxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XHJcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgKyAxIF0gKTtcclxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGFwcGx5UmFkaXVzKCByYWRpdXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xyXG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xyXG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0gPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0gPSB2ZXJ0ZXgueTtcclxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlclsgaSArIDEgXTtcclxuXHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgdSA9IGF6aW11dGgoIHZlcnRleCApIC8gMiAvIE1hdGguUEkgKyAwLjU7XHJcblx0XHRcdFx0Y29uc3QgdiA9IGluY2xpbmF0aW9uKCB2ZXJ0ZXggKSAvIE1hdGguUEkgKyAwLjU7XHJcblx0XHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvcnJlY3RVVnMoKTtcclxuXHJcblx0XHRcdGNvcnJlY3RTZWFtKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xyXG5cclxuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB1dkJ1ZmZlci5sZW5ndGg7IGkgKz0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXHJcblxyXG5cdFx0XHRcdGNvbnN0IHgwID0gdXZCdWZmZXJbIGkgKyAwIF07XHJcblx0XHRcdFx0Y29uc3QgeDEgPSB1dkJ1ZmZlclsgaSArIDIgXTtcclxuXHRcdFx0XHRjb25zdCB4MiA9IHV2QnVmZmVyWyBpICsgNCBdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBtYXggPSBNYXRoLm1heCggeDAsIHgxLCB4MiApO1xyXG5cdFx0XHRcdGNvbnN0IG1pbiA9IE1hdGgubWluKCB4MCwgeDEsIHgyICk7XHJcblxyXG5cdFx0XHRcdC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcclxuXHJcblx0XHRcdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggeDAgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDAgXSArPSAxO1xyXG5cdFx0XHRcdFx0aWYgKCB4MSA8IDAuMiApIHV2QnVmZmVyWyBpICsgMiBdICs9IDE7XHJcblx0XHRcdFx0XHRpZiAoIHgyIDwgMC4yICkgdXZCdWZmZXJbIGkgKyA0IF0gKz0gMTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwdXNoVmVydGV4KCB2ZXJ0ZXggKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ZXhCdWZmZXIucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KCBpbmRleCwgdmVydGV4ICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RyaWRlID0gaW5kZXggKiAzO1xyXG5cclxuXHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMCBdO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBzdHJpZGUgKyAxIF07XHJcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWcygpIHtcclxuXHJcblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRjb25zdCBiID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0Y29uc3QgYyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRjb25zdCBjZW50cm9pZCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRjb25zdCB1dkEgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRjb25zdCB1dkIgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRjb25zdCB1dkMgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBqID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gOSwgaiArPSA2ICkge1xyXG5cclxuXHRcdFx0XHRhLnNldCggdmVydGV4QnVmZmVyWyBpICsgMCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0sIHZlcnRleEJ1ZmZlclsgaSArIDIgXSApO1xyXG5cdFx0XHRcdGIuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyAzIF0sIHZlcnRleEJ1ZmZlclsgaSArIDQgXSwgdmVydGV4QnVmZmVyWyBpICsgNSBdICk7XHJcblx0XHRcdFx0Yy5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDYgXSwgdmVydGV4QnVmZmVyWyBpICsgNyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA4IF0gKTtcclxuXHJcblx0XHRcdFx0dXZBLnNldCggdXZCdWZmZXJbIGogKyAwIF0sIHV2QnVmZmVyWyBqICsgMSBdICk7XHJcblx0XHRcdFx0dXZCLnNldCggdXZCdWZmZXJbIGogKyAyIF0sIHV2QnVmZmVyWyBqICsgMyBdICk7XHJcblx0XHRcdFx0dXZDLnNldCggdXZCdWZmZXJbIGogKyA0IF0sIHV2QnVmZmVyWyBqICsgNSBdICk7XHJcblxyXG5cdFx0XHRcdGNlbnRyb2lkLmNvcHkoIGEgKS5hZGQoIGIgKS5hZGQoIGMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcclxuXHJcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkEsIGogKyAwLCBhLCBhemkgKTtcclxuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QiwgaiArIDIsIGIsIGF6aSApO1xyXG5cdFx0XHRcdGNvcnJlY3RVViggdXZDLCBqICsgNCwgYywgYXppICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHN0cmlkZSwgdmVjdG9yLCBhemltdXRoICkge1xyXG5cclxuXHRcdFx0aWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB7XHJcblxyXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IHV2LnggLSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAoIHZlY3Rvci54ID09PSAwICkgJiYgKCB2ZWN0b3IueiA9PT0gMCApICkge1xyXG5cclxuXHRcdFx0XHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cclxuXHJcblx0XHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cclxuXHJcblx0XHRmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIC0gdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQb2x5aGVkcm9uR2VvbWV0cnkoIGRhdGEudmVydGljZXMsIGRhdGEuaW5kaWNlcywgZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlscyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH0gZnJvbSAnLi9Qb2x5aGVkcm9uR2VvbWV0cnkuanMnO1xyXG5cclxuY2xhc3MgRG9kZWNhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcclxuXHJcblx0XHRjb25zdCB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XHJcblx0XHRjb25zdCByID0gMSAvIHQ7XHJcblxyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXHJcblxyXG5cdFx0XHQvLyAowrExLCDCsTEsIMKxMSlcclxuXHRcdFx0LSAxLCAtIDEsIC0gMSxcdC0gMSwgLSAxLCAxLFxyXG5cdFx0XHQtIDEsIDEsIC0gMSwgLSAxLCAxLCAxLFxyXG5cdFx0XHQxLCAtIDEsIC0gMSwgMSwgLSAxLCAxLFxyXG5cdFx0XHQxLCAxLCAtIDEsIDEsIDEsIDEsXHJcblxyXG5cdFx0XHQvLyAoMCwgwrExL8+GLCDCsc+GKVxyXG5cdFx0XHQwLCAtIHIsIC0gdCwgMCwgLSByLCB0LFxyXG5cdFx0XHQwLCByLCAtIHQsIDAsIHIsIHQsXHJcblxyXG5cdFx0XHQvLyAowrExL8+GLCDCsc+GLCAwKVxyXG5cdFx0XHQtIHIsIC0gdCwgMCwgLSByLCB0LCAwLFxyXG5cdFx0XHRyLCAtIHQsIDAsIHIsIHQsIDAsXHJcblxyXG5cdFx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxyXG5cdFx0XHQtIHQsIDAsIC0gciwgdCwgMCwgLSByLFxyXG5cdFx0XHQtIHQsIDAsIHIsIHQsIDAsIHJcclxuXHRcdF07XHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcclxuXHRcdFx0MywgMTEsIDcsIFx0MywgNywgMTUsIFx0MywgMTUsIDEzLFxyXG5cdFx0XHQ3LCAxOSwgMTcsIFx0NywgMTcsIDYsIFx0NywgNiwgMTUsXHJcblx0XHRcdDE3LCA0LCA4LCBcdDE3LCA4LCAxMCwgXHQxNywgMTAsIDYsXHJcblx0XHRcdDgsIDAsIDE2LCBcdDgsIDE2LCAyLCBcdDgsIDIsIDEwLFxyXG5cdFx0XHQwLCAxMiwgMSwgXHQwLCAxLCAxOCwgXHQwLCAxOCwgMTYsXHJcblx0XHRcdDYsIDEwLCAyLCBcdDYsIDIsIDEzLCBcdDYsIDEzLCAxNSxcclxuXHRcdFx0MiwgMTYsIDE4LCBcdDIsIDE4LCAzLCBcdDIsIDMsIDEzLFxyXG5cdFx0XHQxOCwgMSwgOSwgXHQxOCwgOSwgMTEsIFx0MTgsIDExLCAzLFxyXG5cdFx0XHQ0LCAxNCwgMTIsIFx0NCwgMTIsIDAsIFx0NCwgMCwgOCxcclxuXHRcdFx0MTEsIDksIDUsIFx0MTEsIDUsIDE5LCBcdDExLCAxOSwgNyxcclxuXHRcdFx0MTksIDUsIDE0LCBcdDE5LCAxNCwgNCwgXHQxOSwgNCwgMTcsXHJcblx0XHRcdDEsIDEyLCAxNCwgXHQxLCAxNCwgNSwgXHQxLCA1LCA5XHJcblx0XHRdO1xyXG5cclxuXHRcdHN1cGVyKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IERvZGVjYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IERvZGVjYWhlZHJvbkdlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcbmltcG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi4vbWF0aC9UcmlhbmdsZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9ub3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF90cmlhbmdsZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFRyaWFuZ2xlKCk7XHJcblxyXG5jbGFzcyBFZGdlc0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnkgPSBudWxsLCB0aHJlc2hvbGRBbmdsZSA9IDEgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXHJcblx0XHRcdHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcHJlY2lzaW9uUG9pbnRzID0gNDtcclxuXHRcdFx0Y29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcclxuXHRcdFx0Y29uc3QgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIE1hdGhVdGlscy5ERUcyUkFEICogdGhyZXNob2xkQW5nbGUgKTtcclxuXHJcblx0XHRcdGNvbnN0IGluZGV4QXR0ciA9IGdlb21ldHJ5LmdldEluZGV4KCk7XHJcblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0ciA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xyXG5cdFx0XHRjb25zdCBpbmRleENvdW50ID0gaW5kZXhBdHRyID8gaW5kZXhBdHRyLmNvdW50IDogcG9zaXRpb25BdHRyLmNvdW50O1xyXG5cclxuXHRcdFx0Y29uc3QgaW5kZXhBcnIgPSBbIDAsIDAsIDAgXTtcclxuXHRcdFx0Y29uc3QgdmVydEtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHRcdFx0Y29uc3QgaGFzaGVzID0gbmV3IEFycmF5KCAzICk7XHJcblxyXG5cdFx0XHRjb25zdCBlZGdlRGF0YSA9IHt9O1xyXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBpbmRleENvdW50OyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaW5kZXhBdHRyICkge1xyXG5cclxuXHRcdFx0XHRcdGluZGV4QXJyWyAwIF0gPSBpbmRleEF0dHIuZ2V0WCggaSApO1xyXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGluZGV4QXR0ci5nZXRYKCBpICsgMSApO1xyXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDIgXSA9IGluZGV4QXR0ci5nZXRYKCBpICsgMiApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGluZGV4QXJyWyAwIF0gPSBpO1xyXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDEgXSA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0aW5kZXhBcnJbIDIgXSA9IGkgKyAyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgYSwgYiwgYyB9ID0gX3RyaWFuZ2xlO1xyXG5cdFx0XHRcdGEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleEFyclsgMCBdICk7XHJcblx0XHRcdFx0Yi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4QXJyWyAxIF0gKTtcclxuXHRcdFx0XHRjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDIgXSApO1xyXG5cdFx0XHRcdF90cmlhbmdsZS5nZXROb3JtYWwoIF9ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0Ly8gY3JlYXRlIGhhc2hlcyBmb3IgdGhlIGVkZ2UgZnJvbSB0aGUgdmVydGljZXNcclxuXHRcdFx0XHRoYXNoZXNbIDAgXSA9IGAkeyBNYXRoLnJvdW5kKCBhLnggKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGEueSAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYS56ICogcHJlY2lzaW9uICkgfWA7XHJcblx0XHRcdFx0aGFzaGVzWyAxIF0gPSBgJHsgTWF0aC5yb3VuZCggYi54ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBiLnkgKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGIueiAqIHByZWNpc2lvbiApIH1gO1xyXG5cdFx0XHRcdGhhc2hlc1sgMiBdID0gYCR7IE1hdGgucm91bmQoIGMueCAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYy55ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBjLnogKiBwcmVjaXNpb24gKSB9YDtcclxuXHJcblx0XHRcdFx0Ly8gc2tpcCBkZWdlbmVyYXRlIHRyaWFuZ2xlc1xyXG5cdFx0XHRcdGlmICggaGFzaGVzWyAwIF0gPT09IGhhc2hlc1sgMSBdIHx8IGhhc2hlc1sgMSBdID09PSBoYXNoZXNbIDIgXSB8fCBoYXNoZXNbIDIgXSA9PT0gaGFzaGVzWyAwIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2VcclxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGdldCB0aGUgZmlyc3QgYW5kIG5leHQgdmVydGV4IG1ha2luZyB1cCB0aGUgZWRnZVxyXG5cdFx0XHRcdFx0Y29uc3Qgak5leHQgPSAoIGogKyAxICkgJSAzO1xyXG5cdFx0XHRcdFx0Y29uc3QgdmVjSGFzaDAgPSBoYXNoZXNbIGogXTtcclxuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gxID0gaGFzaGVzWyBqTmV4dCBdO1xyXG5cdFx0XHRcdFx0Y29uc3QgdjAgPSBfdHJpYW5nbGVbIHZlcnRLZXlzWyBqIF0gXTtcclxuXHRcdFx0XHRcdGNvbnN0IHYxID0gX3RyaWFuZ2xlWyB2ZXJ0S2V5c1sgak5leHQgXSBdO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGhhc2ggPSBgJHsgdmVjSGFzaDAgfV8keyB2ZWNIYXNoMSB9YDtcclxuXHRcdFx0XHRcdGNvbnN0IHJldmVyc2VIYXNoID0gYCR7IHZlY0hhc2gxIH1fJHsgdmVjSGFzaDAgfWA7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZXZlcnNlSGFzaCBpbiBlZGdlRGF0YSAmJiBlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGlmIHdlIGZvdW5kIGEgc2libGluZyBlZGdlIGFkZCBpdCBpbnRvIHRoZSB2ZXJ0ZXggYXJyYXkgaWZcclxuXHRcdFx0XHRcdFx0Ly8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cclxuXHRcdFx0XHRcdFx0aWYgKCBfbm9ybWFsLmRvdCggZWRnZURhdGFbIHJldmVyc2VIYXNoIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2MC54LCB2MC55LCB2MC56ICk7XHJcblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0ZWRnZURhdGFbIHJldmVyc2VIYXNoIF0gPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEgKCBoYXNoIGluIGVkZ2VEYXRhICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBlZGdlIGhlcmUgdGhlbiBza2lwIGFkZGluZyBhIG5ldyBvbmVcclxuXHRcdFx0XHRcdFx0ZWRnZURhdGFbIGhhc2ggXSA9IHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW5kZXgwOiBpbmRleEFyclsgaiBdLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4MTogaW5kZXhBcnJbIGpOZXh0IF0sXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsOiBfbm9ybWFsLmNsb25lKCksXHJcblxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcsIHVubWF0Y2hlZCBlZGdlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZlcnRleCBhcnJheVxyXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gZWRnZURhdGEgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZWRnZURhdGFbIGtleSBdICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHsgaW5kZXgwLCBpbmRleDEgfSA9IGVkZ2VEYXRhWyBrZXkgXTtcclxuXHRcdFx0XHRcdF92MC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHIsIGluZGV4MCApO1xyXG5cdFx0XHRcdFx0X3YxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXgxICk7XHJcblxyXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggX3YwLngsIF92MC55LCBfdjAueiApO1xyXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggX3YxLngsIF92MS55LCBfdjEueiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBFZGdlc0dlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IFBhdGggfSBmcm9tICcuL1BhdGguanMnO1xyXG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5cclxuY2xhc3MgU2hhcGUgZXh0ZW5kcyBQYXRoIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBvaW50cyApIHtcclxuXHJcblx0XHRzdXBlciggcG9pbnRzICk7XHJcblxyXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZSc7XHJcblxyXG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0Y29uc3QgaG9sZXNQdHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBob2xlc1B0cztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcclxuXHJcblx0ZXh0cmFjdFBvaW50cyggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRzaGFwZTogdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApLFxyXG5cdFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmhvbGVzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBob2xlID0gc291cmNlLmhvbGVzWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLmhvbGVzLnB1c2goIGhvbGUuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdGRhdGEuaG9sZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBob2xlID0gdGhpcy5ob2xlc1sgaSBdO1xyXG5cdFx0XHRkYXRhLmhvbGVzLnB1c2goIGhvbGUudG9KU09OKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0ZnJvbUpTT04oIGpzb24gKSB7XHJcblxyXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XHJcblx0XHR0aGlzLmhvbGVzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgaG9sZSA9IGpzb24uaG9sZXNbIGkgXTtcclxuXHRcdFx0dGhpcy5ob2xlcy5wdXNoKCBuZXcgUGF0aCgpLmZyb21KU09OKCBob2xlICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBTaGFwZSB9O1xyXG4iLCIvKipcclxuICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4yLjQpXHJcbiAqL1xyXG5cclxuY29uc3QgRWFyY3V0ID0ge1xyXG5cclxuXHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKCBkYXRhLCBob2xlSW5kaWNlcywgZGltID0gMiApIHtcclxuXHJcblx0XHRjb25zdCBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcclxuXHRcdGNvbnN0IG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1sgMCBdICogZGltIDogZGF0YS5sZW5ndGg7XHJcblx0XHRsZXQgb3V0ZXJOb2RlID0gbGlua2VkTGlzdCggZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSApO1xyXG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gW107XHJcblxyXG5cdFx0aWYgKCAhIG91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYgKSByZXR1cm4gdHJpYW5nbGVzO1xyXG5cclxuXHRcdGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xyXG5cclxuXHRcdGlmICggaGFzSG9sZXMgKSBvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlcyggZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltICk7XHJcblxyXG5cdFx0Ly8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XHJcblx0XHRpZiAoIGRhdGEubGVuZ3RoID4gODAgKiBkaW0gKSB7XHJcblxyXG5cdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcclxuXHRcdFx0bWluWSA9IG1heFkgPSBkYXRhWyAxIF07XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSApIHtcclxuXHJcblx0XHRcdFx0eCA9IGRhdGFbIGkgXTtcclxuXHRcdFx0XHR5ID0gZGF0YVsgaSArIDEgXTtcclxuXHRcdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XHJcblx0XHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcclxuXHRcdFx0XHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxyXG5cdFx0XHRpbnZTaXplID0gTWF0aC5tYXgoIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSApO1xyXG5cdFx0XHRpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDMyNzY3IC8gaW52U2l6ZSA6IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGVhcmN1dExpbmtlZCggb3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCApO1xyXG5cclxuXHRcdHJldHVybiB0cmlhbmdsZXM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcclxuZnVuY3Rpb24gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UgKSB7XHJcblxyXG5cdGxldCBpLCBsYXN0O1xyXG5cclxuXHRpZiAoIGNsb2Nrd2lzZSA9PT0gKCBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSA+IDAgKSApIHtcclxuXHJcblx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGZvciAoIGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbGFzdCAmJiBlcXVhbHMoIGxhc3QsIGxhc3QubmV4dCApICkge1xyXG5cclxuXHRcdHJlbW92ZU5vZGUoIGxhc3QgKTtcclxuXHRcdGxhc3QgPSBsYXN0Lm5leHQ7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGxhc3Q7XHJcblxyXG59XHJcblxyXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xyXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdGlmICggISBzdGFydCApIHJldHVybiBzdGFydDtcclxuXHRpZiAoICEgZW5kICkgZW5kID0gc3RhcnQ7XHJcblxyXG5cdGxldCBwID0gc3RhcnQsXHJcblx0XHRhZ2FpbjtcclxuXHRkbyB7XHJcblxyXG5cdFx0YWdhaW4gPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoICEgcC5zdGVpbmVyICYmICggZXF1YWxzKCBwLCBwLm5leHQgKSB8fCBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID09PSAwICkgKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVOb2RlKCBwICk7XHJcblx0XHRcdHAgPSBlbmQgPSBwLnByZXY7XHJcblx0XHRcdGlmICggcCA9PT0gcC5uZXh0ICkgYnJlYWs7XHJcblx0XHRcdGFnYWluID0gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cCA9IHAubmV4dDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gd2hpbGUgKCBhZ2FpbiB8fCBwICE9PSBlbmQgKTtcclxuXHJcblx0cmV0dXJuIGVuZDtcclxuXHJcbn1cclxuXHJcbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxyXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MgKSB7XHJcblxyXG5cdGlmICggISBlYXIgKSByZXR1cm47XHJcblxyXG5cdC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuXHRpZiAoICEgcGFzcyAmJiBpbnZTaXplICkgaW5kZXhDdXJ2ZSggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblxyXG5cdGxldCBzdG9wID0gZWFyLFxyXG5cdFx0cHJldiwgbmV4dDtcclxuXHJcblx0Ly8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXHJcblx0d2hpbGUgKCBlYXIucHJldiAhPT0gZWFyLm5leHQgKSB7XHJcblxyXG5cdFx0cHJldiA9IGVhci5wcmV2O1xyXG5cdFx0bmV4dCA9IGVhci5uZXh0O1xyXG5cclxuXHRcdGlmICggaW52U2l6ZSA/IGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSA6IGlzRWFyKCBlYXIgKSApIHtcclxuXHJcblx0XHRcdC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBwcmV2LmkgLyBkaW0gfCAwICk7XHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBlYXIuaSAvIGRpbSB8IDAgKTtcclxuXHRcdFx0dHJpYW5nbGVzLnB1c2goIG5leHQuaSAvIGRpbSB8IDAgKTtcclxuXHJcblx0XHRcdHJlbW92ZU5vZGUoIGVhciApO1xyXG5cclxuXHRcdFx0Ly8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xyXG5cdFx0XHRlYXIgPSBuZXh0Lm5leHQ7XHJcblx0XHRcdHN0b3AgPSBuZXh0Lm5leHQ7XHJcblxyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZWFyID0gbmV4dDtcclxuXHJcblx0XHQvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xyXG5cdFx0aWYgKCBlYXIgPT09IHN0b3AgKSB7XHJcblxyXG5cdFx0XHQvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxyXG5cdFx0XHRpZiAoICEgcGFzcyApIHtcclxuXHJcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBmaWx0ZXJQb2ludHMoIGVhciApLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSApO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0ZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggZmlsdGVyUG9pbnRzKCBlYXIgKSwgdHJpYW5nbGVzLCBkaW0gKTtcclxuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIgKTtcclxuXHJcblx0XHRcdFx0Ly8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdHNwbGl0RWFyY3V0KCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xyXG5mdW5jdGlvbiBpc0VhciggZWFyICkge1xyXG5cclxuXHRjb25zdCBhID0gZWFyLnByZXYsXHJcblx0XHRiID0gZWFyLFxyXG5cdFx0YyA9IGVhci5uZXh0O1xyXG5cclxuXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuXHQvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxyXG5cdGNvbnN0IGF4ID0gYS54LCBieCA9IGIueCwgY3ggPSBjLngsIGF5ID0gYS55LCBieSA9IGIueSwgY3kgPSBjLnk7XHJcblxyXG5cdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXHJcblx0Y29uc3QgeDAgPSBheCA8IGJ4ID8gKCBheCA8IGN4ID8gYXggOiBjeCApIDogKCBieCA8IGN4ID8gYnggOiBjeCApLFxyXG5cdFx0eTAgPSBheSA8IGJ5ID8gKCBheSA8IGN5ID8gYXkgOiBjeSApIDogKCBieSA8IGN5ID8gYnkgOiBjeSApLFxyXG5cdFx0eDEgPSBheCA+IGJ4ID8gKCBheCA+IGN4ID8gYXggOiBjeCApIDogKCBieCA+IGN4ID8gYnggOiBjeCApLFxyXG5cdFx0eTEgPSBheSA+IGJ5ID8gKCBheSA+IGN5ID8gYXkgOiBjeSApIDogKCBieSA+IGN5ID8gYnkgOiBjeSApO1xyXG5cclxuXHRsZXQgcCA9IGMubmV4dDtcclxuXHR3aGlsZSAoIHAgIT09IGEgKSB7XHJcblxyXG5cdFx0aWYgKCBwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiZcclxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmXHJcblx0XHRcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcclxuXHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xyXG5cclxuXHRjb25zdCBhID0gZWFyLnByZXYsXHJcblx0XHRiID0gZWFyLFxyXG5cdFx0YyA9IGVhci5uZXh0O1xyXG5cclxuXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuXHRjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xyXG5cclxuXHQvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxyXG5cdGNvbnN0IHgwID0gYXggPCBieCA/ICggYXggPCBjeCA/IGF4IDogY3ggKSA6ICggYnggPCBjeCA/IGJ4IDogY3ggKSxcclxuXHRcdHkwID0gYXkgPCBieSA/ICggYXkgPCBjeSA/IGF5IDogY3kgKSA6ICggYnkgPCBjeSA/IGJ5IDogY3kgKSxcclxuXHRcdHgxID0gYXggPiBieCA/ICggYXggPiBjeCA/IGF4IDogY3ggKSA6ICggYnggPiBjeCA/IGJ4IDogY3ggKSxcclxuXHRcdHkxID0gYXkgPiBieSA/ICggYXkgPiBjeSA/IGF5IDogY3kgKSA6ICggYnkgPiBjeSA/IGJ5IDogY3kgKTtcclxuXHJcblx0Ly8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcclxuXHRjb25zdCBtaW5aID0gek9yZGVyKCB4MCwgeTAsIG1pblgsIG1pblksIGludlNpemUgKSxcclxuXHRcdG1heFogPSB6T3JkZXIoIHgxLCB5MSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cclxuXHRsZXQgcCA9IGVhci5wcmV2WixcclxuXHRcdG4gPSBlYXIubmV4dFo7XHJcblxyXG5cdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xyXG5cdHdoaWxlICggcCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaICkge1xyXG5cclxuXHRcdGlmICggcC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxyXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0cCA9IHAucHJldlo7XHJcblxyXG5cdFx0aWYgKCBuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXHJcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkgKSAmJiBhcmVhKCBuLnByZXYsIG4sIG4ubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XHJcblx0XHRuID0gbi5uZXh0WjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxyXG5cdHdoaWxlICggcCAmJiBwLnogPj0gbWluWiApIHtcclxuXHJcblx0XHRpZiAoIHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcclxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmIGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcclxuXHRcdHAgPSBwLnByZXZaO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXHJcblx0d2hpbGUgKCBuICYmIG4ueiA8PSBtYXhaICkge1xyXG5cclxuXHRcdGlmICggbi54ID49IHgwICYmIG4ueCA8PSB4MSAmJiBuLnkgPj0geTAgJiYgbi55IDw9IHkxICYmIG4gIT09IGEgJiYgbiAhPT0gYyAmJlxyXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55ICkgJiYgYXJlYSggbi5wcmV2LCBuLCBuLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0biA9IG4ubmV4dFo7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcblxyXG59XHJcblxyXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xyXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBzdGFydCwgdHJpYW5nbGVzLCBkaW0gKSB7XHJcblxyXG5cdGxldCBwID0gc3RhcnQ7XHJcblx0ZG8ge1xyXG5cclxuXHRcdGNvbnN0IGEgPSBwLnByZXYsXHJcblx0XHRcdGIgPSBwLm5leHQubmV4dDtcclxuXHJcblx0XHRpZiAoICEgZXF1YWxzKCBhLCBiICkgJiYgaW50ZXJzZWN0cyggYSwgcCwgcC5uZXh0LCBiICkgJiYgbG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSApIHtcclxuXHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBhLmkgLyBkaW0gfCAwICk7XHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBwLmkgLyBkaW0gfCAwICk7XHJcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBiLmkgLyBkaW0gfCAwICk7XHJcblxyXG5cdFx0XHQvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXHJcblx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcclxuXHRcdFx0cmVtb3ZlTm9kZSggcC5uZXh0ICk7XHJcblxyXG5cdFx0XHRwID0gc3RhcnQgPSBiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcclxuXHJcblx0cmV0dXJuIGZpbHRlclBvaW50cyggcCApO1xyXG5cclxufVxyXG5cclxuLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcclxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cclxuXHRsZXQgYSA9IHN0YXJ0O1xyXG5cdGRvIHtcclxuXHJcblx0XHRsZXQgYiA9IGEubmV4dC5uZXh0O1xyXG5cdFx0d2hpbGUgKCBiICE9PSBhLnByZXYgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbCggYSwgYiApICkge1xyXG5cclxuXHRcdFx0XHQvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXHJcblx0XHRcdFx0bGV0IGMgPSBzcGxpdFBvbHlnb24oIGEsIGIgKTtcclxuXHJcblx0XHRcdFx0Ly8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcclxuXHRcdFx0XHRhID0gZmlsdGVyUG9pbnRzKCBhLCBhLm5leHQgKTtcclxuXHRcdFx0XHRjID0gZmlsdGVyUG9pbnRzKCBjLCBjLm5leHQgKTtcclxuXHJcblx0XHRcdFx0Ly8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcclxuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwICk7XHJcblx0XHRcdFx0ZWFyY3V0TGlua2VkKCBjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGIgPSBiLm5leHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGEgPSBhLm5leHQ7XHJcblxyXG5cdH0gd2hpbGUgKCBhICE9PSBzdGFydCApO1xyXG5cclxufVxyXG5cclxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xyXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyggZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltICkge1xyXG5cclxuXHRjb25zdCBxdWV1ZSA9IFtdO1xyXG5cdGxldCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0c3RhcnQgPSBob2xlSW5kaWNlc1sgaSBdICogZGltO1xyXG5cdFx0ZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1sgaSArIDEgXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG5cdFx0bGlzdCA9IGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UgKTtcclxuXHRcdGlmICggbGlzdCA9PT0gbGlzdC5uZXh0ICkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcclxuXHRcdHF1ZXVlLnB1c2goIGdldExlZnRtb3N0KCBsaXN0ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRxdWV1ZS5zb3J0KCBjb21wYXJlWCApO1xyXG5cclxuXHQvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxyXG5cdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGUoIHF1ZXVlWyBpIF0sIG91dGVyTm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvdXRlck5vZGU7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wYXJlWCggYSwgYiApIHtcclxuXHJcblx0cmV0dXJuIGEueCAtIGIueDtcclxuXHJcbn1cclxuXHJcbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBsaW5rIGl0XHJcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoIGhvbGUsIG91dGVyTm9kZSApIHtcclxuXHJcblx0Y29uc3QgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApO1xyXG5cdGlmICggISBicmlkZ2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG91dGVyTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdCBicmlkZ2VSZXZlcnNlID0gc3BsaXRQb2x5Z29uKCBicmlkZ2UsIGhvbGUgKTtcclxuXHJcblx0Ly8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXHJcblx0ZmlsdGVyUG9pbnRzKCBicmlkZ2VSZXZlcnNlLCBicmlkZ2VSZXZlcnNlLm5leHQgKTtcclxuXHRyZXR1cm4gZmlsdGVyUG9pbnRzKCBicmlkZ2UsIGJyaWRnZS5uZXh0ICk7XHJcblxyXG59XHJcblxyXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXHJcbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKSB7XHJcblxyXG5cdGxldCBwID0gb3V0ZXJOb2RlLFxyXG5cdFx0cXggPSAtIEluZmluaXR5LFxyXG5cdFx0bTtcclxuXHJcblx0Y29uc3QgaHggPSBob2xlLngsIGh5ID0gaG9sZS55O1xyXG5cclxuXHQvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XHJcblx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoIGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55ICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeCA9IHAueCArICggaHkgLSBwLnkgKSAqICggcC5uZXh0LnggLSBwLnggKSAvICggcC5uZXh0LnkgLSBwLnkgKTtcclxuXHRcdFx0aWYgKCB4IDw9IGh4ICYmIHggPiBxeCApIHtcclxuXHJcblx0XHRcdFx0cXggPSB4O1xyXG5cdFx0XHRcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XHJcblx0XHRcdFx0aWYgKCB4ID09PSBoeCApIHJldHVybiBtOyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsZWZ0bW9zdCBlbmRwb2ludFxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gb3V0ZXJOb2RlICk7XHJcblxyXG5cdGlmICggISBtICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcclxuXHQvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcclxuXHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxyXG5cclxuXHRjb25zdCBzdG9wID0gbSxcclxuXHRcdG14ID0gbS54LFxyXG5cdFx0bXkgPSBtLnk7XHJcblx0bGV0IHRhbk1pbiA9IEluZmluaXR5LCB0YW47XHJcblxyXG5cdHAgPSBtO1xyXG5cclxuXHRkbyB7XHJcblxyXG5cdFx0aWYgKCBoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcclxuXHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55ICkgKSB7XHJcblxyXG5cdFx0XHR0YW4gPSBNYXRoLmFicyggaHkgLSBwLnkgKSAvICggaHggLSBwLnggKTsgLy8gdGFuZ2VudGlhbFxyXG5cclxuXHRcdFx0aWYgKCBsb2NhbGx5SW5zaWRlKCBwLCBob2xlICkgJiYgKCB0YW4gPCB0YW5NaW4gfHwgKCB0YW4gPT09IHRhbk1pbiAmJiAoIHAueCA+IG0ueCB8fCAoIHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKCBtLCBwICkgKSApICkgKSApIHtcclxuXHJcblx0XHRcdFx0bSA9IHA7XHJcblx0XHRcdFx0dGFuTWluID0gdGFuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gc3RvcCApO1xyXG5cclxuXHRyZXR1cm4gbTtcclxuXHJcbn1cclxuXHJcbi8vIHdoZXRoZXIgc2VjdG9yIGluIHZlcnRleCBtIGNvbnRhaW5zIHNlY3RvciBpbiB2ZXJ0ZXggcCBpbiB0aGUgc2FtZSBjb29yZGluYXRlc1xyXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvciggbSwgcCApIHtcclxuXHJcblx0cmV0dXJuIGFyZWEoIG0ucHJldiwgbSwgcC5wcmV2ICkgPCAwICYmIGFyZWEoIHAubmV4dCwgbSwgbS5uZXh0ICkgPCAwO1xyXG5cclxufVxyXG5cclxuLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxyXG5mdW5jdGlvbiBpbmRleEN1cnZlKCBzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0bGV0IHAgPSBzdGFydDtcclxuXHRkbyB7XHJcblxyXG5cdFx0aWYgKCBwLnogPT09IDAgKSBwLnogPSB6T3JkZXIoIHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XHJcblx0XHRwLnByZXZaID0gcC5wcmV2O1xyXG5cdFx0cC5uZXh0WiA9IHAubmV4dDtcclxuXHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xyXG5cclxuXHRwLnByZXZaLm5leHRaID0gbnVsbDtcclxuXHRwLnByZXZaID0gbnVsbDtcclxuXHJcblx0c29ydExpbmtlZCggcCApO1xyXG5cclxufVxyXG5cclxuLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cclxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcclxuZnVuY3Rpb24gc29ydExpbmtlZCggbGlzdCApIHtcclxuXHJcblx0bGV0IGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxyXG5cdFx0aW5TaXplID0gMTtcclxuXHJcblx0ZG8ge1xyXG5cclxuXHRcdHAgPSBsaXN0O1xyXG5cdFx0bGlzdCA9IG51bGw7XHJcblx0XHR0YWlsID0gbnVsbDtcclxuXHRcdG51bU1lcmdlcyA9IDA7XHJcblxyXG5cdFx0d2hpbGUgKCBwICkge1xyXG5cclxuXHRcdFx0bnVtTWVyZ2VzICsrO1xyXG5cdFx0XHRxID0gcDtcclxuXHRcdFx0cFNpemUgPSAwO1xyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGluU2l6ZTsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0cFNpemUgKys7XHJcblx0XHRcdFx0cSA9IHEubmV4dFo7XHJcblx0XHRcdFx0aWYgKCAhIHEgKSBicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHFTaXplID0gaW5TaXplO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBwU2l6ZSA+IDAgfHwgKCBxU2l6ZSA+IDAgJiYgcSApICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBTaXplICE9PSAwICYmICggcVNpemUgPT09IDAgfHwgISBxIHx8IHAueiA8PSBxLnogKSApIHtcclxuXHJcblx0XHRcdFx0XHRlID0gcDtcclxuXHRcdFx0XHRcdHAgPSBwLm5leHRaO1xyXG5cdFx0XHRcdFx0cFNpemUgLS07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZSA9IHE7XHJcblx0XHRcdFx0XHRxID0gcS5uZXh0WjtcclxuXHRcdFx0XHRcdHFTaXplIC0tO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xyXG5cdFx0XHRcdGVsc2UgbGlzdCA9IGU7XHJcblxyXG5cdFx0XHRcdGUucHJldlogPSB0YWlsO1xyXG5cdFx0XHRcdHRhaWwgPSBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cCA9IHE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRhaWwubmV4dFogPSBudWxsO1xyXG5cdFx0aW5TaXplICo9IDI7XHJcblxyXG5cdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XHJcblxyXG5cdHJldHVybiBsaXN0O1xyXG5cclxufVxyXG5cclxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XHJcbmZ1bmN0aW9uIHpPcmRlciggeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxyXG5cdHggPSAoIHggLSBtaW5YICkgKiBpbnZTaXplIHwgMDtcclxuXHR5ID0gKCB5IC0gbWluWSApICogaW52U2l6ZSB8IDA7XHJcblxyXG5cdHggPSAoIHggfCAoIHggPDwgOCApICkgJiAweDAwRkYwMEZGO1xyXG5cdHggPSAoIHggfCAoIHggPDwgNCApICkgJiAweDBGMEYwRjBGO1xyXG5cdHggPSAoIHggfCAoIHggPDwgMiApICkgJiAweDMzMzMzMzMzO1xyXG5cdHggPSAoIHggfCAoIHggPDwgMSApICkgJiAweDU1NTU1NTU1O1xyXG5cclxuXHR5ID0gKCB5IHwgKCB5IDw8IDggKSApICYgMHgwMEZGMDBGRjtcclxuXHR5ID0gKCB5IHwgKCB5IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcclxuXHR5ID0gKCB5IHwgKCB5IDw8IDIgKSApICYgMHgzMzMzMzMzMztcclxuXHR5ID0gKCB5IHwgKCB5IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcclxuXHJcblx0cmV0dXJuIHggfCAoIHkgPDwgMSApO1xyXG5cclxufVxyXG5cclxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xyXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdCggc3RhcnQgKSB7XHJcblxyXG5cdGxldCBwID0gc3RhcnQsXHJcblx0XHRsZWZ0bW9zdCA9IHN0YXJ0O1xyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoIHAueCA8IGxlZnRtb3N0LnggfHwgKCBwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSApICkgbGVmdG1vc3QgPSBwO1xyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XHJcblxyXG5cdHJldHVybiBsZWZ0bW9zdDtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcclxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkgKSB7XHJcblxyXG5cdHJldHVybiAoIGN4IC0gcHggKSAqICggYXkgLSBweSApID49ICggYXggLSBweCApICogKCBjeSAtIHB5ICkgJiZcclxuICAgICAgICAgICAoIGF4IC0gcHggKSAqICggYnkgLSBweSApID49ICggYnggLSBweCApICogKCBheSAtIHB5ICkgJiZcclxuICAgICAgICAgICAoIGJ4IC0gcHggKSAqICggY3kgLSBweSApID49ICggY3ggLSBweCApICogKCBieSAtIHB5ICk7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcclxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKCBhLCBiICkge1xyXG5cclxuXHRyZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICEgaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSAmJiAvLyBkb25lcyd0IGludGVyc2VjdCBvdGhlciBlZGdlc1xyXG4gICAgICAgICAgICggbG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSAmJiBtaWRkbGVJbnNpZGUoIGEsIGIgKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcclxuICAgICAgICAgICAgKCBhcmVhKCBhLnByZXYsIGEsIGIucHJldiApIHx8IGFyZWEoIGEsIGIucHJldiwgYiApICkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXHJcbiAgICAgICAgICAgIGVxdWFscyggYSwgYiApICYmIGFyZWEoIGEucHJldiwgYSwgYS5uZXh0ICkgPiAwICYmIGFyZWEoIGIucHJldiwgYiwgYi5uZXh0ICkgPiAwICk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxyXG5cclxufVxyXG5cclxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxyXG5mdW5jdGlvbiBhcmVhKCBwLCBxLCByICkge1xyXG5cclxuXHRyZXR1cm4gKCBxLnkgLSBwLnkgKSAqICggci54IC0gcS54ICkgLSAoIHEueCAtIHAueCApICogKCByLnkgLSBxLnkgKTtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXHJcbmZ1bmN0aW9uIGVxdWFscyggcDEsIHAyICkge1xyXG5cclxuXHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xyXG5cclxufVxyXG5cclxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxyXG5mdW5jdGlvbiBpbnRlcnNlY3RzKCBwMSwgcTEsIHAyLCBxMiApIHtcclxuXHJcblx0Y29uc3QgbzEgPSBzaWduKCBhcmVhKCBwMSwgcTEsIHAyICkgKTtcclxuXHRjb25zdCBvMiA9IHNpZ24oIGFyZWEoIHAxLCBxMSwgcTIgKSApO1xyXG5cdGNvbnN0IG8zID0gc2lnbiggYXJlYSggcDIsIHEyLCBwMSApICk7XHJcblx0Y29uc3QgbzQgPSBzaWduKCBhcmVhKCBwMiwgcTIsIHExICkgKTtcclxuXHJcblx0aWYgKCBvMSAhPT0gbzIgJiYgbzMgIT09IG80ICkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxyXG5cclxuXHRpZiAoIG8xID09PSAwICYmIG9uU2VnbWVudCggcDEsIHAyLCBxMSApICkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXHJcblx0aWYgKCBvMiA9PT0gMCAmJiBvblNlZ21lbnQoIHAxLCBxMiwgcTEgKSApIHJldHVybiB0cnVlOyAvLyBwMSwgcTEgYW5kIHEyIGFyZSBjb2xsaW5lYXIgYW5kIHEyIGxpZXMgb24gcDFxMVxyXG5cdGlmICggbzMgPT09IDAgJiYgb25TZWdtZW50KCBwMiwgcDEsIHEyICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDIsIHEyIGFuZCBwMSBhcmUgY29sbGluZWFyIGFuZCBwMSBsaWVzIG9uIHAycTJcclxuXHRpZiAoIG80ID09PSAwICYmIG9uU2VnbWVudCggcDIsIHExLCBxMiApICkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXHJcblxyXG5cdHJldHVybiBmYWxzZTtcclxuXHJcbn1cclxuXHJcbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXHJcbmZ1bmN0aW9uIG9uU2VnbWVudCggcCwgcSwgciApIHtcclxuXHJcblx0cmV0dXJuIHEueCA8PSBNYXRoLm1heCggcC54LCByLnggKSAmJiBxLnggPj0gTWF0aC5taW4oIHAueCwgci54ICkgJiYgcS55IDw9IE1hdGgubWF4KCBwLnksIHIueSApICYmIHEueSA+PSBNYXRoLm1pbiggcC55LCByLnkgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpZ24oIG51bSApIHtcclxuXHJcblx0cmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0gMSA6IDA7XHJcblxyXG59XHJcblxyXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xyXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApIHtcclxuXHJcblx0bGV0IHAgPSBhO1xyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoIHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxyXG5cdFx0XHRpbnRlcnNlY3RzKCBwLCBwLm5leHQsIGEsIGIgKSApIHJldHVybiB0cnVlO1xyXG5cdFx0cCA9IHAubmV4dDtcclxuXHJcblx0fSB3aGlsZSAoIHAgIT09IGEgKTtcclxuXHJcblx0cmV0dXJuIGZhbHNlO1xyXG5cclxufVxyXG5cclxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXHJcbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSB7XHJcblxyXG5cdHJldHVybiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApIDwgMCA/XHJcblx0XHRhcmVhKCBhLCBiLCBhLm5leHQgKSA+PSAwICYmIGFyZWEoIGEsIGEucHJldiwgYiApID49IDAgOlxyXG5cdFx0YXJlYSggYSwgYiwgYS5wcmV2ICkgPCAwIHx8IGFyZWEoIGEsIGEubmV4dCwgYiApIDwgMDtcclxuXHJcbn1cclxuXHJcbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxyXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoIGEsIGIgKSB7XHJcblxyXG5cdGxldCBwID0gYSxcclxuXHRcdGluc2lkZSA9IGZhbHNlO1xyXG5cdGNvbnN0IHB4ID0gKCBhLnggKyBiLnggKSAvIDIsXHJcblx0XHRweSA9ICggYS55ICsgYi55ICkgLyAyO1xyXG5cdGRvIHtcclxuXHJcblx0XHRpZiAoICggKCBwLnkgPiBweSApICE9PSAoIHAubmV4dC55ID4gcHkgKSApICYmIHAubmV4dC55ICE9PSBwLnkgJiZcclxuXHRcdFx0KCBweCA8ICggcC5uZXh0LnggLSBwLnggKSAqICggcHkgLSBwLnkgKSAvICggcC5uZXh0LnkgLSBwLnkgKSArIHAueCApIClcclxuXHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHJcblx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHR9IHdoaWxlICggcCAhPT0gYSApO1xyXG5cclxuXHRyZXR1cm4gaW5zaWRlO1xyXG5cclxufVxyXG5cclxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xyXG4vLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcclxuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKCBhLCBiICkge1xyXG5cclxuXHRjb25zdCBhMiA9IG5ldyBOb2RlKCBhLmksIGEueCwgYS55ICksXHJcblx0XHRiMiA9IG5ldyBOb2RlKCBiLmksIGIueCwgYi55ICksXHJcblx0XHRhbiA9IGEubmV4dCxcclxuXHRcdGJwID0gYi5wcmV2O1xyXG5cclxuXHRhLm5leHQgPSBiO1xyXG5cdGIucHJldiA9IGE7XHJcblxyXG5cdGEyLm5leHQgPSBhbjtcclxuXHRhbi5wcmV2ID0gYTI7XHJcblxyXG5cdGIyLm5leHQgPSBhMjtcclxuXHRhMi5wcmV2ID0gYjI7XHJcblxyXG5cdGJwLm5leHQgPSBiMjtcclxuXHRiMi5wcmV2ID0gYnA7XHJcblxyXG5cdHJldHVybiBiMjtcclxuXHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXHJcbmZ1bmN0aW9uIGluc2VydE5vZGUoIGksIHgsIHksIGxhc3QgKSB7XHJcblxyXG5cdGNvbnN0IHAgPSBuZXcgTm9kZSggaSwgeCwgeSApO1xyXG5cclxuXHRpZiAoICEgbGFzdCApIHtcclxuXHJcblx0XHRwLnByZXYgPSBwO1xyXG5cdFx0cC5uZXh0ID0gcDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRwLm5leHQgPSBsYXN0Lm5leHQ7XHJcblx0XHRwLnByZXYgPSBsYXN0O1xyXG5cdFx0bGFzdC5uZXh0LnByZXYgPSBwO1xyXG5cdFx0bGFzdC5uZXh0ID0gcDtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZU5vZGUoIHAgKSB7XHJcblxyXG5cdHAubmV4dC5wcmV2ID0gcC5wcmV2O1xyXG5cdHAucHJldi5uZXh0ID0gcC5uZXh0O1xyXG5cclxuXHRpZiAoIHAucHJldlogKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcclxuXHRpZiAoIHAubmV4dFogKSBwLm5leHRaLnByZXZaID0gcC5wcmV2WjtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIE5vZGUoIGksIHgsIHkgKSB7XHJcblxyXG5cdC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxyXG5cdHRoaXMuaSA9IGk7XHJcblxyXG5cdC8vIHZlcnRleCBjb29yZGluYXRlc1xyXG5cdHRoaXMueCA9IHg7XHJcblx0dGhpcy55ID0geTtcclxuXHJcblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXHJcblx0dGhpcy5wcmV2ID0gbnVsbDtcclxuXHR0aGlzLm5leHQgPSBudWxsO1xyXG5cclxuXHQvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXHJcblx0dGhpcy56ID0gMDtcclxuXHJcblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxyXG5cdHRoaXMucHJldlogPSBudWxsO1xyXG5cdHRoaXMubmV4dFogPSBudWxsO1xyXG5cclxuXHQvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxyXG5cdHRoaXMuc3RlaW5lciA9IGZhbHNlO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkge1xyXG5cclxuXHRsZXQgc3VtID0gMDtcclxuXHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSApIHtcclxuXHJcblx0XHRzdW0gKz0gKCBkYXRhWyBqIF0gLSBkYXRhWyBpIF0gKSAqICggZGF0YVsgaSArIDEgXSArIGRhdGFbIGogKyAxIF0gKTtcclxuXHRcdGogPSBpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBzdW07XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBFYXJjdXQgfTtcclxuIiwiaW1wb3J0IHsgRWFyY3V0IH0gZnJvbSAnLi9FYXJjdXQuanMnO1xyXG5cclxuY2xhc3MgU2hhcGVVdGlscyB7XHJcblxyXG5cdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cclxuXHJcblx0c3RhdGljIGFyZWEoIGNvbnRvdXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cdFx0bGV0IGEgPSAwLjA7XHJcblxyXG5cdFx0Zm9yICggbGV0IHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcclxuXHJcblx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhICogMC41O1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBpc0Nsb2NrV2lzZSggcHRzICkge1xyXG5cclxuXHRcdHJldHVybiBTaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdHJpYW5ndWxhdGVTaGFwZSggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiB2ZXJ0aWNlcyBsaWtlIFsgeDAseTAsIHgxLHkxLCB4Mix5MiwgLi4uIF1cclxuXHRcdGNvbnN0IGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xyXG5cdFx0Y29uc3QgZmFjZXMgPSBbXTsgLy8gZmluYWwgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgbGlrZSBbIFsgYSxiLGQgXSwgWyBiLGMsZCBdIF1cclxuXHJcblx0XHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcclxuXHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRsZXQgaG9sZUluZGV4ID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aG9sZUluZGljZXMucHVzaCggaG9sZUluZGV4ICk7XHJcblx0XHRcdGhvbGVJbmRleCArPSBob2xlc1sgaSBdLmxlbmd0aDtcclxuXHRcdFx0YWRkQ29udG91ciggdmVydGljZXMsIGhvbGVzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCB0cmlhbmdsZXMgPSBFYXJjdXQudHJpYW5ndWxhdGUoIHZlcnRpY2VzLCBob2xlSW5kaWNlcyApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggdHJpYW5nbGVzLnNsaWNlKCBpLCBpICsgMyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWNlcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKCBwb2ludHMgKSB7XHJcblxyXG5cdGNvbnN0IGwgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRpZiAoIGwgPiAyICYmIHBvaW50c1sgbCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnBvcCgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApIHtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnggKTtcclxuXHRcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS55ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNoYXBlVXRpbHMgfTtcclxuIiwiLyoqXHJcbiAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqXHJcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXHJcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXHJcbiAqICBkZXB0aDogPGZsb2F0PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcclxuICpcclxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSAoaW5jbHVkaW5nIGJldmVsT2Zmc2V0KSBpcyBiZXZlbFxyXG4gKiAgYmV2ZWxPZmZzZXQ6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGRvZXMgYmV2ZWwgc3RhcnRcclxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXHJcbiAqXHJcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXHJcbiAqXHJcbiAqICBVVkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0ICogYXMgQ3VydmVzIGZyb20gJy4uL2V4dHJhcy9jdXJ2ZXMvQ3VydmVzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBTaGFwZSB9IGZyb20gJy4uL2V4dHJhcy9jb3JlL1NoYXBlLmpzJztcclxuaW1wb3J0IHsgU2hhcGVVdGlscyB9IGZyb20gJy4uL2V4dHJhcy9TaGFwZVV0aWxzLmpzJztcclxuXHJcbmNsYXNzIEV4dHJ1ZGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAtIDAuNSApLCBuZXcgVmVjdG9yMiggMC41LCAtIDAuNSApIF0gKSwgb3B0aW9ucyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcclxuXHRcdFx0b3B0aW9uczogb3B0aW9uc1xyXG5cdFx0fTtcclxuXHJcblx0XHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBbXTtcclxuXHRcdGNvbnN0IHV2QXJyYXkgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBpIF07XHJcblx0XHRcdGFkZFNoYXBlKCBzaGFwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXNBcnJheSwgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QXJyYXksIDIgKSApO1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHQvLyBmdW5jdGlvbnNcclxuXHJcblx0XHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwbGFjZWhvbGRlciA9IFtdO1xyXG5cclxuXHRcdFx0Ly8gb3B0aW9uc1xyXG5cclxuXHRcdFx0Y29uc3QgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XHJcblx0XHRcdGNvbnN0IHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XHJcblx0XHRcdGNvbnN0IGRlcHRoID0gb3B0aW9ucy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aCA6IDE7XHJcblxyXG5cdFx0XHRsZXQgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTtcclxuXHRcdFx0bGV0IGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDAuMjtcclxuXHRcdFx0bGV0IGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMC4xO1xyXG5cdFx0XHRsZXQgYmV2ZWxPZmZzZXQgPSBvcHRpb25zLmJldmVsT2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsT2Zmc2V0IDogMDtcclxuXHRcdFx0bGV0IGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XHJcblxyXG5cdFx0XHRjb25zdCBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XHJcblxyXG5cdFx0XHRjb25zdCB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBXb3JsZFVWR2VuZXJhdG9yO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGxldCBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XHJcblx0XHRcdGxldCBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblxyXG5cdFx0XHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xyXG5cclxuXHRcdFx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xyXG5cclxuXHRcdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcclxuXHRcdFx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXHJcblxyXG5cdFx0XHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcclxuXHJcblx0XHRcdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcblx0XHRcdFx0c3BsaW5lVHViZSA9IGV4dHJ1ZGVQYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHN0ZXBzLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcclxuXHJcblx0XHRcdFx0Ymlub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdFx0cG9zaXRpb24yID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxyXG5cclxuXHRcdFx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XHJcblx0XHRcdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xyXG5cdFx0XHRcdGJldmVsU2l6ZSA9IDA7XHJcblx0XHRcdFx0YmV2ZWxPZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXHJcblxyXG5cdFx0XHRjb25zdCBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdGxldCB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG5cdFx0XHRjb25zdCBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHRcdFx0Y29uc3QgcmV2ZXJzZSA9ICEgU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcclxuXHJcblx0XHRcdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRjb25zdCBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XHJcblxyXG5cdFx0XHQvKiBWZXJ0aWNlcyAqL1xyXG5cclxuXHRcdFx0Y29uc3QgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxyXG5cclxuXHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNjYWxlUHQyKCBwdCwgdmVjLCBzaXplICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0JyApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcHQuY2xvbmUoKS5hZGRTY2FsZWRWZWN0b3IoIHZlYywgc2l6ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblxyXG5cdFx0XHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XHJcblxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXHJcblx0XHRcdFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxyXG5cdFx0XHRcdC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxyXG5cdFx0XHRcdC8vXHJcblx0XHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cclxuXHRcdFx0XHQvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxyXG5cclxuXHRcdFx0XHRsZXQgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxyXG5cclxuXHRcdFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXHJcblx0XHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcclxuXHJcblx0XHRcdFx0Y29uc3Qgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCxcclxuXHRcdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XHJcblx0XHRcdFx0Y29uc3Qgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcclxuXHRcdFx0XHRcdHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcclxuXHJcblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xyXG5cdFx0XHRcdGNvbnN0IGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcclxuXHJcblx0XHRcdFx0XHQvLyBsZW5ndGggb2YgdmVjdG9ycyBmb3Igbm9ybWFsaXppbmdcclxuXHJcblx0XHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcclxuXHRcdFx0XHRcdGNvbnN0IHZfbmV4dF9sZW4gPSBNYXRoLnNxcnQoIHZfbmV4dF94ICogdl9uZXh0X3ggKyB2X25leHRfeSAqIHZfbmV4dF95ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XHJcblx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XHJcblx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgc2YgPSAoICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cclxuXHRcdFx0XHRcdFx0XHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cclxuXHRcdFx0XHRcdFx0KCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xyXG5cdFx0XHRcdFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xyXG5cclxuXHRcdFx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XHJcblx0XHRcdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXHJcblx0XHRcdFx0XHRjb25zdCB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcclxuXHRcdFx0XHRcdGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXHJcblxyXG5cdFx0XHRcdFx0bGV0IGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxyXG5cclxuXHRcdFx0XHRcdGlmICggdl9wcmV2X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGRpcmVjdGlvbl9lcSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XHJcblx0XHRcdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XHJcblx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl94O1xyXG5cdFx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xyXG5cdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcclxuXHRcdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XHJcblx0XHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Y29uc3QgY29udG91ck1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xyXG5cdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHRcdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxyXG5cclxuXHRcdFx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgaG9sZXNNb3ZlbWVudHMgPSBbXTtcclxuXHRcdFx0bGV0IG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHRcdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHRcdFx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHJcblx0XHRcdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuXHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XHJcblx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICkgKyBiZXZlbE9mZnNldDtcclxuXHJcblx0XHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICsgYmV2ZWxPZmZzZXQ7XHJcblxyXG5cdFx0XHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcclxuXHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cclxuXHRcdFx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggLyBzdGVwcyAqIHMgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcclxuXHJcblx0XHRcdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHRcdFx0Zm9yICggbGV0IGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHRcdFx0Y29uc3QgeiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xyXG5cdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApICsgYmV2ZWxPZmZzZXQ7XHJcblxyXG5cdFx0XHRcdC8vIGNvbnRyYWN0IHNoYXBlXHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBGYWNlcyAqL1xyXG5cclxuXHRcdFx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcclxuXHJcblx0XHRcdGJ1aWxkTGlkRmFjZXMoKTtcclxuXHJcblx0XHRcdC8vIFNpZGVzIGZhY2VzXHJcblxyXG5cdFx0XHRidWlsZFNpZGVGYWNlcygpO1xyXG5cclxuXHJcblx0XHRcdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0XHRsZXQgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcclxuXHRcdFx0XHRcdGxldCBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblx0XHRcdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0XHRsZXQgbGF5ZXJvZmZzZXQgPSAwO1xyXG5cdFx0XHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcclxuXHRcdFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8sIHRydWVcclxuXHRcdFx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMSApO1xyXG5cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdGxldCBpID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHdoaWxlICggLS0gaSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGogPSBpO1xyXG5cdFx0XHRcdFx0bGV0IGsgPSBpIC0gMTtcclxuXHRcdFx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBzID0gMCwgc2wgPSAoIHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDIgKTsgcyA8IHNsOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjEgPSB2bGVuICogcztcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxyXG5cdFx0XHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcclxuXHRcdFx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXHJcblx0XHRcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xyXG5cclxuXHRcdFx0XHRcdFx0ZjQoIGEsIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHggKTtcclxuXHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB5ICk7XHJcblx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGEgKTtcclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGMgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xyXG5cdFx0XHRcdGNvbnN0IHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XHJcblxyXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xyXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDEgXSApO1xyXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQgKSB7XHJcblxyXG5cdFx0XHRcdGFkZFZlcnRleCggYSApO1xyXG5cdFx0XHRcdGFkZFZlcnRleCggYiApO1xyXG5cdFx0XHRcdGFkZFZlcnRleCggZCApO1xyXG5cclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGMgKTtcclxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcclxuXHJcblxyXG5cdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0XHRjb25zdCB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XHJcblxyXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xyXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDEgXSApO1xyXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xyXG5cclxuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0XHRhZGRVViggdXZzWyAyIF0gKTtcclxuXHRcdFx0XHRhZGRVViggdXZzWyAzIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGFkZFZlcnRleCggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDAgXSApO1xyXG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDEgXSApO1xyXG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGFkZFVWKCB2ZWN0b3IyICkge1xyXG5cclxuXHRcdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueCApO1xyXG5cdFx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi55ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XHJcblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5wYXJhbWV0ZXJzLm9wdGlvbnM7XHJcblxyXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21KU09OKCBkYXRhLCBzaGFwZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGogXSBdO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZXh0cnVkZVBhdGggPSBkYXRhLm9wdGlvbnMuZXh0cnVkZVBhdGg7XHJcblxyXG5cdFx0aWYgKCBleHRydWRlUGF0aCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gbmV3IEN1cnZlc1sgZXh0cnVkZVBhdGgudHlwZSBdKCkuZnJvbUpTT04oIGV4dHJ1ZGVQYXRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KCBnZW9tZXRyeVNoYXBlcywgZGF0YS5vcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNvbnN0IFdvcmxkVVZHZW5lcmF0b3IgPSB7XHJcblxyXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuXHRcdGNvbnN0IGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XHJcblx0XHRjb25zdCBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcclxuXHRcdGNvbnN0IGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XHJcblx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcclxuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XHJcblx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRuZXcgVmVjdG9yMiggYV94LCBhX3kgKSxcclxuXHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgYl95ICksXHJcblx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIGNfeSApXHJcblx0XHRdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XHJcblxyXG5cdFx0Y29uc3QgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcclxuXHRcdGNvbnN0IGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xyXG5cdFx0Y29uc3QgYV96ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAyIF07XHJcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xyXG5cdFx0Y29uc3QgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XHJcblx0XHRjb25zdCBiX3ogPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDIgXTtcclxuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XHJcblx0XHRjb25zdCBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcclxuXHRcdGNvbnN0IGNfeiA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMiBdO1xyXG5cdFx0Y29uc3QgZF94ID0gdmVydGljZXNbIGluZGV4RCAqIDMgXTtcclxuXHRcdGNvbnN0IGRfeSA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMSBdO1xyXG5cdFx0Y29uc3QgZF96ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAyIF07XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggYV95IC0gYl95ICkgPCBNYXRoLmFicyggYV94IC0gYl94ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBhX3gsIDEgLSBhX3ogKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYl94LCAxIC0gYl96ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeCwgMSAtIGNfeiApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBkX3gsIDEgLSBkX3ogKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBhX3ksIDEgLSBhX3ogKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYl95LCAxIC0gYl96ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeSwgMSAtIGNfeiApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBkX3ksIDEgLSBkX3ogKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBvcHRpb25zLCBkYXRhICkge1xyXG5cclxuXHRkYXRhLnNoYXBlcyA9IFtdO1xyXG5cclxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcclxuXHJcblx0XHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlLnV1aWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGVzLnV1aWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkYXRhLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7fSwgb3B0aW9ucyApO1xyXG5cclxuXHRpZiAoIG9wdGlvbnMuZXh0cnVkZVBhdGggIT09IHVuZGVmaW5lZCApIGRhdGEub3B0aW9ucy5leHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGgudG9KU09OKCk7XHJcblxyXG5cdHJldHVybiBkYXRhO1xyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEV4dHJ1ZGVHZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfSBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XHJcblxyXG5jbGFzcyBJY29zYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XHJcblxyXG5cdFx0Y29uc3QgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xyXG5cclxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xyXG5cdFx0XHQtIDEsIHQsIDAsIFx0MSwgdCwgMCwgXHQtIDEsIC0gdCwgMCwgXHQxLCAtIHQsIDAsXHJcblx0XHRcdDAsIC0gMSwgdCwgXHQwLCAxLCB0LFx0MCwgLSAxLCAtIHQsIFx0MCwgMSwgLSB0LFxyXG5cdFx0XHR0LCAwLCAtIDEsIFx0dCwgMCwgMSwgXHQtIHQsIDAsIC0gMSwgXHQtIHQsIDAsIDFcclxuXHRcdF07XHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcclxuXHRcdFx0MCwgMTEsIDUsIFx0MCwgNSwgMSwgXHQwLCAxLCA3LCBcdDAsIDcsIDEwLCBcdDAsIDEwLCAxMSxcclxuXHRcdFx0MSwgNSwgOSwgXHQ1LCAxMSwgNCxcdDExLCAxMCwgMixcdDEwLCA3LCA2LFx0NywgMSwgOCxcclxuXHRcdFx0MywgOSwgNCwgXHQzLCA0LCAyLFx0MywgMiwgNixcdDMsIDYsIDgsXHQzLCA4LCA5LFxyXG5cdFx0XHQ0LCA5LCA1LCBcdDIsIDQsIDExLFx0NiwgMiwgMTAsXHQ4LCA2LCA3LFx0OSwgOCwgMVxyXG5cdFx0XTtcclxuXHJcblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgSWNvc2FoZWRyb25HZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfSBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XHJcblxyXG5jbGFzcyBPY3RhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcclxuXHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcclxuXHRcdFx0MSwgMCwgMCwgXHQtIDEsIDAsIDAsXHQwLCAxLCAwLFxyXG5cdFx0XHQwLCAtIDEsIDAsIFx0MCwgMCwgMSxcdDAsIDAsIC0gMVxyXG5cdFx0XTtcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0gW1xyXG5cdFx0XHQwLCAyLCA0LFx0MCwgNCwgMyxcdDAsIDMsIDUsXHJcblx0XHRcdDAsIDUsIDIsXHQxLCAyLCA1LFx0MSwgNSwgMyxcclxuXHRcdFx0MSwgMywgNCxcdDEsIDQsIDJcclxuXHRcdF07XHJcblxyXG5cdFx0c3VwZXIoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IE9jdGFoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE9jdGFoZWRyb25HZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5jbGFzcyBSaW5nR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBpbm5lclJhZGl1cyA9IDAuNSwgb3V0ZXJSYWRpdXMgPSAxLCB0aGV0YVNlZ21lbnRzID0gMzIsIHBoaVNlZ21lbnRzID0gMSwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuXHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG5cdFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxyXG5cdFx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXHJcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGV0YVNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKTtcclxuXHRcdHBoaVNlZ21lbnRzID0gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICk7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XHJcblx0XHRjb25zdCBub3JtYWxzID0gW107XHJcblx0XHRjb25zdCB1dnMgPSBbXTtcclxuXHJcblx0XHQvLyBzb21lIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHRsZXQgcmFkaXVzID0gaW5uZXJSYWRpdXM7XHJcblx0XHRjb25zdCByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XHJcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcGhpU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdGhldGFTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmFsdWVzIGFyZSBnZW5lcmF0ZSBmcm9tIHRoZSBpbnNpZGUgb2YgdGhlIHJpbmcgdG8gdGhlIG91dHNpZGVcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xyXG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0XHQvLyBub3JtYWxcclxuXHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XHJcblxyXG5cdFx0XHRcdC8vIHV2XHJcblxyXG5cdFx0XHRcdHV2LnggPSAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xyXG5cdFx0XHRcdHV2LnkgPSAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xyXG5cclxuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcclxuXHJcblx0XHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgcGhpU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAoIHRoZXRhU2VnbWVudHMgKyAxICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzZWdtZW50ID0gaSArIHRoZXRhU2VnbWVudExldmVsO1xyXG5cclxuXHRcdFx0XHRjb25zdCBhID0gc2VnbWVudDtcclxuXHRcdFx0XHRjb25zdCBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xyXG5cdFx0XHRcdGNvbnN0IGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XHJcblx0XHRcdFx0Y29uc3QgZCA9IHNlZ21lbnQgKyAxO1xyXG5cclxuXHRcdFx0XHQvLyBmYWNlc1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBSaW5nR2VvbWV0cnkoIGRhdGEuaW5uZXJSYWRpdXMsIGRhdGEub3V0ZXJSYWRpdXMsIGRhdGEudGhldGFTZWdtZW50cywgZGF0YS5waGlTZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBSaW5nR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XHJcbmltcG9ydCB7IFNoYXBlVXRpbHMgfSBmcm9tICcuLi9leHRyYXMvU2hhcGVVdGlscy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgU2hhcGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMCwgMC41ICksIG5ldyBWZWN0b3IyKCAtIDAuNSwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgLSAwLjUgKSBdICksIGN1cnZlU2VnbWVudHMgPSAxMiApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHNoYXBlczogc2hhcGVzLFxyXG5cdFx0XHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0gW107XHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xyXG5cdFx0Y29uc3QgdXZzID0gW107XHJcblxyXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xyXG5cclxuXHRcdGxldCBncm91cFN0YXJ0ID0gMDtcclxuXHRcdGxldCBncm91cENvdW50ID0gMDtcclxuXHJcblx0XHQvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXCJzaGFwZXNcIiBwYXJhbWV0ZXJcclxuXHJcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGFkZFNoYXBlKCBzaGFwZXMgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc2hhcGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0YWRkU2hhcGUoIHNoYXBlc1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIGkgKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcclxuXHJcblx0XHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xyXG5cdFx0XHRcdGdyb3VwQ291bnQgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG5cclxuXHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcclxuXHJcblx0XHRmdW5jdGlvbiBhZGRTaGFwZSggc2hhcGUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdGxldCBzaGFwZVZlcnRpY2VzID0gcG9pbnRzLnNoYXBlO1xyXG5cdFx0XHRjb25zdCBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlVmVydGljZXMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlSG9sZSApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHNoYXBlSG9sZXNbIGkgXSA9IHNoYXBlSG9sZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCBzaGFwZVZlcnRpY2VzLCBzaGFwZUhvbGVzICk7XHJcblxyXG5cdFx0XHQvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaGFwZUhvbGUgPSBzaGFwZUhvbGVzWyBpIF07XHJcblx0XHRcdFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMuY29uY2F0KCBzaGFwZUhvbGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdmVydGV4ID0gc2hhcGVWZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIDAgKTtcclxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcclxuXHRcdFx0XHR1dnMucHVzaCggdmVydGV4LngsIHZlcnRleC55ICk7IC8vIHdvcmxkIHV2c1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGNvbnN0IGEgPSBmYWNlWyAwIF0gKyBpbmRleE9mZnNldDtcclxuXHRcdFx0XHRjb25zdCBiID0gZmFjZVsgMSBdICsgaW5kZXhPZmZzZXQ7XHJcblx0XHRcdFx0Y29uc3QgYyA9IGZhY2VbIDIgXSArIGluZGV4T2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGMgKTtcclxuXHRcdFx0XHRncm91cENvdW50ICs9IDM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XHJcblxyXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21KU09OKCBkYXRhLCBzaGFwZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGogXSBdO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KCBnZW9tZXRyeVNoYXBlcywgZGF0YS5jdXJ2ZVNlZ21lbnRzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBkYXRhICkge1xyXG5cclxuXHRkYXRhLnNoYXBlcyA9IFtdO1xyXG5cclxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcclxuXHJcblx0XHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlLnV1aWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGVzLnV1aWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNoYXBlR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5jbGFzcyBTcGhlcmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHdpZHRoU2VnbWVudHMgPSAzMiwgaGVpZ2h0U2VnbWVudHMgPSAxNiwgcGhpU3RhcnQgPSAwLCBwaGlMZW5ndGggPSBNYXRoLlBJICogMiwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXHJcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxyXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgKTtcclxuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgKTtcclxuXHJcblx0XHRjb25zdCB0aGV0YUVuZCA9IE1hdGgubWluKCB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGgsIE1hdGguUEkgKTtcclxuXHJcblx0XHRsZXQgaW5kZXggPSAwO1xyXG5cdFx0Y29uc3QgZ3JpZCA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0gW107XHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xyXG5cdFx0Y29uc3QgdXZzID0gW107XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xyXG5cclxuXHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDw9IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZlcnRpY2VzUm93ID0gW107XHJcblxyXG5cdFx0XHRjb25zdCB2ID0gaXkgLyBoZWlnaHRTZWdtZW50cztcclxuXHJcblx0XHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgdGhlIHBvbGVzXHJcblxyXG5cdFx0XHRsZXQgdU9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGl5ID09PSAwICYmIHRoZXRhU3RhcnQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHVPZmZzZXQgPSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggaXkgPT09IGhlaWdodFNlZ21lbnRzICYmIHRoZXRhRW5kID09PSBNYXRoLlBJICkge1xyXG5cclxuXHRcdFx0XHR1T2Zmc2V0ID0gLSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPD0gd2lkdGhTZWdtZW50czsgaXggKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRleFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgueCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbFxyXG5cclxuXHRcdFx0XHRub3JtYWwuY29weSggdmVydGV4ICkubm9ybWFsaXplKCk7XHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIHV2XHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCB1ICsgdU9mZnNldCwgMSAtIHYgKTtcclxuXHJcblx0XHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKysgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdyaWQucHVzaCggdmVydGljZXNSb3cgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xyXG5cdFx0XHRcdGNvbnN0IGIgPSBncmlkWyBpeSBdWyBpeCBdO1xyXG5cdFx0XHRcdGNvbnN0IGMgPSBncmlkWyBpeSArIDEgXVsgaXggXTtcclxuXHRcdFx0XHRjb25zdCBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGl5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFNwaGVyZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNwaGVyZUdlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IFBvbHloZWRyb25HZW9tZXRyeSB9IGZyb20gJy4vUG9seWhlZHJvbkdlb21ldHJ5LmpzJztcclxuXHJcbmNsYXNzIFRldHJhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcclxuXHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtcclxuXHRcdFx0MSwgMSwgMSwgXHQtIDEsIC0gMSwgMSwgXHQtIDEsIDEsIC0gMSwgXHQxLCAtIDEsIC0gMVxyXG5cdFx0XTtcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0gW1xyXG5cdFx0XHQyLCAxLCAwLCBcdDAsIDMsIDIsXHQxLCAzLCAwLFx0MiwgMywgMVxyXG5cdFx0XTtcclxuXHJcblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1RldHJhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRldHJhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBUZXRyYWhlZHJvbkdlb21ldHJ5IH07XHJcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuY2xhc3MgVG9ydXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHR1YmUgPSAwLjQsIHJhZGlhbFNlZ21lbnRzID0gMTIsIHR1YnVsYXJTZWdtZW50cyA9IDQ4LCBhcmMgPSBNYXRoLlBJICogMiApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHR0dWJlOiB0dWJlLFxyXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRhcmM6IGFyY1xyXG5cdFx0fTtcclxuXHJcblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICk7XHJcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuXHRcdGNvbnN0IHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHRjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xyXG5cclxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG5cdFx0XHRcdGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XHJcblx0XHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0XHQvLyBub3JtYWxcclxuXHJcblx0XHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHRcdGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcclxuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIHV2XHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XHJcblx0XHRcdFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXHJcblxyXG5cdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdFx0XHRjb25zdCBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XHJcblx0XHRcdFx0Y29uc3QgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcblx0XHRcdFx0Y29uc3QgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcclxuXHRcdFx0XHRjb25zdCBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcclxuXHJcblx0XHRcdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVG9ydXNHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEudHViZSwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS50dWJ1bGFyU2VnbWVudHMsIGRhdGEuYXJjICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFRvcnVzR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5jbGFzcyBUb3J1c0tub3RHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIHR1YmUgPSAwLjQsIHR1YnVsYXJTZWdtZW50cyA9IDY0LCByYWRpYWxTZWdtZW50cyA9IDgsIHAgPSAyLCBxID0gMyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0dHViZTogdHViZSxcclxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0cDogcCxcclxuXHRcdFx0cTogcVxyXG5cdFx0fTtcclxuXHJcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcclxuXHRcdGNvbnN0IHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRjb25zdCBQMSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBQMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Y29uc3QgQiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRjb25zdCBUID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdGNvbnN0IE4gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyArKyBpICkge1xyXG5cclxuXHRcdFx0Ly8gdGhlIHJhZGlhbiBcInVcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlIG9mIHRoZSBjdXJyZW50IHR1YnVsYXIgc2VnbWVudFxyXG5cclxuXHRcdFx0Y29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0XHQvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cclxuXHRcdFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXCJjb29yZGluYXRlIHNwYWNlXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xyXG5cclxuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIFAxICk7XHJcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSArIDAuMDEsIHAsIHEsIHJhZGl1cywgUDIgKTtcclxuXHJcblx0XHRcdC8vIGNhbGN1bGF0ZSBvcnRob25vcm1hbCBiYXNpc1xyXG5cclxuXHRcdFx0VC5zdWJWZWN0b3JzKCBQMiwgUDEgKTtcclxuXHRcdFx0Ti5hZGRWZWN0b3JzKCBQMiwgUDEgKTtcclxuXHRcdFx0Qi5jcm9zc1ZlY3RvcnMoIFQsIE4gKTtcclxuXHRcdFx0Ti5jcm9zc1ZlY3RvcnMoIEIsIFQgKTtcclxuXHJcblx0XHRcdC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcclxuXHJcblx0XHRcdEIubm9ybWFsaXplKCk7XHJcblx0XHRcdE4ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxyXG5cdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZXh0cnVkZSBhIHNoYXBlIGluIHRoZSB4eS1wbGFuZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgYSB6LXZhbHVlLlxyXG5cclxuXHRcdFx0XHRjb25zdCB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XHJcblx0XHRcdFx0Y29uc3QgY3ggPSAtIHR1YmUgKiBNYXRoLmNvcyggdiApO1xyXG5cdFx0XHRcdGNvbnN0IGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIGZpbmFsIHZlcnRleCBwb3NpdGlvbi5cclxuXHRcdFx0XHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3JzLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSBQMS54ICsgKCBjeCAqIE4ueCArIGN5ICogQi54ICk7XHJcblx0XHRcdFx0dmVydGV4LnkgPSBQMS55ICsgKCBjeCAqIE4ueSArIGN5ICogQi55ICk7XHJcblx0XHRcdFx0dmVydGV4LnogPSBQMS56ICsgKCBjeCAqIE4ueiArIGN5ICogQi56ICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsIChQMSBpcyBhbHdheXMgdGhlIGNlbnRlci9vcmlnaW4gb2YgdGhlIGV4dHJ1c2lvbiwgdGh1cyB3ZSBjYW4gdXNlIGl0IHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsKVxyXG5cclxuXHRcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBQMSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdFx0Ly8gdXZcclxuXHJcblx0XHRcdFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0XHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcclxuXHJcblx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0XHRcdGNvbnN0IGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xyXG5cdFx0XHRcdGNvbnN0IGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcclxuXHRcdFx0XHRjb25zdCBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xyXG5cdFx0XHRcdGNvbnN0IGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcclxuXHJcblx0XHRcdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0XHQvLyB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlXHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIHBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY3UgPSBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHRjb25zdCBzdSA9IE1hdGguc2luKCB1ICk7XHJcblx0XHRcdGNvbnN0IHF1T3ZlclAgPSBxIC8gcCAqIHU7XHJcblx0XHRcdGNvbnN0IGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uLnggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XHJcblx0XHRcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XHJcblx0XHRcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLnAsIGRhdGEucSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBUb3J1c0tub3RHZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgKiBhcyBDdXJ2ZXMgZnJvbSAnLi4vZXh0cmFzL2N1cnZlcy9DdXJ2ZXMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5jbGFzcyBUdWJlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXRoID0gbmV3IEN1cnZlc1sgJ1F1YWRyYXRpY0JlemllckN1cnZlMycgXSggbmV3IFZlY3RvcjMoIC0gMSwgLSAxLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDEsIDEsIDAgKSApLCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaXVzID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBjbG9zZWQgPSBmYWxzZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cGF0aDogcGF0aCxcclxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdGNsb3NlZDogY2xvc2VkXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGZyYW1lcyA9IHBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggdHVidWxhclNlZ21lbnRzLCBjbG9zZWQgKTtcclxuXHJcblx0XHQvLyBleHBvc2UgaW50ZXJuYWxzXHJcblxyXG5cdFx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcclxuXHRcdHRoaXMubm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzO1xyXG5cdFx0dGhpcy5iaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdGxldCBQID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHQvLyBidWZmZXJcclxuXHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xyXG5cdFx0Y29uc3QgdXZzID0gW107XHJcblx0XHRjb25zdCBpbmRpY2VzID0gW107XHJcblxyXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlciBkYXRhXHJcblxyXG5cdFx0Z2VuZXJhdGVCdWZmZXJEYXRhKCk7XHJcblxyXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuXHRcdC8vIGZ1bmN0aW9uc1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VuZXJhdGVTZWdtZW50KCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXHJcblx0XHRcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXHJcblx0XHRcdC8vXHJcblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXHJcblxyXG5cdFx0XHRnZW5lcmF0ZVNlZ21lbnQoICggY2xvc2VkID09PSBmYWxzZSApID8gdHVidWxhclNlZ21lbnRzIDogMCApO1xyXG5cclxuXHRcdFx0Ly8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cclxuXHRcdFx0Ly8gdGhpcyBtYWtlcyBpdCBlYXN5IGNvbXB1dGUgY29ycmVjdCB2YWx1ZXMgZm9yIGNsb3NlZCBnZW9tZXRyaWVzXHJcblxyXG5cdFx0XHRnZW5lcmF0ZVVWcygpO1xyXG5cclxuXHRcdFx0Ly8gZmluYWxseSBjcmVhdGUgZmFjZXNcclxuXHJcblx0XHRcdGdlbmVyYXRlSW5kaWNlcygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoIGkgKSB7XHJcblxyXG5cdFx0XHQvLyB3ZSB1c2UgZ2V0UG9pbnRBdCB0byBzYW1wbGUgZXZlbmx5IGRpc3RyaWJ1dGVkIHBvaW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoXHJcblxyXG5cdFx0XHRQID0gcGF0aC5nZXRQb2ludEF0KCBpIC8gdHVidWxhclNlZ21lbnRzLCBQICk7XHJcblxyXG5cdFx0XHQvLyByZXRyaWV2ZSBjb3JyZXNwb25kaW5nIG5vcm1hbCBhbmQgYmlub3JtYWxcclxuXHJcblx0XHRcdGNvbnN0IE4gPSBmcmFtZXMubm9ybWFsc1sgaSBdO1xyXG5cdFx0XHRjb25zdCBCID0gZnJhbWVzLmJpbm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgbm9ybWFscyBhbmQgdmVydGljZXMgZm9yIHRoZSBjdXJyZW50IHNlZ21lbnRcclxuXHJcblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbiggdiApO1xyXG5cdFx0XHRcdGNvbnN0IGNvcyA9IC0gTWF0aC5jb3MoIHYgKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdG5vcm1hbC54ID0gKCBjb3MgKiBOLnggKyBzaW4gKiBCLnggKTtcclxuXHRcdFx0XHRub3JtYWwueSA9ICggY29zICogTi55ICsgc2luICogQi55ICk7XHJcblx0XHRcdFx0bm9ybWFsLnogPSAoIGNvcyAqIE4ueiArIHNpbiAqIEIueiApO1xyXG5cdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRleFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAueCArIHJhZGl1cyAqIG5vcm1hbC54O1xyXG5cdFx0XHRcdHZlcnRleC55ID0gUC55ICsgcmFkaXVzICogbm9ybWFsLnk7XHJcblx0XHRcdFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUluZGljZXMoKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XHJcblx0XHRcdFx0XHRjb25zdCBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XHJcblx0XHRcdFx0XHRjb25zdCBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcclxuXHRcdFx0XHRcdHV2LnkgPSBqIC8gcmFkaWFsU2VnbWVudHM7XHJcblxyXG5cdFx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcclxuXHJcblx0XHRkYXRhLnBhdGggPSB0aGlzLnBhcmFtZXRlcnMucGF0aC50b0pTT04oKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBvbmx5IHdvcmtzIGZvciBidWlsdC1pbiBjdXJ2ZXMgKGUuZy4gQ2F0bXVsbFJvbUN1cnZlMykuXHJcblx0XHQvLyBVc2VyIGRlZmluZWQgY3VydmVzIG9yIGluc3RhbmNlcyBvZiBDdXJ2ZVBhdGggd2lsbCBub3QgYmUgZGVzZXJpYWxpemVkLlxyXG5cdFx0cmV0dXJuIG5ldyBUdWJlR2VvbWV0cnkoXHJcblx0XHRcdG5ldyBDdXJ2ZXNbIGRhdGEucGF0aC50eXBlIF0oKS5mcm9tSlNPTiggZGF0YS5wYXRoICksXHJcblx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0ZGF0YS5jbG9zZWRcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBUdWJlR2VvbWV0cnkgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcblxyXG5jbGFzcyBXaXJlZnJhbWVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5ID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnlcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIGJ1ZmZlclxyXG5cclxuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdFx0Y29uc3QgZWRnZXMgPSBuZXcgU2V0KCk7XHJcblxyXG5cdFx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXHJcblxyXG5cdFx0XHRjb25zdCBzdGFydCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdGNvbnN0IGVuZCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdFx0bGV0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcblx0XHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGdyb3VwcyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMuY291bnQsIG1hdGVyaWFsSW5kZXg6IDAgfSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIGVkZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBvIF07XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBTdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBDb3VudCA9IGdyb3VwLmNvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gZ3JvdXBTdGFydCwgbCA9ICggZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKTsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MSA9IGluZGljZXMuZ2V0WCggaSArIGogKTtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSBpbmRpY2VzLmdldFgoIGkgKyAoIGogKyAxICkgJSAzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDEgKTtcclxuXHRcdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzVW5pcXVlRWRnZSggc3RhcnQsIGVuZCwgZWRnZXMgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBzdGFydC54LCBzdGFydC55LCBzdGFydC56ICk7XHJcblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBlbmQueCwgZW5kLnksIGVuZC56ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gKCBwb3NpdGlvbi5jb3VudCAvIDMgKTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHRocmVlIGVkZ2VzIHBlciB0cmlhbmdsZSwgYW4gZWRnZSBpcyByZXByZXNlbnRlZCBhcyAoaW5kZXgxLCBpbmRleDIpXHJcblx0XHRcdFx0XHRcdC8vIGUuZy4gdGhlIGZpcnN0IHRyaWFuZ2xlIGhhcyB0aGUgZm9sbG93aW5nIGVkZ2VzOiAoMCwxKSwoMSwyKSwoMiwwKVxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gMyAqIGkgKyBqO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSAzICogaSArICggKCBqICsgMSApICUgMyApO1xyXG5cclxuXHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xyXG5cdFx0XHRcdFx0XHRlbmQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpc1VuaXF1ZUVkZ2UoIHN0YXJ0LCBlbmQsIGVkZ2VzICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnogKTtcclxuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBlbmQueCwgZW5kLnksIGVuZC56ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApIHtcclxuXHJcblx0Y29uc3QgaGFzaDEgPSBgJHtzdGFydC54fSwke3N0YXJ0Lnl9LCR7c3RhcnQuen0tJHtlbmQueH0sJHtlbmQueX0sJHtlbmQuen1gO1xyXG5cdGNvbnN0IGhhc2gyID0gYCR7ZW5kLnh9LCR7ZW5kLnl9LCR7ZW5kLnp9LSR7c3RhcnQueH0sJHtzdGFydC55fSwke3N0YXJ0Lnp9YDsgLy8gY29pbmNpZGVudCBlZGdlXHJcblxyXG5cdGlmICggZWRnZXMuaGFzKCBoYXNoMSApID09PSB0cnVlIHx8IGVkZ2VzLmhhcyggaGFzaDIgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0ZWRnZXMuYWRkKCBoYXNoMSApO1xyXG5cdFx0ZWRnZXMuYWRkKCBoYXNoMiApO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBXaXJlZnJhbWVHZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgU2hhZG93TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc1NoYWRvd01hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU2hhZG93TWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNoYWRvd01hdGVyaWFsIH07XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsIH0gZnJvbSAnLi9TaGFkZXJNYXRlcmlhbC5qcyc7XHJcblxyXG5jbGFzcyBSYXdTaGFkZXJNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHR0aGlzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFJhd1NoYWRlck1hdGVyaWFsIH07XHJcbiIsImltcG9ydCB7IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblx0XHR0aGlzLnJvdWdobmVzcyA9IDEuMDtcclxuXHRcdHRoaXMubWV0YWxuZXNzID0gMC4wO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcclxuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XHJcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMubWV0YWxuZXNzTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0XHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XHJcblx0XHR0aGlzLm1ldGFsbmVzcyA9IHNvdXJjZS5tZXRhbG5lc3M7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XHJcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcclxuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcclxuXHJcblx0XHR0aGlzLm1ldGFsbmVzc01hcCA9IHNvdXJjZS5tZXRhbG5lc3NNYXA7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0XHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBNZXNoU3RhbmRhcmRNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tICcuL01lc2hTdGFuZGFyZE1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuXHJcbmNsYXNzIE1lc2hQaHlzaWNhbE1hdGVyaWFsIGV4dGVuZHMgTWVzaFN0YW5kYXJkTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0ge1xyXG5cclxuXHRcdFx0J1NUQU5EQVJEJzogJycsXHJcblx0XHRcdCdQSFlTSUNBTCc6ICcnXHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTWVzaFBoeXNpY2FsTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuYW5pc290cm9weVJvdGF0aW9uID0gMDtcclxuXHRcdHRoaXMuYW5pc290cm9weU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5jbGVhcmNvYXRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSAwLjA7XHJcblx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IG51bGw7XHJcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcclxuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmlvciA9IDEuNTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdyZWZsZWN0aXZpdHknLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gKCBNYXRoVXRpbHMuY2xhbXAoIDIuNSAqICggdGhpcy5pb3IgLSAxICkgLyAoIHRoaXMuaW9yICsgMSApLCAwLCAxICkgKTtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCByZWZsZWN0aXZpdHkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuaW9yID0gKCAxICsgMC40ICogcmVmbGVjdGl2aXR5ICkgLyAoIDEgLSAwLjQgKiByZWZsZWN0aXZpdHkgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuaXJpZGVzY2VuY2VJT1IgPSAxLjM7XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBbIDEwMCwgNDAwIF07XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5zaGVlblJvdWdobmVzcyA9IDEuMDtcclxuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMudHJhbnNtaXNzaW9uTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnRoaWNrbmVzcyA9IDA7XHJcblx0XHR0aGlzLnRoaWNrbmVzc01hcCA9IG51bGw7XHJcblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBJbmZpbml0eTtcclxuXHRcdHRoaXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvciggMSwgMSwgMSApO1xyXG5cclxuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSAxLjA7XHJcblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuc3BlY3VsYXJDb2xvciA9IG5ldyBDb2xvciggMSwgMSwgMSApO1xyXG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLl9hbmlzb3Ryb3B5ID0gMDtcclxuXHRcdHRoaXMuX2NsZWFyY29hdCA9IDA7XHJcblx0XHR0aGlzLl9pcmlkZXNjZW5jZSA9IDA7XHJcblx0XHR0aGlzLl9zaGVlbiA9IDAuMDtcclxuXHRcdHRoaXMuX3RyYW5zbWlzc2lvbiA9IDA7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgYW5pc290cm9weSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fYW5pc290cm9weTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgYW5pc290cm9weSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9hbmlzb3Ryb3B5ID4gMCAhPT0gdmFsdWUgPiAwICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9hbmlzb3Ryb3B5ID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGNsZWFyY29hdCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2xlYXJjb2F0O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBjbGVhcmNvYXQoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fY2xlYXJjb2F0ID4gMCAhPT0gdmFsdWUgPiAwICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jbGVhcmNvYXQgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgaXJpZGVzY2VuY2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2lyaWRlc2NlbmNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBpcmlkZXNjZW5jZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pcmlkZXNjZW5jZSA+IDAgIT09IHZhbHVlID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faXJpZGVzY2VuY2UgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgc2hlZW4oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NoZWVuO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBzaGVlbiggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9zaGVlbiA+IDAgIT09IHZhbHVlID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2hlZW4gPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgdHJhbnNtaXNzaW9uKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl90cmFuc21pc3Npb247XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHRyYW5zbWlzc2lvbiggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl90cmFuc21pc3Npb24gPiAwICE9PSB2YWx1ZSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RyYW5zbWlzc2lvbiA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmRlZmluZXMgPSB7XHJcblxyXG5cdFx0XHQnU1RBTkRBUkQnOiAnJyxcclxuXHRcdFx0J1BIWVNJQ0FMJzogJydcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5Um90YXRpb24gPSBzb3VyY2UuYW5pc290cm9weVJvdGF0aW9uO1xyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5TWFwID0gc291cmNlLmFuaXNvdHJvcHlNYXA7XHJcblxyXG5cdFx0dGhpcy5jbGVhcmNvYXQgPSBzb3VyY2UuY2xlYXJjb2F0O1xyXG5cdFx0dGhpcy5jbGVhcmNvYXRNYXAgPSBzb3VyY2UuY2xlYXJjb2F0TWFwO1xyXG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzO1xyXG5cdFx0dGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzTWFwO1xyXG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxNYXAgPSBzb3VyY2UuY2xlYXJjb2F0Tm9ybWFsTWFwO1xyXG5cdFx0dGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS5jb3B5KCBzb3VyY2UuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLmlvciA9IHNvdXJjZS5pb3I7XHJcblxyXG5cdFx0dGhpcy5pcmlkZXNjZW5jZSA9IHNvdXJjZS5pcmlkZXNjZW5jZTtcclxuXHRcdHRoaXMuaXJpZGVzY2VuY2VNYXAgPSBzb3VyY2UuaXJpZGVzY2VuY2VNYXA7XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9SID0gc291cmNlLmlyaWRlc2NlbmNlSU9SO1xyXG5cdFx0dGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWyAuLi5zb3VyY2UuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSBdO1xyXG5cdFx0dGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IHNvdXJjZS5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcDtcclxuXHJcblx0XHR0aGlzLnNoZWVuID0gc291cmNlLnNoZWVuO1xyXG5cdFx0dGhpcy5zaGVlbkNvbG9yLmNvcHkoIHNvdXJjZS5zaGVlbkNvbG9yICk7XHJcblx0XHR0aGlzLnNoZWVuQ29sb3JNYXAgPSBzb3VyY2Uuc2hlZW5Db2xvck1hcDtcclxuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3MgPSBzb3VyY2Uuc2hlZW5Sb3VnaG5lc3M7XHJcblx0XHR0aGlzLnNoZWVuUm91Z2huZXNzTWFwID0gc291cmNlLnNoZWVuUm91Z2huZXNzTWFwO1xyXG5cclxuXHRcdHRoaXMudHJhbnNtaXNzaW9uID0gc291cmNlLnRyYW5zbWlzc2lvbjtcclxuXHRcdHRoaXMudHJhbnNtaXNzaW9uTWFwID0gc291cmNlLnRyYW5zbWlzc2lvbk1hcDtcclxuXHJcblx0XHR0aGlzLnRoaWNrbmVzcyA9IHNvdXJjZS50aGlja25lc3M7XHJcblx0XHR0aGlzLnRoaWNrbmVzc01hcCA9IHNvdXJjZS50aGlja25lc3NNYXA7XHJcblx0XHR0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBzb3VyY2UuYXR0ZW51YXRpb25EaXN0YW5jZTtcclxuXHRcdHRoaXMuYXR0ZW51YXRpb25Db2xvci5jb3B5KCBzb3VyY2UuYXR0ZW51YXRpb25Db2xvciApO1xyXG5cclxuXHRcdHRoaXMuc3BlY3VsYXJJbnRlbnNpdHkgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHk7XHJcblx0XHR0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwID0gc291cmNlLnNwZWN1bGFySW50ZW5zaXR5TWFwO1xyXG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yLmNvcHkoIHNvdXJjZS5zcGVjdWxhckNvbG9yICk7XHJcblx0XHR0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBzb3VyY2Uuc3BlY3VsYXJDb2xvck1hcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgTWVzaFBoeXNpY2FsTWF0ZXJpYWwgfTtcclxuIiwiaW1wb3J0IHsgTXVsdGlwbHlPcGVyYXRpb24sIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgTWVzaFBob25nTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hQaG9uZ01hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuXHRcdHRoaXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDB4MTExMTExICk7XHJcblx0XHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcclxuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XHJcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XHJcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xyXG5cdFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xyXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xyXG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XHJcblx0XHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xyXG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBNZXNoUGhvbmdNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBUYW5nZW50U3BhY2VOb3JtYWxNYXAgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbmNsYXNzIE1lc2hUb29uTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1RPT04nOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLmFvTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcclxuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XHJcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcclxuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHRcdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHRcdHRoaXMuZ3JhZGllbnRNYXAgPSBzb3VyY2UuZ3JhZGllbnRNYXA7XHJcblxyXG5cdFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcclxuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcclxuXHRcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcclxuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XHJcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xyXG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcclxuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBNZXNoVG9vbk1hdGVyaWFsIH07XHJcbiIsImltcG9ydCB7IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi9NYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5cclxuY2xhc3MgTWVzaE5vcm1hbE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xyXG5cdFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcclxuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE1lc2hOb3JtYWxNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBNdWx0aXBseU9wZXJhdGlvbiwgVGFuZ2VudFNwYWNlTm9ybWFsTWFwIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcblxyXG5jbGFzcyBNZXNoTGFtYmVydE1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoTGFtYmVydE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcclxuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0XHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XHJcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XHJcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XHJcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcclxuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcblx0XHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XHJcblx0XHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcclxuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcclxuXHRcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcclxuXHJcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE1lc2hMYW1iZXJ0TWF0ZXJpYWwgfTtcclxuIiwiaW1wb3J0IHsgVGFuZ2VudFNwYWNlTm9ybWFsTWFwIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tICcuL01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcblxyXG5jbGFzcyBNZXNoTWF0Y2FwTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hNYXRjYXBNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnTUFUQ0FQJzogJycgfTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTWVzaE1hdGNhcE1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblxyXG5cdFx0dGhpcy5tYXRjYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5idW1wU2NhbGUgPSAxO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuXHRcdHRoaXMubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcclxuXHRcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmZsYXRTaGFkaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmRlZmluZXMgPSB7ICdNQVRDQVAnOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdFx0dGhpcy5tYXRjYXAgPSBzb3VyY2UubWF0Y2FwO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcclxuXHRcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcclxuXHJcblx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE1lc2hNYXRjYXBNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4vTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5cclxuY2xhc3MgTGluZURhc2hlZE1hdGVyaWFsIGV4dGVuZHMgTGluZUJhc2ljTWF0ZXJpYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuc2NhbGUgPSAxO1xyXG5cdFx0dGhpcy5kYXNoU2l6ZSA9IDM7XHJcblx0XHR0aGlzLmdhcFNpemUgPSAxO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XHJcblx0XHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xyXG5cdFx0dGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IExpbmVEYXNoZWRNYXRlcmlhbCB9O1xyXG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcclxuaW1wb3J0IHsgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5cclxuLy8gc2FtZSBhcyBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCBhbHNvIHdvcmtzIG9uIHR5cGVkIGFycmF5c1xyXG5mdW5jdGlvbiBhcnJheVNsaWNlKCBhcnJheSwgZnJvbSwgdG8gKSB7XHJcblxyXG5cdGlmICggaXNUeXBlZEFycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdC8vIGluIGlvczkgYXJyYXkuc3ViYXJyYXkoZnJvbSwgdW5kZWZpbmVkKSB3aWxsIHJldHVybiBlbXB0eSBhcnJheVxyXG5cdFx0Ly8gYnV0IGFycmF5LnN1YmFycmF5KGZyb20pIG9yIGFycmF5LnN1YmFycmF5KGZyb20sIGxlbikgaXMgY29ycmVjdFxyXG5cdFx0cmV0dXJuIG5ldyBhcnJheS5jb25zdHJ1Y3RvciggYXJyYXkuc3ViYXJyYXkoIGZyb20sIHRvICE9PSB1bmRlZmluZWQgPyB0byA6IGFycmF5Lmxlbmd0aCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGFycmF5LnNsaWNlKCBmcm9tLCB0byApO1xyXG5cclxufVxyXG5cclxuLy8gY29udmVydHMgYW4gYXJyYXkgdG8gYSBzcGVjaWZpYyB0eXBlXHJcbmZ1bmN0aW9uIGNvbnZlcnRBcnJheSggYXJyYXksIHR5cGUsIGZvcmNlQ2xvbmUgKSB7XHJcblxyXG5cdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXHJcblx0XHQhIGZvcmNlQ2xvbmUgJiYgYXJyYXkuY29uc3RydWN0b3IgPT09IHR5cGUgKSByZXR1cm4gYXJyYXk7XHJcblxyXG5cdGlmICggdHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdHlwZSggYXJyYXkgKTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcnJheSApOyAvLyBjcmVhdGUgQXJyYXlcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVHlwZWRBcnJheSggb2JqZWN0ICkge1xyXG5cclxuXHRyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KCBvYmplY3QgKSAmJlxyXG5cdFx0ISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XHJcblxyXG59XHJcblxyXG4vLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxyXG5mdW5jdGlvbiBnZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApIHtcclxuXHJcblx0ZnVuY3Rpb24gY29tcGFyZVRpbWUoIGksIGogKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IG4gPSB0aW1lcy5sZW5ndGg7XHJcblx0Y29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KCBuICk7XHJcblx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuOyArKyBpICkgcmVzdWx0WyBpIF0gPSBpO1xyXG5cclxuXHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn1cclxuXHJcbi8vIHVzZXMgdGhlIGFycmF5IHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgJ2dldEtleWZyYW1lT3JkZXInIHRvIHNvcnQgZGF0YVxyXG5mdW5jdGlvbiBzb3J0ZWRBcnJheSggdmFsdWVzLCBzdHJpZGUsIG9yZGVyICkge1xyXG5cclxuXHRjb25zdCBuVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcclxuXHRjb25zdCByZXN1bHQgPSBuZXcgdmFsdWVzLmNvbnN0cnVjdG9yKCBuVmFsdWVzICk7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArKyBpICkge1xyXG5cclxuXHRcdGNvbnN0IHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGRzdE9mZnNldCArKyBdID0gdmFsdWVzWyBzcmNPZmZzZXQgKyBqIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcblxyXG59XHJcblxyXG4vLyBmdW5jdGlvbiBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0c1xyXG5mdW5jdGlvbiBmbGF0dGVuSlNPTigganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xyXG5cclxuXHRsZXQgaSA9IDEsIGtleSA9IGpzb25LZXlzWyAwIF07XHJcblxyXG5cdHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgJiYga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXHJcblxyXG5cdGxldCB2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcclxuXHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcclxuXHJcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xyXG5cclxuXHRcdGRvIHtcclxuXHJcblx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoLmFwcGx5KCB2YWx1ZXMsIHZhbHVlICk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHR9IGVsc2UgaWYgKCB2YWx1ZS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XHJcblx0XHRcdFx0dmFsdWUudG9BcnJheSggdmFsdWVzLCB2YWx1ZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBzdWJjbGlwKCBzb3VyY2VDbGlwLCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzID0gMzAgKSB7XHJcblxyXG5cdGNvbnN0IGNsaXAgPSBzb3VyY2VDbGlwLmNsb25lKCk7XHJcblxyXG5cdGNsaXAubmFtZSA9IG5hbWU7XHJcblxyXG5cdGNvbnN0IHRyYWNrcyA9IFtdO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwLnRyYWNrcy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0Y29uc3QgdHJhY2sgPSBjbGlwLnRyYWNrc1sgaSBdO1xyXG5cdFx0Y29uc3QgdmFsdWVTaXplID0gdHJhY2suZ2V0VmFsdWVTaXplKCk7XHJcblxyXG5cdFx0Y29uc3QgdGltZXMgPSBbXTtcclxuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHRyYWNrLnRpbWVzLmxlbmd0aDsgKysgaiApIHtcclxuXHJcblx0XHRcdGNvbnN0IGZyYW1lID0gdHJhY2sudGltZXNbIGogXSAqIGZwcztcclxuXHJcblx0XHRcdGlmICggZnJhbWUgPCBzdGFydEZyYW1lIHx8IGZyYW1lID49IGVuZEZyYW1lICkgY29udGludWU7XHJcblxyXG5cdFx0XHR0aW1lcy5wdXNoKCB0cmFjay50aW1lc1sgaiBdICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgayA9IDA7IGsgPCB2YWx1ZVNpemU7ICsrIGsgKSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB0cmFjay52YWx1ZXNbIGogKiB2YWx1ZVNpemUgKyBrIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aW1lcy5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHR0cmFjay50aW1lcyA9IGNvbnZlcnRBcnJheSggdGltZXMsIHRyYWNrLnRpbWVzLmNvbnN0cnVjdG9yICk7XHJcblx0XHR0cmFjay52YWx1ZXMgPSBjb252ZXJ0QXJyYXkoIHZhbHVlcywgdHJhY2sudmFsdWVzLmNvbnN0cnVjdG9yICk7XHJcblxyXG5cdFx0dHJhY2tzLnB1c2goIHRyYWNrICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xpcC50cmFja3MgPSB0cmFja3M7XHJcblxyXG5cdC8vIGZpbmQgbWluaW11bSAudGltZXMgdmFsdWUgYWNyb3NzIGFsbCB0cmFja3MgaW4gdGhlIHRyaW1tZWQgY2xpcFxyXG5cclxuXHRsZXQgbWluU3RhcnRUaW1lID0gSW5maW5pdHk7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRpZiAoIG1pblN0YXJ0VGltZSA+IGNsaXAudHJhY2tzWyBpIF0udGltZXNbIDAgXSApIHtcclxuXHJcblx0XHRcdG1pblN0YXJ0VGltZSA9IGNsaXAudHJhY2tzWyBpIF0udGltZXNbIDAgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gc2hpZnQgYWxsIHRyYWNrcyBzdWNoIHRoYXQgY2xpcCBiZWdpbnMgYXQgdD0wXHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRjbGlwLnRyYWNrc1sgaSBdLnNoaWZ0KCAtIDEgKiBtaW5TdGFydFRpbWUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbGlwLnJlc2V0RHVyYXRpb24oKTtcclxuXHJcblx0cmV0dXJuIGNsaXA7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlQ2xpcEFkZGl0aXZlKCB0YXJnZXRDbGlwLCByZWZlcmVuY2VGcmFtZSA9IDAsIHJlZmVyZW5jZUNsaXAgPSB0YXJnZXRDbGlwLCBmcHMgPSAzMCApIHtcclxuXHJcblx0aWYgKCBmcHMgPD0gMCApIGZwcyA9IDMwO1xyXG5cclxuXHRjb25zdCBudW1UcmFja3MgPSByZWZlcmVuY2VDbGlwLnRyYWNrcy5sZW5ndGg7XHJcblx0Y29uc3QgcmVmZXJlbmNlVGltZSA9IHJlZmVyZW5jZUZyYW1lIC8gZnBzO1xyXG5cclxuXHQvLyBNYWtlIGVhY2ggdHJhY2sncyB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIHZhbHVlcyBhdCB0aGUgcmVmZXJlbmNlIGZyYW1lXHJcblx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbnVtVHJhY2tzOyArKyBpICkge1xyXG5cclxuXHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrID0gcmVmZXJlbmNlQ2xpcC50cmFja3NbIGkgXTtcclxuXHRcdGNvbnN0IHJlZmVyZW5jZVRyYWNrVHlwZSA9IHJlZmVyZW5jZVRyYWNrLlZhbHVlVHlwZU5hbWU7XHJcblxyXG5cdFx0Ly8gU2tpcCB0aGlzIHRyYWNrIGlmIGl0J3Mgbm9uLW51bWVyaWNcclxuXHRcdGlmICggcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnYm9vbCcgfHwgcmVmZXJlbmNlVHJhY2tUeXBlID09PSAnc3RyaW5nJyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdC8vIEZpbmQgdGhlIHRyYWNrIGluIHRoZSB0YXJnZXQgY2xpcCB3aG9zZSBuYW1lIGFuZCB0eXBlIG1hdGNoZXMgdGhlIHJlZmVyZW5jZSB0cmFja1xyXG5cdFx0Y29uc3QgdGFyZ2V0VHJhY2sgPSB0YXJnZXRDbGlwLnRyYWNrcy5maW5kKCBmdW5jdGlvbiAoIHRyYWNrICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRyYWNrLm5hbWUgPT09IHJlZmVyZW5jZVRyYWNrLm5hbWVcclxuXHRcdFx0XHQmJiB0cmFjay5WYWx1ZVR5cGVOYW1lID09PSByZWZlcmVuY2VUcmFja1R5cGU7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGlmICggdGFyZ2V0VHJhY2sgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdGxldCByZWZlcmVuY2VPZmZzZXQgPSAwO1xyXG5cdFx0Y29uc3QgcmVmZXJlbmNlVmFsdWVTaXplID0gcmVmZXJlbmNlVHJhY2suZ2V0VmFsdWVTaXplKCk7XHJcblxyXG5cdFx0aWYgKCByZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSApIHtcclxuXHJcblx0XHRcdHJlZmVyZW5jZU9mZnNldCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAvIDM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xyXG5cdFx0Y29uc3QgdGFyZ2V0VmFsdWVTaXplID0gdGFyZ2V0VHJhY2suZ2V0VmFsdWVTaXplKCk7XHJcblxyXG5cdFx0aWYgKCB0YXJnZXRUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSApIHtcclxuXHJcblx0XHRcdHRhcmdldE9mZnNldCA9IHRhcmdldFZhbHVlU2l6ZSAvIDM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGxhc3RJbmRleCA9IHJlZmVyZW5jZVRyYWNrLnRpbWVzLmxlbmd0aCAtIDE7XHJcblx0XHRsZXQgcmVmZXJlbmNlVmFsdWU7XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgdmFsdWUgdG8gc3VidHJhY3Qgb3V0IG9mIHRoZSB0cmFja1xyXG5cdFx0aWYgKCByZWZlcmVuY2VUaW1lIDw9IHJlZmVyZW5jZVRyYWNrLnRpbWVzWyAwIF0gKSB7XHJcblxyXG5cdFx0XHQvLyBSZWZlcmVuY2UgZnJhbWUgaXMgZWFybGllciB0aGFuIHRoZSBmaXJzdCBrZXlmcmFtZSwgc28ganVzdCB1c2UgdGhlIGZpcnN0IGtleWZyYW1lXHJcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XHJcblx0XHRcdGNvbnN0IGVuZEluZGV4ID0gcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xyXG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IGFycmF5U2xpY2UoIHJlZmVyZW5jZVRyYWNrLnZhbHVlcywgc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCByZWZlcmVuY2VUaW1lID49IHJlZmVyZW5jZVRyYWNrLnRpbWVzWyBsYXN0SW5kZXggXSApIHtcclxuXHJcblx0XHRcdC8vIFJlZmVyZW5jZSBmcmFtZSBpcyBhZnRlciB0aGUgbGFzdCBrZXlmcmFtZSwgc28ganVzdCB1c2UgdGhlIGxhc3Qga2V5ZnJhbWVcclxuXHRcdFx0Y29uc3Qgc3RhcnRJbmRleCA9IGxhc3RJbmRleCAqIHJlZmVyZW5jZVZhbHVlU2l6ZSArIHJlZmVyZW5jZU9mZnNldDtcclxuXHRcdFx0Y29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xyXG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IGFycmF5U2xpY2UoIHJlZmVyZW5jZVRyYWNrLnZhbHVlcywgc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gSW50ZXJwb2xhdGUgdG8gdGhlIHJlZmVyZW5jZSB2YWx1ZVxyXG5cdFx0XHRjb25zdCBpbnRlcnBvbGFudCA9IHJlZmVyZW5jZVRyYWNrLmNyZWF0ZUludGVycG9sYW50KCk7XHJcblx0XHRcdGNvbnN0IHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XHJcblx0XHRcdGNvbnN0IGVuZEluZGV4ID0gcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xyXG5cdFx0XHRpbnRlcnBvbGFudC5ldmFsdWF0ZSggcmVmZXJlbmNlVGltZSApO1xyXG5cdFx0XHRyZWZlcmVuY2VWYWx1ZSA9IGFycmF5U2xpY2UoIGludGVycG9sYW50LnJlc3VsdEJ1ZmZlciwgc3RhcnRJbmRleCwgZW5kSW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29uanVnYXRlIHRoZSBxdWF0ZXJuaW9uXHJcblx0XHRpZiAoIHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3F1YXRlcm5pb24nICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVmZXJlbmNlUXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCkuZnJvbUFycmF5KCByZWZlcmVuY2VWYWx1ZSApLm5vcm1hbGl6ZSgpLmNvbmp1Z2F0ZSgpO1xyXG5cdFx0XHRyZWZlcmVuY2VRdWF0LnRvQXJyYXkoIHJlZmVyZW5jZVZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN1YnRyYWN0IHRoZSByZWZlcmVuY2UgdmFsdWUgZnJvbSBhbGwgb2YgdGhlIHRyYWNrIHZhbHVlc1xyXG5cclxuXHRcdGNvbnN0IG51bVRpbWVzID0gdGFyZ2V0VHJhY2sudGltZXMubGVuZ3RoO1xyXG5cdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgbnVtVGltZXM7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2YWx1ZVN0YXJ0ID0gaiAqIHRhcmdldFZhbHVlU2l6ZSArIHRhcmdldE9mZnNldDtcclxuXHJcblx0XHRcdGlmICggcmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicgKSB7XHJcblxyXG5cdFx0XHRcdC8vIE11bHRpcGx5IHRoZSBjb25qdWdhdGUgZm9yIHF1YXRlcm5pb24gdHJhY2sgdHlwZXNcclxuXHRcdFx0XHRRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KFxyXG5cdFx0XHRcdFx0dGFyZ2V0VHJhY2sudmFsdWVzLFxyXG5cdFx0XHRcdFx0dmFsdWVTdGFydCxcclxuXHRcdFx0XHRcdHJlZmVyZW5jZVZhbHVlLFxyXG5cdFx0XHRcdFx0MCxcclxuXHRcdFx0XHRcdHRhcmdldFRyYWNrLnZhbHVlcyxcclxuXHRcdFx0XHRcdHZhbHVlU3RhcnRcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdmFsdWVFbmQgPSB0YXJnZXRWYWx1ZVNpemUgLSB0YXJnZXRPZmZzZXQgKiAyO1xyXG5cclxuXHRcdFx0XHQvLyBTdWJ0cmFjdCBlYWNoIHZhbHVlIGZvciBhbGwgb3RoZXIgbnVtZXJpYyB0cmFjayB0eXBlc1xyXG5cdFx0XHRcdGZvciAoIGxldCBrID0gMDsgayA8IHZhbHVlRW5kOyArKyBrICkge1xyXG5cclxuXHRcdFx0XHRcdHRhcmdldFRyYWNrLnZhbHVlc1sgdmFsdWVTdGFydCArIGsgXSAtPSByZWZlcmVuY2VWYWx1ZVsgayBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRhcmdldENsaXAuYmxlbmRNb2RlID0gQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGU7XHJcblxyXG5cdHJldHVybiB0YXJnZXRDbGlwO1xyXG5cclxufVxyXG5cclxuY29uc3QgQW5pbWF0aW9uVXRpbHMgPSB7XHJcblx0YXJyYXlTbGljZTogYXJyYXlTbGljZSxcclxuXHRjb252ZXJ0QXJyYXk6IGNvbnZlcnRBcnJheSxcclxuXHRpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcclxuXHRnZXRLZXlmcmFtZU9yZGVyOiBnZXRLZXlmcmFtZU9yZGVyLFxyXG5cdHNvcnRlZEFycmF5OiBzb3J0ZWRBcnJheSxcclxuXHRmbGF0dGVuSlNPTjogZmxhdHRlbkpTT04sXHJcblx0c3ViY2xpcDogc3ViY2xpcCxcclxuXHRtYWtlQ2xpcEFkZGl0aXZlOiBtYWtlQ2xpcEFkZGl0aXZlXHJcbn07XHJcblxyXG5leHBvcnQge1xyXG5cdGFycmF5U2xpY2UsXHJcblx0Y29udmVydEFycmF5LFxyXG5cdGlzVHlwZWRBcnJheSxcclxuXHRnZXRLZXlmcmFtZU9yZGVyLFxyXG5cdHNvcnRlZEFycmF5LFxyXG5cdGZsYXR0ZW5KU09OLFxyXG5cdHN1YmNsaXAsXHJcblx0bWFrZUNsaXBBZGRpdGl2ZSxcclxuXHRBbmltYXRpb25VdGlsc1xyXG59O1xyXG4iLCIvKipcclxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXHJcbiAqXHJcbiAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxyXG4gKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXHJcbiAqXHJcbiAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxyXG4gKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cclxuICpcclxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXHJcbiAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXHJcbiAqXHJcbiAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xyXG4gKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXHJcbiAqXHJcbiAqL1xyXG5cclxuY2xhc3MgSW50ZXJwb2xhbnQge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcclxuXHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcclxuXHJcblx0XHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0cmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3Rvciggc2FtcGxlU2l6ZSApO1xyXG5cdFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XHJcblx0XHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XHJcblxyXG5cdFx0dGhpcy5zZXR0aW5ncyA9IG51bGw7XHJcblx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRldmFsdWF0ZSggdCApIHtcclxuXHJcblx0XHRjb25zdCBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zO1xyXG5cdFx0bGV0IGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXHJcblx0XHRcdHQxID0gcHBbIGkxIF0sXHJcblx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xyXG5cclxuXHRcdHZhbGlkYXRlX2ludGVydmFsOiB7XHJcblxyXG5cdFx0XHRzZWVrOiB7XHJcblxyXG5cdFx0XHRcdGxldCByaWdodDtcclxuXHJcblx0XHRcdFx0bGluZWFyX3NjYW46IHtcclxuXHJcblx0XHRcdFx0XHQvLy0gU2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbXBhcmlzb24tdG8tdW5kZWZpbmVkLzNcclxuXHRcdFx0XHRcdC8vLSBzbG93ZXIgY29kZTpcclxuXHRcdFx0XHRcdC8vLVxyXG5cdFx0XHRcdFx0Ly8tIFx0XHRcdFx0aWYgKCB0ID49IHQxIHx8IHQxID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRmb3J3YXJkX3NjYW46IGlmICggISAoIHQgPCB0MSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGdpdmVVcEF0ID0gaTEgKyAyOyA7ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgZW5kXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXHJcblxyXG5cdFx0XHRcdFx0XHRcdHQwID0gdDE7XHJcblx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcclxuXHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLy0gc2xvd2VyIGNvZGU6XHJcblx0XHRcdFx0XHQvLy1cdFx0XHRcdFx0aWYgKCB0IDwgdDAgfHwgdDAgPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdGlmICggISAoIHQgPj0gdDAgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGxvb3Bpbmc/XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB0MWdsb2JhbCA9IHBwWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHQgPCB0MWdsb2JhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xyXG5cdFx0XHRcdFx0XHRcdHQwID0gdDFnbG9iYWw7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZ2l2ZVVwQXQgPSBpMSAtIDI7IDsgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCAwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXHJcblxyXG5cdFx0XHRcdFx0XHRcdHQxID0gdDA7XHJcblx0XHRcdFx0XHRcdFx0dDAgPSBwcFsgLS0gaTEgLSAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdCA+PSB0MCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XHJcblx0XHRcdFx0XHRcdHJpZ2h0ID0gaTE7XHJcblx0XHRcdFx0XHRcdGkxID0gMDtcclxuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHRoZSBpbnRlcnZhbCBpcyB2YWxpZFxyXG5cclxuXHRcdFx0XHRcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xyXG5cclxuXHRcdFx0XHR9IC8vIGxpbmVhciBzY2FuXHJcblxyXG5cdFx0XHRcdC8vIGJpbmFyeSBzZWFyY2hcclxuXHJcblx0XHRcdFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG1pZCA9ICggaTEgKyByaWdodCApID4+PiAxO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdCA8IHBwWyBtaWQgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJpZ2h0ID0gbWlkO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpMSA9IG1pZCArIDE7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHQxID0gcHBbIGkxIF07XHJcblx0XHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxyXG5cclxuXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcclxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSAvLyBzZWVrXHJcblxyXG5cdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xyXG5cclxuXHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XHJcblxyXG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxyXG5cclxuXHRcdHJldHVybiB0aGlzLmludGVycG9sYXRlXyggaTEsIHQwLCB0LCB0MSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFNldHRpbmdzXygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XHJcblxyXG5cdH1cclxuXHJcblx0Y29weVNhbXBsZVZhbHVlXyggaW5kZXggKSB7XHJcblxyXG5cdFx0Ly8gY29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyXHJcblxyXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcclxuXHJcblx0aW50ZXJwb2xhdGVfKCAvKiBpMSwgdDAsIHQsIHQxICovICkge1xyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvciggJ2NhbGwgdG8gYWJzdHJhY3QgbWV0aG9kJyApO1xyXG5cdFx0Ly8gaW1wbGVtZW50YXRpb25zIHNoYWxsIHJldHVybiB0aGlzLnJlc3VsdEJ1ZmZlclxyXG5cclxuXHR9XHJcblxyXG5cdGludGVydmFsQ2hhbmdlZF8oIC8qIGkxLCB0MCwgdDEgKi8gKSB7XHJcblxyXG5cdFx0Ly8gZW1wdHlcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgSW50ZXJwb2xhbnQgfTtcclxuIiwiaW1wb3J0IHsgWmVyb0N1cnZhdHVyZUVuZGluZywgV3JhcEFyb3VuZEVuZGluZywgWmVyb1Nsb3BlRW5kaW5nIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgSW50ZXJwb2xhbnQgfSBmcm9tICcuLi9JbnRlcnBvbGFudC5qcyc7XHJcblxyXG4vKipcclxuICogRmFzdCBhbmQgc2ltcGxlIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudC5cclxuICpcclxuICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxyXG4gKiBhdCBlYWNoIHNhbXBsZSBwb3NpdGlvbiB0byB0aGUgbGluZWFyIHNsb3BlIGJldHdlZW4gbmVpZ2hib3JpbmcgcG9zaXRpb25zXHJcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxyXG4gKi9cclxuXHJcbmNsYXNzIEN1YmljSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG5cdFx0dGhpcy5fd2VpZ2h0UHJldiA9IC0gMDtcclxuXHRcdHRoaXMuX29mZnNldFByZXYgPSAtIDA7XHJcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gLSAwO1xyXG5cdFx0dGhpcy5fb2Zmc2V0TmV4dCA9IC0gMDtcclxuXHJcblx0XHR0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7XHJcblxyXG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcclxuXHRcdFx0ZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICkge1xyXG5cclxuXHRcdGNvbnN0IHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnM7XHJcblx0XHRsZXQgaVByZXYgPSBpMSAtIDIsXHJcblx0XHRcdGlOZXh0ID0gaTEgKyAxLFxyXG5cclxuXHRcdFx0dFByZXYgPSBwcFsgaVByZXYgXSxcclxuXHRcdFx0dE5leHQgPSBwcFsgaU5leHQgXTtcclxuXHJcblx0XHRpZiAoIHRQcmV2ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0ICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcclxuXHJcblx0XHRcdFx0XHQvLyBmJyh0MCkgPSAwXHJcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xyXG5cdFx0XHRcdFx0dFByZXYgPSAyICogdDAgLSB0MTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxyXG5cclxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxyXG5cdFx0XHRcdFx0aVByZXYgPSBwcC5sZW5ndGggLSAyO1xyXG5cdFx0XHRcdFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXHJcblxyXG5cdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXHJcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xyXG5cdFx0XHRcdFx0dFByZXYgPSB0MTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0TmV4dCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQgKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxyXG5cclxuXHRcdFx0XHRcdC8vIGYnKHROKSA9IDBcclxuXHRcdFx0XHRcdGlOZXh0ID0gaTE7XHJcblx0XHRcdFx0XHR0TmV4dCA9IDIgKiB0MSAtIHQwO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXHJcblx0XHRcdFx0XHRpTmV4dCA9IDE7XHJcblx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcclxuXHJcblx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXHJcblx0XHRcdFx0XHRpTmV4dCA9IGkxIC0gMTtcclxuXHRcdFx0XHRcdHROZXh0ID0gdDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcclxuXHJcblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKCB0MCAtIHRQcmV2ICk7XHJcblx0XHR0aGlzLl93ZWlnaHROZXh0ID0gaGFsZkR0IC8gKCB0TmV4dCAtIHQxICk7XHJcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XHJcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xyXG5cclxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcclxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblxyXG5cdFx0XHRvMSA9IGkxICogc3RyaWRlLFx0XHRvMCA9IG8xIC0gc3RyaWRlLFxyXG5cdFx0XHRvUCA9IHRoaXMuX29mZnNldFByZXYsIFx0b04gPSB0aGlzLl9vZmZzZXROZXh0LFxyXG5cdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXHJcblxyXG5cdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHRwcCA9IHAgKiBwLFxyXG5cdFx0XHRwcHAgPSBwcCAqIHA7XHJcblxyXG5cdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcclxuXHJcblx0XHRjb25zdCBzUCA9IC0gd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcclxuXHRcdGNvbnN0IHMwID0gKCAxICsgd1AgKSAqIHBwcCArICggLSAxLjUgLSAyICogd1AgKSAqIHBwICsgKCAtIDAuNSArIHdQICkgKiBwICsgMTtcclxuXHRcdGNvbnN0IHMxID0gKCAtIDEgLSB3TiApICogcHBwICsgKCAxLjUgKyB3TiApICogcHAgKyAwLjUgKiBwO1xyXG5cdFx0Y29uc3Qgc04gPSB3TiAqIHBwcCAtIHdOICogcHA7XHJcblxyXG5cdFx0Ly8gY29tYmluZSBkYXRhIGxpbmVhcmx5XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xyXG5cdFx0XHRcdFx0czAgKiB2YWx1ZXNbIG8wICsgaSBdICtcclxuXHRcdFx0XHRcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXHJcblx0XHRcdFx0XHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEN1YmljSW50ZXJwb2xhbnQgfTtcclxuIiwiaW1wb3J0IHsgSW50ZXJwb2xhbnQgfSBmcm9tICcuLi9JbnRlcnBvbGFudC5qcyc7XHJcblxyXG5jbGFzcyBMaW5lYXJJbnRlcnBvbGFudCBleHRlbmRzIEludGVycG9sYW50IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHJcblx0XHRcdG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcclxuXHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXHJcblxyXG5cdFx0XHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDAgKyBpIF0gKiB3ZWlnaHQwICtcclxuXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBMaW5lYXJJbnRlcnBvbGFudCB9O1xyXG4iLCJpbXBvcnQgeyBJbnRlcnBvbGFudCB9IGZyb20gJy4uL0ludGVycG9sYW50LmpzJztcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBJbnRlcnBvbGFudCB0aGF0IGV2YWx1YXRlcyB0byB0aGUgc2FtcGxlIHZhbHVlIGF0IHRoZSBwb3NpdGlvbiBwcmVjZWRpbmdcclxuICogdGhlIHBhcmFtZXRlci5cclxuICovXHJcblxyXG5jbGFzcyBEaXNjcmV0ZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0XHRzdXBlciggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVycG9sYXRlXyggaTEgLyosIHQwLCB0LCB0MSAqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IERpc2NyZXRlSW50ZXJwb2xhbnQgfTtcclxuIiwiaW1wb3J0IHtcclxuXHRJbnRlcnBvbGF0ZUxpbmVhcixcclxuXHRJbnRlcnBvbGF0ZVNtb290aCxcclxuXHRJbnRlcnBvbGF0ZURpc2NyZXRlXHJcbn0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgQ3ViaWNJbnRlcnBvbGFudCB9IGZyb20gJy4uL21hdGgvaW50ZXJwb2xhbnRzL0N1YmljSW50ZXJwb2xhbnQuanMnO1xyXG5pbXBvcnQgeyBMaW5lYXJJbnRlcnBvbGFudCB9IGZyb20gJy4uL21hdGgvaW50ZXJwb2xhbnRzL0xpbmVhckludGVycG9sYW50LmpzJztcclxuaW1wb3J0IHsgRGlzY3JldGVJbnRlcnBvbGFudCB9IGZyb20gJy4uL21hdGgvaW50ZXJwb2xhbnRzL0Rpc2NyZXRlSW50ZXJwb2xhbnQuanMnO1xyXG5pbXBvcnQgKiBhcyBBbmltYXRpb25VdGlscyBmcm9tICcuL0FuaW1hdGlvblV0aWxzLmpzJztcclxuXHJcbmNsYXNzIEtleWZyYW1lVHJhY2sge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkJyApO1xyXG5cdFx0aWYgKCB0aW1lcyA9PT0gdW5kZWZpbmVkIHx8IHRpbWVzLmxlbmd0aCA9PT0gMCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IG5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCAnICsgbmFtZSApO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUgKTtcclxuXHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XHJcblxyXG5cdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTZXJpYWxpemF0aW9uIChpbiBzdGF0aWMgY29udGV4dCwgYmVjYXVzZSBvZiBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uXHJcblx0Ly8gYW5kIGF1dG9tYXRpYyBpbnZvY2F0aW9uIG9mIC50b0pTT04pOlxyXG5cclxuXHRzdGF0aWMgdG9KU09OKCB0cmFjayApIHtcclxuXHJcblx0XHRjb25zdCB0cmFja1R5cGUgPSB0cmFjay5jb25zdHJ1Y3RvcjtcclxuXHJcblx0XHRsZXQganNvbjtcclxuXHJcblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXHJcblx0XHRpZiAoIHRyYWNrVHlwZS50b0pTT04gIT09IHRoaXMudG9KU09OICkge1xyXG5cclxuXHRcdFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04oIHRyYWNrICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSB0aGUgZGF0YSBjYW4gYmUgc2VyaWFsaXplZCBhcy1pc1xyXG5cdFx0XHRqc29uID0ge1xyXG5cclxuXHRcdFx0XHQnbmFtZSc6IHRyYWNrLm5hbWUsXHJcblx0XHRcdFx0J3RpbWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcclxuXHRcdFx0XHQndmFsdWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xyXG5cclxuXHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0anNvbi5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0anNvbi50eXBlID0gdHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gbWFuZGF0b3J5XHJcblxyXG5cdFx0cmV0dXJuIGpzb247XHJcblxyXG5cdH1cclxuXHJcblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGUoIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIoIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoKCByZXN1bHQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRsZXQgZmFjdG9yeU1ldGhvZDtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZURpc2NyZXRlOlxyXG5cclxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEludGVycG9sYXRlTGluZWFyOlxyXG5cclxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcclxuXHJcblx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtZXNzYWdlID0gJ3Vuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yICcgK1xyXG5cdFx0XHRcdHRoaXMuVmFsdWVUeXBlTmFtZSArICcga2V5ZnJhbWUgdHJhY2sgbmFtZWQgJyArIHRoaXMubmFtZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcclxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlICk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gZmFjdG9yeU1ldGhvZDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnRlcnBvbGF0aW9uKCkge1xyXG5cclxuXHRcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XHJcblxyXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XHJcblxyXG5cdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZURpc2NyZXRlO1xyXG5cclxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjpcclxuXHJcblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlTGluZWFyO1xyXG5cclxuXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDpcclxuXHJcblx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZVNpemUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAvIHRoaXMudGltZXMubGVuZ3RoO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcclxuXHRzaGlmdCggdGltZU9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcztcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXHJcblx0c2NhbGUoIHRpbWVTY2FsZSApIHtcclxuXHJcblx0XHRpZiAoIHRpbWVTY2FsZSAhPT0gMS4wICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdGltZXMgPSB0aGlzLnRpbWVzO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXHJcblx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xyXG5cdHRyaW0oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcclxuXHJcblx0XHRjb25zdCB0aW1lcyA9IHRoaXMudGltZXMsXHJcblx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xyXG5cclxuXHRcdGxldCBmcm9tID0gMCxcclxuXHRcdFx0dG8gPSBuS2V5cyAtIDE7XHJcblxyXG5cdFx0d2hpbGUgKCBmcm9tICE9PSBuS2V5cyAmJiB0aW1lc1sgZnJvbSBdIDwgc3RhcnRUaW1lICkge1xyXG5cclxuXHRcdFx0KysgZnJvbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKCB0byAhPT0gLSAxICYmIHRpbWVzWyB0byBdID4gZW5kVGltZSApIHtcclxuXHJcblx0XHRcdC0tIHRvO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQrKyB0bzsgLy8gaW5jbHVzaXZlIC0+IGV4Y2x1c2l2ZSBib3VuZFxyXG5cclxuXHRcdGlmICggZnJvbSAhPT0gMCB8fCB0byAhPT0gbktleXMgKSB7XHJcblxyXG5cdFx0XHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcclxuXHRcdFx0aWYgKCBmcm9tID49IHRvICkge1xyXG5cclxuXHRcdFx0XHR0byA9IE1hdGgubWF4KCB0bywgMSApO1xyXG5cdFx0XHRcdGZyb20gPSB0byAtIDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xyXG5cdFx0XHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIGZyb20sIHRvICk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGhpcy52YWx1ZXMsIGZyb20gKiBzdHJpZGUsIHRvICogc3RyaWRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcclxuXHR2YWxpZGF0ZSgpIHtcclxuXHJcblx0XHRsZXQgdmFsaWQgPSB0cnVlO1xyXG5cclxuXHRcdGNvbnN0IHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XHJcblx0XHRpZiAoIHZhbHVlU2l6ZSAtIE1hdGguZmxvb3IoIHZhbHVlU2l6ZSApICE9PSAwICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IEludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFjay4nLCB0aGlzICk7XHJcblx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRpbWVzID0gdGhpcy50aW1lcyxcclxuXHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXHJcblxyXG5cdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIG5LZXlzID09PSAwICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFRyYWNrIGlzIGVtcHR5LicsIHRoaXMgKTtcclxuXHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHByZXZUaW1lID0gbnVsbDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IG5LZXlzOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY3VyclRpbWUgPSB0aW1lc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKCBjdXJyVGltZSApICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVGltZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuJywgdGhpcywgaSwgY3VyclRpbWUgKTtcclxuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwcmV2VGltZSAhPT0gbnVsbCAmJiBwcmV2VGltZSA+IGN1cnJUaW1lICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogT3V0IG9mIG9yZGVyIGtleXMuJywgdGhpcywgaSwgY3VyclRpbWUsIHByZXZUaW1lICk7XHJcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHByZXZUaW1lID0gY3VyclRpbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIEFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSggdmFsdWVzICkgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2YWx1ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbGlkO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgYXMgY29tbW9uIGluIG1vcnBoIHRhcmdldCBzZXF1ZW5jZXNcclxuXHQvLyAoMCwwLDAsMCwxLDEsMSwwLDAsMCwwLDAsMCwwKSAtLT4gKDAsMCwxLDEsMCwwKVxyXG5cdG9wdGltaXplKCkge1xyXG5cclxuXHRcdC8vIHRpbWVzIG9yIHZhbHVlcyBtYXkgYmUgc2hhcmVkIHdpdGggb3RoZXIgdHJhY2tzLCBzbyBvdmVyd3JpdGluZyBpcyB1bnNhZmVcclxuXHRcdGNvbnN0IHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGhpcy50aW1lcyApLFxyXG5cdFx0XHR2YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aGlzLnZhbHVlcyApLFxyXG5cdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxyXG5cclxuXHRcdFx0c21vb3RoSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbigpID09PSBJbnRlcnBvbGF0ZVNtb290aCxcclxuXHJcblx0XHRcdGxhc3RJbmRleCA9IHRpbWVzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0bGV0IHdyaXRlSW5kZXggPSAxO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgKysgaSApIHtcclxuXHJcblx0XHRcdGxldCBrZWVwID0gZmFsc2U7XHJcblxyXG5cdFx0XHRjb25zdCB0aW1lID0gdGltZXNbIGkgXTtcclxuXHRcdFx0Y29uc3QgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcclxuXHJcblx0XHRcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVzWyAwIF0gKSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIHNtb290aEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGkgKiBzdHJpZGUsXHJcblx0XHRcdFx0XHRcdG9mZnNldFAgPSBvZmZzZXQgLSBzdHJpZGUsXHJcblx0XHRcdFx0XHRcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHZhbHVlc1sgb2Zmc2V0ICsgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0a2VlcCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpbi1wbGFjZSBjb21wYWN0aW9uXHJcblxyXG5cdFx0XHRpZiAoIGtlZXAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaSAhPT0gd3JpdGVJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcclxuXHRcdFx0XHRcdFx0d3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Kysgd3JpdGVJbmRleDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcclxuXHJcblx0XHRpZiAoIGxhc3RJbmRleCA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IHJlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZSwgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCsrIHdyaXRlSW5kZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMudGltZXMgPSB0aW1lcztcclxuXHRcdFx0dGhpcy52YWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdGNvbnN0IHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGhpcy50aW1lcywgMCApO1xyXG5cdFx0Y29uc3QgdmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGhpcy52YWx1ZXMsIDAgKTtcclxuXHJcblx0XHRjb25zdCBUeXBlZEtleWZyYW1lVHJhY2sgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG5cdFx0Y29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKCB0aGlzLm5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcclxuXHJcblx0XHQvLyBJbnRlcnBvbGFudCBhcmd1bWVudCB0byBjb25zdHJ1Y3RvciBpcyBub3Qgc2F2ZWQsIHNvIGNvcHkgdGhlIGZhY3RvcnkgbWV0aG9kIGRpcmVjdGx5LlxyXG5cdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSB0aGlzLmNyZWF0ZUludGVycG9sYW50O1xyXG5cclxuXHRcdHJldHVybiB0cmFjaztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVGltZUJ1ZmZlclR5cGUgPSBGbG9hdDMyQXJyYXk7XHJcbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEZsb2F0MzJBcnJheTtcclxuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZUxpbmVhcjtcclxuXHJcbmV4cG9ydCB7IEtleWZyYW1lVHJhY2sgfTtcclxuIiwiaW1wb3J0IHsgSW50ZXJwb2xhdGVEaXNjcmV0ZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuLi9LZXlmcmFtZVRyYWNrLmpzJztcclxuXHJcbi8qKlxyXG4gKiBBIFRyYWNrIG9mIEJvb2xlYW4ga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKi9cclxuY2xhc3MgQm9vbGVhbktleWZyYW1lVHJhY2sgZXh0ZW5kcyBLZXlmcmFtZVRyYWNrIHt9XHJcblxyXG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdib29sJztcclxuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEFycmF5O1xyXG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xyXG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xyXG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoID0gdW5kZWZpbmVkO1xyXG5cclxuLy8gTm90ZTogQWN0dWFsbHkgdGhpcyB0cmFjayBjb3VsZCBoYXZlIGEgb3B0aW1pemVkIC8gY29tcHJlc3NlZFxyXG4vLyByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSB2YWx1ZSBhbmQgYSBjdXN0b20gaW50ZXJwb2xhbnQgdGhhdFxyXG4vLyBjb21wdXRlcyBcImZpcnN0VmFsdWUgXiBpc09kZCggaW5kZXggKVwiLlxyXG5cclxuZXhwb3J0IHsgQm9vbGVhbktleWZyYW1lVHJhY2sgfTtcclxuIiwiaW1wb3J0IHsgS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4uL0tleWZyYW1lVHJhY2suanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgVHJhY2sgb2Yga2V5ZnJhbWUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IGNvbG9yLlxyXG4gKi9cclxuY2xhc3MgQ29sb3JLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxyXG5cclxuQ29sb3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ2NvbG9yJztcclxuLy8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG4vLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbi8vIE5vdGU6IFZlcnkgYmFzaWMgaW1wbGVtZW50YXRpb24gYW5kIG5vdGhpbmcgc3BlY2lhbCB5ZXQuXHJcbi8vIEhvd2V2ZXIsIHRoaXMgaXMgdGhlIHBsYWNlIGZvciBjb2xvciBzcGFjZSBwYXJhbWV0ZXJpemF0aW9uLlxyXG5cclxuZXhwb3J0IHsgQ29sb3JLZXlmcmFtZVRyYWNrIH07XHJcbiIsImltcG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuLi9LZXlmcmFtZVRyYWNrLmpzJztcclxuXHJcbi8qKlxyXG4gKiBBIFRyYWNrIG9mIG51bWVyaWMga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKi9cclxuY2xhc3MgTnVtYmVyS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cclxuXHJcbk51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnbnVtYmVyJztcclxuLy8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG4vLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbmV4cG9ydCB7IE51bWJlcktleWZyYW1lVHJhY2sgfTtcclxuIiwiaW1wb3J0IHsgSW50ZXJwb2xhbnQgfSBmcm9tICcuLi9JbnRlcnBvbGFudC5qcyc7XHJcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9RdWF0ZXJuaW9uLmpzJztcclxuXHJcbi8qKlxyXG4gKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cclxuICovXHJcblxyXG5jbGFzcyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICkge1xyXG5cclxuXHRcdGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcclxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblxyXG5cdFx0XHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcclxuXHJcblx0XHRsZXQgb2Zmc2V0ID0gaTEgKiBzdHJpZGU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGVuZCA9IG9mZnNldCArIHN0cmlkZTsgb2Zmc2V0ICE9PSBlbmQ7IG9mZnNldCArPSA0ICkge1xyXG5cclxuXHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIHJlc3VsdCwgMCwgdmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50IH07XHJcbiIsImltcG9ydCB7IEludGVycG9sYXRlTGluZWFyIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4uL0tleWZyYW1lVHJhY2suanMnO1xyXG5pbXBvcnQgeyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQgfSBmcm9tICcuLi8uLi9tYXRoL2ludGVycG9sYW50cy9RdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQuanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgVHJhY2sgb2YgcXVhdGVybmlvbiBrZXlmcmFtZSB2YWx1ZXMuXHJcbiAqL1xyXG5jbGFzcyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge1xyXG5cclxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIoIHJlc3VsdCApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdxdWF0ZXJuaW9uJztcclxuLy8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZUxpbmVhcjtcclxuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCB7IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIH07XHJcbiIsImltcG9ydCB7IEludGVycG9sYXRlRGlzY3JldGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi4vS2V5ZnJhbWVUcmFjay5qcyc7XHJcblxyXG4vKipcclxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXHJcbiAqL1xyXG5jbGFzcyBTdHJpbmdLZXlmcmFtZVRyYWNrIGV4dGVuZHMgS2V5ZnJhbWVUcmFjayB7fVxyXG5cclxuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdzdHJpbmcnO1xyXG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZUJ1ZmZlclR5cGUgPSBBcnJheTtcclxuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xyXG5TdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIgPSB1bmRlZmluZWQ7XHJcblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcclxuXHJcbmV4cG9ydCB7IFN0cmluZ0tleWZyYW1lVHJhY2sgfTtcclxuIiwiaW1wb3J0IHsgS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4uL0tleWZyYW1lVHJhY2suanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgVHJhY2sgb2YgdmVjdG9yZWQga2V5ZnJhbWUgdmFsdWVzLlxyXG4gKi9cclxuY2xhc3MgVmVjdG9yS2V5ZnJhbWVUcmFjayBleHRlbmRzIEtleWZyYW1lVHJhY2sge31cclxuXHJcblZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAndmVjdG9yJztcclxuLy8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxyXG4vLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcbmV4cG9ydCB7IFZlY3RvcktleWZyYW1lVHJhY2sgfTtcclxuIiwiaW1wb3J0ICogYXMgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi9BbmltYXRpb25VdGlscy5qcyc7XHJcbmltcG9ydCB7IEtleWZyYW1lVHJhY2sgfSBmcm9tICcuL0tleWZyYW1lVHJhY2suanMnO1xyXG5pbXBvcnQgeyBCb29sZWFuS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL0Jvb2xlYW5LZXlmcmFtZVRyYWNrLmpzJztcclxuaW1wb3J0IHsgQ29sb3JLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi90cmFja3MvQ29sb3JLZXlmcmFtZVRyYWNrLmpzJztcclxuaW1wb3J0IHsgTnVtYmVyS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL051bWJlcktleWZyYW1lVHJhY2suanMnO1xyXG5pbXBvcnQgeyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL1F1YXRlcm5pb25LZXlmcmFtZVRyYWNrLmpzJztcclxuaW1wb3J0IHsgU3RyaW5nS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vdHJhY2tzL1N0cmluZ0tleWZyYW1lVHJhY2suanMnO1xyXG5pbXBvcnQgeyBWZWN0b3JLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi90cmFja3MvVmVjdG9yS2V5ZnJhbWVUcmFjay5qcyc7XHJcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcbmltcG9ydCB7IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBBbmltYXRpb25DbGlwIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIGR1cmF0aW9uID0gLSAxLCB0cmFja3MsIGJsZW5kTW9kZSA9IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSApIHtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0dGhpcy50cmFja3MgPSB0cmFja3M7XHJcblx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblx0XHR0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdFx0Ly8gdGhpcyBtZWFucyBpdCBzaG91bGQgZmlndXJlIG91dCBpdHMgZHVyYXRpb24gYnkgc2Nhbm5pbmcgdGhlIHRyYWNrc1xyXG5cdFx0aWYgKCB0aGlzLmR1cmF0aW9uIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMucmVzZXREdXJhdGlvbigpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0c3RhdGljIHBhcnNlKCBqc29uICkge1xyXG5cclxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxyXG5cdFx0XHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXHJcblx0XHRcdGZyYW1lVGltZSA9IDEuMCAvICgganNvbi5mcHMgfHwgMS4wICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0ganNvblRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHR0cmFja3MucHVzaCggcGFyc2VLZXlmcmFtZVRyYWNrKCBqc29uVHJhY2tzWyBpIF0gKS5zY2FsZSggZnJhbWVUaW1lICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY2xpcCA9IG5ldyB0aGlzKCBqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcywganNvbi5ibGVuZE1vZGUgKTtcclxuXHRcdGNsaXAudXVpZCA9IGpzb24udXVpZDtcclxuXHJcblx0XHRyZXR1cm4gY2xpcDtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdG9KU09OKCBjbGlwICkge1xyXG5cclxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdLFxyXG5cdFx0XHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XHJcblxyXG5cdFx0Y29uc3QganNvbiA9IHtcclxuXHJcblx0XHRcdCduYW1lJzogY2xpcC5uYW1lLFxyXG5cdFx0XHQnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxyXG5cdFx0XHQndHJhY2tzJzogdHJhY2tzLFxyXG5cdFx0XHQndXVpZCc6IGNsaXAudXVpZCxcclxuXHRcdFx0J2JsZW5kTW9kZSc6IGNsaXAuYmxlbmRNb2RlXHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBjbGlwVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnRvSlNPTiggY2xpcFRyYWNrc1sgaSBdICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGpzb247XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBtb3JwaFRhcmdldFNlcXVlbmNlLCBmcHMsIG5vTG9vcCApIHtcclxuXHJcblx0XHRjb25zdCBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcclxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdGxldCB0aW1lcyA9IFtdO1xyXG5cdFx0XHRsZXQgdmFsdWVzID0gW107XHJcblxyXG5cdFx0XHR0aW1lcy5wdXNoKFxyXG5cdFx0XHRcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0XHRpLFxyXG5cdFx0XHRcdCggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyApO1xyXG5cclxuXHRcdFx0dmFsdWVzLnB1c2goIDAsIDEsIDAgKTtcclxuXHJcblx0XHRcdGNvbnN0IG9yZGVyID0gQW5pbWF0aW9uVXRpbHMuZ2V0S2V5ZnJhbWVPcmRlciggdGltZXMgKTtcclxuXHRcdFx0dGltZXMgPSBBbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSggdGltZXMsIDEsIG9yZGVyICk7XHJcblx0XHRcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XHJcblxyXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGVcclxuXHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXHJcblx0XHRcdGlmICggISBub0xvb3AgJiYgdGltZXNbIDAgXSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0dGltZXMucHVzaCggbnVtTW9ycGhUYXJnZXRzICk7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlc1sgMCBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0cmFja3MucHVzaChcclxuXHRcdFx0XHRuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayhcclxuXHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcclxuXHRcdFx0XHRcdHRpbWVzLCB2YWx1ZXNcclxuXHRcdFx0XHQpLnNjYWxlKCAxLjAgLyBmcHMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMoIG5hbWUsIC0gMSwgdHJhY2tzICk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZpbmRCeU5hbWUoIG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lICkge1xyXG5cclxuXHRcdGxldCBjbGlwQXJyYXkgPSBvYmplY3RPckNsaXBBcnJheTtcclxuXHJcblx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcclxuXHJcblx0XHRcdGNvbnN0IG8gPSBvYmplY3RPckNsaXBBcnJheTtcclxuXHRcdFx0Y2xpcEFycmF5ID0gby5nZW9tZXRyeSAmJiBvLmdlb21ldHJ5LmFuaW1hdGlvbnMgfHwgby5hbmltYXRpb25zO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXRpYyBDcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggbW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCApIHtcclxuXHJcblx0XHRjb25zdCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xyXG5cclxuXHRcdC8vIHRlc3RlZCB3aXRoIGh0dHBzOi8vcmVnZXgxMDEuY29tLyBvbiB0cmljayBzZXF1ZW5jZXNcclxuXHRcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxyXG5cdFx0Y29uc3QgcGF0dGVybiA9IC9eKFtcXHctXSo/KShbXFxkXSspJC87XHJcblxyXG5cdFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXHJcblx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHRcdGNvbnN0IHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuXHRcdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBuYW1lID0gcGFydHNbIDEgXTtcclxuXHJcblx0XHRcdFx0bGV0IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjbGlwcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRjbGlwcy5wdXNoKCB0aGlzLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdLCBmcHMsIG5vTG9vcCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjbGlwcztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcclxuXHRzdGF0aWMgcGFyc2VBbmltYXRpb24oIGFuaW1hdGlvbiwgYm9uZXMgKSB7XHJcblxyXG5cdFx0aWYgKCAhIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLicgKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGFkZE5vbmVtcHR5VHJhY2sgPSBmdW5jdGlvbiAoIHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XHJcblxyXG5cdFx0XHQvLyBvbmx5IHJldHVybiB0cmFjayBpZiB0aGVyZSBhcmUgYWN0dWFsbHkga2V5cy5cclxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGltZXMgPSBbXTtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oIGFuaW1hdGlvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHByb3BlcnR5TmFtZSApO1xyXG5cclxuXHRcdFx0XHQvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXHJcblx0XHRcdFx0aWYgKCB0aW1lcy5sZW5ndGggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGVzdFRyYWNrcy5wdXNoKCBuZXcgdHJhY2tUeXBlKCB0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCB0cmFja3MgPSBbXTtcclxuXHJcblx0XHRjb25zdCBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0JztcclxuXHRcdGNvbnN0IGZwcyA9IGFuaW1hdGlvbi5mcHMgfHwgMzA7XHJcblx0XHRjb25zdCBibGVuZE1vZGUgPSBhbmltYXRpb24uYmxlbmRNb2RlO1xyXG5cclxuXHRcdC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxyXG5cdFx0bGV0IGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtIDE7XHJcblxyXG5cdFx0Y29uc3QgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XHJcblxyXG5cdFx0XHQvLyBza2lwIGVtcHR5IHRyYWNrc1xyXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzXHJcblx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcclxuXHRcdFx0XHRjb25zdCBtb3JwaFRhcmdldE5hbWVzID0ge307XHJcblxyXG5cdFx0XHRcdGxldCBrO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGxldCBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtb3JwaFRhcmdldE5hbWVzWyBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF0gXSA9IC0gMTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cclxuXHRcdFx0XHQvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxyXG5cdFx0XHRcdC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cclxuXHRcdFx0XHRmb3IgKCBjb25zdCBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0aW1lcyA9IFtdO1xyXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IG0gPSAwOyBtICE9PSBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgKysgbSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNbIGsgXTtcclxuXHJcblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goIGFuaW1hdGlvbktleS50aW1lICk7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCAoIGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lICkgPyAxIDogMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0cmFja3MucHVzaCggbmV3IE51bWJlcktleWZyYW1lVHJhY2soICcubW9ycGhUYXJnZXRJbmZsdWVuY2VbJyArIG1vcnBoVGFyZ2V0TmFtZSArICddJywgdGltZXMsIHZhbHVlcyApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqIGZwcztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cclxuXHJcblx0XHRcdFx0Y29uc3QgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XHJcblxyXG5cdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXHJcblx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucG9zaXRpb24nLFxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3BvcycsIHRyYWNrcyApO1xyXG5cclxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxyXG5cdFx0XHRcdFx0UXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJyxcclxuXHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MgKTtcclxuXHJcblx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcclxuXHRcdFx0XHRcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5zY2FsZScsXHJcblx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjbGlwID0gbmV3IHRoaXMoIGNsaXBOYW1lLCBkdXJhdGlvbiwgdHJhY2tzLCBibGVuZE1vZGUgKTtcclxuXHJcblx0XHRyZXR1cm4gY2xpcDtcclxuXHJcblx0fVxyXG5cclxuXHRyZXNldER1cmF0aW9uKCkge1xyXG5cclxuXHRcdGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzO1xyXG5cdFx0bGV0IGR1cmF0aW9uID0gMDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xyXG5cclxuXHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heCggZHVyYXRpb24sIHRyYWNrLnRpbWVzWyB0cmFjay50aW1lcy5sZW5ndGggLSAxIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyaW0oKSB7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy50cmFja3NbIGkgXS50cmltKCAwLCB0aGlzLmR1cmF0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhbGlkYXRlKCkge1xyXG5cclxuXHRcdGxldCB2YWxpZCA9IHRydWU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFsaWQgPSB2YWxpZCAmJiB0aGlzLnRyYWNrc1sgaSBdLnZhbGlkYXRlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWxpZDtcclxuXHJcblx0fVxyXG5cclxuXHRvcHRpbWl6ZSgpIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnRyYWNrc1sgaSBdLm9wdGltaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdGNvbnN0IHRyYWNrcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRyYWNrcy5wdXNoKCB0aGlzLnRyYWNrc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm5hbWUsIHRoaXMuZHVyYXRpb24sIHRyYWNrcywgdGhpcy5ibGVuZE1vZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9KU09OKCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIHR5cGVOYW1lICkge1xyXG5cclxuXHRzd2l0Y2ggKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xyXG5cclxuXHRcdGNhc2UgJ3NjYWxhcic6XHJcblx0XHRjYXNlICdkb3VibGUnOlxyXG5cdFx0Y2FzZSAnZmxvYXQnOlxyXG5cdFx0Y2FzZSAnbnVtYmVyJzpcclxuXHRcdGNhc2UgJ2ludGVnZXInOlxyXG5cclxuXHRcdFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0Y2FzZSAndmVjdG9yJzpcclxuXHRcdGNhc2UgJ3ZlY3RvcjInOlxyXG5cdFx0Y2FzZSAndmVjdG9yMyc6XHJcblx0XHRjYXNlICd2ZWN0b3I0JzpcclxuXHJcblx0XHRcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xyXG5cclxuXHRcdGNhc2UgJ2NvbG9yJzpcclxuXHJcblx0XHRcdHJldHVybiBDb2xvcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0Y2FzZSAncXVhdGVybmlvbic6XHJcblxyXG5cdFx0XHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0Y2FzZSAnYm9vbCc6XHJcblx0XHRjYXNlICdib29sZWFuJzpcclxuXHJcblx0XHRcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRjYXNlICdzdHJpbmcnOlxyXG5cclxuXHRcdFx0cmV0dXJuIFN0cmluZ0tleWZyYW1lVHJhY2s7XHJcblxyXG5cdH1cclxuXHJcblx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVW5zdXBwb3J0ZWQgdHlwZU5hbWU6ICcgKyB0eXBlTmFtZSApO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VLZXlmcmFtZVRyYWNrKCBqc29uICkge1xyXG5cclxuXHRpZiAoIGpzb24udHlwZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IHRyYWNrVHlwZSA9IGdldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xyXG5cclxuXHRpZiAoIGpzb24udGltZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRjb25zdCB0aW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTigganNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnICk7XHJcblxyXG5cdFx0anNvbi50aW1lcyA9IHRpbWVzO1xyXG5cdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXHJcblx0aWYgKCB0cmFja1R5cGUucGFyc2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXHJcblx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZSgganNvbi5uYW1lLCBqc29uLnRpbWVzLCBqc29uLnZhbHVlcywganNvbi5pbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEFuaW1hdGlvbkNsaXAgfTtcclxuIiwiY29uc3QgQ2FjaGUgPSB7XHJcblxyXG5cdGVuYWJsZWQ6IGZhbHNlLFxyXG5cclxuXHRmaWxlczoge30sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBrZXksIGZpbGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQWRkaW5nIGtleTonLCBrZXkgKTtcclxuXHJcblx0XHR0aGlzLmZpbGVzWyBrZXkgXSA9IGZpbGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcclxuXHJcblx0XHRkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5maWxlcyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbmV4cG9ydCB7IENhY2hlIH07XHJcbiIsImNsYXNzIExvYWRpbmdNYW5hZ2VyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cdFx0bGV0IGl0ZW1zTG9hZGVkID0gMDtcclxuXHRcdGxldCBpdGVtc1RvdGFsID0gMDtcclxuXHRcdGxldCB1cmxNb2RpZmllciA9IHVuZGVmaW5lZDtcclxuXHRcdGNvbnN0IGhhbmRsZXJzID0gW107XHJcblxyXG5cdFx0Ly8gUmVmZXIgdG8gIzU2ODkgZm9yIHRoZSByZWFzb24gd2h5IHdlIGRvbid0IHNldCAub25TdGFydFxyXG5cdFx0Ly8gaW4gdGhlIGNvbnN0cnVjdG9yXHJcblxyXG5cdFx0dGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XHJcblx0XHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xyXG5cdFx0dGhpcy5vbkVycm9yID0gb25FcnJvcjtcclxuXHJcblx0XHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdFx0aXRlbXNUb3RhbCArKztcclxuXHJcblx0XHRcdGlmICggaXNMb2FkaW5nID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpc0xvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0XHRpdGVtc0xvYWRlZCArKztcclxuXHJcblx0XHRcdGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xyXG5cclxuXHRcdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5vbkxvYWQoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5vbkVycm9yKCB1cmwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMucmVzb2x2ZVVSTCA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdFx0aWYgKCB1cmxNb2RpZmllciApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHVybE1vZGlmaWVyKCB1cmwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1cmw7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFVSTE1vZGlmaWVyID0gZnVuY3Rpb24gKCB0cmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0XHR1cmxNb2RpZmllciA9IHRyYW5zZm9ybTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5hZGRIYW5kbGVyID0gZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xyXG5cclxuXHRcdFx0aGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoIHJlZ2V4ICkge1xyXG5cclxuXHRcdFx0Y29uc3QgaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKCByZWdleCApO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGluZGV4LCAyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uICggZmlsZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgcmVnZXggPSBoYW5kbGVyc1sgaSBdO1xyXG5cdFx0XHRcdGNvbnN0IGxvYWRlciA9IGhhbmRsZXJzWyBpICsgMSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlZ2V4Lmdsb2JhbCApIHJlZ2V4Lmxhc3RJbmRleCA9IDA7IC8vIHNlZSAjMTc5MjBcclxuXHJcblx0XHRcdFx0aWYgKCByZWdleC50ZXN0KCBmaWxlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGxvYWRlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY29uc3QgRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gLypAX19QVVJFX18qLyBuZXcgTG9hZGluZ01hbmFnZXIoKTtcclxuXHJcbmV4cG9ydCB7IERlZmF1bHRMb2FkaW5nTWFuYWdlciwgTG9hZGluZ01hbmFnZXIgfTtcclxuIiwiaW1wb3J0IHsgRGVmYXVsdExvYWRpbmdNYW5hZ2VyIH0gZnJvbSAnLi9Mb2FkaW5nTWFuYWdlci5qcyc7XHJcblxyXG5jbGFzcyBMb2FkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5wYXRoID0gJyc7XHJcblx0XHR0aGlzLnJlc291cmNlUGF0aCA9ICcnO1xyXG5cdFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0ge307XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggLyogdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKi8gKSB7fVxyXG5cclxuXHRsb2FkQXN5bmMoIHVybCwgb25Qcm9ncmVzcyApIHtcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUsIHJlamVjdCApIHtcclxuXHJcblx0XHRcdHNjb3BlLmxvYWQoIHVybCwgcmVzb2x2ZSwgb25Qcm9ncmVzcywgcmVqZWN0ICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlKCAvKiBkYXRhICovICkge31cclxuXHJcblx0c2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICkge1xyXG5cclxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFdpdGhDcmVkZW50aWFscyggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFBhdGgoIHBhdGggKSB7XHJcblxyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFJlc291cmNlUGF0aCggcmVzb3VyY2VQYXRoICkge1xyXG5cclxuXHRcdHRoaXMucmVzb3VyY2VQYXRoID0gcmVzb3VyY2VQYXRoO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0UmVxdWVzdEhlYWRlciggcmVxdWVzdEhlYWRlciApIHtcclxuXHJcblx0XHR0aGlzLnJlcXVlc3RIZWFkZXIgPSByZXF1ZXN0SGVhZGVyO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbkxvYWRlci5ERUZBVUxUX01BVEVSSUFMX05BTUUgPSAnX19ERUZBVUxUJztcclxuXHJcbmV4cG9ydCB7IExvYWRlciB9O1xyXG4iLCJpbXBvcnQgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xyXG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XHJcblxyXG5jb25zdCBsb2FkaW5nID0ge307XHJcblxyXG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtZXNzYWdlLCByZXNwb25zZSApIHtcclxuXHJcblx0XHRzdXBlciggbWVzc2FnZSApO1xyXG5cdFx0dGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBGaWxlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcclxuXHJcblx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XHJcblxyXG5cdFx0Y29uc3QgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcclxuXHJcblx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG5cdFx0XHRzZXRUaW1lb3V0KCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSwgMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgcmVxdWVzdCBpcyBkdXBsaWNhdGVcclxuXHJcblx0XHRpZiAoIGxvYWRpbmdbIHVybCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsb2FkaW5nWyB1cmwgXS5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxyXG5cdFx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXHJcblx0XHRcdFx0b25FcnJvcjogb25FcnJvclxyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0aWFsaXNlIGFycmF5IGZvciBkdXBsaWNhdGUgcmVxdWVzdHNcclxuXHRcdGxvYWRpbmdbIHVybCBdID0gW107XHJcblxyXG5cdFx0bG9hZGluZ1sgdXJsIF0ucHVzaCgge1xyXG5cdFx0XHRvbkxvYWQ6IG9uTG9hZCxcclxuXHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcclxuXHRcdFx0b25FcnJvcjogb25FcnJvcixcclxuXHRcdH0gKTtcclxuXHJcblx0XHQvLyBjcmVhdGUgcmVxdWVzdFxyXG5cdFx0Y29uc3QgcmVxID0gbmV3IFJlcXVlc3QoIHVybCwge1xyXG5cdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyggdGhpcy5yZXF1ZXN0SGVhZGVyICksXHJcblx0XHRcdGNyZWRlbnRpYWxzOiB0aGlzLndpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbicsXHJcblx0XHRcdC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0Ly8gcmVjb3JkIHN0YXRlcyAoIGF2b2lkIGRhdGEgcmFjZSApXHJcblx0XHRjb25zdCBtaW1lVHlwZSA9IHRoaXMubWltZVR5cGU7XHJcblx0XHRjb25zdCByZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuXHJcblx0XHQvLyBzdGFydCB0aGUgZmV0Y2hcclxuXHRcdGZldGNoKCByZXEgKVxyXG5cdFx0XHQudGhlbiggcmVzcG9uc2UgPT4ge1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcclxuXHRcdFx0XHRcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZXNwb25zZS5zdGF0dXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gV29ya2Fyb3VuZDogQ2hlY2tpbmcgaWYgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIGZvciBBbGlwYXkgYnJvd3NlciAjMjM1NDhcclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2U7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xyXG5cdFx0XHRcdFx0Y29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcclxuXHJcblx0XHRcdFx0XHQvLyBOZ2lueCBuZWVkcyBYLUZpbGUtU2l6ZSBjaGVja1xyXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzQ4Mjg3NS93aHktZG9lcy1uZ2lueC1yZW1vdmUtY29udGVudC1sZW5ndGgtaGVhZGVyLWZvci1jaHVua2VkLWNvbnRlbnRcclxuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzLmdldCggJ0NvbnRlbnQtTGVuZ3RoJyApIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCAnWC1GaWxlLVNpemUnICk7XHJcblx0XHRcdFx0XHRjb25zdCB0b3RhbCA9IGNvbnRlbnRMZW5ndGggPyBwYXJzZUludCggY29udGVudExlbmd0aCApIDogMDtcclxuXHRcdFx0XHRcdGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSB0b3RhbCAhPT0gMDtcclxuXHRcdFx0XHRcdGxldCBsb2FkZWQgPSAwO1xyXG5cclxuXHRcdFx0XHRcdC8vIHBlcmlvZGljYWxseSByZWFkIGRhdGEgaW50byB0aGUgbmV3IHN0cmVhbSB0cmFja2luZyB3aGlsZSBkb3dubG9hZCBwcm9ncmVzc1xyXG5cdFx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKCB7XHJcblx0XHRcdFx0XHRcdHN0YXJ0KCBjb250cm9sbGVyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZWFkRGF0YSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiByZWFkRGF0YSgpIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oICggeyBkb25lLCB2YWx1ZSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkb25lICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZXZlbnQgPSBuZXcgUHJvZ3Jlc3NFdmVudCggJ3Byb2dyZXNzJywgeyBsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsIH0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLm9uUHJvZ3Jlc3MgKSBjYWxsYmFjay5vblByb2dyZXNzKCBldmVudCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZSggdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZWFkRGF0YSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKCBzdHJlYW0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgSHR0cEVycm9yKCBgZmV0Y2ggZm9yIFwiJHtyZXNwb25zZS51cmx9XCIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCwgcmVzcG9uc2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSApXHJcblx0XHRcdC50aGVuKCByZXNwb25zZSA9PiB7XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHJlc3BvbnNlVHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdibG9iJzpcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5ibG9iKCk7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnZG9jdW1lbnQnOlxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLnRleHQoKVxyXG5cdFx0XHRcdFx0XHRcdC50aGVuKCB0ZXh0ID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgbWltZVR5cGUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ2pzb24nOlxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBtaW1lVHlwZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gc25pZmYgZW5jb2RpbmdcclxuXHRcdFx0XHRcdFx0XHRjb25zdCByZSA9IC9jaGFyc2V0PVwiPyhbXjtcIlxcc10qKVwiPy9pO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGV4ZWMgPSByZS5leGVjKCBtaW1lVHlwZSApO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxhYmVsID0gZXhlYyAmJiBleGVjWyAxIF0gPyBleGVjWyAxIF0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCBsYWJlbCApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpLnRoZW4oIGFiID0+IGRlY29kZXIuZGVjb2RlKCBhYiApICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gKVxyXG5cdFx0XHQudGhlbiggZGF0YSA9PiB7XHJcblxyXG5cdFx0XHRcdC8vIEFkZCB0byBjYWNoZSBvbmx5IG9uIEhUVFAgc3VjY2Vzcywgc28gdGhhdCB3ZSBkbyBub3QgY2FjaGVcclxuXHRcdFx0XHQvLyBlcnJvciByZXNwb25zZSBib2RpZXMgYXMgcHJvcGVyIHJlc3BvbnNlcyB0byByZXF1ZXN0cy5cclxuXHRcdFx0XHRDYWNoZS5hZGQoIHVybCwgZGF0YSApO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcclxuXHRcdFx0XHRkZWxldGUgbG9hZGluZ1sgdXJsIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcclxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25Mb2FkICkgY2FsbGJhY2sub25Mb2FkKCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gKVxyXG5cdFx0XHQuY2F0Y2goIGVyciA9PiB7XHJcblxyXG5cdFx0XHRcdC8vIEFib3J0IGVycm9ycyBhbmQgb3RoZXIgZXJyb3JzIGFyZSBoYW5kbGVkIHRoZSBzYW1lXHJcblxyXG5cdFx0XHRcdGNvbnN0IGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFdoZW4gb25Mb2FkIHdhcyBjYWxsZWQgYW5kIHVybCB3YXMgZGVsZXRlZCBpbiBgbG9hZGluZ2BcclxuXHRcdFx0XHRcdHRoaXMubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSBsb2FkaW5nWyB1cmwgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xyXG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXJyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblxyXG5cdFx0XHR9IClcclxuXHRcdFx0LmZpbmFsbHkoICgpID0+IHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdHRoaXMubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFJlc3BvbnNlVHlwZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE1pbWVUeXBlKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm1pbWVUeXBlID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEZpbGVMb2FkZXIgfTtcclxuIiwiaW1wb3J0IHsgQW5pbWF0aW9uQ2xpcCB9IGZyb20gJy4uL2FuaW1hdGlvbi9BbmltYXRpb25DbGlwLmpzJztcclxuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XHJcbmltcG9ydCB7IExvYWRlciB9IGZyb20gJy4vTG9hZGVyLmpzJztcclxuXHJcbmNsYXNzIEFuaW1hdGlvbkxvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcclxuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xyXG5cclxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcclxuXHJcblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2UoIGpzb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgYW5pbWF0aW9ucyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhbmltYXRpb25zO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgQW5pbWF0aW9uTG9hZGVyIH07XHJcbiIsImltcG9ydCB7IExpbmVhckZpbHRlciB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL0ZpbGVMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBDb21wcmVzc2VkVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0NvbXByZXNzZWRUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxyXG4gKlxyXG4gKiBTdWIgY2xhc3NlcyBoYXZlIHRvIGltcGxlbWVudCB0aGUgcGFyc2UoKSBtZXRob2Qgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGxvYWQoKS5cclxuICovXHJcblxyXG5jbGFzcyBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGltYWdlcyA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ29tcHJlc3NlZFRleHR1cmUoKTtcclxuXHJcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XHJcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcclxuXHJcblx0XHRsZXQgbG9hZGVkID0gMDtcclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcclxuXHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmxbIGkgXSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRleERhdGFzID0gc2NvcGUucGFyc2UoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcclxuXHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcclxuXHRcdFx0XHRcdGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXHJcblx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0bG9hZGVkICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcclxuXHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHM6IFtdIH07XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgfTtcclxuIiwiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcclxuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50TlMgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcblxyXG5jbGFzcyBJbWFnZUxvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcclxuXHJcblx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSwgMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaW1hZ2UgPSBjcmVhdGVFbGVtZW50TlMoICdpbWcnICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVFdmVudExpc3RlbmVycygpO1xyXG5cclxuXHRcdFx0Q2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0aGlzICk7XHJcblxyXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbkltYWdlRXJyb3IoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHJcblx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xyXG5cclxuXHRcdFx0aW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UgKTtcclxuXHRcdFx0aW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgb25JbWFnZUVycm9yLCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIG9uSW1hZ2VMb2FkLCBmYWxzZSApO1xyXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgb25JbWFnZUVycm9yLCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggdXJsLnNsaWNlKCAwLCA1ICkgIT09ICdkYXRhOicgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdGltYWdlLnNyYyA9IHVybDtcclxuXHJcblx0XHRyZXR1cm4gaW1hZ2U7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBJbWFnZUxvYWRlciB9O1xyXG4iLCJpbXBvcnQgeyBJbWFnZUxvYWRlciB9IGZyb20gJy4vSW1hZ2VMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBDdWJlVGV4dHVyZSB9IGZyb20gJy4uL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBDdWJlVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJscywgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcclxuXHRcdHRleHR1cmUuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xyXG5cclxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHJcblx0XHRsZXQgbG9hZGVkID0gMDtcclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcclxuXHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcclxuXHJcblx0XHRcdFx0bG9hZGVkICsrO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9LCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEN1YmVUZXh0dXJlTG9hZGVyIH07XHJcbiIsImltcG9ydCB7IExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nIH0gZnJvbSAnLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XHJcbmltcG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxyXG4gKlxyXG4gKiBTdWIgY2xhc3NlcyBoYXZlIHRvIGltcGxlbWVudCB0aGUgcGFyc2UoKSBtZXRob2Qgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGxvYWQoKS5cclxuICovXHJcblxyXG5jbGFzcyBEYXRhVGV4dHVyZUxvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoKTtcclxuXHJcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdGV4RGF0YSA9IHNjb3BlLnBhcnNlKCBidWZmZXIgKTtcclxuXHJcblx0XHRcdGlmICggISB0ZXhEYXRhICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXhEYXRhLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4RGF0YS5kYXRhICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xyXG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGV4dHVyZS53cmFwUyA9IHRleERhdGEud3JhcFMgIT09IHVuZGVmaW5lZCA/IHRleERhdGEud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gdGV4RGF0YS53cmFwVCAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleERhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcclxuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB0ZXhEYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSB0ZXhEYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XHJcblxyXG5cdFx0XHRpZiAoIHRleERhdGEuY29sb3JTcGFjZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXhEYXRhLmNvbG9yU3BhY2U7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXhEYXRhLmVuY29kaW5nICE9PSB1bmRlZmluZWQgKSB7IC8vIEBkZXByZWNhdGVkLCByMTUyXHJcblxyXG5cdFx0XHRcdHRleHR1cmUuZW5jb2RpbmcgPSB0ZXhEYXRhLmVuY29kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXhEYXRhLmZsaXBZICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuZmxpcFkgPSB0ZXhEYXRhLmZsaXBZO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXhEYXRhLmZvcm1hdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXhEYXRhLnR5cGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXhEYXRhLm1pcG1hcHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xyXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOyAvLyBwcmVzdW1hYmx5Li4uXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleERhdGEubWlwbWFwQ291bnQgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXhEYXRhLmdlbmVyYXRlTWlwbWFwcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleERhdGEuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciB9O1xyXG4iLCJpbXBvcnQgeyBJbWFnZUxvYWRlciB9IGZyb20gJy4vSW1hZ2VMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IExvYWRlciB9IGZyb20gJy4vTG9hZGVyLmpzJztcclxuXHJcbmNsYXNzIFRleHR1cmVMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcclxuXHJcblx0XHRzdXBlciggbWFuYWdlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xyXG5cclxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xyXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFRleHR1cmVMb2FkZXIgfTtcclxuIiwiaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbmNsYXNzIExpZ2h0IGV4dGVuZHMgT2JqZWN0M0Qge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSA9IDEgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzTGlnaHQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaWdodCc7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcclxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gaW50ZW5zaXR5O1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0Ly8gRW1wdHkgaGVyZSBpbiBiYXNlIGNsYXNzOyBzb21lIHN1YmNsYXNzZXMgb3ZlcnJpZGUuXHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggbWV0YSApIHtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCBtZXRhICk7XHJcblxyXG5cdFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cdFx0ZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XHJcblx0XHRpZiAoIHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcclxuXHRcdGlmICggdGhpcy5kZWNheSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xyXG5cdFx0aWYgKCB0aGlzLnBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmE7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNoYWRvdyAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3Quc2hhZG93ID0gdGhpcy5zaGFkb3cudG9KU09OKCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IExpZ2h0IH07XHJcbiIsImltcG9ydCB7IExpZ2h0IH0gZnJvbSAnLi9MaWdodC5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcblxyXG5jbGFzcyBIZW1pc3BoZXJlTGlnaHQgZXh0ZW5kcyBMaWdodCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0XHRzdXBlciggc2t5Q29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMuaXNIZW1pc3BoZXJlTGlnaHQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuREVGQVVMVF9VUCApO1xyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKCBncm91bmRDb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0dGhpcy5ncm91bmRDb2xvci5jb3B5KCBzb3VyY2UuZ3JvdW5kQ29sb3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0IH07XHJcbiIsImltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5pbXBvcnQgeyBGcnVzdHVtIH0gZnJvbSAnLi4vbWF0aC9GcnVzdHVtLmpzJztcclxuXHJcbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfbGlnaHRQb3NpdGlvbldvcmxkID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfbG9va1RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIExpZ2h0U2hhZG93IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGNhbWVyYSApIHtcclxuXHJcblx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHR0aGlzLmJpYXMgPSAwO1xyXG5cdFx0dGhpcy5ub3JtYWxCaWFzID0gMDtcclxuXHRcdHRoaXMucmFkaXVzID0gMTtcclxuXHRcdHRoaXMuYmx1clNhbXBsZXMgPSA4O1xyXG5cclxuXHRcdHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCA1MTIsIDUxMiApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHRcdHRoaXMubWFwUGFzcyA9IG51bGw7XHJcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcclxuXHRcdHRoaXMuX2ZyYW1lRXh0ZW50cyA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDE7XHJcblxyXG5cdFx0dGhpcy5fdmlld3BvcnRzID0gW1xyXG5cclxuXHRcdFx0bmV3IFZlY3RvcjQoIDAsIDAsIDEsIDEgKVxyXG5cclxuXHRcdF07XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Vmlld3BvcnRDb3VudCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fdmlld3BvcnRDb3VudDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGcnVzdHVtKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9mcnVzdHVtO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCApIHtcclxuXHJcblx0XHRjb25zdCBzaGFkb3dDYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHRcdGNvbnN0IHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xyXG5cclxuXHRcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcclxuXHJcblx0XHRfbG9va1RhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcclxuXHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHR0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdHNoYWRvd01hdHJpeC5zZXQoXHJcblx0XHRcdDAuNSwgMC4wLCAwLjAsIDAuNSxcclxuXHRcdFx0MC4wLCAwLjUsIDAuMCwgMC41LFxyXG5cdFx0XHQwLjAsIDAuMCwgMC41LCAwLjUsXHJcblx0XHRcdDAuMCwgMC4wLCAwLjAsIDEuMFxyXG5cdFx0KTtcclxuXHJcblx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Vmlld3BvcnQoIHZpZXdwb3J0SW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXdwb3J0c1sgdmlld3BvcnRJbmRleCBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEZyYW1lRXh0ZW50cygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZnJhbWVFeHRlbnRzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hcCApIHtcclxuXHJcblx0XHRcdHRoaXMubWFwLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hcFBhc3MgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hcFBhc3MuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHNvdXJjZS5yYWRpdXM7XHJcblxyXG5cdFx0dGhpcy5tYXBTaXplLmNvcHkoIHNvdXJjZS5tYXBTaXplICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTigpIHtcclxuXHJcblx0XHRjb25zdCBvYmplY3QgPSB7fTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYmlhcyAhPT0gMCApIG9iamVjdC5iaWFzID0gdGhpcy5iaWFzO1xyXG5cdFx0aWYgKCB0aGlzLm5vcm1hbEJpYXMgIT09IDAgKSBvYmplY3Qubm9ybWFsQmlhcyA9IHRoaXMubm9ybWFsQmlhcztcclxuXHRcdGlmICggdGhpcy5yYWRpdXMgIT09IDEgKSBvYmplY3QucmFkaXVzID0gdGhpcy5yYWRpdXM7XHJcblx0XHRpZiAoIHRoaXMubWFwU2l6ZS54ICE9PSA1MTIgfHwgdGhpcy5tYXBTaXplLnkgIT09IDUxMiApIG9iamVjdC5tYXBTaXplID0gdGhpcy5tYXBTaXplLnRvQXJyYXkoKTtcclxuXHJcblx0XHRvYmplY3QuY2FtZXJhID0gdGhpcy5jYW1lcmEudG9KU09OKCBmYWxzZSApLm9iamVjdDtcclxuXHRcdGRlbGV0ZSBvYmplY3QuY2FtZXJhLm1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gb2JqZWN0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBMaWdodFNoYWRvdyB9O1xyXG4iLCJpbXBvcnQgeyBMaWdodFNoYWRvdyB9IGZyb20gJy4vTGlnaHRTaGFkb3cuanMnO1xyXG5pbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xyXG5cclxuY2xhc3MgU3BvdExpZ2h0U2hhZG93IGV4dGVuZHMgTGlnaHRTaGFkb3cge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlciggbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgMC41LCA1MDAgKSApO1xyXG5cclxuXHRcdHRoaXMuaXNTcG90TGlnaHRTaGFkb3cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZm9jdXMgPSAxO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCApIHtcclxuXHJcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHJcblx0XHRjb25zdCBmb3YgPSBNYXRoVXRpbHMuUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZSAqIHRoaXMuZm9jdXM7XHJcblx0XHRjb25zdCBhc3BlY3QgPSB0aGlzLm1hcFNpemUud2lkdGggLyB0aGlzLm1hcFNpemUuaGVpZ2h0O1xyXG5cdFx0Y29uc3QgZmFyID0gbGlnaHQuZGlzdGFuY2UgfHwgY2FtZXJhLmZhcjtcclxuXHJcblx0XHRpZiAoIGZvdiAhPT0gY2FtZXJhLmZvdiB8fCBhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgfHwgZmFyICE9PSBjYW1lcmEuZmFyICkge1xyXG5cclxuXHRcdFx0Y2FtZXJhLmZvdiA9IGZvdjtcclxuXHRcdFx0Y2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcclxuXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcclxuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3VwZXIudXBkYXRlTWF0cmljZXMoIGxpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNwb3RMaWdodFNoYWRvdyB9O1xyXG4iLCJpbXBvcnQgeyBMaWdodCB9IGZyb20gJy4vTGlnaHQuanMnO1xyXG5pbXBvcnQgeyBTcG90TGlnaHRTaGFkb3cgfSBmcm9tICcuL1Nwb3RMaWdodFNoYWRvdy5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcblxyXG5jbGFzcyBTcG90TGlnaHQgZXh0ZW5kcyBMaWdodCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSA9IDAsIGFuZ2xlID0gTWF0aC5QSSAvIDMsIHBlbnVtYnJhID0gMCwgZGVjYXkgPSAyICkge1xyXG5cclxuXHRcdHN1cGVyKCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy5pc1Nwb3RMaWdodCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XHJcblxyXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5ERUZBVUxUX1VQICk7XHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0dGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG5cdFx0dGhpcy5hbmdsZSA9IGFuZ2xlO1xyXG5cdFx0dGhpcy5wZW51bWJyYSA9IHBlbnVtYnJhO1xyXG5cdFx0dGhpcy5kZWNheSA9IGRlY2F5O1xyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNoYWRvdyA9IG5ldyBTcG90TGlnaHRTaGFkb3coKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgcG93ZXIoKSB7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0aGUgbGlnaHQncyBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKSBmcm9tIGl0cyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpXHJcblx0XHQvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcclxuXHRcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIE1hdGguUEk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHBvd2VyKCBwb3dlciApIHtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGxpZ2h0J3MgaW50ZW5zaXR5IChpbiBjYW5kZWxhKSBmcm9tIHRoZSBkZXNpcmVkIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpXHJcblx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gTWF0aC5QSTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XHJcblx0XHR0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xyXG5cdFx0dGhpcy5wZW51bWJyYSA9IHNvdXJjZS5wZW51bWJyYTtcclxuXHRcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XHJcblxyXG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNwb3RMaWdodCB9O1xyXG4iLCJpbXBvcnQgeyBMaWdodFNoYWRvdyB9IGZyb20gJy4vTGlnaHRTaGFkb3cuanMnO1xyXG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuXHJcbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfbGlnaHRQb3NpdGlvbldvcmxkID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfbG9va1RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIFBvaW50TGlnaHRTaGFkb3cgZXh0ZW5kcyBMaWdodFNoYWRvdyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxLCAwLjUsIDUwMCApICk7XHJcblxyXG5cdFx0dGhpcy5pc1BvaW50TGlnaHRTaGFkb3cgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2ZyYW1lRXh0ZW50cyA9IG5ldyBWZWN0b3IyKCA0LCAyICk7XHJcblxyXG5cdFx0dGhpcy5fdmlld3BvcnRDb3VudCA9IDY7XHJcblxyXG5cdFx0dGhpcy5fdmlld3BvcnRzID0gW1xyXG5cdFx0XHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcclxuXHRcdFx0Ly8gZm9sbG93aW5nIG9yaWVudGF0aW9uOlxyXG5cdFx0XHQvL1xyXG5cdFx0XHQvLyAgeHpYWlxyXG5cdFx0XHQvLyAgIHkgWVxyXG5cdFx0XHQvL1xyXG5cdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cclxuXHRcdFx0Ly8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXHJcblx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cclxuXHRcdFx0Ly8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXHJcblx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cclxuXHRcdFx0Ly8gcG9zaXRpdmUgWFxyXG5cdFx0XHRuZXcgVmVjdG9yNCggMiwgMSwgMSwgMSApLFxyXG5cdFx0XHQvLyBuZWdhdGl2ZSBYXHJcblx0XHRcdG5ldyBWZWN0b3I0KCAwLCAxLCAxLCAxICksXHJcblx0XHRcdC8vIHBvc2l0aXZlIFpcclxuXHRcdFx0bmV3IFZlY3RvcjQoIDMsIDEsIDEsIDEgKSxcclxuXHRcdFx0Ly8gbmVnYXRpdmUgWlxyXG5cdFx0XHRuZXcgVmVjdG9yNCggMSwgMSwgMSwgMSApLFxyXG5cdFx0XHQvLyBwb3NpdGl2ZSBZXHJcblx0XHRcdG5ldyBWZWN0b3I0KCAzLCAwLCAxLCAxICksXHJcblx0XHRcdC8vIG5lZ2F0aXZlIFlcclxuXHRcdFx0bmV3IFZlY3RvcjQoIDEsIDAsIDEsIDEgKVxyXG5cdFx0XTtcclxuXHJcblx0XHR0aGlzLl9jdWJlRGlyZWN0aW9ucyA9IFtcclxuXHRcdFx0bmV3IFZlY3RvcjMoIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIC0gMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFxyXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMCwgLSAxICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAtIDEsIDAgKVxyXG5cdFx0XTtcclxuXHJcblx0XHR0aGlzLl9jdWJlVXBzID0gW1xyXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxyXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApXHJcblx0XHRdO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1hdHJpY2VzKCBsaWdodCwgdmlld3BvcnRJbmRleCA9IDAgKSB7XHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcblx0XHRjb25zdCBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuXHJcblx0XHRjb25zdCBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xyXG5cclxuXHRcdGlmICggZmFyICE9PSBjYW1lcmEuZmFyICkge1xyXG5cclxuXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcclxuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRjYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xyXG5cclxuXHRcdF9sb29rVGFyZ2V0LmNvcHkoIGNhbWVyYS5wb3NpdGlvbiApO1xyXG5cdFx0X2xvb2tUYXJnZXQuYWRkKCB0aGlzLl9jdWJlRGlyZWN0aW9uc1sgdmlld3BvcnRJbmRleCBdICk7XHJcblx0XHRjYW1lcmEudXAuY29weSggdGhpcy5fY3ViZVVwc1sgdmlld3BvcnRJbmRleCBdICk7XHJcblx0XHRjYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG5cdFx0Y2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0c2hhZG93TWF0cml4Lm1ha2VUcmFuc2xhdGlvbiggLSBfbGlnaHRQb3NpdGlvbldvcmxkLngsIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC55LCAtIF9saWdodFBvc2l0aW9uV29ybGQueiApO1xyXG5cclxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHR0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBQb2ludExpZ2h0U2hhZG93IH07XHJcbiIsImltcG9ydCB7IExpZ2h0IH0gZnJvbSAnLi9MaWdodC5qcyc7XHJcbmltcG9ydCB7IFBvaW50TGlnaHRTaGFkb3cgfSBmcm9tICcuL1BvaW50TGlnaHRTaGFkb3cuanMnO1xyXG5cclxuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIExpZ2h0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlID0gMCwgZGVjYXkgPSAyICkge1xyXG5cclxuXHRcdHN1cGVyKCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy5pc1BvaW50TGlnaHQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcclxuXHJcblx0XHR0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XHJcblx0XHR0aGlzLmRlY2F5ID0gZGVjYXk7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3cgPSBuZXcgUG9pbnRMaWdodFNoYWRvdygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBwb3dlcigpIHtcclxuXHJcblx0XHQvLyBjb21wdXRlIHRoZSBsaWdodCdzIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpIGZyb20gaXRzIGludGVuc2l0eSAoaW4gY2FuZGVsYSlcclxuXHRcdC8vIGZvciBhbiBpc290cm9waWMgbGlnaHQgc291cmNlLCBsdW1pbm91cyBwb3dlciAobG0pID0gNCDPgCBsdW1pbm91cyBpbnRlbnNpdHkgKGNkKVxyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogNCAqIE1hdGguUEk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHBvd2VyKCBwb3dlciApIHtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGxpZ2h0J3MgaW50ZW5zaXR5IChpbiBjYW5kZWxhKSBmcm9tIHRoZSBkZXNpcmVkIGx1bWlub3VzIHBvd2VyIChpbiBsdW1lbnMpXHJcblx0XHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gKCA0ICogTWF0aC5QSSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3cuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcclxuXHRcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFBvaW50TGlnaHQgfTtcclxuIiwiaW1wb3J0IHsgTGlnaHRTaGFkb3cgfSBmcm9tICcuL0xpZ2h0U2hhZG93LmpzJztcclxuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMnO1xyXG5cclxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBleHRlbmRzIExpZ2h0U2hhZG93IHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gNSwgNSwgNSwgLSA1LCAwLjUsIDUwMCApICk7XHJcblxyXG5cdFx0dGhpcy5pc0RpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IH07XHJcbiIsImltcG9ydCB7IExpZ2h0IH0gZnJvbSAnLi9MaWdodC5qcyc7XHJcbmltcG9ydCB7IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgfSBmcm9tICcuL0RpcmVjdGlvbmFsTGlnaHRTaGFkb3cuanMnO1xyXG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5cclxuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHR0aGlzLmlzRGlyZWN0aW9uYWxMaWdodCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuREVGQVVMVF9VUCApO1xyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xyXG5cclxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XHJcblx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgRGlyZWN0aW9uYWxMaWdodCB9O1xyXG4iLCJpbXBvcnQgeyBMaWdodCB9IGZyb20gJy4vTGlnaHQuanMnO1xyXG5cclxuY2xhc3MgQW1iaWVudExpZ2h0IGV4dGVuZHMgTGlnaHQge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggY29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMuaXNBbWJpZW50TGlnaHQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBBbWJpZW50TGlnaHQgfTtcclxuIiwiaW1wb3J0IHsgTGlnaHQgfSBmcm9tICcuL0xpZ2h0LmpzJztcclxuXHJcbmNsYXNzIFJlY3RBcmVhTGlnaHQgZXh0ZW5kcyBMaWdodCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjb2xvciwgaW50ZW5zaXR5LCB3aWR0aCA9IDEwLCBoZWlnaHQgPSAxMCApIHtcclxuXHJcblx0XHRzdXBlciggY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMuaXNSZWN0QXJlYUxpZ2h0ID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUmVjdEFyZWFMaWdodCc7XHJcblxyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHBvd2VyKCkge1xyXG5cclxuXHRcdC8vIGNvbXB1dGUgdGhlIGxpZ2h0J3MgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucykgZnJvbSBpdHMgaW50ZW5zaXR5IChpbiBuaXRzKVxyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogTWF0aC5QSTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgcG93ZXIoIHBvd2VyICkge1xyXG5cclxuXHRcdC8vIHNldCB0aGUgbGlnaHQncyBpbnRlbnNpdHkgKGluIG5pdHMpIGZyb20gdGhlIGRlc2lyZWQgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucylcclxuXHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIE1hdGguUEkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oIG1ldGEgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTiggbWV0YSApO1xyXG5cclxuXHRcdGRhdGEub2JqZWN0LndpZHRoID0gdGhpcy53aWR0aDtcclxuXHRcdGRhdGEub2JqZWN0LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBSZWN0QXJlYUxpZ2h0IH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xyXG5cclxuLyoqXHJcbiAqIFByaW1hcnkgcmVmZXJlbmNlOlxyXG4gKiAgIGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L3BhcGVycy9lbnZtYXAvZW52bWFwLnBkZlxyXG4gKlxyXG4gKiBTZWNvbmRhcnkgcmVmZXJlbmNlOlxyXG4gKiAgIGh0dHBzOi8vd3d3LnBwc2xvYW4ub3JnL3B1YmxpY2F0aW9ucy9TdHVwaWRTSDM2LnBkZlxyXG4gKi9cclxuXHJcbi8vIDMtYmFuZCBTSCBkZWZpbmVkIGJ5IDkgY29lZmZpY2llbnRzXHJcblxyXG5jbGFzcyBTcGhlcmljYWxIYXJtb25pY3MzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy5pc1NwaGVyaWNhbEhhcm1vbmljczMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuY29lZmZpY2llbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY29lZmZpY2llbnRzLnB1c2goIG5ldyBWZWN0b3IzKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBjb2VmZmljaWVudHMgKSB7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY29lZmZpY2llbnRzWyBpIF0uY29weSggY29lZmZpY2llbnRzWyBpIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0emVybygpIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZ2V0IHRoZSByYWRpYW5jZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcclxuXHQvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXHJcblx0Z2V0QXQoIG5vcm1hbCwgdGFyZ2V0ICkge1xyXG5cclxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoXHJcblxyXG5cdFx0Y29uc3QgeCA9IG5vcm1hbC54LCB5ID0gbm9ybWFsLnksIHogPSBub3JtYWwuejtcclxuXHJcblx0XHRjb25zdCBjb2VmZiA9IHRoaXMuY29lZmZpY2llbnRzO1xyXG5cclxuXHRcdC8vIGJhbmQgMFxyXG5cdFx0dGFyZ2V0LmNvcHkoIGNvZWZmWyAwIF0gKS5tdWx0aXBseVNjYWxhciggMC4yODIwOTUgKTtcclxuXHJcblx0XHQvLyBiYW5kIDFcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAxIF0sIDAuNDg4NjAzICogeSApO1xyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDIgXSwgMC40ODg2MDMgKiB6ICk7XHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMyBdLCAwLjQ4ODYwMyAqIHggKTtcclxuXHJcblx0XHQvLyBiYW5kIDJcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA0IF0sIDEuMDkyNTQ4ICogKCB4ICogeSApICk7XHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNSBdLCAxLjA5MjU0OCAqICggeSAqIHogKSApO1xyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDYgXSwgMC4zMTUzOTIgKiAoIDMuMCAqIHogKiB6IC0gMS4wICkgKTtcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA3IF0sIDEuMDkyNTQ4ICogKCB4ICogeiApICk7XHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgOCBdLCAwLjU0NjI3NCAqICggeCAqIHggLSB5ICogeSApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBnZXQgdGhlIGlycmFkaWFuY2UgKHJhZGlhbmNlIGNvbnZvbHZlZCB3aXRoIGNvc2luZSBsb2JlKSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcclxuXHQvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXHJcblx0Ly8gaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXHJcblx0Z2V0SXJyYWRpYW5jZUF0KCBub3JtYWwsIHRhcmdldCApIHtcclxuXHJcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XHJcblxyXG5cdFx0Y29uc3QgY29lZmYgPSB0aGlzLmNvZWZmaWNpZW50cztcclxuXHJcblx0XHQvLyBiYW5kIDBcclxuXHRcdHRhcmdldC5jb3B5KCBjb2VmZlsgMCBdICkubXVsdGlwbHlTY2FsYXIoIDAuODg2MjI3ICk7IC8vIM+AICogMC4yODIwOTVcclxuXHJcblx0XHQvLyBiYW5kIDFcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAxIF0sIDIuMCAqIDAuNTExNjY0ICogeSApOyAvLyAoIDIgKiDPgCAvIDMgKSAqIDAuNDg4NjAzXHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgMiBdLCAyLjAgKiAwLjUxMTY2NCAqIHogKTtcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyAzIF0sIDIuMCAqIDAuNTExNjY0ICogeCApO1xyXG5cclxuXHRcdC8vIGJhbmQgMlxyXG5cdFx0dGFyZ2V0LmFkZFNjYWxlZFZlY3RvciggY29lZmZbIDQgXSwgMi4wICogMC40MjkwNDMgKiB4ICogeSApOyAvLyAoIM+AIC8gNCApICogMS4wOTI1NDhcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA1IF0sIDIuMCAqIDAuNDI5MDQzICogeSAqIHogKTtcclxuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIGNvZWZmWyA2IF0sIDAuNzQzMTI1ICogeiAqIHogLSAwLjI0NzcwOCApOyAvLyAoIM+AIC8gNCApICogMC4zMTUzOTIgKiAzXHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgNyBdLCAyLjAgKiAwLjQyOTA0MyAqIHggKiB6ICk7XHJcblx0XHR0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKCBjb2VmZlsgOCBdLCAwLjQyOTA0MyAqICggeCAqIHggLSB5ICogeSApICk7IC8vICggz4AgLyA0ICkgKiAwLjU0NjI3NFxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkKCBzaCApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5hZGQoIHNoLmNvZWZmaWNpZW50c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZFNjYWxlZFNIKCBzaCwgcyApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5hZGRTY2FsZWRWZWN0b3IoIHNoLmNvZWZmaWNpZW50c1sgaSBdLCBzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNjYWxlKCBzICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvZWZmaWNpZW50c1sgaSBdLm11bHRpcGx5U2NhbGFyKCBzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGxlcnAoIHNoLCBhbHBoYSApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb2VmZmljaWVudHNbIGkgXS5sZXJwKCBzaC5jb2VmZmljaWVudHNbIGkgXSwgYWxwaGEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXF1YWxzKCBzaCApIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMuY29lZmZpY2llbnRzWyBpIF0uZXF1YWxzKCBzaC5jb2VmZmljaWVudHNbIGkgXSApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldCggc2guY29lZmZpY2llbnRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XHJcblxyXG5cdFx0Y29uc3QgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvZWZmaWNpZW50c1sgaSBdLmZyb21BcnJheSggYXJyYXksIG9mZnNldCArICggaSAqIDMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdGNvbnN0IGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb2VmZmljaWVudHNbIGkgXS50b0FycmF5KCBhcnJheSwgb2Zmc2V0ICsgKCBpICogMyApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBldmFsdWF0ZSB0aGUgYmFzaXMgZnVuY3Rpb25zXHJcblx0Ly8gc2hCYXNpcyBpcyBhbiBBcnJheVsgOSBdXHJcblx0c3RhdGljIGdldEJhc2lzQXQoIG5vcm1hbCwgc2hCYXNpcyApIHtcclxuXHJcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxyXG5cclxuXHRcdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XHJcblxyXG5cdFx0Ly8gYmFuZCAwXHJcblx0XHRzaEJhc2lzWyAwIF0gPSAwLjI4MjA5NTtcclxuXHJcblx0XHQvLyBiYW5kIDFcclxuXHRcdHNoQmFzaXNbIDEgXSA9IDAuNDg4NjAzICogeTtcclxuXHRcdHNoQmFzaXNbIDIgXSA9IDAuNDg4NjAzICogejtcclxuXHRcdHNoQmFzaXNbIDMgXSA9IDAuNDg4NjAzICogeDtcclxuXHJcblx0XHQvLyBiYW5kIDJcclxuXHRcdHNoQmFzaXNbIDQgXSA9IDEuMDkyNTQ4ICogeCAqIHk7XHJcblx0XHRzaEJhc2lzWyA1IF0gPSAxLjA5MjU0OCAqIHkgKiB6O1xyXG5cdFx0c2hCYXNpc1sgNiBdID0gMC4zMTUzOTIgKiAoIDMgKiB6ICogeiAtIDEgKTtcclxuXHRcdHNoQmFzaXNbIDcgXSA9IDEuMDkyNTQ4ICogeCAqIHo7XHJcblx0XHRzaEJhc2lzWyA4IF0gPSAwLjU0NjI3NCAqICggeCAqIHggLSB5ICogeSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBTcGhlcmljYWxIYXJtb25pY3MzIH07XHJcbiIsImltcG9ydCB7IFNwaGVyaWNhbEhhcm1vbmljczMgfSBmcm9tICcuLi9tYXRoL1NwaGVyaWNhbEhhcm1vbmljczMuanMnO1xyXG5pbXBvcnQgeyBMaWdodCB9IGZyb20gJy4vTGlnaHQuanMnO1xyXG5cclxuY2xhc3MgTGlnaHRQcm9iZSBleHRlbmRzIExpZ2h0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNoID0gbmV3IFNwaGVyaWNhbEhhcm1vbmljczMoKSwgaW50ZW5zaXR5ID0gMSApIHtcclxuXHJcblx0XHRzdXBlciggdW5kZWZpbmVkLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHR0aGlzLmlzTGlnaHRQcm9iZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zaCA9IHNoO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnNoLmNvcHkoIHNvdXJjZS5zaCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21KU09OKCBqc29uICkge1xyXG5cclxuXHRcdHRoaXMuaW50ZW5zaXR5ID0ganNvbi5pbnRlbnNpdHk7IC8vIFRPRE86IE1vdmUgdGhpcyBiaXQgdG8gTGlnaHQuZnJvbUpTT04oKTtcclxuXHRcdHRoaXMuc2guZnJvbUFycmF5KCBqc29uLnNoICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oIG1ldGEgKTtcclxuXHJcblx0XHRkYXRhLm9iamVjdC5zaCA9IHRoaXMuc2gudG9BcnJheSgpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBMaWdodFByb2JlIH07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4vRmlsZUxvYWRlci5qcyc7XHJcbmltcG9ydCB7IExvYWRlciB9IGZyb20gJy4vTG9hZGVyLmpzJztcclxuaW1wb3J0IHtcclxuXHRTaGFkb3dNYXRlcmlhbCxcclxuXHRTcHJpdGVNYXRlcmlhbCxcclxuXHRSYXdTaGFkZXJNYXRlcmlhbCxcclxuXHRTaGFkZXJNYXRlcmlhbCxcclxuXHRQb2ludHNNYXRlcmlhbCxcclxuXHRNZXNoUGh5c2ljYWxNYXRlcmlhbCxcclxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbCxcclxuXHRNZXNoUGhvbmdNYXRlcmlhbCxcclxuXHRNZXNoVG9vbk1hdGVyaWFsLFxyXG5cdE1lc2hOb3JtYWxNYXRlcmlhbCxcclxuXHRNZXNoTGFtYmVydE1hdGVyaWFsLFxyXG5cdE1lc2hEZXB0aE1hdGVyaWFsLFxyXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLFxyXG5cdE1lc2hCYXNpY01hdGVyaWFsLFxyXG5cdE1lc2hNYXRjYXBNYXRlcmlhbCxcclxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwsXHJcblx0TGluZUJhc2ljTWF0ZXJpYWwsXHJcblx0TWF0ZXJpYWwsXHJcbn0gZnJvbSAnLi4vbWF0ZXJpYWxzL01hdGVyaWFscy5qcyc7XHJcblxyXG5jbGFzcyBNYXRlcmlhbExvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblx0XHR0aGlzLnRleHR1cmVzID0ge307XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xyXG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcclxuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlKCBqc29uICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCBuYW1lICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IE1hdGVyaWFsTG9hZGVyLmNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIGpzb24udHlwZSApO1xyXG5cclxuXHRcdGlmICgganNvbi51dWlkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51dWlkID0ganNvbi51dWlkO1xyXG5cdFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XHJcblx0XHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XHJcblx0XHRpZiAoIGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcclxuXHRcdGlmICgganNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xyXG5cdFx0aWYgKCBqc29uLnNoZWVuICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGVlbiA9IGpzb24uc2hlZW47XHJcblx0XHRpZiAoIGpzb24uc2hlZW5Db2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW5Db2xvciA9IG5ldyBDb2xvcigpLnNldEhleCgganNvbi5zaGVlbkNvbG9yICk7XHJcblx0XHRpZiAoIGpzb24uc2hlZW5Sb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0ganNvbi5zaGVlblJvdWdobmVzcztcclxuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcclxuXHRcdGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcclxuXHRcdGlmICgganNvbi5zcGVjdWxhckludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHkgPSBqc29uLnNwZWN1bGFySW50ZW5zaXR5O1xyXG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLnNldEhleCgganNvbi5zcGVjdWxhckNvbG9yICk7XHJcblx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcclxuXHRcdGlmICgganNvbi5jbGVhcmNvYXQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdCA9IGpzb24uY2xlYXJjb2F0O1xyXG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0ganNvbi5jbGVhcmNvYXRSb3VnaG5lc3M7XHJcblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlID0ganNvbi5pcmlkZXNjZW5jZTtcclxuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZUlPUiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IgPSBqc29uLmlyaWRlc2NlbmNlSU9SO1xyXG5cdFx0aWYgKCBqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPSBqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2U7XHJcblx0XHRpZiAoIGpzb24udHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc21pc3Npb24gPSBqc29uLnRyYW5zbWlzc2lvbjtcclxuXHRcdGlmICgganNvbi50aGlja25lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRoaWNrbmVzcyA9IGpzb24udGhpY2tuZXNzO1xyXG5cdFx0aWYgKCBqc29uLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBqc29uLmF0dGVudWF0aW9uRGlzdGFuY2U7XHJcblx0XHRpZiAoIGpzb24uYXR0ZW51YXRpb25Db2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3Iuc2V0SGV4KCBqc29uLmF0dGVudWF0aW9uQ29sb3IgKTtcclxuXHRcdGlmICgganNvbi5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbmlzb3Ryb3B5ID0ganNvbi5hbmlzb3Ryb3B5O1xyXG5cdFx0aWYgKCBqc29uLmFuaXNvdHJvcHlSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW5pc290cm9weVJvdGF0aW9uID0ganNvbi5hbmlzb3Ryb3B5Um90YXRpb247XHJcblx0XHRpZiAoIGpzb24uZm9nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mb2cgPSBqc29uLmZvZztcclxuXHRcdGlmICgganNvbi5mbGF0U2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLmZsYXRTaGFkaW5nO1xyXG5cdFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XHJcblx0XHRpZiAoIGpzb24uY29tYmluZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29tYmluZSA9IGpzb24uY29tYmluZTtcclxuXHRcdGlmICgganNvbi5zaWRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaWRlID0ganNvbi5zaWRlO1xyXG5cdFx0aWYgKCBqc29uLnNoYWRvd1NpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRvd1NpZGUgPSBqc29uLnNoYWRvd1NpZGU7XHJcblx0XHRpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcclxuXHRcdGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xyXG5cdFx0aWYgKCBqc29uLmFscGhhVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XHJcblx0XHRpZiAoIGpzb24uYWxwaGFIYXNoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYUhhc2ggPSBqc29uLmFscGhhSGFzaDtcclxuXHRcdGlmICgganNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGpzb24uZGVwdGhUZXN0O1xyXG5cdFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XHJcblx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcclxuXHJcblx0XHRpZiAoIGpzb24uc3RlbmNpbFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsV3JpdGUgPSBqc29uLnN0ZW5jaWxXcml0ZTtcclxuXHRcdGlmICgganNvbi5zdGVuY2lsV3JpdGVNYXNrICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrID0ganNvbi5zdGVuY2lsV3JpdGVNYXNrO1xyXG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxGdW5jICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsRnVuYyA9IGpzb24uc3RlbmNpbEZ1bmM7XHJcblx0XHRpZiAoIGpzb24uc3RlbmNpbFJlZiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3RlbmNpbFJlZiA9IGpzb24uc3RlbmNpbFJlZjtcclxuXHRcdGlmICgganNvbi5zdGVuY2lsRnVuY01hc2sgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayA9IGpzb24uc3RlbmNpbEZ1bmNNYXNrO1xyXG5cdFx0aWYgKCBqc29uLnN0ZW5jaWxGYWlsICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsRmFpbCA9IGpzb24uc3RlbmNpbEZhaWw7XHJcblx0XHRpZiAoIGpzb24uc3RlbmNpbFpGYWlsICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zdGVuY2lsWkZhaWwgPSBqc29uLnN0ZW5jaWxaRmFpbDtcclxuXHRcdGlmICgganNvbi5zdGVuY2lsWlBhc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyA9IGpzb24uc3RlbmNpbFpQYXNzO1xyXG5cclxuXHRcdGlmICgganNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZSA9IGpzb24ud2lyZWZyYW1lO1xyXG5cdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IGpzb24ud2lyZWZyYW1lTGluZWNhcDtcclxuXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSBqc29uLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRcdGlmICgganNvbi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm90YXRpb24gPSBqc29uLnJvdGF0aW9uO1xyXG5cclxuXHRcdGlmICgganNvbi5saW5ld2lkdGggIT09IDEgKSBtYXRlcmlhbC5saW5ld2lkdGggPSBqc29uLmxpbmV3aWR0aDtcclxuXHRcdGlmICgganNvbi5kYXNoU2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGFzaFNpemUgPSBqc29uLmRhc2hTaXplO1xyXG5cdFx0aWYgKCBqc29uLmdhcFNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdhcFNpemUgPSBqc29uLmdhcFNpemU7XHJcblx0XHRpZiAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNjYWxlID0ganNvbi5zY2FsZTtcclxuXHJcblx0XHRpZiAoIGpzb24ucG9seWdvbk9mZnNldCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IGpzb24ucG9seWdvbk9mZnNldDtcclxuXHRcdGlmICgganNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0ganNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xyXG5cdFx0aWYgKCBqc29uLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0ganNvbi5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdFx0aWYgKCBqc29uLmRpdGhlcmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGl0aGVyaW5nID0ganNvbi5kaXRoZXJpbmc7XHJcblxyXG5cdFx0aWYgKCBqc29uLmFscGhhVG9Db3ZlcmFnZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlID0ganNvbi5hbHBoYVRvQ292ZXJhZ2U7XHJcblx0XHRpZiAoIGpzb24ucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgPSBqc29uLnByZW11bHRpcGxpZWRBbHBoYTtcclxuXHRcdGlmICgganNvbi5mb3JjZVNpbmdsZVBhc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZvcmNlU2luZ2xlUGFzcyA9IGpzb24uZm9yY2VTaW5nbGVQYXNzO1xyXG5cclxuXHRcdGlmICgganNvbi52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52aXNpYmxlID0ganNvbi52aXNpYmxlO1xyXG5cclxuXHRcdGlmICgganNvbi50b25lTWFwcGVkICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50b25lTWFwcGVkID0ganNvbi50b25lTWFwcGVkO1xyXG5cclxuXHRcdGlmICgganNvbi51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xyXG5cclxuXHRcdGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mIGpzb24udmVydGV4Q29sb3JzID09PSAnbnVtYmVyJyApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gKCBqc29uLnZlcnRleENvbG9ycyA+IDAgKSA/IHRydWUgOiBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTaGFkZXIgTWF0ZXJpYWxcclxuXHJcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IG5hbWUgaW4ganNvbi51bmlmb3JtcyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybSA9IGpzb24udW5pZm9ybXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXSA9IHt9O1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCB1bmlmb3JtLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAndCc6XHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSBnZXRUZXh0dXJlKCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC51bmlmb3Jtc1sgbmFtZSBdLnZhbHVlID0gbmV3IENvbG9yKCkuc2V0SGV4KCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ3YyJzpcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ3YzJzpcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ3Y0JzpcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ20zJzpcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBNYXRyaXgzKCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ200JzpcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNbIG5hbWUgXS52YWx1ZSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB1bmlmb3JtLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zWyBuYW1lIF0udmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZWZpbmVzID0ganNvbi5kZWZpbmVzO1xyXG5cdFx0aWYgKCBqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XHJcblx0XHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcclxuXHRcdGlmICgganNvbi5nbHNsVmVyc2lvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZ2xzbFZlcnNpb24gPSBqc29uLmdsc2xWZXJzaW9uO1xyXG5cclxuXHRcdGlmICgganNvbi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4ganNvbi5leHRlbnNpb25zICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5leHRlbnNpb25zWyBrZXkgXSA9IGpzb24uZXh0ZW5zaW9uc1sga2V5IF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5saWdodHMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0cyA9IGpzb24ubGlnaHRzO1xyXG5cdFx0aWYgKCBqc29uLmNsaXBwaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGlwcGluZyA9IGpzb24uY2xpcHBpbmc7XHJcblxyXG5cdFx0Ly8gZm9yIFBvaW50c01hdGVyaWFsXHJcblxyXG5cdFx0aWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XHJcblx0XHRpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHQvLyBtYXBzXHJcblxyXG5cdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gZ2V0VGV4dHVyZSgganNvbi5tYXAgKTtcclxuXHRcdGlmICgganNvbi5tYXRjYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hdGNhcCA9IGdldFRleHR1cmUoIGpzb24ubWF0Y2FwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcclxuXHJcblx0XHRpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IGdldFRleHR1cmUoIGpzb24uYnVtcE1hcCApO1xyXG5cdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XHJcblxyXG5cdFx0aWYgKCBqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcclxuXHRcdGlmICgganNvbi5ub3JtYWxNYXBUeXBlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0ganNvbi5ub3JtYWxNYXBUeXBlO1xyXG5cdFx0aWYgKCBqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsZXQgbm9ybWFsU2NhbGUgPSBqc29uLm5vcm1hbFNjYWxlO1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBub3JtYWxTY2FsZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gQmxlbmRlciBleHBvcnRlciB1c2VkIHRvIGV4cG9ydCBhIHNjYWxhci4gU2VlICM3NDU5XHJcblxyXG5cdFx0XHRcdG5vcm1hbFNjYWxlID0gWyBub3JtYWxTY2FsZSwgbm9ybWFsU2NhbGUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkoIG5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XHJcblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xyXG5cclxuXHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XHJcblx0XHRpZiAoIGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm1ldGFsbmVzc01hcCApO1xyXG5cclxuXHRcdGlmICgganNvbi5lbWlzc2l2ZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVtaXNzaXZlTWFwICk7XHJcblx0XHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xyXG5cdFx0aWYgKCBqc29uLnNwZWN1bGFySW50ZW5zaXR5TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCA9IGdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXAgKTtcclxuXHRcdGlmICgganNvbi5zcGVjdWxhckNvbG9yTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhckNvbG9yTWFwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcclxuXHRcdGlmICgganNvbi5lbnZNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcEludGVuc2l0eSA9IGpzb24uZW52TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdGlmICgganNvbi5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xyXG5cdFx0aWYgKCBqc29uLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0ganNvbi5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcclxuXHRcdGlmICgganNvbi5saWdodE1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XHJcblx0XHRpZiAoIGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0ganNvbi5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHRpZiAoIGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdyYWRpZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5ncmFkaWVudE1hcCApO1xyXG5cclxuXHRcdGlmICgganNvbi5jbGVhcmNvYXRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNsZWFyY29hdE1hcCA9IGdldFRleHR1cmUoIGpzb24uY2xlYXJjb2F0TWFwICk7XHJcblx0XHRpZiAoIGpzb24uY2xlYXJjb2F0Um91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmNsZWFyY29hdFJvdWdobmVzc01hcCApO1xyXG5cdFx0aWYgKCBqc29uLmNsZWFyY29hdE5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwID0gZ2V0VGV4dHVyZSgganNvbi5jbGVhcmNvYXROb3JtYWxNYXAgKTtcclxuXHRcdGlmICgganNvbi5jbGVhcmNvYXROb3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSgganNvbi5jbGVhcmNvYXROb3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdGlmICgganNvbi5pcmlkZXNjZW5jZU1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmlyaWRlc2NlbmNlTWFwICk7XHJcblx0XHRpZiAoIGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCApO1xyXG5cclxuXHRcdGlmICgganNvbi50cmFuc21pc3Npb25NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCA9IGdldFRleHR1cmUoIGpzb24udHJhbnNtaXNzaW9uTWFwICk7XHJcblx0XHRpZiAoIGpzb24udGhpY2tuZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50aGlja25lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnRoaWNrbmVzc01hcCApO1xyXG5cclxuXHRcdGlmICgganNvbi5hbmlzb3Ryb3B5TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwID0gZ2V0VGV4dHVyZSgganNvbi5hbmlzb3Ryb3B5TWFwICk7XHJcblxyXG5cdFx0aWYgKCBqc29uLnNoZWVuQ29sb3JNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNoZWVuQ29sb3JNYXAgKTtcclxuXHRcdGlmICgganNvbi5zaGVlblJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNoZWVuUm91Z2huZXNzTWFwICk7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFRleHR1cmVzKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgY3JlYXRlTWF0ZXJpYWxGcm9tVHlwZSggdHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbExpYiA9IHtcclxuXHRcdFx0U2hhZG93TWF0ZXJpYWwsXHJcblx0XHRcdFNwcml0ZU1hdGVyaWFsLFxyXG5cdFx0XHRSYXdTaGFkZXJNYXRlcmlhbCxcclxuXHRcdFx0U2hhZGVyTWF0ZXJpYWwsXHJcblx0XHRcdFBvaW50c01hdGVyaWFsLFxyXG5cdFx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbCxcclxuXHRcdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwsXHJcblx0XHRcdE1lc2hQaG9uZ01hdGVyaWFsLFxyXG5cdFx0XHRNZXNoVG9vbk1hdGVyaWFsLFxyXG5cdFx0XHRNZXNoTm9ybWFsTWF0ZXJpYWwsXHJcblx0XHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWwsXHJcblx0XHRcdE1lc2hEZXB0aE1hdGVyaWFsLFxyXG5cdFx0XHRNZXNoRGlzdGFuY2VNYXRlcmlhbCxcclxuXHRcdFx0TWVzaEJhc2ljTWF0ZXJpYWwsXHJcblx0XHRcdE1lc2hNYXRjYXBNYXRlcmlhbCxcclxuXHRcdFx0TGluZURhc2hlZE1hdGVyaWFsLFxyXG5cdFx0XHRMaW5lQmFzaWNNYXRlcmlhbCxcclxuXHRcdFx0TWF0ZXJpYWxcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBtYXRlcmlhbExpYlsgdHlwZSBdKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IE1hdGVyaWFsTG9hZGVyIH07XHJcbiIsImNsYXNzIExvYWRlclV0aWxzIHtcclxuXHJcblx0c3RhdGljIGRlY29kZVRleHQoIGFycmF5ICkge1xyXG5cclxuXHRcdGlmICggdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyApIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEF2b2lkIHRoZSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBzaG9ydGN1dCwgd2hpY2hcclxuXHRcdC8vIHRocm93cyBhIFwibWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiBlcnJvciBmb3IgbGFyZ2UgYXJyYXlzLlxyXG5cclxuXHRcdGxldCBzID0gJyc7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gSW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW4uXHJcblx0XHRcdHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYXJyYXlbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0Ly8gbWVyZ2VzIG11bHRpLWJ5dGUgdXRmLTggY2hhcmFjdGVycy5cclxuXHJcblx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoIGVzY2FwZSggcyApICk7XHJcblxyXG5cdFx0fSBjYXRjaCAoIGUgKSB7IC8vIHNlZSAjMTYzNThcclxuXHJcblx0XHRcdHJldHVybiBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZXh0cmFjdFVybEJhc2UoIHVybCApIHtcclxuXHJcblx0XHRjb25zdCBpbmRleCA9IHVybC5sYXN0SW5kZXhPZiggJy8nICk7XHJcblxyXG5cdFx0aWYgKCBpbmRleCA9PT0gLSAxICkgcmV0dXJuICcuLyc7XHJcblxyXG5cdFx0cmV0dXJuIHVybC5zbGljZSggMCwgaW5kZXggKyAxICk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIHJlc29sdmVVUkwoIHVybCwgcGF0aCApIHtcclxuXHJcblx0XHQvLyBJbnZhbGlkIFVSTFxyXG5cdFx0aWYgKCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCB1cmwgPT09ICcnICkgcmV0dXJuICcnO1xyXG5cclxuXHRcdC8vIEhvc3QgUmVsYXRpdmUgVVJMXHJcblx0XHRpZiAoIC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoIHBhdGggKSAmJiAvXlxcLy8udGVzdCggdXJsICkgKSB7XHJcblxyXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCAvKF5odHRwcz86XFwvXFwvW15cXC9dKykuKi9pLCAnJDEnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFic29sdXRlIFVSTCBodHRwOi8vLGh0dHBzOi8vLC8vXHJcblx0XHRpZiAoIC9eKGh0dHBzPzopP1xcL1xcLy9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcclxuXHJcblx0XHQvLyBEYXRhIFVSSVxyXG5cdFx0aWYgKCAvXmRhdGE6LiosLiokL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xyXG5cclxuXHRcdC8vIEJsb2IgVVJMXHJcblx0XHRpZiAoIC9eYmxvYjouKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XHJcblxyXG5cdFx0Ly8gUmVsYXRpdmUgVVJMXHJcblx0XHRyZXR1cm4gcGF0aCArIHVybDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgTG9hZGVyVXRpbHMgfTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuXHJcbmNsYXNzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcclxuXHRcdHRoaXMuaW5zdGFuY2VDb3VudCA9IEluZmluaXR5O1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmluc3RhbmNlQ291bnQgPSBzb3VyY2UuaW5zdGFuY2VDb3VudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHR0b0pTT04oKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xyXG5cclxuXHRcdGRhdGEuaW5zdGFuY2VDb3VudCA9IHRoaXMuaW5zdGFuY2VDb3VudDtcclxuXHJcblx0XHRkYXRhLmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB9O1xyXG4iLCJpbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL0ZpbGVMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XHJcbmltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXIgfSBmcm9tICcuLi9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzJztcclxuaW1wb3J0IHsgZ2V0VHlwZWRBcnJheSB9IGZyb20gJy4uL3V0aWxzLmpzJztcclxuXHJcbmNsYXNzIEJ1ZmZlckdlb21ldHJ5TG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xyXG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XHJcblxyXG5cdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xyXG5cclxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcclxuXHJcblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2UoIGpzb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXJNYXAgPSB7fTtcclxuXHRcdGNvbnN0IGFycmF5QnVmZmVyTWFwID0ge307XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoIGpzb24sIHV1aWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGludGVybGVhdmVkQnVmZmVyTWFwWyB1dWlkIF0gIT09IHVuZGVmaW5lZCApIHJldHVybiBpbnRlcmxlYXZlZEJ1ZmZlck1hcFsgdXVpZCBdO1xyXG5cclxuXHRcdFx0Y29uc3QgaW50ZXJsZWF2ZWRCdWZmZXJzID0ganNvbi5pbnRlcmxlYXZlZEJ1ZmZlcnM7XHJcblx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gaW50ZXJsZWF2ZWRCdWZmZXJzWyB1dWlkIF07XHJcblxyXG5cdFx0XHRjb25zdCBidWZmZXIgPSBnZXRBcnJheUJ1ZmZlcigganNvbiwgaW50ZXJsZWF2ZWRCdWZmZXIuYnVmZmVyICk7XHJcblxyXG5cdFx0XHRjb25zdCBhcnJheSA9IGdldFR5cGVkQXJyYXkoIGludGVybGVhdmVkQnVmZmVyLnR5cGUsIGJ1ZmZlciApO1xyXG5cdFx0XHRjb25zdCBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIGludGVybGVhdmVkQnVmZmVyLnN0cmlkZSApO1xyXG5cdFx0XHRpYi51dWlkID0gaW50ZXJsZWF2ZWRCdWZmZXIudXVpZDtcclxuXHJcblx0XHRcdGludGVybGVhdmVkQnVmZmVyTWFwWyB1dWlkIF0gPSBpYjtcclxuXHJcblx0XHRcdHJldHVybiBpYjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoIGpzb24sIHV1aWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFycmF5QnVmZmVyTWFwWyB1dWlkIF0gIT09IHVuZGVmaW5lZCApIHJldHVybiBhcnJheUJ1ZmZlck1hcFsgdXVpZCBdO1xyXG5cclxuXHRcdFx0Y29uc3QgYXJyYXlCdWZmZXJzID0ganNvbi5hcnJheUJ1ZmZlcnM7XHJcblx0XHRcdGNvbnN0IGFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXJzWyB1dWlkIF07XHJcblxyXG5cdFx0XHRjb25zdCBhYiA9IG5ldyBVaW50MzJBcnJheSggYXJyYXlCdWZmZXIgKS5idWZmZXI7XHJcblxyXG5cdFx0XHRhcnJheUJ1ZmZlck1hcFsgdXVpZCBdID0gYWI7XHJcblxyXG5cdFx0XHRyZXR1cm4gYWI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0ganNvbi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gbmV3IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHRjb25zdCBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheSggaW5kZXgudHlwZSwgaW5kZXguYXJyYXkgKTtcclxuXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHRcdFx0bGV0IGJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGludGVybGVhdmVkQnVmZmVyID0gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoIGpzb24uZGF0YSwgYXR0cmlidXRlLmRhdGEgKTtcclxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5vZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0eXBlZEFycmF5ID0gZ2V0VHlwZWRBcnJheSggYXR0cmlidXRlLnR5cGUsIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZUNvbnN0ciA9IGF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA/IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA6IEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgYnVmZmVyQXR0cmlidXRlQ29uc3RyKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5uYW1lICE9PSB1bmRlZmluZWQgKSBidWZmZXJBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS51c2FnZSAhPT0gdW5kZWZpbmVkICkgYnVmZmVyQXR0cmlidXRlLnNldFVzYWdlKCBhdHRyaWJ1dGUudXNhZ2UgKTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlLnVwZGF0ZVJhbmdlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5vZmZzZXQgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2Uub2Zmc2V0O1xyXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudCA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgga2V5LCBidWZmZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ganNvbi5kYXRhLm1vcnBoQXR0cmlidXRlcztcclxuXHJcblx0XHRpZiAoIG1vcnBoQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZUFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZUFycmF5WyBpIF07XHJcblx0XHRcdFx0XHRsZXQgYnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IGdldEludGVybGVhdmVkQnVmZmVyKCBqc29uLmRhdGEsIGF0dHJpYnV0ZS5kYXRhICk7XHJcblx0XHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm9mZnNldCwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgdHlwZWRBcnJheSA9IGdldFR5cGVkQXJyYXkoIGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkgKTtcclxuXHRcdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGUubm9ybWFsaXplZCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5uYW1lICE9PSB1bmRlZmluZWQgKSBidWZmZXJBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xyXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggYnVmZmVyQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzWyBrZXkgXSA9IGFycmF5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGpzb24uZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcclxuXHJcblx0XHRpZiAoIG1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XHJcblxyXG5cdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XHJcblxyXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24ubmFtZSApIGdlb21ldHJ5Lm5hbWUgPSBqc29uLm5hbWU7XHJcblx0XHRpZiAoIGpzb24udXNlckRhdGEgKSBnZW9tZXRyeS51c2VyRGF0YSA9IGpzb24udXNlckRhdGE7XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBCdWZmZXJHZW9tZXRyeUxvYWRlciB9O1xyXG4iLCJpbXBvcnQge1xyXG5cdFVWTWFwcGluZyxcclxuXHRDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXHJcblx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxyXG5cdEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxyXG5cdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLFxyXG5cdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLFxyXG5cclxuXHRSZXBlYXRXcmFwcGluZyxcclxuXHRDbGFtcFRvRWRnZVdyYXBwaW5nLFxyXG5cdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXHJcblxyXG5cdE5lYXJlc3RGaWx0ZXIsXHJcblx0TmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXHJcblx0TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcclxuXHRMaW5lYXJGaWx0ZXIsXHJcblx0TGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcclxuXHRMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcclxufSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnLi4vb2JqZWN0cy9Hcm91cC5qcyc7XHJcbmltcG9ydCB7IEluc3RhbmNlZE1lc2ggfSBmcm9tICcuLi9vYmplY3RzL0luc3RhbmNlZE1lc2guanMnO1xyXG5pbXBvcnQgeyBTcHJpdGUgfSBmcm9tICcuLi9vYmplY3RzL1Nwcml0ZS5qcyc7XHJcbmltcG9ydCB7IFBvaW50cyB9IGZyb20gJy4uL29iamVjdHMvUG9pbnRzLmpzJztcclxuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4uL29iamVjdHMvTGluZS5qcyc7XHJcbmltcG9ydCB7IExpbmVMb29wIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lTG9vcC5qcyc7XHJcbmltcG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4uL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcclxuaW1wb3J0IHsgTE9EIH0gZnJvbSAnLi4vb2JqZWN0cy9MT0QuanMnO1xyXG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vb2JqZWN0cy9NZXNoLmpzJztcclxuaW1wb3J0IHsgU2tpbm5lZE1lc2ggfSBmcm9tICcuLi9vYmplY3RzL1NraW5uZWRNZXNoLmpzJztcclxuaW1wb3J0IHsgQm9uZSB9IGZyb20gJy4uL29iamVjdHMvQm9uZS5qcyc7XHJcbmltcG9ydCB7IFNrZWxldG9uIH0gZnJvbSAnLi4vb2JqZWN0cy9Ta2VsZXRvbi5qcyc7XHJcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vZXh0cmFzL2NvcmUvU2hhcGUuanMnO1xyXG5pbXBvcnQgeyBGb2cgfSBmcm9tICcuLi9zY2VuZXMvRm9nLmpzJztcclxuaW1wb3J0IHsgRm9nRXhwMiB9IGZyb20gJy4uL3NjZW5lcy9Gb2dFeHAyLmpzJztcclxuaW1wb3J0IHsgSGVtaXNwaGVyZUxpZ2h0IH0gZnJvbSAnLi4vbGlnaHRzL0hlbWlzcGhlcmVMaWdodC5qcyc7XHJcbmltcG9ydCB7IFNwb3RMaWdodCB9IGZyb20gJy4uL2xpZ2h0cy9TcG90TGlnaHQuanMnO1xyXG5pbXBvcnQgeyBQb2ludExpZ2h0IH0gZnJvbSAnLi4vbGlnaHRzL1BvaW50TGlnaHQuanMnO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0IH0gZnJvbSAnLi4vbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanMnO1xyXG5pbXBvcnQgeyBBbWJpZW50TGlnaHQgfSBmcm9tICcuLi9saWdodHMvQW1iaWVudExpZ2h0LmpzJztcclxuaW1wb3J0IHsgUmVjdEFyZWFMaWdodCB9IGZyb20gJy4uL2xpZ2h0cy9SZWN0QXJlYUxpZ2h0LmpzJztcclxuaW1wb3J0IHsgTGlnaHRQcm9iZSB9IGZyb20gJy4uL2xpZ2h0cy9MaWdodFByb2JlLmpzJztcclxuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4uL3NjZW5lcy9TY2VuZS5qcyc7XHJcbmltcG9ydCB7IEN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4uL3RleHR1cmVzL1NvdXJjZS5qcyc7XHJcbmltcG9ydCB7IERhdGFUZXh0dXJlIH0gZnJvbSAnLi4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBJbWFnZUxvYWRlciB9IGZyb20gJy4vSW1hZ2VMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBMb2FkaW5nTWFuYWdlciB9IGZyb20gJy4vTG9hZGluZ01hbmFnZXIuanMnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25DbGlwIH0gZnJvbSAnLi4vYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanMnO1xyXG5pbXBvcnQgeyBNYXRlcmlhbExvYWRlciB9IGZyb20gJy4vTWF0ZXJpYWxMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBMb2FkZXJVdGlscyB9IGZyb20gJy4vTG9hZGVyVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeUxvYWRlciB9IGZyb20gJy4vQnVmZmVyR2VvbWV0cnlMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XHJcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL0ZpbGVMb2FkZXIuanMnO1xyXG5pbXBvcnQgKiBhcyBHZW9tZXRyaWVzIGZyb20gJy4uL2dlb21ldHJpZXMvR2VvbWV0cmllcy5qcyc7XHJcbmltcG9ydCB7IGdldFR5cGVkQXJyYXkgfSBmcm9tICcuLi91dGlscy5qcyc7XHJcblxyXG5jbGFzcyBPYmplY3RMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcclxuXHJcblx0XHRzdXBlciggbWFuYWdlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XHJcblx0XHR0aGlzLnJlc291cmNlUGF0aCA9IHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGg7XHJcblxyXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xyXG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdGxldCBqc29uID0gbnVsbDtcclxuXHJcblx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XHJcblxyXG5cdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkgb25FcnJvciggZXJyb3IgKTtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFOk9iamVjdExvYWRlcjogQ2FuXFwndCBwYXJzZSAnICsgdXJsICsgJy4nLCBlcnJvci5tZXNzYWdlICk7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcblx0XHRcdGlmICggbWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgIT09IHVuZGVmaW5lZCApIG9uRXJyb3IoIG5ldyBFcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwgKSApO1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjb3BlLnBhcnNlKCBqc29uLCBvbkxvYWQgKTtcclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHBhdGggPSAoIHRoaXMucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHRoaXMucGF0aDtcclxuXHRcdHRoaXMucmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aDtcclxuXHJcblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XHJcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xyXG5cclxuXHRcdGNvbnN0IHRleHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCB1cmwsIG9uUHJvZ3Jlc3MgKTtcclxuXHJcblx0XHRjb25zdCBqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xyXG5cclxuXHRcdGNvbnN0IG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcblx0XHRpZiAoIG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JyApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGF3YWl0IHNjb3BlLnBhcnNlQXN5bmMoIGpzb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHRwYXJzZSgganNvbiwgb25Mb2FkICkge1xyXG5cclxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XHJcblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcnNlU2hhcGVzKCBqc29uLnNoYXBlcyApO1xyXG5cdFx0Y29uc3QgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMsIHNoYXBlcyApO1xyXG5cclxuXHRcdGNvbnN0IGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xyXG5cdFx0Y29uc3QgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XHJcblxyXG5cdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdCgganNvbi5vYmplY3QsIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMgKTtcclxuXHRcdGNvbnN0IHNrZWxldG9ucyA9IHRoaXMucGFyc2VTa2VsZXRvbnMoIGpzb24uc2tlbGV0b25zLCBvYmplY3QgKTtcclxuXHJcblx0XHR0aGlzLmJpbmRTa2VsZXRvbnMoIG9iamVjdCwgc2tlbGV0b25zICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bGV0IGhhc0ltYWdlcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgdXVpZCBpbiBpbWFnZXMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2VzWyB1dWlkIF0uZGF0YSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aGFzSW1hZ2VzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ltYWdlcyA9PT0gZmFsc2UgKSBvbkxvYWQoIG9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb2JqZWN0O1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIHBhcnNlQXN5bmMoIGpzb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKCBqc29uLmFuaW1hdGlvbnMgKTtcclxuXHRcdGNvbnN0IHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZXMoIGpzb24uc2hhcGVzICk7XHJcblx0XHRjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcywgc2hhcGVzICk7XHJcblxyXG5cdFx0Y29uc3QgaW1hZ2VzID0gYXdhaXQgdGhpcy5wYXJzZUltYWdlc0FzeW5jKCBqc29uLmltYWdlcyApO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcclxuXHRcdGNvbnN0IG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xyXG5cclxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMsIHRleHR1cmVzLCBhbmltYXRpb25zICk7XHJcblx0XHRjb25zdCBza2VsZXRvbnMgPSB0aGlzLnBhcnNlU2tlbGV0b25zKCBqc29uLnNrZWxldG9ucywgb2JqZWN0ICk7XHJcblxyXG5cdFx0dGhpcy5iaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApO1xyXG5cclxuXHRcdHJldHVybiBvYmplY3Q7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2VTaGFwZXMoIGpzb24gKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2hhcGVzID0ge307XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbmV3IFNoYXBlKCkuZnJvbUpTT04oIGpzb25bIGkgXSApO1xyXG5cclxuXHRcdFx0XHRzaGFwZXNbIHNoYXBlLnV1aWQgXSA9IHNoYXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlU2tlbGV0b25zKCBqc29uLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2tlbGV0b25zID0ge307XHJcblx0XHRjb25zdCBib25lcyA9IHt9O1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIGJvbmUgbG9va3VwIHRhYmxlXHJcblxyXG5cdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xyXG5cclxuXHRcdFx0aWYgKCBjaGlsZC5pc0JvbmUgKSBib25lc1sgY2hpbGQudXVpZCBdID0gY2hpbGQ7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSBza2VsZXRvbnNcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oKS5mcm9tSlNPTigganNvblsgaSBdLCBib25lcyApO1xyXG5cclxuXHRcdFx0XHRza2VsZXRvbnNbIHNrZWxldG9uLnV1aWQgXSA9IHNrZWxldG9uO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2tlbGV0b25zO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlR2VvbWV0cmllcygganNvbiwgc2hhcGVzICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJpZXMgPSB7fTtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gbmV3IEJ1ZmZlckdlb21ldHJ5TG9hZGVyKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGxldCBnZW9tZXRyeTtcclxuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0Y2FzZSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhLnR5cGUgaW4gR2VvbWV0cmllcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXS5mcm9tSlNPTiggZGF0YSwgc2hhcGVzICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIGBUSFJFRS5PYmplY3RMb2FkZXI6IFVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgXCIkeyBkYXRhLnR5cGUgfVwiYCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cdFx0XHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cmllcztcclxuXHJcblx0fVxyXG5cclxuXHRwYXJzZU1hdGVyaWFscygganNvbiwgdGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgY2FjaGUgPSB7fTsgLy8gTXVsdGlNYXRlcmlhbFxyXG5cdFx0Y29uc3QgbWF0ZXJpYWxzID0ge307XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcclxuXHRcdFx0bG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNhY2hlWyBkYXRhLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNhY2hlWyBkYXRhLnV1aWQgXSA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBjYWNoZVsgZGF0YS51dWlkIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXRlcmlhbHM7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2VBbmltYXRpb25zKCBqc29uICkge1xyXG5cclxuXHRcdGNvbnN0IGFuaW1hdGlvbnMgPSB7fTtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRhbmltYXRpb25zWyBjbGlwLnV1aWQgXSA9IGNsaXA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhbmltYXRpb25zO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlSW1hZ2VzKCBqc29uLCBvbkxvYWQgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaW1hZ2VzID0ge307XHJcblxyXG5cdFx0bGV0IGxvYWRlcjtcclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggdXJsICkgPyB1cmwgOiBzY29wZS5yZXNvdXJjZVBhdGggKyB1cmw7XHJcblxyXG5cdFx0XHRcdHJldHVybiBsb2FkSW1hZ2UoIHBhdGggKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2UuZGF0YSApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRkYXRhOiBnZXRUeXBlZEFycmF5KCBpbWFnZS50eXBlLCBpbWFnZS5kYXRhICksXHJcblx0XHRcdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcclxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5oZWlnaHRcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XHJcblxyXG5cdFx0XHRsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0ganNvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBqc29uWyBpIF07XHJcblx0XHRcdFx0Y29uc3QgdXJsID0gaW1hZ2UudXJsO1xyXG5cclxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGxvYWQgYXJyYXkgb2YgaW1hZ2VzIGUuZyBDdWJlVGV4dHVyZVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGltYWdlQXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gdXJsLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFVybCA9IHVybFsgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKCBjdXJyZW50VXJsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGRlc2VyaWFsaXplZEltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goIGRlc2VyaWFsaXplZEltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgYXJyYXkgb2YgZGF0YSB0ZXh0dXJlcyBmb3IgY3ViZSB0ZXh0dXJlc1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQXJyYXkucHVzaCggbmV3IERhdGFUZXh0dXJlKCBkZXNlcmlhbGl6ZWRJbWFnZS5kYXRhLCBkZXNlcmlhbGl6ZWRJbWFnZS53aWR0aCwgZGVzZXJpYWxpemVkSW1hZ2UuaGVpZ2h0ICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IG5ldyBTb3VyY2UoIGltYWdlQXJyYXkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBsb2FkIHNpbmdsZSBpbWFnZVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gZGVzZXJpYWxpemVJbWFnZSggaW1hZ2UudXJsICk7XHJcblx0XHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IG5ldyBTb3VyY2UoIGRlc2VyaWFsaXplZEltYWdlICk7XHJcblxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZXM7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgcGFyc2VJbWFnZXNBc3luYygganNvbiApIHtcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblx0XHRjb25zdCBpbWFnZXMgPSB7fTtcclxuXHJcblx0XHRsZXQgbG9hZGVyO1xyXG5cclxuXHRcdGFzeW5jIGZ1bmN0aW9uIGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB1cmwgPSBpbWFnZTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggdXJsICkgPyB1cmwgOiBzY29wZS5yZXNvdXJjZVBhdGggKyB1cmw7XHJcblxyXG5cdFx0XHRcdHJldHVybiBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCBwYXRoICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGltYWdlLmRhdGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0ZGF0YTogZ2V0VHlwZWRBcnJheSggaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSApLFxyXG5cdFx0XHRcdFx0XHR3aWR0aDogaW1hZ2Uud2lkdGgsXHJcblx0XHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0XHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGpzb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGltYWdlID0ganNvblsgaSBdO1xyXG5cdFx0XHRcdGNvbnN0IHVybCA9IGltYWdlLnVybDtcclxuXHJcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBsb2FkIGFycmF5IG9mIGltYWdlcyBlLmcgQ3ViZVRleHR1cmVcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbWFnZUFycmF5ID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IHVybC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRVcmwgPSB1cmxbIGogXTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGRlc2VyaWFsaXplZEltYWdlID0gYXdhaXQgZGVzZXJpYWxpemVJbWFnZSggY3VycmVudFVybCApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkZXNlcmlhbGl6ZWRJbWFnZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXNlcmlhbGl6ZWRJbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VBcnJheS5wdXNoKCBkZXNlcmlhbGl6ZWRJbWFnZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIGFycmF5IG9mIGRhdGEgdGV4dHVyZXMgZm9yIGN1YmUgdGV4dHVyZXNcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbWFnZUFycmF5LnB1c2goIG5ldyBEYXRhVGV4dHVyZSggZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBuZXcgU291cmNlKCBpbWFnZUFycmF5ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbG9hZCBzaW5nbGUgaW1hZ2VcclxuXHJcblx0XHRcdFx0XHRjb25zdCBkZXNlcmlhbGl6ZWRJbWFnZSA9IGF3YWl0IGRlc2VyaWFsaXplSW1hZ2UoIGltYWdlLnVybCApO1xyXG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBuZXcgU291cmNlKCBkZXNlcmlhbGl6ZWRJbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbWFnZXM7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2VUZXh0dXJlcygganNvbiwgaW1hZ2VzICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlLCB0eXBlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHR5cGVbIHZhbHVlIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVzID0ge307XHJcblxyXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3Qgc291cmNlID0gaW1hZ2VzWyBkYXRhLmltYWdlIF07XHJcblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBzb3VyY2UuZGF0YTtcclxuXHJcblx0XHRcdFx0bGV0IHRleHR1cmU7XHJcblxyXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggaW1hZ2UgKSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbWFnZS5sZW5ndGggPT09IDYgKSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGltYWdlICYmIGltYWdlLmRhdGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGltYWdlICkgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7IC8vIHRleHR1cmVzIGNhbiBoYXZlIHVuZGVmaW5lZCBpbWFnZSBkYXRhXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dHVyZS5zb3VyY2UgPSBzb3VyY2U7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZywgVEVYVFVSRV9NQVBQSU5HICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLmNoYW5uZWwgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY2hhbm5lbCA9IGRhdGEuY2hhbm5lbDtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBkYXRhLm9mZnNldCApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggZGF0YS5yZXBlYXQgKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuY2VudGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNlbnRlci5mcm9tQXJyYXkoIGRhdGEuY2VudGVyICk7XHJcblx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLndyYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcclxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSwgVEVYVFVSRV9XUkFQUElORyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5mb3JtYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZm9ybWF0ID0gZGF0YS5mb3JtYXQ7XHJcblx0XHRcdFx0aWYgKCBkYXRhLmludGVybmFsRm9ybWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmludGVybmFsRm9ybWF0ID0gZGF0YS5pbnRlcm5hbEZvcm1hdDtcclxuXHRcdFx0XHRpZiAoIGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS50eXBlID0gZGF0YS50eXBlO1xyXG5cdFx0XHRcdGlmICggZGF0YS5jb2xvclNwYWNlICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBkYXRhLmNvbG9yU3BhY2U7XHJcblx0XHRcdFx0aWYgKCBkYXRhLmVuY29kaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmVuY29kaW5nID0gZGF0YS5lbmNvZGluZzsgLy8gQGRlcHJlY2F0ZWQsIHIxNTJcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIgKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xyXG5cdFx0XHRcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5mbGlwWSA9IGRhdGEuZmxpcFk7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZGF0YS5nZW5lcmF0ZU1pcG1hcHM7XHJcblx0XHRcdFx0aWYgKCBkYXRhLnByZW11bHRpcGx5QWxwaGEgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IGRhdGEucHJlbXVsdGlwbHlBbHBoYTtcclxuXHRcdFx0XHRpZiAoIGRhdGEudW5wYWNrQWxpZ25tZW50ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IGRhdGEudW5wYWNrQWxpZ25tZW50O1xyXG5cdFx0XHRcdGlmICggZGF0YS5jb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCApIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uID0gZGF0YS5jb21wYXJlRnVuY3Rpb247XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlcztcclxuXHJcblx0fVxyXG5cclxuXHRwYXJzZU9iamVjdCggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyApIHtcclxuXHJcblx0XHRsZXQgb2JqZWN0O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcclxuXHJcblx0XHRcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXVpZCA9IG5hbWVbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsc1sgdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIHV1aWQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWxzWyB1dWlkIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCB1dWlkICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlc1sgdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCB1dWlkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGV4dHVyZXNbIHV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGdlb21ldHJ5LCBtYXRlcmlhbDtcclxuXHJcblx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRjYXNlICdTY2VuZSc6XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTY2VuZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggTnVtYmVyLmlzSW50ZWdlciggZGF0YS5iYWNrZ3JvdW5kICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QuYmFja2dyb3VuZCA9IG5ldyBDb2xvciggZGF0YS5iYWNrZ3JvdW5kICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gZ2V0VGV4dHVyZSggZGF0YS5iYWNrZ3JvdW5kICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5lbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5lbnZpcm9ubWVudCA9IGdldFRleHR1cmUoIGRhdGEuZW52aXJvbm1lbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuZm9nICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZ0V4cDInICkge1xyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0LmZvZyA9IG5ldyBGb2dFeHAyKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cuZGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3MgIT09IHVuZGVmaW5lZCApIG9iamVjdC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IGRhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3M7XHJcblx0XHRcdFx0aWYgKCBkYXRhLmJhY2tncm91bmRJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG9iamVjdC5iYWNrZ3JvdW5kSW50ZW5zaXR5ID0gZGF0YS5iYWNrZ3JvdW5kSW50ZW5zaXR5O1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLmZvY3VzICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZm9jdXMgPSBkYXRhLmZvY3VzO1xyXG5cdFx0XHRcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbUdhdWdlID0gZGF0YS5maWxtR2F1Z2U7XHJcblx0XHRcdFx0aWYgKCBkYXRhLmZpbG1PZmZzZXQgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtT2Zmc2V0ID0gZGF0YS5maWxtT2Zmc2V0O1xyXG5cdFx0XHRcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdPcnRob2dyYXBoaWNDYW1lcmEnOlxyXG5cclxuXHRcdFx0XHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XHJcblx0XHRcdFx0aWYgKCBkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIGRhdGEudmlldyApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ0FtYmllbnRMaWdodCc6XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxyXG5cclxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0JzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdMaWdodFByb2JlJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpZ2h0UHJvYmUoKS5mcm9tSlNPTiggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1NraW5uZWRNZXNoJzpcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xyXG5cdFx0XHQgXHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5iaW5kTW9kZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJpbmRNb2RlID0gZGF0YS5iaW5kTW9kZTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmJpbmRNYXRyaXguZnJvbUFycmF5KCBkYXRhLmJpbmRNYXRyaXggKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5za2VsZXRvbiA9IGRhdGEuc2tlbGV0b247XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnTWVzaCc6XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcclxuXHRcdFx0XHRtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdJbnN0YW5jZWRNZXNoJzpcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xyXG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcclxuXHRcdFx0XHRjb25zdCBjb3VudCA9IGRhdGEuY291bnQ7XHJcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VNYXRyaXggPSBkYXRhLmluc3RhbmNlTWF0cml4O1xyXG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlQ29sb3IgPSBkYXRhLmluc3RhbmNlQ29sb3I7XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBJbnN0YW5jZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGNvdW50ICk7XHJcblx0XHRcdFx0b2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggaW5zdGFuY2VNYXRyaXguYXJyYXkgKSwgMTYgKTtcclxuXHRcdFx0XHRpZiAoIGluc3RhbmNlQ29sb3IgIT09IHVuZGVmaW5lZCApIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggaW5zdGFuY2VDb2xvci5hcnJheSApLCBpbnN0YW5jZUNvbG9yLml0ZW1TaXplICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnTE9EJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IExPRCgpO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ0xpbmUnOlxyXG5cclxuXHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ0xpbmVMb29wJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVMb29wKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnTGluZVNlZ21lbnRzJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVTZWdtZW50cyggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxyXG5cdFx0XHRjYXNlICdQb2ludHMnOlxyXG5cclxuXHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnU3ByaXRlJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IFNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ0dyb3VwJzpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IEdyb3VwKCk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnQm9uZSc6XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IG5ldyBCb25lKCk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuXHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcclxuXHJcblx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QubWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcclxuXHJcblx0XHRcdGlmICggZGF0YS5tYXRyaXhBdXRvVXBkYXRlICE9PSB1bmRlZmluZWQgKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGRhdGEubWF0cml4QXV0b1VwZGF0ZTtcclxuXHRcdFx0aWYgKCBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSApIG9iamVjdC5tYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XHJcblx0XHRcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xyXG5cdFx0XHRpZiAoIGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBkYXRhLnF1YXRlcm5pb24gKTtcclxuXHRcdFx0aWYgKCBkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KCBkYXRhLnNjYWxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGF0YS51cCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVwLmZyb21BcnJheSggZGF0YS51cCApO1xyXG5cclxuXHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcclxuXHRcdGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcclxuXHJcblx0XHRpZiAoIGRhdGEuc2hhZG93ICkge1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xyXG5cdFx0XHRpZiAoIGRhdGEuc2hhZG93Lm5vcm1hbEJpYXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cubm9ybWFsQmlhcyA9IGRhdGEuc2hhZG93Lm5vcm1hbEJpYXM7XHJcblx0XHRcdGlmICggZGF0YS5zaGFkb3cucmFkaXVzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LnJhZGl1cyA9IGRhdGEuc2hhZG93LnJhZGl1cztcclxuXHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5tYXBTaXplICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KCBkYXRhLnNoYWRvdy5tYXBTaXplICk7XHJcblx0XHRcdGlmICggZGF0YS5zaGFkb3cuY2FtZXJhICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmNhbWVyYSA9IHRoaXMucGFyc2VPYmplY3QoIGRhdGEuc2hhZG93LmNhbWVyYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XHJcblx0XHRpZiAoIGRhdGEuZnJ1c3R1bUN1bGxlZCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSBkYXRhLmZydXN0dW1DdWxsZWQ7XHJcblx0XHRpZiAoIGRhdGEucmVuZGVyT3JkZXIgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZW5kZXJPcmRlciA9IGRhdGEucmVuZGVyT3JkZXI7XHJcblx0XHRpZiAoIGRhdGEudXNlckRhdGEgIT09IHVuZGVmaW5lZCApIG9iamVjdC51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XHJcblx0XHRpZiAoIGRhdGEubGF5ZXJzICE9PSB1bmRlZmluZWQgKSBvYmplY3QubGF5ZXJzLm1hc2sgPSBkYXRhLmxheWVycztcclxuXHJcblx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbjtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmFkZCggdGhpcy5wYXJzZU9iamVjdCggY2hpbGRyZW5bIGkgXSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGF0YS5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBvYmplY3RBbmltYXRpb25zID0gZGF0YS5hbmltYXRpb25zO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgb2JqZWN0QW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHV1aWQgPSBvYmplY3RBbmltYXRpb25zWyBpIF07XHJcblxyXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbnNbIHV1aWQgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRhdGEudHlwZSA9PT0gJ0xPRCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEuYXV0b1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmF1dG9VcGRhdGUgPSBkYXRhLmF1dG9VcGRhdGU7XHJcblxyXG5cdFx0XHRjb25zdCBsZXZlbHMgPSBkYXRhLmxldmVscztcclxuXHJcblx0XHRcdGZvciAoIGxldCBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxldmVsID0gbGV2ZWxzWyBsIF07XHJcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlLCBsZXZlbC5oeXN0ZXJlc2lzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0fVxyXG5cclxuXHRiaW5kU2tlbGV0b25zKCBvYmplY3QsIHNrZWxldG9ucyApIHtcclxuXHJcblx0XHRpZiAoIE9iamVjdC5rZXlzKCBza2VsZXRvbnMgKS5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0b2JqZWN0LnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xyXG5cclxuXHRcdFx0aWYgKCBjaGlsZC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmIGNoaWxkLnNrZWxldG9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNrZWxldG9uID0gc2tlbGV0b25zWyBjaGlsZC5za2VsZXRvbiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNrZWxldG9uID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBza2VsZXRvbiBmb3VuZCB3aXRoIFVVSUQ6JywgY2hpbGQuc2tlbGV0b24gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjaGlsZC5iaW5kKCBza2VsZXRvbiwgY2hpbGQuYmluZE1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jb25zdCBURVhUVVJFX01BUFBJTkcgPSB7XHJcblx0VVZNYXBwaW5nOiBVVk1hcHBpbmcsXHJcblx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXHJcblx0Q3ViZVJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXHJcblx0RXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxyXG5cdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcclxuXHRDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmdcclxufTtcclxuXHJcbmNvbnN0IFRFWFRVUkVfV1JBUFBJTkcgPSB7XHJcblx0UmVwZWF0V3JhcHBpbmc6IFJlcGVhdFdyYXBwaW5nLFxyXG5cdENsYW1wVG9FZGdlV3JhcHBpbmc6IENsYW1wVG9FZGdlV3JhcHBpbmcsXHJcblx0TWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xyXG59O1xyXG5cclxuY29uc3QgVEVYVFVSRV9GSUxURVIgPSB7XHJcblx0TmVhcmVzdEZpbHRlcjogTmVhcmVzdEZpbHRlcixcclxuXHROZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXHJcblx0TmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcclxuXHRMaW5lYXJGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxyXG5cdExpbmVhck1pcG1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXHJcbn07XHJcblxyXG5leHBvcnQgeyBPYmplY3RMb2FkZXIgfTtcclxuIiwiaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcclxuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi9Mb2FkZXIuanMnO1xyXG5cclxuY2xhc3MgSW1hZ2VCaXRtYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcclxuXHJcblx0XHRzdXBlciggbWFuYWdlciApO1xyXG5cclxuXHRcdHRoaXMuaXNJbWFnZUJpdG1hcExvYWRlciA9IHRydWU7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGNyZWF0ZUltYWdlQml0bWFwKCkgbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBmZXRjaCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9wdGlvbnMgPSB7IHByZW11bHRpcGx5QWxwaGE6ICdub25lJyB9O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcclxuXHJcblx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0fSwgMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZmV0Y2hPcHRpb25zID0ge307XHJcblx0XHRmZXRjaE9wdGlvbnMuY3JlZGVudGlhbHMgPSAoIHRoaXMuY3Jvc3NPcmlnaW4gPT09ICdhbm9ueW1vdXMnICkgPyAnc2FtZS1vcmlnaW4nIDogJ2luY2x1ZGUnO1xyXG5cdFx0ZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSB0aGlzLnJlcXVlc3RIZWFkZXI7XHJcblxyXG5cdFx0ZmV0Y2goIHVybCwgZmV0Y2hPcHRpb25zICkudGhlbiggZnVuY3Rpb24gKCByZXMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzLmJsb2IoKTtcclxuXHJcblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBibG9iICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKCBibG9iLCBPYmplY3QuYXNzaWduKCBzY29wZS5vcHRpb25zLCB7IGNvbG9yU3BhY2VDb252ZXJzaW9uOiAnbm9uZScgfSApICk7XHJcblxyXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggaW1hZ2VCaXRtYXAgKSB7XHJcblxyXG5cdFx0XHRDYWNoZS5hZGQoIHVybCwgaW1hZ2VCaXRtYXAgKTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBpbWFnZUJpdG1hcCApO1xyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHR9ICkuY2F0Y2goIGZ1bmN0aW9uICggZSApIHtcclxuXHJcblx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGUgKTtcclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBJbWFnZUJpdG1hcExvYWRlciB9O1xyXG4iLCJsZXQgX2NvbnRleHQ7XHJcblxyXG5jbGFzcyBBdWRpb0NvbnRleHQge1xyXG5cclxuXHRzdGF0aWMgZ2V0Q29udGV4dCgpIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfY29udGV4dDtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgc2V0Q29udGV4dCggdmFsdWUgKSB7XHJcblxyXG5cdFx0X2NvbnRleHQgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQXVkaW9Db250ZXh0IH07XHJcbiIsImltcG9ydCB7IEF1ZGlvQ29udGV4dCB9IGZyb20gJy4uL2F1ZGlvL0F1ZGlvQ29udGV4dC5qcyc7XHJcbmltcG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL0ZpbGVMb2FkZXIuanMnO1xyXG5pbXBvcnQgeyBMb2FkZXIgfSBmcm9tICcuL0xvYWRlci5qcyc7XHJcblxyXG5jbGFzcyBBdWRpb0xvYWRlciBleHRlbmRzIExvYWRlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHN1cGVyKCBtYW5hZ2VyICk7XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcclxuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcclxuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGJ1ZmZlci4gVGhlIGBkZWNvZGVBdWRpb0RhdGFgIG1ldGhvZFxyXG5cdFx0XHRcdC8vIGRldGFjaGVzIHRoZSBidWZmZXIgd2hlbiBjb21wbGV0ZSwgcHJldmVudGluZyByZXVzZS5cclxuXHRcdFx0XHRjb25zdCBidWZmZXJDb3B5ID0gYnVmZmVyLnNsaWNlKCAwICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xyXG5cdFx0XHRcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCBidWZmZXJDb3B5LCBmdW5jdGlvbiAoIGF1ZGlvQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdG9uTG9hZCggYXVkaW9CdWZmZXIgKTtcclxuXHJcblx0XHRcdFx0fSwgaGFuZGxlRXJyb3IgKTtcclxuXHJcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xyXG5cclxuXHRcdFx0XHRoYW5kbGVFcnJvciggZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVFcnJvciggZSApIHtcclxuXHJcblx0XHRcdGlmICggb25FcnJvciApIHtcclxuXHJcblx0XHRcdFx0b25FcnJvciggZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEF1ZGlvTG9hZGVyIH07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBMaWdodFByb2JlIH0gZnJvbSAnLi9MaWdodFByb2JlLmpzJztcclxuXHJcbmNsYXNzIEhlbWlzcGhlcmVMaWdodFByb2JlIGV4dGVuZHMgTGlnaHRQcm9iZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSA9IDEgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHVuZGVmaW5lZCwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy5pc0hlbWlzcGhlcmVMaWdodFByb2JlID0gdHJ1ZTtcclxuXHJcblx0XHRjb25zdCBjb2xvcjEgPSBuZXcgQ29sb3IoKS5zZXQoIHNreUNvbG9yICk7XHJcblx0XHRjb25zdCBjb2xvcjIgPSBuZXcgQ29sb3IoKS5zZXQoIGdyb3VuZENvbG9yICk7XHJcblxyXG5cdFx0Y29uc3Qgc2t5ID0gbmV3IFZlY3RvcjMoIGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIgKTtcclxuXHRcdGNvbnN0IGdyb3VuZCA9IG5ldyBWZWN0b3IzKCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iICk7XHJcblxyXG5cdFx0Ly8gd2l0aG91dCBleHRyYSBmYWN0b3Igb2YgUEkgaW4gdGhlIHNoYWRlciwgc2hvdWxkID0gMSAvIE1hdGguc3FydCggTWF0aC5QSSApO1xyXG5cdFx0Y29uc3QgYzAgPSBNYXRoLnNxcnQoIE1hdGguUEkgKTtcclxuXHRcdGNvbnN0IGMxID0gYzAgKiBNYXRoLnNxcnQoIDAuNzUgKTtcclxuXHJcblx0XHR0aGlzLnNoLmNvZWZmaWNpZW50c1sgMCBdLmNvcHkoIHNreSApLmFkZCggZ3JvdW5kICkubXVsdGlwbHlTY2FsYXIoIGMwICk7XHJcblx0XHR0aGlzLnNoLmNvZWZmaWNpZW50c1sgMSBdLmNvcHkoIHNreSApLnN1YiggZ3JvdW5kICkubXVsdGlwbHlTY2FsYXIoIGMxICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IEhlbWlzcGhlcmVMaWdodFByb2JlIH07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IExpZ2h0UHJvYmUgfSBmcm9tICcuL0xpZ2h0UHJvYmUuanMnO1xyXG5cclxuY2xhc3MgQW1iaWVudExpZ2h0UHJvYmUgZXh0ZW5kcyBMaWdodFByb2JlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHkgPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCB1bmRlZmluZWQsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMuaXNBbWJpZW50TGlnaHRQcm9iZSA9IHRydWU7XHJcblxyXG5cdFx0Y29uc3QgY29sb3IxID0gbmV3IENvbG9yKCkuc2V0KCBjb2xvciApO1xyXG5cclxuXHRcdC8vIHdpdGhvdXQgZXh0cmEgZmFjdG9yIG9mIFBJIGluIHRoZSBzaGFkZXIsIHdvdWxkIGJlIDIgLyBNYXRoLnNxcnQoIE1hdGguUEkgKTtcclxuXHRcdHRoaXMuc2guY29lZmZpY2llbnRzWyAwIF0uc2V0KCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICkubXVsdGlwbHlTY2FsYXIoIDIgKiBNYXRoLnNxcnQoIE1hdGguUEkgKSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBBbWJpZW50TGlnaHRQcm9iZSB9O1xyXG4iLCJpbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICcuL1BlcnNwZWN0aXZlQ2FtZXJhLmpzJztcclxuXHJcbmNvbnN0IF9leWVSaWdodCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcclxuY29uc3QgX2V5ZUxlZnQgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF9wcm9qZWN0aW9uTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5cclxuY2xhc3MgU3RlcmVvQ2FtZXJhIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1N0ZXJlb0NhbWVyYSc7XHJcblxyXG5cdFx0dGhpcy5hc3BlY3QgPSAxO1xyXG5cclxuXHRcdHRoaXMuZXllU2VwID0gMC4wNjQ7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XHJcblx0XHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xyXG5cdFx0dGhpcy5jYW1lcmFMLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHRcdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XHJcblx0XHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX2NhY2hlID0ge1xyXG5cdFx0XHRmb2N1czogbnVsbCxcclxuXHRcdFx0Zm92OiBudWxsLFxyXG5cdFx0XHRhc3BlY3Q6IG51bGwsXHJcblx0XHRcdG5lYXI6IG51bGwsXHJcblx0XHRcdGZhcjogbnVsbCxcclxuXHRcdFx0em9vbTogbnVsbCxcclxuXHRcdFx0ZXllU2VwOiBudWxsXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSggY2FtZXJhICkge1xyXG5cclxuXHRcdGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGU7XHJcblxyXG5cdFx0Y29uc3QgbmVlZHNVcGRhdGUgPSBjYWNoZS5mb2N1cyAhPT0gY2FtZXJhLmZvY3VzIHx8IGNhY2hlLmZvdiAhPT0gY2FtZXJhLmZvdiB8fFxyXG5cdFx0XHRjYWNoZS5hc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdCB8fCBjYWNoZS5uZWFyICE9PSBjYW1lcmEubmVhciB8fFxyXG5cdFx0XHRjYWNoZS5mYXIgIT09IGNhbWVyYS5mYXIgfHwgY2FjaGUuem9vbSAhPT0gY2FtZXJhLnpvb20gfHwgY2FjaGUuZXllU2VwICE9PSB0aGlzLmV5ZVNlcDtcclxuXHJcblx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0Y2FjaGUuZm9jdXMgPSBjYW1lcmEuZm9jdXM7XHJcblx0XHRcdGNhY2hlLmZvdiA9IGNhbWVyYS5mb3Y7XHJcblx0XHRcdGNhY2hlLmFzcGVjdCA9IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdDtcclxuXHRcdFx0Y2FjaGUubmVhciA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0XHRjYWNoZS5mYXIgPSBjYW1lcmEuZmFyO1xyXG5cdFx0XHRjYWNoZS56b29tID0gY2FtZXJhLnpvb207XHJcblx0XHRcdGNhY2hlLmV5ZVNlcCA9IHRoaXMuZXllU2VwO1xyXG5cclxuXHRcdFx0Ly8gT2ZmLWF4aXMgc3RlcmVvc2NvcGljIGVmZmVjdCBiYXNlZCBvblxyXG5cdFx0XHQvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvc3RlcmVvZ3JhcGhpY3Mvc3RlcmVvcmVuZGVyL1xyXG5cclxuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0Y29uc3QgZXllU2VwSGFsZiA9IGNhY2hlLmV5ZVNlcCAvIDI7XHJcblx0XHRcdGNvbnN0IGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcEhhbGYgKiBjYWNoZS5uZWFyIC8gY2FjaGUuZm9jdXM7XHJcblx0XHRcdGNvbnN0IHltYXggPSAoIGNhY2hlLm5lYXIgKiBNYXRoLnRhbiggTWF0aFV0aWxzLkRFRzJSQUQgKiBjYWNoZS5mb3YgKiAwLjUgKSApIC8gY2FjaGUuem9vbTtcclxuXHRcdFx0bGV0IHhtaW4sIHhtYXg7XHJcblxyXG5cdFx0XHQvLyB0cmFuc2xhdGUgeE9mZnNldFxyXG5cclxuXHRcdFx0X2V5ZUxlZnQuZWxlbWVudHNbIDEyIF0gPSAtIGV5ZVNlcEhhbGY7XHJcblx0XHRcdF9leWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcEhhbGY7XHJcblxyXG5cdFx0XHQvLyBmb3IgbGVmdCBleWVcclxuXHJcblx0XHRcdHhtaW4gPSAtIHltYXggKiBjYWNoZS5hc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XHJcblx0XHRcdHhtYXggPSB5bWF4ICogY2FjaGUuYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xyXG5cclxuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBjYWNoZS5uZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cclxuXHRcdFx0dGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weSggX3Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIGZvciByaWdodCBleWVcclxuXHJcblx0XHRcdHhtaW4gPSAtIHltYXggKiBjYWNoZS5hc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XHJcblx0XHRcdHhtYXggPSB5bWF4ICogY2FjaGUuYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xyXG5cclxuXHRcdFx0X3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBjYWNoZS5uZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRfcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cclxuXHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weSggX3Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBfZXllTGVmdCApO1xyXG5cdFx0dGhpcy5jYW1lcmFSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBfZXllUmlnaHQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgU3RlcmVvQ2FtZXJhIH07XHJcbiIsImNsYXNzIENsb2NrIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGF1dG9TdGFydCA9IHRydWUgKSB7XHJcblxyXG5cdFx0dGhpcy5hdXRvU3RhcnQgPSBhdXRvU3RhcnQ7XHJcblxyXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xyXG5cdFx0dGhpcy5vbGRUaW1lID0gMDtcclxuXHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cclxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0YXJ0KCkge1xyXG5cclxuXHRcdHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XHJcblxyXG5cdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcclxuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0c3RvcCgpIHtcclxuXHJcblx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XHJcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RWxhcHNlZFRpbWUoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXREZWx0YSgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RGVsdGEoKSB7XHJcblxyXG5cdFx0bGV0IGRpZmYgPSAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnN0YXJ0KCk7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMucnVubmluZyApIHtcclxuXHJcblx0XHRcdGNvbnN0IG5ld1RpbWUgPSBub3coKTtcclxuXHJcblx0XHRcdGRpZmYgPSAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKSAvIDEwMDA7XHJcblx0XHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XHJcblxyXG5cdFx0XHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkaWZmO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBub3coKSB7XHJcblxyXG5cdHJldHVybiAoIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UgKS5ub3coKTsgLy8gc2VlICMxMDczMlxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQ2xvY2sgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuLi9tYXRoL1F1YXRlcm5pb24uanMnO1xyXG5pbXBvcnQgeyBDbG9jayB9IGZyb20gJy4uL2NvcmUvQ2xvY2suanMnO1xyXG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5pbXBvcnQgeyBBdWRpb0NvbnRleHQgfSBmcm9tICcuL0F1ZGlvQ29udGV4dC5qcyc7XHJcblxyXG5jb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xyXG5jb25zdCBfc2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9vcmllbnRhdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIEF1ZGlvTGlzdGVuZXIgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xyXG5cclxuXHRcdHRoaXMuY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XHJcblxyXG5cdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHR0aGlzLmZpbHRlciA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy50aW1lRGVsdGEgPSAwO1xyXG5cclxuXHRcdC8vIHByaXZhdGVcclxuXHJcblx0XHR0aGlzLl9jbG9jayA9IG5ldyBDbG9jaygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldElucHV0KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdhaW47XHJcblxyXG5cdH1cclxuXHJcblx0cmVtb3ZlRmlsdGVyKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcclxuXHRcdFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblx0XHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHRcdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGaWx0ZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZpbHRlciggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG5cdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpbHRlciA9IHZhbHVlO1xyXG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XHJcblx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRNYXN0ZXJWb2x1bWUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE1hc3RlclZvbHVtZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5nYWluLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKCB2YWx1ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHRcdGNvbnN0IGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xyXG5cdFx0Y29uc3QgdXAgPSB0aGlzLnVwO1xyXG5cclxuXHRcdHRoaXMudGltZURlbHRhID0gdGhpcy5fY2xvY2suZ2V0RGVsdGEoKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlICk7XHJcblxyXG5cdFx0X29yaWVudGF0aW9uLnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXIucG9zaXRpb25YICkge1xyXG5cclxuXHRcdFx0Ly8gY29kZSBwYXRoIGZvciBDaHJvbWUgKHNlZSAjMTQzOTMpXHJcblxyXG5cdFx0XHRjb25zdCBlbmRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy50aW1lRGVsdGE7XHJcblxyXG5cdFx0XHRsaXN0ZW5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9wb3NpdGlvbi54LCBlbmRUaW1lICk7XHJcblx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLnksIGVuZFRpbWUgKTtcclxuXHRcdFx0bGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfcG9zaXRpb24ueiwgZW5kVGltZSApO1xyXG5cdFx0XHRsaXN0ZW5lci5mb3J3YXJkWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLngsIGVuZFRpbWUgKTtcclxuXHRcdFx0bGlzdGVuZXIuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIF9vcmllbnRhdGlvbi55LCBlbmRUaW1lICk7XHJcblx0XHRcdGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCBfb3JpZW50YXRpb24ueiwgZW5kVGltZSApO1xyXG5cdFx0XHRsaXN0ZW5lci51cFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoIHVwLngsIGVuZFRpbWUgKTtcclxuXHRcdFx0bGlzdGVuZXIudXBZLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKCB1cC55LCBlbmRUaW1lICk7XHJcblx0XHRcdGxpc3RlbmVyLnVwWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggdXAueiwgZW5kVGltZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lci5zZXRQb3NpdGlvbiggX3Bvc2l0aW9uLngsIF9wb3NpdGlvbi55LCBfcG9zaXRpb24ueiApO1xyXG5cdFx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggX29yaWVudGF0aW9uLngsIF9vcmllbnRhdGlvbi55LCBfb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQXVkaW9MaXN0ZW5lciB9O1xyXG4iLCJpbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5cclxuY2xhc3MgQXVkaW8gZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdBdWRpbyc7XHJcblxyXG5cdFx0dGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG5cdFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcclxuXHJcblx0XHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xyXG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIGxpc3RlbmVyLmdldElucHV0KCkgKTtcclxuXHJcblx0XHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5idWZmZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5kZXR1bmUgPSAwO1xyXG5cdFx0dGhpcy5sb29wID0gZmFsc2U7XHJcblx0XHR0aGlzLmxvb3BTdGFydCA9IDA7XHJcblx0XHR0aGlzLmxvb3BFbmQgPSAwO1xyXG5cdFx0dGhpcy5vZmZzZXQgPSAwO1xyXG5cdFx0dGhpcy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gMTtcclxuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IHRydWU7XHJcblx0XHR0aGlzLnNvdXJjZSA9IG51bGw7XHJcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnZW1wdHknO1xyXG5cclxuXHRcdHRoaXMuX3N0YXJ0ZWRBdCA9IDA7XHJcblx0XHR0aGlzLl9wcm9ncmVzcyA9IDA7XHJcblx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmZpbHRlcnMgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRPdXRwdXQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2FpbjtcclxuXHJcblx0fVxyXG5cclxuXHRzZXROb2RlU291cmNlKCBhdWRpb05vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcclxuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdhdWRpb05vZGUnO1xyXG5cdFx0dGhpcy5zb3VyY2UgPSBhdWRpb05vZGU7XHJcblx0XHR0aGlzLmNvbm5lY3QoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRNZWRpYUVsZW1lbnRTb3VyY2UoIG1lZGlhRWxlbWVudCApIHtcclxuXHJcblx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ21lZGlhTm9kZSc7XHJcblx0XHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoIG1lZGlhRWxlbWVudCApO1xyXG5cdFx0dGhpcy5jb25uZWN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TWVkaWFTdHJlYW1Tb3VyY2UoIG1lZGlhU3RyZWFtICkge1xyXG5cclxuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XHJcblx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFTdHJlYW1Ob2RlJztcclxuXHRcdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKCBtZWRpYVN0cmVhbSApO1xyXG5cdFx0dGhpcy5jb25uZWN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0QnVmZmVyKCBhdWRpb0J1ZmZlciApIHtcclxuXHJcblx0XHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xyXG5cdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9wbGF5ICkgdGhpcy5wbGF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0cGxheSggZGVsYXkgPSAwICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9zdGFydGVkQXQgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKyBkZWxheTtcclxuXHJcblx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcblx0XHRzb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcclxuXHRcdHNvdXJjZS5sb29wU3RhcnQgPSB0aGlzLmxvb3BTdGFydDtcclxuXHRcdHNvdXJjZS5sb29wRW5kID0gdGhpcy5sb29wRW5kO1xyXG5cdFx0c291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xyXG5cdFx0c291cmNlLnN0YXJ0KCB0aGlzLl9zdGFydGVkQXQsIHRoaXMuX3Byb2dyZXNzICsgdGhpcy5vZmZzZXQsIHRoaXMuZHVyYXRpb24gKTtcclxuXHJcblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblxyXG5cdFx0dGhpcy5zZXREZXR1bmUoIHRoaXMuZGV0dW5lICk7XHJcblx0XHR0aGlzLnNldFBsYXliYWNrUmF0ZSggdGhpcy5wbGF5YmFja1JhdGUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0cGF1c2UoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBjdXJyZW50IHByb2dyZXNzXHJcblxyXG5cdFx0XHR0aGlzLl9wcm9ncmVzcyArPSBNYXRoLm1heCggdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5fc3RhcnRlZEF0LCAwICkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5sb29wID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHQvLyBlbnN1cmUgX3Byb2dyZXNzIGRvZXMgbm90IGV4Y2VlZCBkdXJhdGlvbiB3aXRoIGxvb3BlZCBhdWRpb3NcclxuXHJcblx0XHRcdFx0dGhpcy5fcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcyAlICggdGhpcy5kdXJhdGlvbiB8fCB0aGlzLmJ1ZmZlci5kdXJhdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG5cdFx0XHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gbnVsbDtcclxuXHJcblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0b3AoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcHJvZ3Jlc3MgPSAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5zb3VyY2UgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XHJcblx0XHRcdHRoaXMuc291cmNlLm9uZW5kZWQgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbm5lY3QoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5maWx0ZXJzWyBpIC0gMSBdLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzY29ubmVjdCgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuZmlsdGVycy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyAwIF0gKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZpbHRlcnNbIGkgLSAxIF0uZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RmlsdGVycygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZpbHRlcnMoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggISB2YWx1ZSApIHZhbHVlID0gW107XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9jb25uZWN0ZWQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcclxuXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWUuc2xpY2UoKTtcclxuXHRcdFx0dGhpcy5jb25uZWN0KCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlLnNsaWNlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldERldHVuZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5kZXR1bmUgPSB2YWx1ZTtcclxuXHJcblx0XHRpZiAoIHRoaXMuc291cmNlLmRldHVuZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBvbmx5IHNldCBkZXR1bmUgd2hlbiBhdmFpbGFibGVcclxuXHJcblx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSggdGhpcy5kZXR1bmUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXREZXR1bmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGV0dW5lO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEZpbHRlcigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbIDAgXTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGaWx0ZXIoIGZpbHRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKCBmaWx0ZXIgPyBbIGZpbHRlciBdIDogW10gKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRQbGF5YmFja1JhdGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS5zZXRUYXJnZXRBdFRpbWUoIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUsIDAuMDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UGxheWJhY2tSYXRlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcclxuXHJcblx0fVxyXG5cclxuXHRvbkVuZGVkKCkge1xyXG5cclxuXHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TG9vcCgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5sb29wO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldExvb3AoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubG9vcCA9IHZhbHVlO1xyXG5cclxuXHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRMb29wU3RhcnQoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMubG9vcFN0YXJ0ID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TG9vcEVuZCggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5sb29wRW5kID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Vm9sdW1lKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRWb2x1bWUoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuZ2Fpbi5nYWluLnNldFRhcmdldEF0VGltZSggdmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBBdWRpbyB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XHJcbmltcG9ydCB7IEF1ZGlvIH0gZnJvbSAnLi9BdWRpby5qcyc7XHJcblxyXG5jb25zdCBfcG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xyXG5jb25zdCBfc2NhbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9vcmllbnRhdGlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIFBvc2l0aW9uYWxBdWRpbyBleHRlbmRzIEF1ZGlvIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdHN1cGVyKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xyXG5cdFx0dGhpcy5wYW5uZXIucGFubmluZ01vZGVsID0gJ0hSVEYnO1xyXG5cdFx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29ubmVjdCgpIHtcclxuXHJcblx0XHRzdXBlci5jb25uZWN0KCk7XHJcblxyXG5cdFx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzY29ubmVjdCgpIHtcclxuXHJcblx0XHRzdXBlci5kaXNjb25uZWN0KCk7XHJcblxyXG5cdFx0dGhpcy5wYW5uZXIuZGlzY29ubmVjdCggdGhpcy5nYWluICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0T3V0cHV0KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnBhbm5lcjtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRSZWZEaXN0YW5jZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0UmVmRGlzdGFuY2UoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Um9sbG9mZkZhY3RvcigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRSb2xsb2ZmRmFjdG9yKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RGlzdGFuY2VNb2RlbCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXREaXN0YW5jZU1vZGVsKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TWF4RGlzdGFuY2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE1heERpc3RhbmNlKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldERpcmVjdGlvbmFsQ29uZSggY29uZUlubmVyQW5nbGUsIGNvbmVPdXRlckFuZ2xlLCBjb25lT3V0ZXJHYWluICkge1xyXG5cclxuXHRcdHRoaXMucGFubmVyLmNvbmVJbm5lckFuZ2xlID0gY29uZUlubmVyQW5nbGU7XHJcblx0XHR0aGlzLnBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IGNvbmVPdXRlckFuZ2xlO1xyXG5cdFx0dGhpcy5wYW5uZXIuY29uZU91dGVyR2FpbiA9IGNvbmVPdXRlckdhaW47XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IHRydWUgJiYgdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCBfc2NhbGUgKTtcclxuXHJcblx0XHRfb3JpZW50YXRpb24uc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdGNvbnN0IHBhbm5lciA9IHRoaXMucGFubmVyO1xyXG5cclxuXHRcdGlmICggcGFubmVyLnBvc2l0aW9uWCApIHtcclxuXHJcblx0XHRcdC8vIGNvZGUgcGF0aCBmb3IgQ2hyb21lIGFuZCBGaXJlZm94IChzZWUgIzE0MzkzKVxyXG5cclxuXHRcdFx0Y29uc3QgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubGlzdGVuZXIudGltZURlbHRhO1xyXG5cclxuXHRcdFx0cGFubmVyLnBvc2l0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLngsIGVuZFRpbWUgKTtcclxuXHRcdFx0cGFubmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLnksIGVuZFRpbWUgKTtcclxuXHRcdFx0cGFubmVyLnBvc2l0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX3Bvc2l0aW9uLnosIGVuZFRpbWUgKTtcclxuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLngsIGVuZFRpbWUgKTtcclxuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLnksIGVuZFRpbWUgKTtcclxuXHRcdFx0cGFubmVyLm9yaWVudGF0aW9uWi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSggX29yaWVudGF0aW9uLnosIGVuZFRpbWUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cGFubmVyLnNldFBvc2l0aW9uKCBfcG9zaXRpb24ueCwgX3Bvc2l0aW9uLnksIF9wb3NpdGlvbi56ICk7XHJcblx0XHRcdHBhbm5lci5zZXRPcmllbnRhdGlvbiggX29yaWVudGF0aW9uLngsIF9vcmllbnRhdGlvbi55LCBfb3JpZW50YXRpb24ueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgUG9zaXRpb25hbEF1ZGlvIH07XHJcbiIsImNsYXNzIEF1ZGlvQW5hbHlzZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXVkaW8sIGZmdFNpemUgPSAyMDQ4ICkge1xyXG5cclxuXHRcdHRoaXMuYW5hbHlzZXIgPSBhdWRpby5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XHJcblx0XHR0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplO1xyXG5cclxuXHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XHJcblxyXG5cdFx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRnZXRGcmVxdWVuY3lEYXRhKCkge1xyXG5cclxuXHRcdHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIHRoaXMuZGF0YSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QXZlcmFnZUZyZXF1ZW5jeSgpIHtcclxuXHJcblx0XHRsZXQgdmFsdWUgPSAwO1xyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFsdWUgKz0gZGF0YVsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWUgLyBkYXRhLmxlbmd0aDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQXVkaW9BbmFseXNlciB9O1xyXG4iLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcclxuXHJcbmNsYXNzIFByb3BlcnR5TWl4ZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcclxuXHJcblx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xyXG5cdFx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XHJcblxyXG5cdFx0bGV0IG1peEZ1bmN0aW9uLFxyXG5cdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlLFxyXG5cdFx0XHRzZXRJZGVudGl0eTtcclxuXHJcblx0XHQvLyBidWZmZXIgbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgfCBhZGRBY2N1IHwgKG9wdGlvbmFsIHdvcmspIF1cclxuXHRcdC8vXHJcblx0XHQvLyBpbnRlcnBvbGF0b3JzIGNhbiB1c2UgLmJ1ZmZlciBhcyB0aGVpciAucmVzdWx0XHJcblx0XHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xyXG5cdFx0Ly9cclxuXHRcdC8vICdhY2N1MCcgYW5kICdhY2N1MScgYXJlIHVzZWQgZnJhbWUtaW50ZXJsZWF2ZWQgZm9yXHJcblx0XHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3RcclxuXHRcdC8vIGNoYW5nZXNcclxuXHRcdC8vXHJcblx0XHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcclxuXHRcdC8vXHJcblx0XHQvLyAnYWRkJyBpcyB1c2VkIGZvciBhZGRpdGl2ZSBjdW11bGF0aXZlIHJlc3VsdHNcclxuXHRcdC8vXHJcblx0XHQvLyAnd29yaycgaXMgb3B0aW9uYWwgYW5kIGlzIG9ubHkgcHJlc2VudCBmb3IgcXVhdGVybmlvbiB0eXBlcy4gSXQgaXMgdXNlZFxyXG5cdFx0Ly8gdG8gc3RvcmUgaW50ZXJtZWRpYXRlIHF1YXRlcm5pb24gbXVsdGlwbGljYXRpb24gcmVzdWx0c1xyXG5cclxuXHRcdHN3aXRjaCAoIHR5cGVOYW1lICkge1xyXG5cclxuXHRcdFx0Y2FzZSAncXVhdGVybmlvbic6XHJcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zbGVycDtcclxuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fc2xlcnBBZGRpdGl2ZTtcclxuXHRcdFx0XHRzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uO1xyXG5cclxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkoIHZhbHVlU2l6ZSAqIDYgKTtcclxuXHRcdFx0XHR0aGlzLl93b3JrSW5kZXggPSA1O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcclxuXHRcdFx0Y2FzZSAnYm9vbCc6XHJcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XHJcblxyXG5cdFx0XHRcdC8vIFVzZSB0aGUgcmVndWxhciBtaXggZnVuY3Rpb24gYW5kIGZvciBhZGRpdGl2ZSBvbiB0aGVzZSB0eXBlcyxcclxuXHRcdFx0XHQvLyBhZGRpdGl2ZSBpcyBub3QgcmVsZXZhbnQgZm9yIG5vbi1udW1lcmljIHR5cGVzXHJcblx0XHRcdFx0bWl4RnVuY3Rpb25BZGRpdGl2ZSA9IHRoaXMuX3NlbGVjdDtcclxuXHJcblx0XHRcdFx0c2V0SWRlbnRpdHkgPSB0aGlzLl9zZXRBZGRpdGl2ZUlkZW50aXR5T3RoZXI7XHJcblxyXG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEFycmF5KCB2YWx1ZVNpemUgKiA1ICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcclxuXHRcdFx0XHRtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fbGVycEFkZGl0aXZlO1xyXG5cdFx0XHRcdHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWM7XHJcblxyXG5cdFx0XHRcdHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSggdmFsdWVTaXplICogNSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24gPSBtaXhGdW5jdGlvbjtcclxuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlID0gbWl4RnVuY3Rpb25BZGRpdGl2ZTtcclxuXHRcdHRoaXMuX3NldElkZW50aXR5ID0gc2V0SWRlbnRpdHk7XHJcblx0XHR0aGlzLl9vcmlnSW5kZXggPSAzO1xyXG5cdFx0dGhpcy5fYWRkSW5kZXggPSA0O1xyXG5cclxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcblx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XHJcblxyXG5cdFx0dGhpcy51c2VDb3VudCA9IDA7XHJcblx0XHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXHJcblx0YWNjdW11bGF0ZSggYWNjdUluZGV4LCB3ZWlnaHQgKSB7XHJcblxyXG5cdFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3NcclxuXHRcdC8vIHRoZSB3ZWlnaHQgYW5kIHNob3VsZG4ndCBoYXZlIG1hZGUgdGhlIGNhbGwgaW4gdGhlIGZpcnN0IHBsYWNlXHJcblxyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXHJcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGU7XHJcblxyXG5cdFx0bGV0IGN1cnJlbnRXZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudFdlaWdodCA9IHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxyXG5cclxuXHRcdFx0Y3VycmVudFdlaWdodCArPSB3ZWlnaHQ7XHJcblx0XHRcdGNvbnN0IG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XHJcblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiggYnVmZmVyLCBvZmZzZXQsIDAsIG1peCwgc3RyaWRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IGN1cnJlbnRXZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhZGQnXHJcblx0YWNjdW11bGF0ZUFkZGl0aXZlKCB3ZWlnaHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXHJcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cdFx0XHRvZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9hZGRJbmRleDtcclxuXHJcblx0XHRpZiAoIHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID09PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gYWRkID0gaWRlbnRpdHlcclxuXHJcblx0XHRcdHRoaXMuX3NldElkZW50aXR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFkZCA6PSBhZGQgKyBpbmNvbWluZyAqIHdlaWdodFxyXG5cclxuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbkFkZGl0aXZlKCBidWZmZXIsIG9mZnNldCwgMCwgd2VpZ2h0LCBzdHJpZGUgKTtcclxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlICs9IHdlaWdodDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXHJcblx0YXBwbHkoIGFjY3VJbmRleCApIHtcclxuXHJcblx0XHRjb25zdCBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHRcdFx0YnVmZmVyID0gdGhpcy5idWZmZXIsXHJcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcclxuXHJcblx0XHRcdHdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodCxcclxuXHRcdFx0d2VpZ2h0QWRkaXRpdmUgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSxcclxuXHJcblx0XHRcdGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XHJcblxyXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID0gMDtcclxuXHJcblx0XHRpZiAoIHdlaWdodCA8IDEgKSB7XHJcblxyXG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIG9yaWdpbmFsICogKCAxIC0gY3VtdWxhdGl2ZVdlaWdodCApXHJcblxyXG5cdFx0XHRjb25zdCBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogdGhpcy5fb3JpZ0luZGV4O1xyXG5cclxuXHRcdFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKFxyXG5cdFx0XHRcdGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB3ZWlnaHRBZGRpdGl2ZSA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGFkZGl0aXZlIGFjY3VOXHJcblxyXG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZSggYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSBzdHJpZGUsIGUgPSBzdHJpZGUgKyBzdHJpZGU7IGkgIT09IGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJ1ZmZlclsgaSBdICE9PSBidWZmZXJbIGkgKyBzdHJpZGUgXSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0XHRcdGJpbmRpbmcuc2V0VmFsdWUoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIHJlbWVtYmVyIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkgYW5kIGNvcHkgaXQgdG8gYm90aCBhY2N1c1xyXG5cdHNhdmVPcmlnaW5hbFN0YXRlKCkge1xyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XHJcblxyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXIsXHJcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cclxuXHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIHRoaXMuX29yaWdJbmRleDtcclxuXHJcblx0XHRiaW5kaW5nLmdldFZhbHVlKCBidWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcclxuXHJcblx0XHQvLyBhY2N1WzAuLjFdIDo9IG9yaWcgLS0gaW5pdGlhbGx5IGRldGVjdCBjaGFuZ2VzIGFnYWluc3QgdGhlIG9yaWdpbmFsXHJcblx0XHRmb3IgKCBsZXQgaSA9IHN0cmlkZSwgZSA9IG9yaWdpbmFsVmFsdWVPZmZzZXQ7IGkgIT09IGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRidWZmZXJbIGkgXSA9IGJ1ZmZlclsgb3JpZ2luYWxWYWx1ZU9mZnNldCArICggaSAlIHN0cmlkZSApIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCB0byBpZGVudGl0eSBmb3IgYWRkaXRpdmVcclxuXHRcdHRoaXMuX3NldElkZW50aXR5KCk7XHJcblxyXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcclxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBhcHBseSB0aGUgc3RhdGUgcHJldmlvdXNseSB0YWtlbiB2aWEgJ3NhdmVPcmlnaW5hbFN0YXRlJyB0byB0aGUgYmluZGluZ1xyXG5cdHJlc3RvcmVPcmlnaW5hbFN0YXRlKCkge1xyXG5cclxuXHRcdGNvbnN0IG9yaWdpbmFsVmFsdWVPZmZzZXQgPSB0aGlzLnZhbHVlU2l6ZSAqIDM7XHJcblx0XHR0aGlzLmJpbmRpbmcuc2V0VmFsdWUoIHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCkge1xyXG5cclxuXHRcdGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplO1xyXG5cdFx0Y29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgdGhpcy52YWx1ZVNpemU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJ1ZmZlclsgaSBdID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0X3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uKCkge1xyXG5cclxuXHRcdHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCk7XHJcblx0XHR0aGlzLmJ1ZmZlclsgdGhpcy5fYWRkSW5kZXggKiB0aGlzLnZhbHVlU2l6ZSArIDMgXSA9IDE7XHJcblxyXG5cdH1cclxuXHJcblx0X3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpIHtcclxuXHJcblx0XHRjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fb3JpZ0luZGV4ICogdGhpcy52YWx1ZVNpemU7XHJcblx0XHRjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemU7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZVNpemU7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJ1ZmZlclsgdGFyZ2V0SW5kZXggKyBpIF0gPSB0aGlzLmJ1ZmZlclsgc3RhcnRJbmRleCArIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIG1peCBmdW5jdGlvbnNcclxuXHJcblx0X3NlbGVjdCggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xyXG5cclxuXHRcdGlmICggdCA+PSAwLjUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YnVmZmVyWyBkc3RPZmZzZXQgKyBpIF0gPSBidWZmZXJbIHNyY09mZnNldCArIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0X3NsZXJwKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0ICkge1xyXG5cclxuXHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgc3JjT2Zmc2V0LCB0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3NsZXJwQWRkaXRpdmUoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcclxuXHJcblx0XHRjb25zdCB3b3JrT2Zmc2V0ID0gdGhpcy5fd29ya0luZGV4ICogc3RyaWRlO1xyXG5cclxuXHRcdC8vIFN0b3JlIHJlc3VsdCBpbiBpbnRlcm1lZGlhdGUgYnVmZmVyIG9mZnNldFxyXG5cdFx0UXVhdGVybmlvbi5tdWx0aXBseVF1YXRlcm5pb25zRmxhdCggYnVmZmVyLCB3b3JrT2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQgKTtcclxuXHJcblx0XHQvLyBTbGVycCB0byB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdFxyXG5cdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCB3b3JrT2Zmc2V0LCB0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2xlcnAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcclxuXHJcblx0XHRjb25zdCBzID0gMSAtIHQ7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcclxuXHJcblx0XHRcdGJ1ZmZlclsgaiBdID0gYnVmZmVyWyBqIF0gKiBzICsgYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF0gKiB0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfbGVycEFkZGl0aXZlKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBqID0gZHN0T2Zmc2V0ICsgaTtcclxuXHJcblx0XHRcdGJ1ZmZlclsgaiBdID0gYnVmZmVyWyBqIF0gKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgUHJvcGVydHlNaXhlciB9O1xyXG4iLCIvLyBDaGFyYWN0ZXJzIFtdLjovIGFyZSByZXNlcnZlZCBmb3IgdHJhY2sgYmluZGluZyBzeW50YXguXHJcbmNvbnN0IF9SRVNFUlZFRF9DSEFSU19SRSA9ICdcXFxcW1xcXFxdXFxcXC46XFxcXC8nO1xyXG5jb25zdCBfcmVzZXJ2ZWRSZSA9IG5ldyBSZWdFeHAoICdbJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJywgJ2cnICk7XHJcblxyXG4vLyBBdHRlbXB0cyB0byBhbGxvdyBub2RlIG5hbWVzIGZyb20gYW55IGxhbmd1YWdlLiBFUzUncyBgXFx3YCByZWdleHAgbWF0Y2hlc1xyXG4vLyBvbmx5IGxhdGluIGNoYXJhY3RlcnMsIGFuZCB0aGUgdW5pY29kZSBcXHB7TH0gaXMgbm90IHlldCBzdXBwb3J0ZWQuIFNvXHJcbi8vIGluc3RlYWQsIHdlIGV4Y2x1ZGUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgbWF0Y2ggZXZlcnl0aGluZyBlbHNlLlxyXG5jb25zdCBfd29yZENoYXIgPSAnW14nICsgX1JFU0VSVkVEX0NIQVJTX1JFICsgJ10nO1xyXG5jb25zdCBfd29yZENoYXJPckRvdCA9ICdbXicgKyBfUkVTRVJWRURfQ0hBUlNfUkUucmVwbGFjZSggJ1xcXFwuJywgJycgKSArICddJztcclxuXHJcbi8vIFBhcmVudCBkaXJlY3RvcmllcywgZGVsaW1pdGVkIGJ5ICcvJyBvciAnOicuIEN1cnJlbnRseSB1bnVzZWQsIGJ1dCBtdXN0XHJcbi8vIGJlIG1hdGNoZWQgdG8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHRyYWNrIG5hbWUuXHJcbmNvbnN0IF9kaXJlY3RvcnlSZSA9IC8qQF9fUFVSRV9fKi8gLygoPzpXQytbXFwvOl0pKikvLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcclxuXHJcbi8vIFRhcmdldCBub2RlLiBNYXkgY29udGFpbiB3b3JkIGNoYXJhY3RlcnMgKGEtekEtWjAtOV8pIGFuZCAnLicgb3IgJy0nLlxyXG5jb25zdCBfbm9kZVJlID0gLypAX19QVVJFX18qLyAvKFdDT0QrKT8vLnNvdXJjZS5yZXBsYWNlKCAnV0NPRCcsIF93b3JkQ2hhck9yRG90ICk7XHJcblxyXG4vLyBPYmplY3Qgb24gdGFyZ2V0IG5vZGUsIGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkXHJcbi8vIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heSBjb250YWluIGFueSBjaGFyYWN0ZXIgZXhjZXB0IGNsb3NpbmcgYnJhY2tldC5cclxuY29uc3QgX29iamVjdFJlID0gLypAX19QVVJFX18qLyAvKD86XFwuKFdDKykoPzpcXFsoLispXFxdKT8pPy8uc291cmNlLnJlcGxhY2UoICdXQycsIF93b3JkQ2hhciApO1xyXG5cclxuLy8gUHJvcGVydHkgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWQgY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5XHJcbi8vIGNvbnRhaW4gYW55IG5vbi1icmFja2V0IGNoYXJhY3RlcnMuXHJcbmNvbnN0IF9wcm9wZXJ0eVJlID0gLypAX19QVVJFX18qLyAvXFwuKFdDKykoPzpcXFsoLispXFxdKT8vLnNvdXJjZS5yZXBsYWNlKCAnV0MnLCBfd29yZENoYXIgKTtcclxuXHJcbmNvbnN0IF90cmFja1JlID0gbmV3IFJlZ0V4cCggJydcclxuXHQrICdeJ1xyXG5cdCsgX2RpcmVjdG9yeVJlXHJcblx0KyBfbm9kZVJlXHJcblx0KyBfb2JqZWN0UmVcclxuXHQrIF9wcm9wZXJ0eVJlXHJcblx0KyAnJCdcclxuKTtcclxuXHJcbmNvbnN0IF9zdXBwb3J0ZWRPYmplY3ROYW1lcyA9IFsgJ21hdGVyaWFsJywgJ21hdGVyaWFscycsICdib25lcycsICdtYXAnIF07XHJcblxyXG5jbGFzcyBDb21wb3NpdGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggdGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCApIHtcclxuXHJcblx0XHRjb25zdCBwYXJzZWRQYXRoID0gb3B0aW9uYWxQYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xyXG5cclxuXHRcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XHJcblx0XHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmJpbmQoKTsgLy8gYmluZCBhbGwgYmluZGluZ1xyXG5cclxuXHRcdGNvbnN0IGZpcnN0VmFsaWRJbmRleCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0YmluZGluZyA9IHRoaXMuX2JpbmRpbmdzWyBmaXJzdFZhbGlkSW5kZXggXTtcclxuXHJcblx0XHQvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcclxuXHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkgYmluZGluZy5nZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGJpbmQoKSB7XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1bmJpbmQoKSB7XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vLyBOb3RlOiBUaGlzIGNsYXNzIHVzZXMgYSBTdGF0ZSBwYXR0ZXJuIG9uIGEgcGVyLW1ldGhvZCBiYXNpczpcclxuLy8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcclxuLy8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcclxuLy8gdGhlIGJvdW5kIHN0YXRlLiBXaGVuIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHRoZSBtZXRob2RzXHJcbi8vIGJlY29tZSBuby1vcHMuXHJcbmNsYXNzIFByb3BlcnR5QmluZGluZyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcclxuXHJcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xyXG5cdFx0dGhpcy5wYXJzZWRQYXRoID0gcGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcclxuXHJcblx0XHR0aGlzLm5vZGUgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHJvb3ROb2RlLCB0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUgKTtcclxuXHJcblx0XHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XHJcblxyXG5cdFx0Ly8gaW5pdGlhbCBzdGF0ZSBvZiB0aGVzZSBtZXRob2RzIHRoYXQgY2FsbHMgJ2JpbmQnXHJcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcclxuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRzdGF0aWMgY3JlYXRlKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICkge1xyXG5cclxuXHRcdGlmICggISAoIHJvb3QgJiYgcm9vdC5pc0FuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZyggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVwbGFjZXMgc3BhY2VzIHdpdGggdW5kZXJzY29yZXMgYW5kIHJlbW92ZXMgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycyBmcm9tXHJcblx0ICogbm9kZSBuYW1lcywgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBwYXJzZVRyYWNrTmFtZSgpLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTm9kZSBuYW1lIHRvIGJlIHNhbml0aXplZC5cclxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0ICovXHJcblx0c3RhdGljIHNhbml0aXplTm9kZU5hbWUoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5hbWUucmVwbGFjZSggL1xccy9nLCAnXycgKS5yZXBsYWNlKCBfcmVzZXJ2ZWRSZSwgJycgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgcGFyc2VUcmFja05hbWUoIHRyYWNrTmFtZSApIHtcclxuXHJcblx0XHRjb25zdCBtYXRjaGVzID0gX3RyYWNrUmUuZXhlYyggdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0aWYgKCBtYXRjaGVzID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJlc3VsdHMgPSB7XHJcblx0XHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXHJcblx0XHRcdG5vZGVOYW1lOiBtYXRjaGVzWyAyIF0sXHJcblx0XHRcdG9iamVjdE5hbWU6IG1hdGNoZXNbIDMgXSxcclxuXHRcdFx0b2JqZWN0SW5kZXg6IG1hdGNoZXNbIDQgXSxcclxuXHRcdFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWyA1IF0sIC8vIHJlcXVpcmVkXHJcblx0XHRcdHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbIDYgXVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCAnLicgKTtcclxuXHJcblx0XHRpZiAoIGxhc3REb3QgIT09IHVuZGVmaW5lZCAmJiBsYXN0RG90ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBvYmplY3ROYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIGxhc3REb3QgKyAxICk7XHJcblxyXG5cdFx0XHQvLyBPYmplY3QgbmFtZXMgbXVzdCBiZSBjaGVja2VkIGFnYWluc3QgYW4gYWxsb3dsaXN0LiBPdGhlcndpc2UsIHRoZXJlXHJcblx0XHRcdC8vIGlzIG5vIHdheSB0byBwYXJzZSAnZm9vLmJhci5iYXonOiAnYmF6JyBtdXN0IGJlIGEgcHJvcGVydHksIGJ1dFxyXG5cdFx0XHQvLyAnYmFyJyBjb3VsZCBiZSB0aGUgb2JqZWN0TmFtZSwgb3IgcGFydCBvZiBhIG5vZGVOYW1lICh3aGljaCBjYW5cclxuXHRcdFx0Ly8gaW5jbHVkZSAnLicgY2hhcmFjdGVycykuXHJcblx0XHRcdGlmICggX3N1cHBvcnRlZE9iamVjdE5hbWVzLmluZGV4T2YoIG9iamVjdE5hbWUgKSAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIDAsIGxhc3REb3QgKTtcclxuXHRcdFx0XHRyZXN1bHRzLm9iamVjdE5hbWUgPSBvYmplY3ROYW1lO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlc3VsdHMucHJvcGVydHlOYW1lID09PSBudWxsIHx8IHJlc3VsdHMucHJvcGVydHlOYW1lLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6ICcgKyB0cmFja05hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdHM7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhdGljIGZpbmROb2RlKCByb290LCBub2RlTmFtZSApIHtcclxuXHJcblx0XHRpZiAoIG5vZGVOYW1lID09PSB1bmRlZmluZWQgfHwgbm9kZU5hbWUgPT09ICcnIHx8IG5vZGVOYW1lID09PSAnLicgfHwgbm9kZU5hbWUgPT09IC0gMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcm9vdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXHJcblx0XHRpZiAoIHJvb3Quc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0XHRjb25zdCBib25lID0gcm9vdC5za2VsZXRvbi5nZXRCb25lQnlOYW1lKCBub2RlTmFtZSApO1xyXG5cclxuXHRcdFx0aWYgKCBib25lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBib25lO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXHJcblx0XHRpZiAoIHJvb3QuY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uICggY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlblsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3Qgc3ViVHJlZU5vZGUgPSBzZWFyY2hOb2RlU3VidHJlZSggcm9vdC5jaGlsZHJlbiApO1xyXG5cclxuXHRcdFx0aWYgKCBzdWJUcmVlTm9kZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBcImJpbmRcIiBhIG5vbmV4aXN0ZW50IHByb3BlcnR5XHJcblx0X2dldFZhbHVlX3VuYXZhaWxhYmxlKCkge31cclxuXHRfc2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fVxyXG5cclxuXHQvLyBHZXR0ZXJzXHJcblxyXG5cdF9nZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGJ1ZmZlclsgb2Zmc2V0IF0gPSB0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VmFsdWVfdG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gRGlyZWN0XHJcblxyXG5cdF9zZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcclxuXHJcblx0fVxyXG5cclxuXHRfc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0X3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBFbnRpcmVBcnJheVxyXG5cclxuXHRfc2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0X3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBBcnJheUVsZW1lbnRcclxuXHJcblx0X3NldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblxyXG5cdH1cclxuXHJcblx0X3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0X3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcclxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEhhc1RvRnJvbUFycmF5XHJcblxyXG5cdF9zZXRWYWx1ZV9mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRfc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VmFsdWVfdW5ib3VuZCggdGFyZ2V0QXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmJpbmQoKTtcclxuXHRcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfc2V0VmFsdWVfdW5ib3VuZCggc291cmNlQXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmJpbmQoKTtcclxuXHRcdHRoaXMuc2V0VmFsdWUoIHNvdXJjZUFycmF5LCBvZmZzZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXHJcblx0YmluZCgpIHtcclxuXHJcblx0XHRsZXQgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlO1xyXG5cdFx0Y29uc3QgcGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aDtcclxuXHJcblx0XHRjb25zdCBvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lO1xyXG5cdFx0Y29uc3QgcHJvcGVydHlOYW1lID0gcGFyc2VkUGF0aC5wcm9wZXJ0eU5hbWU7XHJcblx0XHRsZXQgcHJvcGVydHlJbmRleCA9IHBhcnNlZFBhdGgucHJvcGVydHlJbmRleDtcclxuXHJcblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dGFyZ2V0T2JqZWN0ID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCB0aGlzLnJvb3ROb2RlLCBwYXJzZWRQYXRoLm5vZGVOYW1lICk7XHJcblxyXG5cdFx0XHR0aGlzLm5vZGUgPSB0YXJnZXRPYmplY3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXHJcblx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5hdmFpbGFibGU7XHJcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7XHJcblxyXG5cdFx0Ly8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxyXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6ICcgKyB0aGlzLnBhdGggKyAnIGJ1dCBpdCB3YXNuXFwndCBmb3VuZC4nICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3ROYW1lICkge1xyXG5cclxuXHRcdFx0bGV0IG9iamVjdEluZGV4ID0gcGFyc2VkUGF0aC5vYmplY3RJbmRleDtcclxuXHJcblx0XHRcdC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cclxuXHRcdFx0c3dpdGNoICggb2JqZWN0TmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWxzJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXRlcmlhbHMgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWxzIGFycmF5LicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdib25lcyc6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5za2VsZXRvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4nLCB0aGlzICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxyXG5cdFx0XHRcdFx0Ly8gYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxyXG5cclxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcclxuXHJcblx0XHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIGkgXS5uYW1lID09PSBvYmplY3RJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0SW5kZXggPSBpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbWFwJzpcclxuXHJcblx0XHRcdFx0XHRpZiAoICdtYXAnIGluIHRhcmdldE9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5tYXA7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsLicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbC5tYXAgYXMgbm9kZS5tYXRlcmlhbCBkb2VzIG5vdCBoYXZlIGEgbWFwLicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWFwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG9iamVjdE5hbWUgb2Ygbm9kZSB1bmRlZmluZWQuJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGlmICggb2JqZWN0SW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzb2x2ZSBwcm9wZXJ0eVxyXG5cdFx0Y29uc3Qgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRpZiAoIG5vZGVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9kZU5hbWUgPSBwYXJzZWRQYXRoLm5vZGVOYW1lO1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArXHJcblx0XHRcdFx0Jy4nICsgcHJvcGVydHlOYW1lICsgJyBidXQgaXQgd2FzblxcJ3QgZm91bmQuJywgdGFyZ2V0T2JqZWN0ICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXHJcblx0XHRsZXQgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5Ob25lO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdGlmICggdGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG1hdGVyaWFsXHJcblxyXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXHJcblxyXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcclxuXHRcdGxldCBiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuRGlyZWN0O1xyXG5cclxuXHRcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXHJcblxyXG5cdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHBvdGVudGlhbCBvcHRpbWl6YXRpb24sIHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxyXG5cclxuXHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXHJcblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkuJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgcHJvcGVydHlJbmRleCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cHJvcGVydHlJbmRleCA9IHRhcmdldE9iamVjdC5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHByb3BlcnR5SW5kZXggXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkFycmF5RWxlbWVudDtcclxuXHJcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcclxuXHRcdFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cclxuXHJcblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcclxuXHJcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBub2RlUHJvcGVydHkgKSApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcclxuXHJcblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNlbGVjdCBnZXR0ZXIgLyBzZXR0ZXJcclxuXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XHJcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1sgYmluZGluZ1R5cGUgXVsgdmVyc2lvbmluZyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdHVuYmluZCgpIHtcclxuXHJcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xyXG5cclxuXHRcdC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcclxuXHRcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XHJcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5ib3VuZDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSA9IENvbXBvc2l0ZTtcclxuXHJcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuQmluZGluZ1R5cGUgPSB7XHJcblx0RGlyZWN0OiAwLFxyXG5cdEVudGlyZUFycmF5OiAxLFxyXG5cdEFycmF5RWxlbWVudDogMixcclxuXHRIYXNGcm9tVG9BcnJheTogM1xyXG59O1xyXG5cclxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5WZXJzaW9uaW5nID0ge1xyXG5cdE5vbmU6IDAsXHJcblx0TmVlZHNVcGRhdGU6IDEsXHJcblx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxyXG59O1xyXG5cclxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5HZXR0ZXJCeUJpbmRpbmdUeXBlID0gW1xyXG5cclxuXHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9kaXJlY3QsXHJcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXksXHJcblx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fZ2V0VmFsdWVfYXJyYXlFbGVtZW50LFxyXG5cdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX3RvQXJyYXksXHJcblxyXG5dO1xyXG5cclxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZyA9IFtcclxuXHJcblx0W1xyXG5cdFx0Ly8gRGlyZWN0XHJcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3QsXHJcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUsXHJcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSxcclxuXHJcblx0XSwgW1xyXG5cclxuXHRcdC8vIEVudGlyZUFycmF5XHJcblxyXG5cdFx0UHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXksXHJcblx0XHRQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSxcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUsXHJcblxyXG5cdF0sIFtcclxuXHJcblx0XHQvLyBBcnJheUVsZW1lbnRcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudCxcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSxcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlLFxyXG5cclxuXHRdLCBbXHJcblxyXG5cdFx0Ly8gSGFzVG9Gcm9tQXJyYXlcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheSxcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSxcclxuXHRcdFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlLFxyXG5cclxuXHRdXHJcblxyXG5dO1xyXG5cclxuXHJcbmV4cG9ydCB7IFByb3BlcnR5QmluZGluZyB9O1xyXG4iLCJpbXBvcnQgeyBQcm9wZXJ0eUJpbmRpbmcgfSBmcm9tICcuL1Byb3BlcnR5QmluZGluZy5qcyc7XHJcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcblxyXG4vKipcclxuICpcclxuICogQSBncm91cCBvZiBvYmplY3RzIHRoYXQgcmVjZWl2ZXMgYSBzaGFyZWQgYW5pbWF0aW9uIHN0YXRlLlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICpcclxuICogIC0gQWRkIG9iamVjdHMgeW91IHdvdWxkIG90aGVyd2lzZSBwYXNzIGFzICdyb290JyB0byB0aGVcclxuICogICAgY29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cclxuICpcclxuICogIC0gSW5zdGVhZCBwYXNzIHRoaXMgb2JqZWN0IGFzICdyb290Jy5cclxuICpcclxuICogIC0gWW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcclxuICogICAgaXMgcnVubmluZy5cclxuICpcclxuICogTm90ZTpcclxuICpcclxuICogICAgT2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcclxuICogICAgc28gY2FjaGUgY29udHJvbCBvZiB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG11c3QgYmUgZG9uZVxyXG4gKiAgICBvbiB0aGUgZ3JvdXAuXHJcbiAqXHJcbiAqIExpbWl0YXRpb246XHJcbiAqXHJcbiAqICAtIFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcclxuICogICAgYWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxyXG4gKlxyXG4gKiAgLSBBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXHJcbiAqICAgIHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxyXG4gKi9cclxuXHJcbmNsYXNzIEFuaW1hdGlvbk9iamVjdEdyb3VwIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy5pc0FuaW1hdGlvbk9iamVjdEdyb3VwID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdFx0Ly8gY2FjaGVkIG9iamVjdHMgZm9sbG93ZWQgYnkgdGhlIGFjdGl2ZSBvbmVzXHJcblx0XHR0aGlzLl9vYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDsgLy8gdGhyZXNob2xkXHJcblx0XHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0ge307XHJcblx0XHR0aGlzLl9pbmRpY2VzQnlVVUlEID0gaW5kaWNlczsgLy8gZm9yIGJvb2trZWVwaW5nXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGluZGljZXNbIGFyZ3VtZW50c1sgaSBdLnV1aWQgXSA9IGk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BhdGhzID0gW107IC8vIGluc2lkZTogc3RyaW5nXHJcblx0XHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdOyAvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XHJcblx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxyXG5cdFx0dGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoID0ge307IC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dGhpcy5zdGF0cyA9IHtcclxuXHJcblx0XHRcdG9iamVjdHM6IHtcclxuXHRcdFx0XHRnZXQgdG90YWwoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZCgpIHtcclxuXHJcblx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdHBhdGhzID0gdGhpcy5fcGF0aHMsXHJcblx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXHJcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRsZXQga25vd25PYmplY3QgPSB1bmRlZmluZWQsXHJcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXHJcblx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxyXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZDtcclxuXHRcdFx0bGV0IGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyB1bmtub3duIG9iamVjdCAtPiBhZGQgaXQgdG8gdGhlIEFDVElWRSByZWdpb25cclxuXHJcblx0XHRcdFx0aW5kZXggPSBuT2JqZWN0cyArKztcclxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRiaW5kaW5nc1sgaiBdLnB1c2goIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRcdGtub3duT2JqZWN0ID0gb2JqZWN0c1sgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cclxuXHJcblx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxyXG5cdFx0XHRcdFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcclxuXHJcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcclxuXHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRsZXQgYmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYmluZGluZyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXHJcblx0XHRcdFx0XHRcdC8vIGZvciBvYmplY3RzIHRoYXQgYXJlIGNhY2hlZCwgdGhlIGJpbmRpbmcgbWF5XHJcblx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3RcclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwOiBEaWZmZXJlbnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIFVVSUQgJyArXHJcblx0XHRcdFx0XHQnZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBpbmZyYXN0cnVjdHVyZSB3aGVuIHJlbG9hZGluZyBzY2VuZXMuJyApO1xyXG5cclxuXHRcdFx0fSAvLyBlbHNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSB3aGVyZSB3ZSB3YW50IGl0IHRvIGJlXHJcblxyXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXHJcblxyXG5cdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcclxuXHJcblx0fVxyXG5cclxuXHRyZW1vdmUoKSB7XHJcblxyXG5cdFx0Y29uc3Qgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXHJcblx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxyXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0bGV0IG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdGNvbnN0IG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxyXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcclxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxyXG5cclxuXHRcdFx0XHRjb25zdCBsYXN0Q2FjaGVkSW5kZXggPSBuQ2FjaGVkT2JqZWN0cyArKyxcclxuXHRcdFx0XHRcdGZpcnN0QWN0aXZlT2JqZWN0ID0gb2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF07XHJcblxyXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIGZpcnN0QWN0aXZlT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcclxuXHJcblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gbGFzdENhY2hlZEluZGV4O1xyXG5cdFx0XHRcdG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxyXG5cdFx0XHRcdFx0XHRmaXJzdEFjdGl2ZSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0sXHJcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gZmlyc3RBY3RpdmU7XHJcblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdID0gYmluZGluZztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xyXG5cclxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gcmVtb3ZlICYgZm9yZ2V0XHJcblx0dW5jYWNoZSgpIHtcclxuXHJcblx0XHRjb25zdCBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRsZXQgbkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXHJcblx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxyXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGNhY2hlZCwgc2hyaW5rIHRoZSBDQUNIRUQgcmVnaW9uXHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxyXG5cdFx0XHRcdFx0XHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcclxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGxhc3QgY2FjaGVkIG9iamVjdCB0YWtlcyB0aGlzIG9iamVjdCdzIHBsYWNlXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbGFzdCBvYmplY3QgZ29lcyB0byB0aGUgYWN0aXZhdGVkIHNsb3QgYW5kIHBvcFxyXG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xyXG5cdFx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdE9iamVjdDtcclxuXHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRcdGxhc3QgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0O1xyXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcclxuXHJcblx0XHRcdFx0XHRjb25zdCBsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcclxuXHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGFzdEluZGV4ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0T2JqZWN0O1xyXG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gLy8gY2FjaGVkIG9yIGFjdGl2ZVxyXG5cclxuXHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cclxuXHJcblx0XHR9IC8vIGZvciBhcmd1bWVudHNcclxuXHJcblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEludGVybmFsIGludGVyZmFjZSB1c2VkIGJ5IGJlZnJpZW5kZWQgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZTpcclxuXHJcblx0c3Vic2NyaWJlXyggcGF0aCwgcGFyc2VkUGF0aCApIHtcclxuXHJcblx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcclxuXHRcdC8vIGFjY29yZGluZyB0byB0aGUgY29udGFpbmVkIG9iamVjdHMgaW4gdGhlIGdyb3VwXHJcblxyXG5cdFx0Y29uc3QgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aDtcclxuXHRcdGxldCBpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXTtcclxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGJpbmRpbmdzWyBpbmRleCBdO1xyXG5cclxuXHRcdGNvbnN0IHBhdGhzID0gdGhpcy5fcGF0aHMsXHJcblx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXHJcblx0XHRcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxyXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxyXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxyXG5cdFx0XHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkoIG5PYmplY3RzICk7XHJcblxyXG5cdFx0aW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XHJcblxyXG5cdFx0cGF0aHMucHVzaCggcGF0aCApO1xyXG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xyXG5cdFx0YmluZGluZ3MucHVzaCggYmluZGluZ3NGb3JQYXRoICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xyXG5cdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGkgXSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYmluZGluZ3NGb3JQYXRoO1xyXG5cclxuXHR9XHJcblxyXG5cdHVuc3Vic2NyaWJlXyggcGF0aCApIHtcclxuXHJcblx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXHJcblx0XHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxyXG5cdFx0XHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwYXRocyA9IHRoaXMuX3BhdGhzLFxyXG5cdFx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXHJcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXHJcblx0XHRcdFx0bGFzdEJpbmRpbmdzID0gYmluZGluZ3NbIGxhc3RCaW5kaW5nc0luZGV4IF0sXHJcblx0XHRcdFx0bGFzdEJpbmRpbmdzUGF0aCA9IHBhdGhbIGxhc3RCaW5kaW5nc0luZGV4IF07XHJcblxyXG5cdFx0XHRpbmRpY2VzQnlQYXRoWyBsYXN0QmluZGluZ3NQYXRoIF0gPSBpbmRleDtcclxuXHJcblx0XHRcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xyXG5cdFx0XHRiaW5kaW5ncy5wb3AoKTtcclxuXHJcblx0XHRcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XHJcblx0XHRcdHBhcnNlZFBhdGhzLnBvcCgpO1xyXG5cclxuXHRcdFx0cGF0aHNbIGluZGV4IF0gPSBwYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcclxuXHRcdFx0cGF0aHMucG9wKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBBbmltYXRpb25PYmplY3RHcm91cCB9O1xyXG4iLCJpbXBvcnQgeyBXcmFwQXJvdW5kRW5kaW5nLCBaZXJvQ3VydmF0dXJlRW5kaW5nLCBaZXJvU2xvcGVFbmRpbmcsIExvb3BQaW5nUG9uZywgTG9vcE9uY2UsIExvb3BSZXBlYXQsIE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSwgQWRkaXRpdmVBbmltYXRpb25CbGVuZE1vZGUgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5cclxuXHJcbmNsYXNzIEFuaW1hdGlvbkFjdGlvbiB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtaXhlciwgY2xpcCwgbG9jYWxSb290ID0gbnVsbCwgYmxlbmRNb2RlID0gY2xpcC5ibGVuZE1vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcclxuXHRcdHRoaXMuX2NsaXAgPSBjbGlwO1xyXG5cdFx0dGhpcy5fbG9jYWxSb290ID0gbG9jYWxSb290O1xyXG5cdFx0dGhpcy5ibGVuZE1vZGUgPSBibGVuZE1vZGU7XHJcblxyXG5cdFx0Y29uc3QgdHJhY2tzID0gY2xpcC50cmFja3MsXHJcblx0XHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxyXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcclxuXHJcblx0XHRjb25zdCBpbnRlcnBvbGFudFNldHRpbmdzID0ge1xyXG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcclxuXHRcdFx0ZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdHJhY2tzWyBpIF0uY3JlYXRlSW50ZXJwb2xhbnQoIG51bGwgKTtcclxuXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0gPSBpbnRlcnBvbGFudDtcclxuXHRcdFx0aW50ZXJwb2xhbnQuc2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcclxuXHJcblx0XHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7IC8vIGJvdW5kIGJ5IHRoZSBtaXhlclxyXG5cclxuXHRcdC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXHJcblx0XHR0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XHJcblxyXG5cdFx0dGhpcy5fY2FjaGVJbmRleCA9IG51bGw7IC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcclxuXHRcdHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXHJcblxyXG5cdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cdFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMubG9vcCA9IExvb3BSZXBlYXQ7XHJcblx0XHR0aGlzLl9sb29wQ291bnQgPSAtIDE7XHJcblxyXG5cdFx0Ly8gZ2xvYmFsIG1peGVyIHRpbWUgd2hlbiB0aGUgYWN0aW9uIGlzIHRvIGJlIHN0YXJ0ZWRcclxuXHRcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxyXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcclxuXHJcblx0XHQvLyBzY2FsZWQgbG9jYWwgdGltZSBvZiB0aGUgYWN0aW9uXHJcblx0XHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXHJcblx0XHR0aGlzLnRpbWUgPSAwO1xyXG5cclxuXHRcdHRoaXMudGltZVNjYWxlID0gMTtcclxuXHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XHJcblxyXG5cdFx0dGhpcy53ZWlnaHQgPSAxO1xyXG5cdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gMTtcclxuXHJcblx0XHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IC8vIG5vLiBvZiByZXBldGl0aW9ucyB3aGVuIGxvb3BpbmdcclxuXHJcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlOyAvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcclxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7IC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxyXG5cclxuXHRcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgPSBmYWxzZTsvLyBrZWVwIGZlZWRpbmcgdGhlIGxhc3QgZnJhbWU/XHJcblxyXG5cdFx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID0gdHJ1ZTsvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXHJcblx0XHR0aGlzLnplcm9TbG9wZUF0RW5kID0gdHJ1ZTsvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxyXG5cclxuXHR9XHJcblxyXG5cdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xyXG5cclxuXHRwbGF5KCkge1xyXG5cclxuXHRcdHRoaXMuX21peGVyLl9hY3RpdmF0ZUFjdGlvbiggdGhpcyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHN0b3AoKSB7XHJcblxyXG5cdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlc2V0KCkge1xyXG5cclxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudGltZSA9IDA7IC8vIHJlc3RhcnQgY2xpcFxyXG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLSAxOy8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xyXG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDsvLyBmb3JnZXQgc2NoZWR1bGluZ1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGlzUnVubmluZygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcclxuXHRcdFx0dGhpcy5fc3RhcnRUaW1lID09PSBudWxsICYmIHRoaXMuX21peGVyLl9pc0FjdGl2ZUFjdGlvbiggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcclxuXHRpc1NjaGVkdWxlZCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RhcnRBdCggdGltZSApIHtcclxuXHJcblx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldExvb3AoIG1vZGUsIHJlcGV0aXRpb25zICkge1xyXG5cclxuXHRcdHRoaXMubG9vcCA9IG1vZGU7XHJcblx0XHR0aGlzLnJlcGV0aXRpb25zID0gcmVwZXRpdGlvbnM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gV2VpZ2h0XHJcblxyXG5cdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXHJcblx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXHJcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xyXG5cdHNldEVmZmVjdGl2ZVdlaWdodCggd2VpZ2h0ICkge1xyXG5cclxuXHRcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xyXG5cclxuXHRcdC8vIG5vdGU6IHNhbWUgbG9naWMgYXMgd2hlbiB1cGRhdGVkIGF0IHJ1bnRpbWVcclxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHJldHVybiB0aGUgd2VpZ2h0IGNvbnNpZGVyaW5nIGZhZGluZyBhbmQgLmVuYWJsZWRcclxuXHRnZXRFZmZlY3RpdmVXZWlnaHQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcclxuXHJcblx0fVxyXG5cclxuXHRmYWRlSW4oIGR1cmF0aW9uICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDAsIDEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmYWRlT3V0KCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3Jvc3NGYWRlRnJvbSggZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG5cdFx0ZmFkZU91dEFjdGlvbi5mYWRlT3V0KCBkdXJhdGlvbiApO1xyXG5cdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0aWYgKCB3YXJwICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZmFkZUluRHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxyXG5cdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXHJcblxyXG5cdFx0XHRcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcclxuXHRcdFx0XHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XHJcblxyXG5cdFx0XHRmYWRlT3V0QWN0aW9uLndhcnAoIDEuMCwgc3RhcnRFbmRSYXRpbywgZHVyYXRpb24gKTtcclxuXHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyb3NzRmFkZVRvKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xyXG5cclxuXHRcdHJldHVybiBmYWRlSW5BY3Rpb24uY3Jvc3NGYWRlRnJvbSggdGhpcywgZHVyYXRpb24sIHdhcnAgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzdG9wRmFkaW5nKCkge1xyXG5cclxuXHRcdGNvbnN0IHdlaWdodEludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcclxuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB3ZWlnaHRJbnRlcnBvbGFudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcclxuXHJcblx0Ly8gc2V0IHRoZSB0aW1lIHNjYWxlIHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgd2FycGluZ1xyXG5cdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXHJcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXHJcblx0c2V0RWZmZWN0aXZlVGltZVNjYWxlKCB0aW1lU2NhbGUgKSB7XHJcblxyXG5cdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOiB0aW1lU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxyXG5cdGdldEVmZmVjdGl2ZVRpbWVTY2FsZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldER1cmF0aW9uKCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHR9XHJcblxyXG5cdHN5bmNXaXRoKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XHJcblx0XHR0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcclxuXHJcblx0fVxyXG5cclxuXHRoYWx0KCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0d2FycCggc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgbWl4ZXIgPSB0aGlzLl9taXhlcixcclxuXHRcdFx0bm93ID0gbWl4ZXIudGltZSxcclxuXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG5cdFx0bGV0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcclxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXHJcblx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcclxuXHJcblx0XHR0aW1lc1sgMCBdID0gbm93O1xyXG5cdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1xyXG5cclxuXHRcdHZhbHVlc1sgMCBdID0gc3RhcnRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XHJcblx0XHR2YWx1ZXNbIDEgXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzdG9wV2FycGluZygpIHtcclxuXHJcblx0XHRjb25zdCB0aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xyXG5cclxuXHRcdGlmICggdGltZVNjYWxlSW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XHJcblx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggdGltZVNjYWxlSW50ZXJwb2xhbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gT2JqZWN0IEFjY2Vzc29yc1xyXG5cclxuXHRnZXRNaXhlcigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXI7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2xpcCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRSb290KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gSW50ZXJuYVxyXG5cclxuXHRfdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcclxuXHJcblx0XHQvLyBjYWxsZWQgYnkgdGhlIG1peGVyXHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdC8vIGNhbGwgLl91cGRhdGVXZWlnaHQoKSB0byB1cGRhdGUgLl9lZmZlY3RpdmVXZWlnaHRcclxuXHJcblx0XHRcdHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcclxuXHJcblx0XHRpZiAoIHN0YXJ0VGltZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIGNoZWNrIGZvciBzY2hlZHVsZWQgc3RhcnQgb2YgYWN0aW9uXHJcblxyXG5cdFx0XHRjb25zdCB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcclxuXHRcdFx0aWYgKCB0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0ZGVsdGFUaW1lID0gMDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cclxuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXHJcblx0XHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcclxuXHJcblx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XHJcblx0XHRjb25zdCBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoIGRlbHRhVGltZSApO1xyXG5cclxuXHRcdC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXHJcblx0XHQvLyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIDBcclxuXHJcblx0XHRjb25zdCB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcclxuXHJcblx0XHRpZiAoIHdlaWdodCA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XHJcblx0XHRcdGNvbnN0IHByb3BlcnR5TWl4ZXJzID0gdGhpcy5fcHJvcGVydHlCaW5kaW5ncztcclxuXHJcblx0XHRcdHN3aXRjaCAoIHRoaXMuYmxlbmRNb2RlICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlOlxyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcclxuXHRcdFx0XHRcdFx0cHJvcGVydHlNaXhlcnNbIGogXS5hY2N1bXVsYXRlQWRkaXRpdmUoIHdlaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGU6XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XHJcblx0XHRcdFx0XHRcdHByb3BlcnR5TWl4ZXJzWyBqIF0uYWNjdW11bGF0ZSggYWNjdUluZGV4LCB3ZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF91cGRhdGVXZWlnaHQoIHRpbWUgKSB7XHJcblxyXG5cdFx0bGV0IHdlaWdodCA9IDA7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHR3ZWlnaHQgPSB0aGlzLndlaWdodDtcclxuXHRcdFx0Y29uc3QgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XHJcblxyXG5cdFx0XHRcdHdlaWdodCAqPSBpbnRlcnBvbGFudFZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnN0b3BGYWRpbmcoKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGludGVycG9sYW50VmFsdWUgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcclxuXHRcdFx0XHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHdlaWdodDtcclxuXHRcdHJldHVybiB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcblx0X3VwZGF0ZVRpbWVTY2FsZSggdGltZSApIHtcclxuXHJcblx0XHRsZXQgdGltZVNjYWxlID0gMDtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5wYXVzZWQgKSB7XHJcblxyXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0XHRcdGNvbnN0IGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0XHRpZiAoIGludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xyXG5cclxuXHRcdFx0XHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGltZVNjYWxlID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gbW90aW9uIGhhcyBoYWx0ZWQsIHBhdXNlXHJcblx0XHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gd2FycCBkb25lIC0gYXBwbHkgZmluYWwgdGltZSBzY2FsZVxyXG5cdFx0XHRcdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xyXG5cdFx0cmV0dXJuIHRpbWVTY2FsZTtcclxuXHJcblx0fVxyXG5cclxuXHRfdXBkYXRlVGltZSggZGVsdGFUaW1lICkge1xyXG5cclxuXHRcdGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbjtcclxuXHRcdGNvbnN0IGxvb3AgPSB0aGlzLmxvb3A7XHJcblxyXG5cdFx0bGV0IHRpbWUgPSB0aGlzLnRpbWUgKyBkZWx0YVRpbWU7XHJcblx0XHRsZXQgbG9vcENvdW50ID0gdGhpcy5fbG9vcENvdW50O1xyXG5cclxuXHRcdGNvbnN0IHBpbmdQb25nID0gKCBsb29wID09PSBMb29wUGluZ1BvbmcgKTtcclxuXHJcblx0XHRpZiAoIGRlbHRhVGltZSA9PT0gMCApIHtcclxuXHJcblx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSByZXR1cm4gdGltZTtcclxuXHJcblx0XHRcdHJldHVybiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGxvb3AgPT09IExvb3BPbmNlICkge1xyXG5cclxuXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXHJcblxyXG5cdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IDA7XHJcblx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGhhbmRsZV9zdG9wOiB7XHJcblxyXG5cdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lID0gZHVyYXRpb247XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRpbWUgPSAwO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWsgaGFuZGxlX3N0b3A7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdGVsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XHJcblxyXG5cdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcclxuXHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcclxuXHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0gMSA6IDFcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHsgLy8gcmVwZXRpdGl2ZSBSZXBlYXQgb3IgUGluZ1BvbmdcclxuXHJcblx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxyXG5cclxuXHRcdFx0XHRpZiAoIGRlbHRhVGltZSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGxvb3BDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXHJcblx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxyXG5cdFx0XHRcdFx0Ly8gc28gbGVhdmUgbG9vcENvdW50IGF0IC0xXHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB3cmFwIGFyb3VuZFxyXG5cclxuXHRcdFx0XHRjb25zdCBsb29wRGVsdGEgPSBNYXRoLmZsb29yKCB0aW1lIC8gZHVyYXRpb24gKTsgLy8gc2lnbmVkXHJcblx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcclxuXHJcblx0XHRcdFx0bG9vcENvdW50ICs9IE1hdGguYWJzKCBsb29wRGVsdGEgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XHJcblxyXG5cdFx0XHRcdGlmICggcGVuZGluZyA8PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGhhdmUgdG8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxyXG5cclxuXHRcdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGVsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy50aW1lID0gdGltZTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcclxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPiAwID8gMSA6IC0gMVxyXG5cdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIGtlZXAgcnVubmluZ1xyXG5cclxuXHRcdFx0XHRcdGlmICggcGVuZGluZyA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGVudGVyaW5nIHRoZSBsYXN0IHJvdW5kXHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcclxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggYXRTdGFydCwgISBhdFN0YXJ0LCBwaW5nUG9uZyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCBmYWxzZSwgZmFsc2UsIHBpbmdQb25nICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcclxuXHRcdFx0XHRcdFx0dHlwZTogJ2xvb3AnLCBhY3Rpb246IHRoaXMsIGxvb3BEZWx0YTogbG9vcERlbHRhXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudGltZSA9IHRpbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXHJcblxyXG5cdFx0XHRcdHJldHVybiBkdXJhdGlvbiAtIHRpbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdF9zZXRFbmRpbmdzKCBhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHRcdGlmICggcGluZ1BvbmcgKSB7XHJcblxyXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFplcm9TbG9wZUVuZGluZztcclxuXHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gWmVyb1Nsb3BlRW5kaW5nO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBhc3N1bWluZyBmb3IgTG9vcE9uY2UgYXRTdGFydCA9PSBhdEVuZCA9PSB0cnVlXHJcblxyXG5cdFx0XHRpZiAoIGF0U3RhcnQgKSB7XHJcblxyXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gV3JhcEFyb3VuZEVuZGluZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYXRFbmQgKSB7XHJcblxyXG5cdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCA9IHRoaXMuemVyb1Nsb3BlQXRFbmQgPyBaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kIFx0ID0gV3JhcEFyb3VuZEVuZGluZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0X3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgd2VpZ2h0Tm93LCB3ZWlnaHRUaGVuICkge1xyXG5cclxuXHRcdGNvbnN0IG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWU7XHJcblx0XHRsZXQgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xyXG5cdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcclxuXHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xyXG5cclxuXHRcdHRpbWVzWyAwIF0gPSBub3c7XHJcblx0XHR2YWx1ZXNbIDAgXSA9IHdlaWdodE5vdztcclxuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcclxuXHRcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IEFuaW1hdGlvbkFjdGlvbiB9O1xyXG4iLCJpbXBvcnQgeyBBbmltYXRpb25BY3Rpb24gfSBmcm9tICcuL0FuaW1hdGlvbkFjdGlvbi5qcyc7XHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcclxuaW1wb3J0IHsgTGluZWFySW50ZXJwb2xhbnQgfSBmcm9tICcuLi9tYXRoL2ludGVycG9sYW50cy9MaW5lYXJJbnRlcnBvbGFudC5qcyc7XHJcbmltcG9ydCB7IFByb3BlcnR5QmluZGluZyB9IGZyb20gJy4vUHJvcGVydHlCaW5kaW5nLmpzJztcclxuaW1wb3J0IHsgUHJvcGVydHlNaXhlciB9IGZyb20gJy4vUHJvcGVydHlNaXhlci5qcyc7XHJcbmltcG9ydCB7IEFuaW1hdGlvbkNsaXAgfSBmcm9tICcuL0FuaW1hdGlvbkNsaXAuanMnO1xyXG5pbXBvcnQgeyBOb3JtYWxBbmltYXRpb25CbGVuZE1vZGUgfSBmcm9tICcuLi9jb25zdGFudHMuanMnO1xyXG5cclxuXHJcbmNvbnN0IF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheSggMSApO1xyXG5cclxuXHJcbmNsYXNzIEFuaW1hdGlvbk1peGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJvb3QgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLl9yb290ID0gcm9vdDtcclxuXHRcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XHJcblx0XHR0aGlzLl9hY2N1SW5kZXggPSAwO1xyXG5cdFx0dGhpcy50aW1lID0gMDtcclxuXHRcdHRoaXMudGltZVNjYWxlID0gMS4wO1xyXG5cclxuXHR9XHJcblxyXG5cdF9iaW5kQWN0aW9uKCBhY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApIHtcclxuXHJcblx0XHRjb25zdCByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcclxuXHRcdFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcclxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXHJcblx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxyXG5cdFx0XHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcclxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXHJcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lO1xyXG5cclxuXHRcdGxldCBiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdGlmICggYmluZGluZ3NCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJpbmRpbmdzQnlOYW1lID0ge307XHJcblx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRyYWNrID0gdHJhY2tzWyBpIF0sXHJcblx0XHRcdFx0dHJhY2tOYW1lID0gdHJhY2submFtZTtcclxuXHJcblx0XHRcdGxldCBiaW5kaW5nID0gYmluZGluZ3NCeU5hbWVbIHRyYWNrTmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XHJcblx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZXhpc3RpbmcgYmluZGluZywgbWFrZSBzdXJlIHRoZSBjYWNoZSBrbm93c1xyXG5cclxuXHRcdFx0XHRcdGlmICggYmluZGluZy5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cclxuXHRcdFx0XHRcdF9wcm9wZXJ0eUJpbmRpbmdzWyBpIF0uYmluZGluZy5wYXJzZWRQYXRoO1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nID0gbmV3IFByb3BlcnR5TWl4ZXIoXHJcblx0XHRcdFx0XHRQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlKCByb290LCB0cmFja05hbWUsIHBhdGggKSxcclxuXHRcdFx0XHRcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XHJcblxyXG5cdFx0XHRcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XHJcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9hY3RpdmF0ZUFjdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdGlmICggISB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbi5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXHJcblx0XHRcdFx0Ly8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcclxuXHJcblx0XHRcdFx0Y29uc3Qgcm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkLFxyXG5cdFx0XHRcdFx0Y2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcclxuXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxyXG5cdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF0gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcclxuXHJcblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBiaW5kaW5nLnVzZUNvdW50ICsrID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX2xlbmRCaW5kaW5nKCBiaW5kaW5nICk7XHJcblx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XHJcblxyXG5cdFx0XHQvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggLS0gYmluZGluZy51c2VDb3VudCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XHJcblx0XHRcdFx0XHR0aGlzLl90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBNZW1vcnkgbWFuYWdlclxyXG5cclxuXHRfaW5pdE1lbW9yeU1hbmFnZXIoKSB7XHJcblxyXG5cdFx0dGhpcy5fYWN0aW9ucyA9IFtdOyAvLyAnbkFjdGl2ZUFjdGlvbnMnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcclxuXHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcclxuXHJcblx0XHR0aGlzLl9hY3Rpb25zQnlDbGlwID0ge307XHJcblx0XHQvLyBpbnNpZGU6XHJcblx0XHQvLyB7XHJcblx0XHQvLyBcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+IC0gdXNlZCBhcyBwcm90b3R5cGVzXHJcblx0XHQvLyBcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uIC0gbG9va3VwXHJcblx0XHQvLyB9XHJcblxyXG5cclxuXHRcdHRoaXMuX2JpbmRpbmdzID0gW107IC8vICduQWN0aXZlQmluZGluZ3MnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcclxuXHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XHJcblxyXG5cdFx0dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lID0ge307IC8vIGluc2lkZTogTWFwPCBuYW1lLCBQcm9wZXJ0eU1peGVyID5cclxuXHJcblxyXG5cdFx0dGhpcy5fY29udHJvbEludGVycG9sYW50cyA9IFtdOyAvLyBzYW1lIGdhbWUgYXMgYWJvdmVcclxuXHRcdHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcclxuXHJcblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dGhpcy5zdGF0cyA9IHtcclxuXHJcblx0XHRcdGFjdGlvbnM6IHtcclxuXHRcdFx0XHRnZXQgdG90YWwoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQWN0aW9ucztcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRiaW5kaW5nczoge1xyXG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQmluZGluZ3M7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xyXG5cdFx0XHRcdGdldCB0b3RhbCgpIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGdldCBpblVzZSgpIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBBbmltYXRpb25BY3Rpb24gb2JqZWN0c1xyXG5cclxuXHRfaXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHRjb25zdCBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcclxuXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xyXG5cclxuXHR9XHJcblxyXG5cdF9hZGRJbmFjdGl2ZUFjdGlvbiggYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKSB7XHJcblxyXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xyXG5cclxuXHRcdGxldCBhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XHJcblxyXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XHJcblxyXG5cdFx0XHRcdGtub3duQWN0aW9uczogWyBhY3Rpb24gXSxcclxuXHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcclxuXHJcblx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0gPSBhY3Rpb25zRm9yQ2xpcDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3Qga25vd25BY3Rpb25zID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xyXG5cclxuXHRcdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0ga25vd25BY3Rpb25zLmxlbmd0aDtcclxuXHRcdFx0a25vd25BY3Rpb25zLnB1c2goIGFjdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcclxuXHRcdGFjdGlvbnMucHVzaCggYWN0aW9uICk7XHJcblxyXG5cdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBhY3Rpb25zLmxlbmd0aCAtIDEgXSxcclxuXHRcdFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcclxuXHJcblx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xyXG5cdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xyXG5cdFx0YWN0aW9ucy5wb3AoKTtcclxuXHJcblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xyXG5cclxuXHJcblx0XHRjb25zdCBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxyXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLFxyXG5cdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zLFxyXG5cclxuXHRcdFx0bGFzdEtub3duQWN0aW9uID1cclxuXHRcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCAtIDEgXSxcclxuXHJcblx0XHRcdGJ5Q2xpcENhY2hlSW5kZXggPSBhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXg7XHJcblxyXG5cdFx0bGFzdEtub3duQWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gYnlDbGlwQ2FjaGVJbmRleDtcclxuXHRcdGtub3duQWN0aW9uc0ZvckNsaXBbIGJ5Q2xpcENhY2hlSW5kZXggXSA9IGxhc3RLbm93bkFjdGlvbjtcclxuXHRcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XHJcblxyXG5cdFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcclxuXHJcblxyXG5cdFx0Y29uc3QgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxyXG5cdFx0XHRyb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQ7XHJcblxyXG5cdFx0ZGVsZXRlIGFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHRpZiAoIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIC0tIGJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfbGVuZEFjdGlvbiggYWN0aW9uICkge1xyXG5cclxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgPnwgaW5hY3RpdmUgYWN0aW9ucyBdXHJcblx0XHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxyXG5cdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxyXG5cdFx0Ly8gICAgICAgICAgICAgICAgIGEgICAgICAgIHNcclxuXHJcblx0XHRjb25zdCBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcclxuXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxyXG5cclxuXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMgKyssXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0YWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBhY3Rpb247XHJcblxyXG5cdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcclxuXHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRfdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApIHtcclxuXHJcblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cclxuXHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0Ly8gICAgICAgIGEgICAgICAgIHNcclxuXHRcdC8vICAgICAgICAgPC1zd2FwLT5cclxuXHRcdC8vICAgICAgICBzICAgICAgICBhXHJcblxyXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cclxuXHRcdFx0bGFzdEFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcclxuXHRcdGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYWN0aW9uO1xyXG5cclxuXHRcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVBY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIFByb3BlcnR5TWl4ZXIgb2JqZWN0c1xyXG5cclxuXHRfYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxyXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xyXG5cclxuXHRcdGxldCBiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XHJcblxyXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0ge307XHJcblx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ0J5TmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBiaW5kaW5ncy5sZW5ndGg7XHJcblx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApIHtcclxuXHJcblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcclxuXHRcdFx0cm9vdFV1aWQgPSBwcm9wQmluZGluZy5yb290Tm9kZS51dWlkLFxyXG5cdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxyXG5cdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcclxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxyXG5cclxuXHRcdFx0bGFzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBiaW5kaW5ncy5sZW5ndGggLSAxIF0sXHJcblx0XHRcdGNhY2hlSW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4O1xyXG5cclxuXHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xyXG5cdFx0YmluZGluZ3NbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUJpbmRpbmc7XHJcblx0XHRiaW5kaW5ncy5wb3AoKTtcclxuXHJcblx0XHRkZWxldGUgYmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF07XHJcblxyXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggYmluZGluZ0J5TmFtZSApLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0X2xlbmRCaW5kaW5nKCBiaW5kaW5nICkge1xyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0YmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcclxuXHJcblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcclxuXHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xyXG5cclxuXHR9XHJcblxyXG5cdF90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXHJcblxyXG5cdF9sZW5kQ29udHJvbEludGVycG9sYW50KCkge1xyXG5cclxuXHRcdGNvbnN0IGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXHJcblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzICsrO1xyXG5cclxuXHRcdGxldCBpbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgTGluZWFySW50ZXJwb2xhbnQoXHJcblx0XHRcdFx0bmV3IEZsb2F0MzJBcnJheSggMiApLCBuZXcgRmxvYXQzMkFycmF5KCAyICksXHJcblx0XHRcdFx0MSwgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgKTtcclxuXHJcblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcclxuXHRcdFx0aW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW50ZXJwb2xhbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0X3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCBpbnRlcnBvbGFudCApIHtcclxuXHJcblx0XHRjb25zdCBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxyXG5cdFx0XHRwcmV2SW5kZXggPSBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyxcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xyXG5cdFx0aW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xyXG5cclxuXHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRpbnRlcnBvbGFudHNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHJldHVybiBhbiBhY3Rpb24gZm9yIGEgY2xpcCBvcHRpb25hbGx5IHVzaW5nIGEgY3VzdG9tIHJvb3QgdGFyZ2V0XHJcblx0Ly8gb2JqZWN0ICh0aGlzIG1ldGhvZCBhbGxvY2F0ZXMgYSBsb3Qgb2YgZHluYW1pYyBtZW1vcnkgaW4gY2FzZSBhXHJcblx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXHJcblx0Y2xpcEFjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290LCBibGVuZE1vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3Qgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxyXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZDtcclxuXHJcblx0XHRsZXQgY2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcDtcclxuXHJcblx0XHRjb25zdCBjbGlwVXVpZCA9IGNsaXBPYmplY3QgIT09IG51bGwgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwO1xyXG5cclxuXHRcdGNvbnN0IGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcclxuXHRcdGxldCBwcm90b3R5cGVBY3Rpb24gPSBudWxsO1xyXG5cclxuXHRcdGlmICggYmxlbmRNb2RlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNsaXBPYmplY3QgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGJsZW5kTW9kZSA9IGNsaXBPYmplY3QuYmxlbmRNb2RlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBleGlzdGluZ0FjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggZXhpc3RpbmdBY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBleGlzdGluZ0FjdGlvbi5ibGVuZE1vZGUgPT09IGJsZW5kTW9kZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gd2Uga25vdyB0aGUgY2xpcCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBwYXJzZSBhbGxcclxuXHRcdFx0Ly8gdGhlIGJpbmRpbmdzIGFnYWluIGJ1dCBjYW4ganVzdCBjb3B5XHJcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xyXG5cclxuXHRcdFx0Ly8gYWxzbywgdGFrZSB0aGUgY2xpcCBmcm9tIHRoZSBwcm90b3R5cGUgYWN0aW9uXHJcblx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXHJcblx0XHRcdFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xpcCBtdXN0IGJlIGtub3duIHdoZW4gc3BlY2lmaWVkIHZpYSBzdHJpbmdcclxuXHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XHJcblx0XHRjb25zdCBuZXdBY3Rpb24gPSBuZXcgQW5pbWF0aW9uQWN0aW9uKCB0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSApO1xyXG5cclxuXHRcdHRoaXMuX2JpbmRBY3Rpb24oIG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uICk7XHJcblxyXG5cdFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcclxuXHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBuZXdBY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xyXG5cclxuXHRcdHJldHVybiBuZXdBY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZ2V0IGFuIGV4aXN0aW5nIGFjdGlvblxyXG5cdGV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XHJcblxyXG5cdFx0Y29uc3Qgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxyXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcclxuXHJcblx0XHRcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgP1xyXG5cdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcclxuXHJcblx0XHRcdGNsaXBVdWlkID0gY2xpcE9iamVjdCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXAsXHJcblxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XHJcblxyXG5cdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSB8fCBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBkZWFjdGl2YXRlcyBhbGwgcHJldmlvdXNseSBzY2hlZHVsZWQgYWN0aW9uc1xyXG5cdHN0b3BBbGxBY3Rpb24oKSB7XHJcblxyXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSBuQWN0aW9ucyAtIDE7IGkgPj0gMDsgLS0gaSApIHtcclxuXHJcblx0XHRcdGFjdGlvbnNbIGkgXS5zdG9wKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXHJcblx0dXBkYXRlKCBkZWx0YVRpbWUgKSB7XHJcblxyXG5cdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xyXG5cclxuXHRcdGNvbnN0IGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cclxuXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXHJcblx0XHRcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxyXG5cclxuXHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XHJcblxyXG5cdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRcdGFjdGlvbi5fdXBkYXRlKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcclxuXHJcblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRiaW5kaW5nc1sgaSBdLmFwcGx5KCBhY2N1SW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQWxsb3dzIHlvdSB0byBzZWVrIHRvIGEgc3BlY2lmaWMgdGltZSBpbiBhbiBhbmltYXRpb24uXHJcblx0c2V0VGltZSggdGltZUluU2Vjb25kcyApIHtcclxuXHJcblx0XHR0aGlzLnRpbWUgPSAwOyAvLyBaZXJvIG91dCB0aW1lIGF0dHJpYnV0ZSBmb3IgQW5pbWF0aW9uTWl4ZXIgb2JqZWN0O1xyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGhpcy5fYWN0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9hY3Rpb25zWyBpIF0udGltZSA9IDA7IC8vIFplcm8gb3V0IHRpbWUgYXR0cmlidXRlIGZvciBhbGwgYXNzb2NpYXRlZCBBbmltYXRpb25BY3Rpb24gb2JqZWN0cy5cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCB0aW1lSW5TZWNvbmRzICk7IC8vIFVwZGF0ZSB1c2VkIHRvIHNldCBleGFjdCB0aW1lLiBSZXR1cm5zIFwidGhpc1wiIEFuaW1hdGlvbk1peGVyIG9iamVjdC5cclxuXHJcblx0fVxyXG5cclxuXHQvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxyXG5cdGdldFJvb3QoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXHJcblx0dW5jYWNoZUNsaXAoIGNsaXAgKSB7XHJcblxyXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdGNsaXBVdWlkID0gY2xpcC51dWlkLFxyXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcclxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xyXG5cclxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIG5vdGU6IGp1c3QgY2FsbGluZyBfcmVtb3ZlSW5hY3RpdmVBY3Rpb24gd291bGQgbWVzcyB1cCB0aGVcclxuXHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxyXG5cdFx0XHQvLyBqdXN0IHRocm93IGF3YXlcclxuXHJcblx0XHRcdGNvbnN0IGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNUb1JlbW92ZVsgaSBdO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcclxuXHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xyXG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XHJcblx0XHRcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xyXG5cdFx0XHRcdGFjdGlvbnMucG9wKCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XHJcblx0dW5jYWNoZVJvb3QoIHJvb3QgKSB7XHJcblxyXG5cdFx0Y29uc3Qgcm9vdFV1aWQgPSByb290LnV1aWQsXHJcblx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLmFjdGlvbkJ5Um9vdCxcclxuXHRcdFx0XHRhY3Rpb24gPSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxyXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XHJcblxyXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xyXG5cdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcclxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gcmVtb3ZlIGEgdGFyZ2V0ZWQgY2xpcCBmcm9tIHRoZSBjYWNoZVxyXG5cdHVuY2FjaGVBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcclxuXHJcblx0XHRjb25zdCBhY3Rpb24gPSB0aGlzLmV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKTtcclxuXHJcblx0XHRpZiAoIGFjdGlvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBBbmltYXRpb25NaXhlciB9O1xyXG4iLCJjbGFzcyBVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFVuaWZvcm0oIHRoaXMudmFsdWUuY2xvbmUgPT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmNsb25lKCkgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgVW5pZm9ybSB9O1xyXG4iLCJpbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlci5qcyc7XHJcbmltcG9ydCB7IFN0YXRpY0RyYXdVc2FnZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5sZXQgaWQgPSAwO1xyXG5cclxuY2xhc3MgVW5pZm9ybXNHcm91cCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc1VuaWZvcm1zR3JvdXAgPSB0cnVlO1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogaWQgKysgfSApO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHRcdHRoaXMudXNhZ2UgPSBTdGF0aWNEcmF3VXNhZ2U7XHJcblx0XHR0aGlzLnVuaWZvcm1zID0gW107XHJcblxyXG5cdH1cclxuXHJcblx0YWRkKCB1bmlmb3JtICkge1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMucHVzaCggdW5pZm9ybSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbW92ZSggdW5pZm9ybSApIHtcclxuXHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMudW5pZm9ybXMuaW5kZXhPZiggdW5pZm9ybSApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHRoaXMudW5pZm9ybXMuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE5hbWUoIG5hbWUgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRVc2FnZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cdFx0dGhpcy51c2FnZSA9IHNvdXJjZS51c2FnZTtcclxuXHJcblx0XHRjb25zdCB1bmlmb3Jtc1NvdXJjZSA9IHNvdXJjZS51bmlmb3JtcztcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdW5pZm9ybXNTb3VyY2UubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMudW5pZm9ybXMucHVzaCggdW5pZm9ybXNTb3VyY2VbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgVW5pZm9ybXNHcm91cCB9O1xyXG4iLCJpbXBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlciB9IGZyb20gJy4vSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xyXG5cclxuY2xhc3MgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgZXh0ZW5kcyBJbnRlcmxlYXZlZEJ1ZmZlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlID0gMSApIHtcclxuXHJcblx0XHRzdXBlciggYXJyYXksIHN0cmlkZSApO1xyXG5cclxuXHRcdHRoaXMuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoIGRhdGEgKSB7XHJcblxyXG5cdFx0Y29uc3QgaWIgPSBzdXBlci5jbG9uZSggZGF0YSApO1xyXG5cclxuXHRcdGliLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0cmV0dXJuIGliO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggZGF0YSApIHtcclxuXHJcblx0XHRjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCBkYXRhICk7XHJcblxyXG5cdFx0anNvbi5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcclxuXHRcdGpzb24ubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0XHRyZXR1cm4ganNvbjtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgfTtcclxuIiwiY2xhc3MgR0xCdWZmZXJBdHRyaWJ1dGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYnVmZmVyLCB0eXBlLCBpdGVtU2l6ZSwgZWxlbWVudFNpemUsIGNvdW50ICkge1xyXG5cclxuXHRcdHRoaXMuaXNHTEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdFx0dGhpcy5idWZmZXIgPSBidWZmZXI7XHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cdFx0dGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xyXG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IG5lZWRzVXBkYXRlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEJ1ZmZlciggYnVmZmVyICkge1xyXG5cclxuXHRcdHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFR5cGUoIHR5cGUsIGVsZW1lbnRTaXplICkge1xyXG5cclxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLmVsZW1lbnRTaXplID0gZWxlbWVudFNpemU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0SXRlbVNpemUoIGl0ZW1TaXplICkge1xyXG5cclxuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRDb3VudCggY291bnQgKSB7XHJcblxyXG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBHTEJ1ZmZlckF0dHJpYnV0ZSB9O1xyXG4iLCJpbXBvcnQgeyBSYXkgfSBmcm9tICcuLi9tYXRoL1JheS5qcyc7XHJcbmltcG9ydCB7IExheWVycyB9IGZyb20gJy4vTGF5ZXJzLmpzJztcclxuXHJcbmNsYXNzIFJheWNhc3RlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciA9IDAsIGZhciA9IEluZmluaXR5ICkge1xyXG5cclxuXHRcdHRoaXMucmF5ID0gbmV3IFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhcjtcclxuXHRcdHRoaXMuZmFyID0gZmFyO1xyXG5cdFx0dGhpcy5jYW1lcmEgPSBudWxsO1xyXG5cdFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XHJcblxyXG5cdFx0dGhpcy5wYXJhbXMgPSB7XHJcblx0XHRcdE1lc2g6IHt9LFxyXG5cdFx0XHRMaW5lOiB7IHRocmVzaG9sZDogMSB9LFxyXG5cdFx0XHRMT0Q6IHt9LFxyXG5cdFx0XHRQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXHJcblx0XHRcdFNwcml0ZToge31cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tQ2FtZXJhKCBjb29yZHMsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksICggY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyICkgLyAoIGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhciApICkudW5wcm9qZWN0KCBjYW1lcmEgKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcclxuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlOiAnICsgY2FtZXJhLnR5cGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJlY3Vyc2l2ZSA9IHRydWUsIGludGVyc2VjdHMgPSBbXSApIHtcclxuXHJcblx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0T2JqZWN0cyggb2JqZWN0cywgcmVjdXJzaXZlID0gdHJ1ZSwgaW50ZXJzZWN0cyA9IFtdICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XHJcblxyXG5cdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIHJheWNhc3Rlci5sYXllcnMgKSApIHtcclxuXHJcblx0XHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBSYXljYXN0ZXIgfTtcclxuIiwiLyoqXHJcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3BoZXJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXHJcbiAqXHJcbiAqIFRoZSBwb2xhciBhbmdsZSAocGhpKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB5LWF4aXMuIFRoZSBwb3NpdGl2ZSB5LWF4aXMgaXMgdXAuXHJcbiAqIFRoZSBhemltdXRoYWwgYW5nbGUgKHRoZXRhKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXMuXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcclxuXHJcbmNsYXNzIFNwaGVyaWNhbCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBwaGkgPSAwLCB0aGV0YSA9IDAgKSB7XHJcblxyXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblx0XHR0aGlzLnBoaSA9IHBoaTsgLy8gcG9sYXIgYW5nbGVcclxuXHRcdHRoaXMudGhldGEgPSB0aGV0YTsgLy8gYXppbXV0aGFsIGFuZ2xlXHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblx0XHR0aGlzLnBoaSA9IHBoaTtcclxuXHRcdHRoaXMudGhldGEgPSB0aGV0YTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBvdGhlciApIHtcclxuXHJcblx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcclxuXHRcdHRoaXMucGhpID0gb3RoZXIucGhpO1xyXG5cdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIEVQUyBhbmQgUEktRVBTXHJcblx0bWFrZVNhZmUoKSB7XHJcblxyXG5cdFx0Y29uc3QgRVBTID0gMC4wMDAwMDE7XHJcblx0XHR0aGlzLnBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCB0aGlzLnBoaSApICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyggdi54LCB2LnksIHYueiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xyXG5cclxuXHRcdGlmICggdGhpcy5yYWRpdXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnRoZXRhID0gMDtcclxuXHRcdFx0dGhpcy5waGkgPSAwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggeCwgeiApO1xyXG5cdFx0XHR0aGlzLnBoaSA9IE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCB5IC8gdGhpcy5yYWRpdXMsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgU3BoZXJpY2FsIH07XHJcbiIsIi8qKlxyXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N5bGluZHJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXHJcbiAqL1xyXG5cclxuY2xhc3MgQ3lsaW5kcmljYWwge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdGhldGEgPSAwLCB5ID0gMCApIHtcclxuXHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1czsgLy8gZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luIHRvIGEgcG9pbnQgaW4gdGhlIHgteiBwbGFuZVxyXG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhOyAvLyBjb3VudGVyY2xvY2t3aXNlIGFuZ2xlIGluIHRoZSB4LXogcGxhbmUgbWVhc3VyZWQgaW4gcmFkaWFucyBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXNcclxuXHRcdHRoaXMueSA9IHk7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCByYWRpdXMsIHRoZXRhLCB5ICkge1xyXG5cclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBvdGhlciApIHtcclxuXHJcblx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcclxuXHRcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcclxuXHRcdHRoaXMueSA9IG90aGVyLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RnJvbVZlY3RvcjMoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyggdi54LCB2LnksIHYueiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21DYXJ0ZXNpYW5Db29yZHMoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIHggKiB4ICsgeiAqIHogKTtcclxuXHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB4LCB6ICk7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQ3lsaW5kcmljYWwgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4vVmVjdG9yMi5qcyc7XHJcblxyXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMigpO1xyXG5cclxuY2xhc3MgQm94MiB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtaW4gPSBuZXcgVmVjdG9yMiggKyBJbmZpbml0eSwgKyBJbmZpbml0eSApLCBtYXggPSBuZXcgVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApICkge1xyXG5cclxuXHRcdHRoaXMuaXNCb3gyID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm1pbiA9IG1pbjtcclxuXHRcdHRoaXMubWF4ID0gbWF4O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdGNvbnN0IGhhbGZTaXplID0gX3ZlY3Rvci5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdG1ha2VFbXB0eSgpIHtcclxuXHJcblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9ICsgSW5maW5pdHk7XHJcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0aXNFbXB0eSgpIHtcclxuXHJcblx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAgKSA6IHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRhcmdldC5zZXQoIDAsIDAgKSA6IHRhcmdldC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fVxyXG5cclxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRleHBhbmRCeVNjYWxhciggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udGFpbnNQb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcblx0XHRcdHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ID8gZmFsc2UgOiB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnRhaW5zQm94KCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmXHJcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFBhcmFtZXRlciggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LnNldChcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xyXG5cclxuXHRcdC8vIHVzaW5nIDQgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zXHJcblxyXG5cdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2xhbXBQb2ludCggcG9pbnQsIF92ZWN0b3IgKS5kaXN0YW5jZVRvKCBwb2ludCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGludGVyc2VjdCggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0dW5pb24oIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGVxdWFscyggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQm94MiB9O1xyXG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcclxuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcclxuXHJcbmNvbnN0IF9zdGFydFAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9zdGFydEVuZCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIExpbmUzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHN0YXJ0ID0gbmV3IFZlY3RvcjMoKSwgZW5kID0gbmV3IFZlY3RvcjMoKSApIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcblx0XHR0aGlzLmVuZCA9IGVuZDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQoIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xyXG5cdFx0dGhpcy5lbmQuY29weSggZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggbGluZSApIHtcclxuXHJcblx0XHR0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHRcdHRoaXMuZW5kLmNvcHkoIGxpbmUuZW5kICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2VudGVyKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkZWx0YSggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXN0YW5jZVNxKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3RhbmNlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXQoIHQsIHRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggdGFyZ2V0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XHJcblxyXG5cdFx0X3N0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xyXG5cdFx0X3N0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdFx0Y29uc3Qgc3RhcnRFbmQyID0gX3N0YXJ0RW5kLmRvdCggX3N0YXJ0RW5kICk7XHJcblx0XHRjb25zdCBzdGFydEVuZF9zdGFydFAgPSBfc3RhcnRFbmQuZG90KCBfc3RhcnRQICk7XHJcblxyXG5cdFx0bGV0IHQgPSBzdGFydEVuZF9zdGFydFAgLyBzdGFydEVuZDI7XHJcblxyXG5cdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcclxuXHJcblx0XHRcdHQgPSBNYXRoVXRpbHMuY2xhbXAoIHQsIDAsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIGNsYW1wVG9MaW5lLCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHRhcmdldCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRlcXVhbHMoIGxpbmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgTGluZTMgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4uL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcclxuaW1wb3J0IHsgTGluZUJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5cclxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIFNwb3RMaWdodEhlbHBlciBleHRlbmRzIE9iamVjdDNEIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGxpZ2h0LCBjb2xvciApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHJcblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTcG90TGlnaHRIZWxwZXInO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb25zID0gW1xyXG5cdFx0XHQwLCAwLCAwLCBcdDAsIDAsIDEsXHJcblx0XHRcdDAsIDAsIDAsIFx0MSwgMCwgMSxcclxuXHRcdFx0MCwgMCwgMCxcdC0gMSwgMCwgMSxcclxuXHRcdFx0MCwgMCwgMCwgXHQwLCAxLCAxLFxyXG5cdFx0XHQwLCAwLCAwLCBcdDAsIC0gMSwgMVxyXG5cdFx0XTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAxLCBsID0gMzI7IGkgPCBsOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcclxuXHRcdFx0Y29uc3QgcDIgPSAoIGogLyBsICkgKiBNYXRoLlBJICogMjtcclxuXHJcblx0XHRcdHBvc2l0aW9ucy5wdXNoKFxyXG5cdFx0XHRcdE1hdGguY29zKCBwMSApLCBNYXRoLnNpbiggcDEgKSwgMSxcclxuXHRcdFx0XHRNYXRoLmNvcyggcDIgKSwgTWF0aC5zaW4oIHAyICksIDFcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XHJcblxyXG5cdFx0dGhpcy5jb25lID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLmFkZCggdGhpcy5jb25lICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSgpIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xyXG5cdFx0dGhpcy5saWdodC50YXJnZXQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0Y29uc3QgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDtcclxuXHRcdGNvbnN0IGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xyXG5cclxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XHJcblxyXG5cdFx0X3ZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dGhpcy5jb25lLmxvb2tBdCggX3ZlY3RvciApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFNwb3RMaWdodEhlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5cclxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX2JvbmVNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcbmNvbnN0IF9tYXRyaXhXb3JsZEludiA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcclxuXHJcblxyXG5jbGFzcyBTa2VsZXRvbkhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgYm9uZXMgPSBnZXRCb25lTGlzdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0Y29uc3QgY29sb3JzID0gW107XHJcblxyXG5cdFx0Y29uc3QgY29sb3IxID0gbmV3IENvbG9yKCAwLCAwLCAxICk7XHJcblx0XHRjb25zdCBjb2xvcjIgPSBuZXcgQ29sb3IoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBib25lID0gYm9uZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICk7XHJcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0b25lTWFwcGVkOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLmlzU2tlbGV0b25IZWxwZXIgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTa2VsZXRvbkhlbHBlcic7XHJcblxyXG5cdFx0dGhpcy5yb290ID0gb2JqZWN0O1xyXG5cdFx0dGhpcy5ib25lcyA9IGJvbmVzO1xyXG5cclxuXHRcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuXHRcdGNvbnN0IGJvbmVzID0gdGhpcy5ib25lcztcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xyXG5cclxuXHRcdF9tYXRyaXhXb3JsZEludi5jb3B5KCB0aGlzLnJvb3QubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYm9uZSA9IGJvbmVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcclxuXHJcblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggX21hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X3ZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIF9ib25lTWF0cml4ICk7XHJcblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBqLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XHJcblxyXG5cdFx0XHRcdF9ib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIF9tYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggX2JvbmVNYXRyaXggKTtcclxuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGogKyAxLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XHJcblxyXG5cdFx0XHRcdGogKz0gMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldEJvbmVMaXN0KCBvYmplY3QgKSB7XHJcblxyXG5cdGNvbnN0IGJvbmVMaXN0ID0gW107XHJcblxyXG5cdGlmICggb2JqZWN0LmlzQm9uZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCBnZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBib25lTGlzdDtcclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBTa2VsZXRvbkhlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vb2JqZWN0cy9NZXNoLmpzJztcclxuaW1wb3J0IHsgTWVzaEJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBTcGhlcmVHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanMnO1xyXG5cclxuY2xhc3MgUG9pbnRMaWdodEhlbHBlciBleHRlbmRzIE1lc2gge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQsIHNwaGVyZVNpemUsIGNvbG9yICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcclxuXHJcblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodEhlbHBlcic7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblxyXG5cdFx0LypcclxuXHQvLyBUT0RPOiBkZWxldGUgdGhpcyBjb21tZW50P1xyXG5cdGNvbnN0IGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xyXG5cdGNvbnN0IGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XHJcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcclxuXHJcblx0Y29uc3QgZCA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XHJcblx0Ki9cclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCkge1xyXG5cclxuXHRcdHRoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdGNvbnN0IGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRcdGlmICggZCA9PT0gMC4wICkge1xyXG5cclxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdFx0fVxyXG5cdFx0Ki9cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFBvaW50TGlnaHRIZWxwZXIgfTtcclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi9vYmplY3RzL01lc2guanMnO1xyXG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IE9jdGFoZWRyb25HZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvT2N0YWhlZHJvbkdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5cclxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX2NvbG9yMSA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yKCk7XHJcbmNvbnN0IF9jb2xvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBDb2xvcigpO1xyXG5cclxuY2xhc3MgSGVtaXNwaGVyZUxpZ2h0SGVscGVyIGV4dGVuZHMgT2JqZWN0M0Qge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cclxuXHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodEhlbHBlcic7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KCBzaXplICk7XHJcblx0XHRnZW9tZXRyeS5yb3RhdGVZKCBNYXRoLlBJICogMC41ICk7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcclxuXHRcdGlmICggdGhpcy5jb2xvciA9PT0gdW5kZWZpbmVkICkgdGhpcy5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XHJcblx0XHRjb25zdCBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbi5jb3VudCAqIDMgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XHJcblxyXG5cdFx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLmNoaWxkcmVuWyAwIF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSgpIHtcclxuXHJcblx0XHRjb25zdCBtZXNoID0gdGhpcy5jaGlsZHJlblsgMCBdO1xyXG5cclxuXHRcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgY29sb3JzID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdjb2xvcicgKTtcclxuXHJcblx0XHRcdF9jb2xvcjEuY29weSggdGhpcy5saWdodC5jb2xvciApO1xyXG5cdFx0XHRfY29sb3IyLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGNvbG9ycy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gKCBpIDwgKCBsIC8gMiApICkgPyBfY29sb3IxIDogX2NvbG9yMjtcclxuXHJcblx0XHRcdFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5saWdodC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHRtZXNoLmxvb2tBdCggX3ZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0SGVscGVyIH07XHJcbiIsImltcG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4uL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcclxuaW1wb3J0IHsgTGluZUJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBzaXplID0gMTAsIGRpdmlzaW9ucyA9IDEwLCBjb2xvcjEgPSAweDQ0NDQ0NCwgY29sb3IyID0gMHg4ODg4ODggKSB7XHJcblxyXG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgKTtcclxuXHRcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICk7XHJcblxyXG5cdFx0Y29uc3QgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcclxuXHRcdGNvbnN0IHN0ZXAgPSBzaXplIC8gZGl2aXNpb25zO1xyXG5cdFx0Y29uc3QgaGFsZlNpemUgPSBzaXplIC8gMjtcclxuXHJcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdLCBjb2xvcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGogPSAwLCBrID0gLSBoYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzLnB1c2goIC0gaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrICk7XHJcblx0XHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRjb25zdCBjb2xvciA9IGkgPT09IGNlbnRlciA/IGNvbG9yMSA6IGNvbG9yMjtcclxuXHJcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XHJcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XHJcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XHJcblx0XHRcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xyXG5cclxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnR3JpZEhlbHBlcic7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgR3JpZEhlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XHJcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbmNsYXNzIFBvbGFyR3JpZEhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxMCwgc2VjdG9ycyA9IDE2LCByaW5ncyA9IDgsIGRpdmlzaW9ucyA9IDY0LCBjb2xvcjEgPSAweDQ0NDQ0NCwgY29sb3IyID0gMHg4ODg4ODggKSB7XHJcblxyXG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgKTtcclxuXHRcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSB0aGUgc2VjdG9yc1xyXG5cclxuXHRcdGlmICggc2VjdG9ycyA+IDEgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzZWN0b3JzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2ID0gKCBpIC8gc2VjdG9ycyApICogKCBNYXRoLlBJICogMiApO1xyXG5cclxuXHRcdFx0XHRjb25zdCB4ID0gTWF0aC5zaW4oIHYgKSAqIHJhZGl1cztcclxuXHRcdFx0XHRjb25zdCB6ID0gTWF0aC5jb3MoIHYgKSAqIHJhZGl1cztcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgY29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XHJcblxyXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XHJcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3JlYXRlIHRoZSByaW5nc1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJpbmdzOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XHJcblxyXG5cdFx0XHRjb25zdCByID0gcmFkaXVzIC0gKCByYWRpdXMgLyByaW5ncyAqIGkgKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gZmlyc3QgdmVydGV4XHJcblxyXG5cdFx0XHRcdGxldCB2ID0gKCBqIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0XHRcdGxldCB4ID0gTWF0aC5zaW4oIHYgKSAqIHI7XHJcblx0XHRcdFx0bGV0IHogPSBNYXRoLmNvcyggdiApICogcjtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xyXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdC8vIHNlY29uZCB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0diA9ICggKCBqICsgMSApIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcjtcclxuXHRcdFx0XHR6ID0gTWF0aC5jb3MoIHYgKSAqIHI7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcclxuXHRcdFx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcclxuXHJcblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BvbGFyR3JpZEhlbHBlcic7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgUG9sYXJHcmlkSGVscGVyIH07XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4uL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lLmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgTGluZUJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5cclxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfdjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF92MyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcclxuXHJcbmNsYXNzIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc2l6ZSwgY29sb3IgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodEhlbHBlcic7XHJcblxyXG5cdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTtcclxuXHJcblx0XHRsZXQgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFtcclxuXHRcdFx0LSBzaXplLCBzaXplLCAwLFxyXG5cdFx0XHRzaXplLCBzaXplLCAwLFxyXG5cdFx0XHRzaXplLCAtIHNpemUsIDAsXHJcblx0XHRcdC0gc2l6ZSwgLSBzaXplLCAwLFxyXG5cdFx0XHQtIHNpemUsIHNpemUsIDBcclxuXHRcdF0sIDMgKSApO1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMCwgMSBdLCAzICkgKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCkge1xyXG5cclxuXHRcdHRoaXMubGlnaHQudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XHJcblx0XHR0aGlzLmxpZ2h0LnRhcmdldC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHRfdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRfdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0X3YzLnN1YlZlY3RvcnMoIF92MiwgX3YxICk7XHJcblxyXG5cdFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdCggX3YyICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XHJcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHRcdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmxvb2tBdCggX3YyICk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IF92My5sZW5ndGgoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IERpcmVjdGlvbmFsTGlnaHRIZWxwZXIgfTtcclxuIiwiaW1wb3J0IHsgQ2FtZXJhIH0gZnJvbSAnLi4vY2FtZXJhcy9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgTGluZVNlZ21lbnRzIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lU2VnbWVudHMuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcblxyXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfY2FtZXJhID0gLypAX19QVVJFX18qLyBuZXcgQ2FtZXJhKCk7XHJcblxyXG4vKipcclxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxyXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXHJcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxyXG4gKlx0XHRodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbGlnaHRnbC5qcy9ibG9iL21hc3Rlci90ZXN0cy9zaGFkb3dtYXAuaHRtbFxyXG4gKi9cclxuXHJcbmNsYXNzIENhbWVyYUhlbHBlciBleHRlbmRzIExpbmVTZWdtZW50cyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiB0cnVlLCB0b25lTWFwcGVkOiBmYWxzZSB9ICk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IHBvaW50TWFwID0ge307XHJcblxyXG5cdFx0Ly8gbmVhclxyXG5cclxuXHRcdGFkZExpbmUoICduMScsICduMicgKTtcclxuXHRcdGFkZExpbmUoICduMicsICduNCcgKTtcclxuXHRcdGFkZExpbmUoICduNCcsICduMycgKTtcclxuXHRcdGFkZExpbmUoICduMycsICduMScgKTtcclxuXHJcblx0XHQvLyBmYXJcclxuXHJcblx0XHRhZGRMaW5lKCAnZjEnLCAnZjInICk7XHJcblx0XHRhZGRMaW5lKCAnZjInLCAnZjQnICk7XHJcblx0XHRhZGRMaW5lKCAnZjQnLCAnZjMnICk7XHJcblx0XHRhZGRMaW5lKCAnZjMnLCAnZjEnICk7XHJcblxyXG5cdFx0Ly8gc2lkZXNcclxuXHJcblx0XHRhZGRMaW5lKCAnbjEnLCAnZjEnICk7XHJcblx0XHRhZGRMaW5lKCAnbjInLCAnZjInICk7XHJcblx0XHRhZGRMaW5lKCAnbjMnLCAnZjMnICk7XHJcblx0XHRhZGRMaW5lKCAnbjQnLCAnZjQnICk7XHJcblxyXG5cdFx0Ly8gY29uZVxyXG5cclxuXHRcdGFkZExpbmUoICdwJywgJ24xJyApO1xyXG5cdFx0YWRkTGluZSggJ3AnLCAnbjInICk7XHJcblx0XHRhZGRMaW5lKCAncCcsICduMycgKTtcclxuXHRcdGFkZExpbmUoICdwJywgJ240JyApO1xyXG5cclxuXHRcdC8vIHVwXHJcblxyXG5cdFx0YWRkTGluZSggJ3UxJywgJ3UyJyApO1xyXG5cdFx0YWRkTGluZSggJ3UyJywgJ3UzJyApO1xyXG5cdFx0YWRkTGluZSggJ3UzJywgJ3UxJyApO1xyXG5cclxuXHRcdC8vIHRhcmdldFxyXG5cclxuXHRcdGFkZExpbmUoICdjJywgJ3QnICk7XHJcblx0XHRhZGRMaW5lKCAncCcsICdjJyApO1xyXG5cclxuXHRcdC8vIGNyb3NzXHJcblxyXG5cdFx0YWRkTGluZSggJ2NuMScsICdjbjInICk7XHJcblx0XHRhZGRMaW5lKCAnY24zJywgJ2NuNCcgKTtcclxuXHJcblx0XHRhZGRMaW5lKCAnY2YxJywgJ2NmMicgKTtcclxuXHRcdGFkZExpbmUoICdjZjMnLCAnY2Y0JyApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRhZGRQb2ludCggYSApO1xyXG5cdFx0XHRhZGRQb2ludCggYiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRQb2ludCggaWQgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XHJcblx0XHRcdGNvbG9ycy5wdXNoKCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb2ludE1hcFsgaWQgXS5wdXNoKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSAtIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHRzdXBlciggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0NhbWVyYUhlbHBlcic7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblx0XHRpZiAoIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggKSB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRjb25zdCBjb2xvckZydXN0dW0gPSBuZXcgQ29sb3IoIDB4ZmZhYTAwICk7XHJcblx0XHRjb25zdCBjb2xvckNvbmUgPSBuZXcgQ29sb3IoIDB4ZmYwMDAwICk7XHJcblx0XHRjb25zdCBjb2xvclVwID0gbmV3IENvbG9yKCAweDAwYWFmZiApO1xyXG5cdFx0Y29uc3QgY29sb3JUYXJnZXQgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0XHRjb25zdCBjb2xvckNyb3NzID0gbmV3IENvbG9yKCAweDMzMzMzMyApO1xyXG5cclxuXHRcdHRoaXMuc2V0Q29sb3JzKCBjb2xvckZydXN0dW0sIGNvbG9yQ29uZSwgY29sb3JVcCwgY29sb3JUYXJnZXQsIGNvbG9yQ3Jvc3MgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRDb2xvcnMoIGZydXN0dW0sIGNvbmUsIHVwLCB0YXJnZXQsIGNyb3NzICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0XHRjb25zdCBjb2xvckF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ2NvbG9yJyApO1xyXG5cclxuXHRcdC8vIG5lYXJcclxuXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDAsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAxLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4xLCBuMlxyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMywgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyAvLyBuMiwgbjRcclxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggNCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDUsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjQsIG4zXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDYsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA3LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IC8vIG4zLCBuMVxyXG5cclxuXHRcdC8vIGZhclxyXG5cclxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggOCwgZnJ1c3R1bS5yLCBmcnVzdHVtLmcsIGZydXN0dW0uYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDksIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjEsIGYyXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDEwLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTEsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjIsIGY0XHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDEyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjQsIGYzXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE0LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTUsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gZjMsIGYxXHJcblxyXG5cdFx0Ly8gc2lkZXNcclxuXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE2LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTcsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjEsIGYxXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDE4LCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMTksIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjIsIGYyXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDIwLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjEsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjMsIGYzXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDIyLCBmcnVzdHVtLnIsIGZydXN0dW0uZywgZnJ1c3R1bS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjMsIGZydXN0dW0uciwgZnJ1c3R1bS5nLCBmcnVzdHVtLmIgKTsgLy8gbjQsIGY0XHJcblxyXG5cdFx0Ly8gY29uZVxyXG5cclxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjQsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuMVxyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAyNiwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDI3LCBjb25lLnIsIGNvbmUuZywgY29uZS5iICk7IC8vIHAsIG4yXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDI4LCBjb25lLnIsIGNvbmUuZywgY29uZS5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggMjksIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgLy8gcCwgbjNcclxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzAsIGNvbmUuciwgY29uZS5nLCBjb25lLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMSwgY29uZS5yLCBjb25lLmcsIGNvbmUuYiApOyAvLyBwLCBuNFxyXG5cclxuXHRcdC8vIHVwXHJcblxyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzMiwgdXAuciwgdXAuZywgdXAuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDMzLCB1cC5yLCB1cC5nLCB1cC5iICk7IC8vIHUxLCB1MlxyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzNCwgdXAuciwgdXAuZywgdXAuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM1LCB1cC5yLCB1cC5nLCB1cC5iICk7IC8vIHUyLCB1M1xyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzNiwgdXAuciwgdXAuZywgdXAuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDM3LCB1cC5yLCB1cC5nLCB1cC5iICk7IC8vIHUzLCB1MVxyXG5cclxuXHRcdC8vIHRhcmdldFxyXG5cclxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggMzgsIHRhcmdldC5yLCB0YXJnZXQuZywgdGFyZ2V0LmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCAzOSwgdGFyZ2V0LnIsIHRhcmdldC5nLCB0YXJnZXQuYiApOyAvLyBjLCB0XHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQwLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDEsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gcCwgY1xyXG5cclxuXHRcdC8vIGNyb3NzXHJcblxyXG5cdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0MiwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyBjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQzLCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IC8vIGNuMSwgY24yXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ0LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDUsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY24zLCBjbjRcclxuXHJcblx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIDQ2LCBjcm9zcy5yLCBjcm9zcy5nLCBjcm9zcy5iICk7IGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDcsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgLy8gY2YxLCBjZjJcclxuXHRcdGNvbG9yQXR0cmlidXRlLnNldFhZWiggNDgsIGNyb3NzLnIsIGNyb3NzLmcsIGNyb3NzLmIgKTsgY29sb3JBdHRyaWJ1dGUuc2V0WFlaKCA0OSwgY3Jvc3MuciwgY3Jvc3MuZywgY3Jvc3MuYiApOyAvLyBjZjMsIGNmNFxyXG5cclxuXHRcdGNvbG9yQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0Y29uc3QgcG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xyXG5cclxuXHRcdGNvbnN0IHcgPSAxLCBoID0gMTtcclxuXHJcblx0XHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4IGludmVyc2VcclxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XHJcblxyXG5cdFx0X2NhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApO1xyXG5cclxuXHRcdC8vIGNlbnRlciAvIHRhcmdldFxyXG5cclxuXHRcdHNldFBvaW50KCAnYycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgMCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggJ3QnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIDAsIDEgKTtcclxuXHJcblx0XHQvLyBuZWFyXHJcblxyXG5cdFx0c2V0UG9pbnQoICduMScsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3LCAtIGgsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoICduMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLSBoLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCAnbjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC0gdywgaCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggJ240JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCBoLCAtIDEgKTtcclxuXHJcblx0XHQvLyBmYXJcclxuXHJcblx0XHRzZXRQb2ludCggJ2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIC0gaCwgMSApO1xyXG5cdFx0c2V0UG9pbnQoICdmMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgLSBoLCAxICk7XHJcblx0XHRzZXRQb2ludCggJ2YzJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIGgsIDEgKTtcclxuXHRcdHNldFBvaW50KCAnZjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIGgsIDEgKTtcclxuXHJcblx0XHQvLyB1cFxyXG5cclxuXHRcdHNldFBvaW50KCAndTEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoICd1MicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcclxuXHRcdHNldFBvaW50KCAndTMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGggKiAyLCAtIDEgKTtcclxuXHJcblx0XHQvLyBjcm9zc1xyXG5cclxuXHRcdHNldFBvaW50KCAnY2YxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIDAsIDEgKTtcclxuXHRcdHNldFBvaW50KCAnY2YyJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAwLCAxICk7XHJcblx0XHRzZXRQb2ludCggJ2NmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLSBoLCAxICk7XHJcblx0XHRzZXRQb2ludCggJ2NmNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgMSApO1xyXG5cclxuXHRcdHNldFBvaW50KCAnY24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtIHcsIDAsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoICdjbjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIDAsIC0gMSApO1xyXG5cdFx0c2V0UG9pbnQoICdjbjMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIC0gaCwgLSAxICk7XHJcblx0XHRzZXRQb2ludCggJ2NuNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgLSAxICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgcG9pbnRNYXAsIGdlb21ldHJ5LCBjYW1lcmEsIHgsIHksIHogKSB7XHJcblxyXG5cdF92ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcblx0Y29uc3QgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XHJcblxyXG5cdGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHBvc2l0aW9uLnNldFhZWiggcG9pbnRzWyBpIF0sIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IENhbWVyYUhlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcclxuaW1wb3J0IHsgTGluZVNlZ21lbnRzIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lU2VnbWVudHMuanMnO1xyXG5pbXBvcnQgeyBMaW5lQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9MaW5lQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuXHJcbmNvbnN0IF9ib3ggPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XHJcblxyXG5jbGFzcyBCb3hIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCBjb2xvciA9IDB4ZmZmZjAwICkge1xyXG5cclxuXHRcdGNvbnN0IGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XHJcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICogMyApO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblxyXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcclxuXHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdHRoaXMudHlwZSA9ICdCb3hIZWxwZXInO1xyXG5cclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2JveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIF9ib3guaXNFbXB0eSgpICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IG1pbiA9IF9ib3gubWluO1xyXG5cdFx0Y29uc3QgbWF4ID0gX2JveC5tYXg7XHJcblxyXG5cdFx0LypcclxuXHRcdFx0NV9fX180XHJcblx0XHQxL19fXzAvfFxyXG5cdFx0fCA2X198XzdcclxuXHRcdDIvX19fMy9cclxuXHJcblx0XHQwOiBtYXgueCwgbWF4LnksIG1heC56XHJcblx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XHJcblx0XHQyOiBtaW4ueCwgbWluLnksIG1heC56XHJcblx0XHQzOiBtYXgueCwgbWluLnksIG1heC56XHJcblx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XHJcblx0XHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XHJcblx0XHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XHJcblx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XHJcblx0XHQqL1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0Y29uc3QgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcclxuXHJcblx0XHRhcnJheVsgMCBdID0gbWF4Lng7IGFycmF5WyAxIF0gPSBtYXgueTsgYXJyYXlbIDIgXSA9IG1heC56O1xyXG5cdFx0YXJyYXlbIDMgXSA9IG1pbi54OyBhcnJheVsgNCBdID0gbWF4Lnk7IGFycmF5WyA1IF0gPSBtYXguejtcclxuXHRcdGFycmF5WyA2IF0gPSBtaW4ueDsgYXJyYXlbIDcgXSA9IG1pbi55OyBhcnJheVsgOCBdID0gbWF4Lno7XHJcblx0XHRhcnJheVsgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XHJcblx0XHRhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xyXG5cdFx0YXJyYXlbIDE1IF0gPSBtaW4ueDsgYXJyYXlbIDE2IF0gPSBtYXgueTsgYXJyYXlbIDE3IF0gPSBtaW4uejtcclxuXHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XHJcblx0XHRhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xyXG5cclxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEZyb21PYmplY3QoIG9iamVjdCApIHtcclxuXHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0c3VwZXIuY29weSggc291cmNlLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHR0aGlzLm9iamVjdCA9IHNvdXJjZS5vYmplY3Q7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgQm94SGVscGVyIH07XHJcbiIsImltcG9ydCB7IExpbmVTZWdtZW50cyB9IGZyb20gJy4uL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcclxuaW1wb3J0IHsgTGluZUJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcblxyXG5jbGFzcyBCb3gzSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJveCwgY29sb3IgPSAweGZmZmYwMCApIHtcclxuXHJcblx0XHRjb25zdCBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFsgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSBdO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xyXG5cclxuXHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblxyXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcclxuXHJcblx0XHR0aGlzLmJveCA9IGJveDtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQm94M0hlbHBlcic7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgYm94ID0gdGhpcy5ib3g7XHJcblxyXG5cdFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xyXG5cclxuXHRcdGJveC5nZXRDZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcclxuXHJcblx0XHRib3guZ2V0U2l6ZSggdGhpcy5zY2FsZSApO1xyXG5cclxuXHRcdHRoaXMuc2NhbGUubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgQm94M0hlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi4vb2JqZWN0cy9MaW5lLmpzJztcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uL29iamVjdHMvTWVzaC5qcyc7XHJcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgTWVzaEJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5cclxuY2xhc3MgUGxhbmVIZWxwZXIgZXh0ZW5kcyBMaW5lIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBsYW5lLCBzaXplID0gMSwgaGV4ID0gMHhmZmZmMDAgKSB7XHJcblxyXG5cdFx0Y29uc3QgY29sb3IgPSBoZXg7XHJcblxyXG5cdFx0Y29uc3QgcG9zaXRpb25zID0gWyAxLCAtIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIC0gMSwgMCwgMSwgMSwgMCBdO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0c3VwZXIoIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVIZWxwZXInO1xyXG5cclxuXHRcdHRoaXMucGxhbmUgPSBwbGFuZTtcclxuXHJcblx0XHR0aGlzLnNpemUgPSBzaXplO1xyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uczIgPSBbIDEsIDEsIDAsIC0gMSwgMSwgMCwgLSAxLCAtIDEsIDAsIDEsIDEsIDAsIC0gMSwgLSAxLCAwLCAxLCAtIDEsIDAgXTtcclxuXHJcblx0XHRjb25zdCBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMyLCAzICkgKTtcclxuXHRcdGdlb21ldHJ5Mi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5MiwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC4yLCB0cmFuc3BhcmVudDogdHJ1ZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZS5zZXQoIDAuNSAqIHRoaXMuc2l6ZSwgMC41ICogdGhpcy5zaXplLCAxICk7XHJcblxyXG5cdFx0dGhpcy5sb29rQXQoIHRoaXMucGxhbmUubm9ybWFsICk7XHJcblxyXG5cdFx0dGhpcy50cmFuc2xhdGVaKCAtIHRoaXMucGxhbmUuY29uc3RhbnQgKTtcclxuXHJcblx0XHRzdXBlci51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLmNoaWxkcmVuWyAwIF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHsgUGxhbmVIZWxwZXIgfTtcclxuIiwiaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuLi9jb3JlL09iamVjdDNELmpzJztcclxuaW1wb3J0IHsgQ3lsaW5kZXJHZW9tZXRyeSB9IGZyb20gJy4uL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IE1lc2hCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL01lc2hCYXNpY01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgTGluZUJhc2ljTWF0ZXJpYWwgfSBmcm9tICcuLi9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vb2JqZWN0cy9NZXNoLmpzJztcclxuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4uL29iamVjdHMvTGluZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuY29uc3QgX2F4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcbmxldCBfbGluZUdlb21ldHJ5LCBfY29uZUdlb21ldHJ5O1xyXG5cclxuY2xhc3MgQXJyb3dIZWxwZXIgZXh0ZW5kcyBPYmplY3QzRCB7XHJcblxyXG5cdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0Y29uc3RydWN0b3IoIGRpciA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICksIG9yaWdpbiA9IG5ldyBWZWN0b3IzKCAwLCAwLCAwICksIGxlbmd0aCA9IDEsIGNvbG9yID0gMHhmZmZmMDAsIGhlYWRMZW5ndGggPSBsZW5ndGggKiAwLjIsIGhlYWRXaWR0aCA9IGhlYWRMZW5ndGggKiAwLjIgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQXJyb3dIZWxwZXInO1xyXG5cclxuXHRcdGlmICggX2xpbmVHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2xpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0XHRfbGluZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMSwgMCBdLCAzICkgKTtcclxuXHJcblx0XHRcdF9jb25lR2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XHJcblx0XHRcdF9jb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xyXG5cclxuXHRcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBfbGluZUdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB0b25lTWFwcGVkOiBmYWxzZSB9ICkgKTtcclxuXHRcdHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XHJcblxyXG5cdFx0dGhpcy5jb25lID0gbmV3IE1lc2goIF9jb25lR2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIHRvbmVNYXBwZWQ6IGZhbHNlIH0gKSApO1xyXG5cdFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcblx0XHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XHJcblx0XHR0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXREaXJlY3Rpb24oIGRpciApIHtcclxuXHJcblx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0aWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9heGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGNvbnN0IHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggX2F4aXMsIHJhZGlhbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGggPSBsZW5ndGggKiAwLjIsIGhlYWRXaWR0aCA9IGhlYWRMZW5ndGggKiAwLjIgKSB7XHJcblxyXG5cdFx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAuMDAwMSwgbGVuZ3RoIC0gaGVhZExlbmd0aCApLCAxICk7IC8vIHNlZSAjMTc0NThcclxuXHRcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xyXG5cdFx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XHJcblx0XHR0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Q29sb3IoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIGNvbG9yICk7XHJcblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIGZhbHNlICk7XHJcblxyXG5cdFx0dGhpcy5saW5lLmNvcHkoIHNvdXJjZS5saW5lICk7XHJcblx0XHR0aGlzLmNvbmUuY29weSggc291cmNlLmNvbmUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMubGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBBcnJvd0hlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuLi9vYmplY3RzL0xpbmVTZWdtZW50cy5qcyc7XHJcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vbWF0ZXJpYWxzL0xpbmVCYXNpY01hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbmNsYXNzIEF4ZXNIZWxwZXIgZXh0ZW5kcyBMaW5lU2VnbWVudHMge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggc2l6ZSA9IDEgKSB7XHJcblxyXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXHJcblx0XHRcdDAsIDAsIDAsXHRzaXplLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLFx0MCwgc2l6ZSwgMCxcclxuXHRcdFx0MCwgMCwgMCxcdDAsIDAsIHNpemVcclxuXHRcdF07XHJcblxyXG5cdFx0Y29uc3QgY29sb3JzID0gW1xyXG5cdFx0XHQxLCAwLCAwLFx0MSwgMC42LCAwLFxyXG5cdFx0XHQwLCAxLCAwLFx0MC42LCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxLFx0MCwgMC42LCAxXHJcblx0XHRdO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogdHJ1ZSwgdG9uZU1hcHBlZDogZmFsc2UgfSApO1xyXG5cclxuXHRcdHN1cGVyKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQXhlc0hlbHBlcic7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Q29sb3JzKCB4QXhpc0NvbG9yLCB5QXhpc0NvbG9yLCB6QXhpc0NvbG9yICkge1xyXG5cclxuXHRcdGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKCk7XHJcblx0XHRjb25zdCBhcnJheSA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcclxuXHJcblx0XHRjb2xvci5zZXQoIHhBeGlzQ29sb3IgKTtcclxuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCAwICk7XHJcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgMyApO1xyXG5cclxuXHRcdGNvbG9yLnNldCggeUF4aXNDb2xvciApO1xyXG5cdFx0Y29sb3IudG9BcnJheSggYXJyYXksIDYgKTtcclxuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCA5ICk7XHJcblxyXG5cdFx0Y29sb3Iuc2V0KCB6QXhpc0NvbG9yICk7XHJcblx0XHRjb2xvci50b0FycmF5KCBhcnJheSwgMTIgKTtcclxuXHRcdGNvbG9yLnRvQXJyYXkoIGFycmF5LCAxNSApO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgQXhlc0hlbHBlciB9O1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9QYXRoLmpzJztcclxuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuL1NoYXBlLmpzJztcclxuaW1wb3J0IHsgU2hhcGVVdGlscyB9IGZyb20gJy4uL1NoYXBlVXRpbHMuanMnO1xyXG5cclxuY2xhc3MgU2hhcGVQYXRoIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlUGF0aCc7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvcigpO1xyXG5cclxuXHRcdHRoaXMuc3ViUGF0aHMgPSBbXTtcclxuXHRcdHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdG1vdmVUbyggeCwgeSApIHtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBhdGgoKTtcclxuXHRcdHRoaXMuc3ViUGF0aHMucHVzaCggdGhpcy5jdXJyZW50UGF0aCApO1xyXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oIHgsIHkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRsaW5lVG8oIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oIHgsIHkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRxdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRiZXppZXJDdXJ2ZVRvKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNwbGluZVRocnUoIHB0cyApIHtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUoIHB0cyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvU2hhcGVzKCBpc0NDVyApIHtcclxuXHJcblx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzaGFwZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcclxuXHRcdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHJcblx0XHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxyXG5cdFx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXHJcblx0XHRcdC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcclxuXHRcdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcclxuXHRcdFx0bGV0IGluc2lkZSA9IGZhbHNlO1xyXG5cdFx0XHRmb3IgKCBsZXQgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xyXG5cclxuXHRcdFx0XHRsZXQgZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBwIF07XHJcblx0XHRcdFx0bGV0IGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcclxuXHJcblx0XHRcdFx0bGV0IGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xyXG5cdFx0XHRcdGxldCBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBub3QgcGFyYWxsZWxcclxuXHRcdFx0XHRcdGlmICggZWRnZUR5IDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcSBdOyBlZGdlRHggPSAtIGVkZ2VEeDtcclxuXHRcdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApIFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcclxuXHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA9PT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHRcdGlmICggcGVycEVkZ2UgPCAwICkgXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHRcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcclxuXHRcdFx0XHRcdGlmICggaW5QdC55ICE9PSBlZGdlTG93UHQueSApIFx0XHRjb250aW51ZTtcdFx0XHQvLyBwYXJhbGxlbFxyXG5cdFx0XHRcdFx0Ly8gZWRnZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XHJcblx0XHRcdFx0XHRpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XHJcblx0XHRcdFx0XHRcdCAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApXHRcdHJldHVyblx0dHJ1ZTtcdC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxyXG5cdFx0XHRcdFx0Ly8gY29udGludWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVyblx0aW5zaWRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc0Nsb2NrV2lzZSA9IFNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XHJcblxyXG5cdFx0Y29uc3Qgc3ViUGF0aHMgPSB0aGlzLnN1YlBhdGhzO1xyXG5cdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XHJcblxyXG5cdFx0bGV0IHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZTtcclxuXHRcdGNvbnN0IHNoYXBlcyA9IFtdO1xyXG5cclxuXHRcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxICkge1xyXG5cclxuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XHJcblx0XHRcdHRtcFNoYXBlID0gbmV3IFNoYXBlKCk7XHJcblx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHRcdFx0cmV0dXJuIHNoYXBlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0XHRob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XHJcblxyXG5cdFx0Y29uc3QgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xyXG5cdFx0Y29uc3QgbmV3U2hhcGVzID0gW107XHJcblx0XHRsZXQgbmV3U2hhcGVIb2xlcyA9IFtdO1xyXG5cdFx0bGV0IG1haW5JZHggPSAwO1xyXG5cdFx0bGV0IHRtcFBvaW50cztcclxuXHJcblx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcclxuXHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXSA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcclxuXHRcdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcclxuXHRcdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XHJcblx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XHJcblxyXG5cdFx0XHRpZiAoIHNvbGlkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcdG1haW5JZHggKys7XHJcblxyXG5cdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XHJcblx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHJcblx0XHRcdFx0aWYgKCBob2xlc0ZpcnN0IClcdG1haW5JZHggKys7XHJcblx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cclxuXHRcdGlmICggISBuZXdTaGFwZXNbIDAgXSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcclxuXHJcblxyXG5cdFx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGxldCBhbWJpZ3VvdXMgPSBmYWxzZTtcclxuXHRcdFx0bGV0IHRvQ2hhbmdlID0gMDtcclxuXHJcblx0XHRcdGZvciAoIGxldCBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGxldCBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaG8gPSBzaG9bIGhJZHggXTtcclxuXHRcdFx0XHRcdGxldCBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGxldCBzMklkeCA9IDA7IHMySWR4IDwgbmV3U2hhcGVzLmxlbmd0aDsgczJJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHNJZHggIT09IHMySWR4IClcdHRvQ2hhbmdlICsrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRob2xlX3VuYXNzaWduZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRhbWJpZ3VvdXMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRvQ2hhbmdlID4gMCAmJiBhbWJpZ3VvdXMgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRtcEhvbGVzO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0bXBTaGFwZSA9IG5ld1NoYXBlc1sgaSBdLnM7XHJcblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0XHR0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRcdHJldHVybiBzaGFwZXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQgeyBTaGFwZVBhdGggfTtcclxuIiwiaW1wb3J0IHsgUkVWSVNJT04gfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XHJcblxyXG5leHBvcnQgeyBXZWJHTEFycmF5UmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9yZW5kZXJlcnMvV2ViR0xBcnJheVJlbmRlclRhcmdldC5qcyc7XHJcbmV4cG9ydCB7IFdlYkdMM0RSZW5kZXJUYXJnZXQgfSBmcm9tICcuL3JlbmRlcmVycy9XZWJHTDNEUmVuZGVyVGFyZ2V0LmpzJztcclxuZXhwb3J0IHsgV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgfSBmcm9tICcuL3JlbmRlcmVycy9XZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cy5qcyc7XHJcbmV4cG9ydCB7IFdlYkdMQ3ViZVJlbmRlclRhcmdldCB9IGZyb20gJy4vcmVuZGVyZXJzL1dlYkdMQ3ViZVJlbmRlclRhcmdldC5qcyc7XHJcbmV4cG9ydCB7IFdlYkdMUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi9yZW5kZXJlcnMvV2ViR0xSZW5kZXJUYXJnZXQuanMnO1xyXG5leHBvcnQgeyBXZWJHTFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJlcnMvV2ViR0xSZW5kZXJlci5qcyc7XHJcbmV4cG9ydCB7IFdlYkdMMVJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXJlcnMvV2ViR0wxUmVuZGVyZXIuanMnO1xyXG5leHBvcnQgeyBTaGFkZXJMaWIgfSBmcm9tICcuL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qcyc7XHJcbmV4cG9ydCB7IFVuaWZvcm1zTGliIH0gZnJvbSAnLi9yZW5kZXJlcnMvc2hhZGVycy9Vbmlmb3Jtc0xpYi5qcyc7XHJcbmV4cG9ydCB7IFVuaWZvcm1zVXRpbHMgfSBmcm9tICcuL3JlbmRlcmVycy9zaGFkZXJzL1VuaWZvcm1zVXRpbHMuanMnO1xyXG5leHBvcnQgeyBTaGFkZXJDaHVuayB9IGZyb20gJy4vcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanMnO1xyXG5leHBvcnQgeyBGb2dFeHAyIH0gZnJvbSAnLi9zY2VuZXMvRm9nRXhwMi5qcyc7XHJcbmV4cG9ydCB7IEZvZyB9IGZyb20gJy4vc2NlbmVzL0ZvZy5qcyc7XHJcbmV4cG9ydCB7IFNjZW5lIH0gZnJvbSAnLi9zY2VuZXMvU2NlbmUuanMnO1xyXG5leHBvcnQgeyBTcHJpdGUgfSBmcm9tICcuL29iamVjdHMvU3ByaXRlLmpzJztcclxuZXhwb3J0IHsgTE9EIH0gZnJvbSAnLi9vYmplY3RzL0xPRC5qcyc7XHJcbmV4cG9ydCB7IFNraW5uZWRNZXNoIH0gZnJvbSAnLi9vYmplY3RzL1NraW5uZWRNZXNoLmpzJztcclxuZXhwb3J0IHsgU2tlbGV0b24gfSBmcm9tICcuL29iamVjdHMvU2tlbGV0b24uanMnO1xyXG5leHBvcnQgeyBCb25lIH0gZnJvbSAnLi9vYmplY3RzL0JvbmUuanMnO1xyXG5leHBvcnQgeyBNZXNoIH0gZnJvbSAnLi9vYmplY3RzL01lc2guanMnO1xyXG5leHBvcnQgeyBJbnN0YW5jZWRNZXNoIH0gZnJvbSAnLi9vYmplY3RzL0luc3RhbmNlZE1lc2guanMnO1xyXG5leHBvcnQgeyBMaW5lU2VnbWVudHMgfSBmcm9tICcuL29iamVjdHMvTGluZVNlZ21lbnRzLmpzJztcclxuZXhwb3J0IHsgTGluZUxvb3AgfSBmcm9tICcuL29iamVjdHMvTGluZUxvb3AuanMnO1xyXG5leHBvcnQgeyBMaW5lIH0gZnJvbSAnLi9vYmplY3RzL0xpbmUuanMnO1xyXG5leHBvcnQgeyBQb2ludHMgfSBmcm9tICcuL29iamVjdHMvUG9pbnRzLmpzJztcclxuZXhwb3J0IHsgR3JvdXAgfSBmcm9tICcuL29iamVjdHMvR3JvdXAuanMnO1xyXG5leHBvcnQgeyBWaWRlb1RleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL1ZpZGVvVGV4dHVyZS5qcyc7XHJcbmV4cG9ydCB7IEZyYW1lYnVmZmVyVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvRnJhbWVidWZmZXJUZXh0dXJlLmpzJztcclxuZXhwb3J0IHsgU291cmNlIH0gZnJvbSAnLi90ZXh0dXJlcy9Tb3VyY2UuanMnO1xyXG5leHBvcnQgeyBEYXRhVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvRGF0YVRleHR1cmUuanMnO1xyXG5leHBvcnQgeyBEYXRhQXJyYXlUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9EYXRhQXJyYXlUZXh0dXJlLmpzJztcclxuZXhwb3J0IHsgRGF0YTNEVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvRGF0YTNEVGV4dHVyZS5qcyc7XHJcbmV4cG9ydCB7IENvbXByZXNzZWRUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qcyc7XHJcbmV4cG9ydCB7IENvbXByZXNzZWRBcnJheVRleHR1cmUgfSBmcm9tICcuL3RleHR1cmVzL0NvbXByZXNzZWRBcnJheVRleHR1cmUuanMnO1xyXG5leHBvcnQgeyBDdWJlVGV4dHVyZSB9IGZyb20gJy4vdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMnO1xyXG5leHBvcnQgeyBDYW52YXNUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9DYW52YXNUZXh0dXJlLmpzJztcclxuZXhwb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMnO1xyXG5leHBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi90ZXh0dXJlcy9UZXh0dXJlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9nZW9tZXRyaWVzL0dlb21ldHJpZXMuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL21hdGVyaWFscy9NYXRlcmlhbHMuanMnO1xyXG5leHBvcnQgeyBBbmltYXRpb25Mb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQW5pbWF0aW9uTG9hZGVyLmpzJztcclxuZXhwb3J0IHsgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIuanMnO1xyXG5leHBvcnQgeyBDdWJlVGV4dHVyZUxvYWRlciB9IGZyb20gJy4vbG9hZGVycy9DdWJlVGV4dHVyZUxvYWRlci5qcyc7XHJcbmV4cG9ydCB7IERhdGFUZXh0dXJlTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXJzL0RhdGFUZXh0dXJlTG9hZGVyLmpzJztcclxuZXhwb3J0IHsgVGV4dHVyZUxvYWRlciB9IGZyb20gJy4vbG9hZGVycy9UZXh0dXJlTG9hZGVyLmpzJztcclxuZXhwb3J0IHsgT2JqZWN0TG9hZGVyIH0gZnJvbSAnLi9sb2FkZXJzL09iamVjdExvYWRlci5qcyc7XHJcbmV4cG9ydCB7IE1hdGVyaWFsTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXJzL01hdGVyaWFsTG9hZGVyLmpzJztcclxuZXhwb3J0IHsgQnVmZmVyR2VvbWV0cnlMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanMnO1xyXG5leHBvcnQgeyBEZWZhdWx0TG9hZGluZ01hbmFnZXIsIExvYWRpbmdNYW5hZ2VyIH0gZnJvbSAnLi9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzJztcclxuZXhwb3J0IHsgSW1hZ2VMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvSW1hZ2VMb2FkZXIuanMnO1xyXG5leHBvcnQgeyBJbWFnZUJpdG1hcExvYWRlciB9IGZyb20gJy4vbG9hZGVycy9JbWFnZUJpdG1hcExvYWRlci5qcyc7XHJcbmV4cG9ydCB7IEZpbGVMb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvRmlsZUxvYWRlci5qcyc7XHJcbmV4cG9ydCB7IExvYWRlciB9IGZyb20gJy4vbG9hZGVycy9Mb2FkZXIuanMnO1xyXG5leHBvcnQgeyBMb2FkZXJVdGlscyB9IGZyb20gJy4vbG9hZGVycy9Mb2FkZXJVdGlscy5qcyc7XHJcbmV4cG9ydCB7IENhY2hlIH0gZnJvbSAnLi9sb2FkZXJzL0NhY2hlLmpzJztcclxuZXhwb3J0IHsgQXVkaW9Mb2FkZXIgfSBmcm9tICcuL2xvYWRlcnMvQXVkaW9Mb2FkZXIuanMnO1xyXG5leHBvcnQgeyBTcG90TGlnaHQgfSBmcm9tICcuL2xpZ2h0cy9TcG90TGlnaHQuanMnO1xyXG5leHBvcnQgeyBQb2ludExpZ2h0IH0gZnJvbSAnLi9saWdodHMvUG9pbnRMaWdodC5qcyc7XHJcbmV4cG9ydCB7IFJlY3RBcmVhTGlnaHQgfSBmcm9tICcuL2xpZ2h0cy9SZWN0QXJlYUxpZ2h0LmpzJztcclxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0IH0gZnJvbSAnLi9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzJztcclxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0UHJvYmUgfSBmcm9tICcuL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHRQcm9iZS5qcyc7XHJcbmV4cG9ydCB7IERpcmVjdGlvbmFsTGlnaHQgfSBmcm9tICcuL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzJztcclxuZXhwb3J0IHsgQW1iaWVudExpZ2h0IH0gZnJvbSAnLi9saWdodHMvQW1iaWVudExpZ2h0LmpzJztcclxuZXhwb3J0IHsgQW1iaWVudExpZ2h0UHJvYmUgfSBmcm9tICcuL2xpZ2h0cy9BbWJpZW50TGlnaHRQcm9iZS5qcyc7XHJcbmV4cG9ydCB7IExpZ2h0IH0gZnJvbSAnLi9saWdodHMvTGlnaHQuanMnO1xyXG5leHBvcnQgeyBMaWdodFByb2JlIH0gZnJvbSAnLi9saWdodHMvTGlnaHRQcm9iZS5qcyc7XHJcbmV4cG9ydCB7IFN0ZXJlb0NhbWVyYSB9IGZyb20gJy4vY2FtZXJhcy9TdGVyZW9DYW1lcmEuanMnO1xyXG5leHBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4vY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qcyc7XHJcbmV4cG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9IGZyb20gJy4vY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMnO1xyXG5leHBvcnQgeyBDdWJlQ2FtZXJhIH0gZnJvbSAnLi9jYW1lcmFzL0N1YmVDYW1lcmEuanMnO1xyXG5leHBvcnQgeyBBcnJheUNhbWVyYSB9IGZyb20gJy4vY2FtZXJhcy9BcnJheUNhbWVyYS5qcyc7XHJcbmV4cG9ydCB7IENhbWVyYSB9IGZyb20gJy4vY2FtZXJhcy9DYW1lcmEuanMnO1xyXG5leHBvcnQgeyBBdWRpb0xpc3RlbmVyIH0gZnJvbSAnLi9hdWRpby9BdWRpb0xpc3RlbmVyLmpzJztcclxuZXhwb3J0IHsgUG9zaXRpb25hbEF1ZGlvIH0gZnJvbSAnLi9hdWRpby9Qb3NpdGlvbmFsQXVkaW8uanMnO1xyXG5leHBvcnQgeyBBdWRpb0NvbnRleHQgfSBmcm9tICcuL2F1ZGlvL0F1ZGlvQ29udGV4dC5qcyc7XHJcbmV4cG9ydCB7IEF1ZGlvQW5hbHlzZXIgfSBmcm9tICcuL2F1ZGlvL0F1ZGlvQW5hbHlzZXIuanMnO1xyXG5leHBvcnQgeyBBdWRpbyB9IGZyb20gJy4vYXVkaW8vQXVkaW8uanMnO1xyXG5leHBvcnQgeyBWZWN0b3JLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi9hbmltYXRpb24vdHJhY2tzL1ZlY3RvcktleWZyYW1lVHJhY2suanMnO1xyXG5leHBvcnQgeyBTdHJpbmdLZXlmcmFtZVRyYWNrIH0gZnJvbSAnLi9hbmltYXRpb24vdHJhY2tzL1N0cmluZ0tleWZyYW1lVHJhY2suanMnO1xyXG5leHBvcnQgeyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vYW5pbWF0aW9uL3RyYWNrcy9RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5qcyc7XHJcbmV4cG9ydCB7IE51bWJlcktleWZyYW1lVHJhY2sgfSBmcm9tICcuL2FuaW1hdGlvbi90cmFja3MvTnVtYmVyS2V5ZnJhbWVUcmFjay5qcyc7XHJcbmV4cG9ydCB7IENvbG9yS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vYW5pbWF0aW9uL3RyYWNrcy9Db2xvcktleWZyYW1lVHJhY2suanMnO1xyXG5leHBvcnQgeyBCb29sZWFuS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vYW5pbWF0aW9uL3RyYWNrcy9Cb29sZWFuS2V5ZnJhbWVUcmFjay5qcyc7XHJcbmV4cG9ydCB7IFByb3BlcnR5TWl4ZXIgfSBmcm9tICcuL2FuaW1hdGlvbi9Qcm9wZXJ0eU1peGVyLmpzJztcclxuZXhwb3J0IHsgUHJvcGVydHlCaW5kaW5nIH0gZnJvbSAnLi9hbmltYXRpb24vUHJvcGVydHlCaW5kaW5nLmpzJztcclxuZXhwb3J0IHsgS2V5ZnJhbWVUcmFjayB9IGZyb20gJy4vYW5pbWF0aW9uL0tleWZyYW1lVHJhY2suanMnO1xyXG5leHBvcnQgeyBBbmltYXRpb25VdGlscyB9IGZyb20gJy4vYW5pbWF0aW9uL0FuaW1hdGlvblV0aWxzLmpzJztcclxuZXhwb3J0IHsgQW5pbWF0aW9uT2JqZWN0R3JvdXAgfSBmcm9tICcuL2FuaW1hdGlvbi9BbmltYXRpb25PYmplY3RHcm91cC5qcyc7XHJcbmV4cG9ydCB7IEFuaW1hdGlvbk1peGVyIH0gZnJvbSAnLi9hbmltYXRpb24vQW5pbWF0aW9uTWl4ZXIuanMnO1xyXG5leHBvcnQgeyBBbmltYXRpb25DbGlwIH0gZnJvbSAnLi9hbmltYXRpb24vQW5pbWF0aW9uQ2xpcC5qcyc7XHJcbmV4cG9ydCB7IEFuaW1hdGlvbkFjdGlvbiB9IGZyb20gJy4vYW5pbWF0aW9uL0FuaW1hdGlvbkFjdGlvbi5qcyc7XHJcbmV4cG9ydCB7IFVuaWZvcm0gfSBmcm9tICcuL2NvcmUvVW5pZm9ybS5qcyc7XHJcbmV4cG9ydCB7IFVuaWZvcm1zR3JvdXAgfSBmcm9tICcuL2NvcmUvVW5pZm9ybXNHcm91cC5qcyc7XHJcbmV4cG9ydCB7IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzJztcclxuZXhwb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xyXG5leHBvcnQgeyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vY29yZS9JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmV4cG9ydCB7IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyIH0gZnJvbSAnLi9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzJztcclxuZXhwb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXIgfSBmcm9tICcuL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanMnO1xyXG5leHBvcnQgeyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuZXhwb3J0IHsgR0xCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL2NvcmUvR0xCdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuZXhwb3J0IHsgT2JqZWN0M0QgfSBmcm9tICcuL2NvcmUvT2JqZWN0M0QuanMnO1xyXG5leHBvcnQgeyBSYXljYXN0ZXIgfSBmcm9tICcuL2NvcmUvUmF5Y2FzdGVyLmpzJztcclxuZXhwb3J0IHsgTGF5ZXJzIH0gZnJvbSAnLi9jb3JlL0xheWVycy5qcyc7XHJcbmV4cG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vY29yZS9FdmVudERpc3BhdGNoZXIuanMnO1xyXG5leHBvcnQgeyBDbG9jayB9IGZyb20gJy4vY29yZS9DbG9jay5qcyc7XHJcbmV4cG9ydCB7IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCB9IGZyb20gJy4vbWF0aC9pbnRlcnBvbGFudHMvUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LmpzJztcclxuZXhwb3J0IHsgTGluZWFySW50ZXJwb2xhbnQgfSBmcm9tICcuL21hdGgvaW50ZXJwb2xhbnRzL0xpbmVhckludGVycG9sYW50LmpzJztcclxuZXhwb3J0IHsgRGlzY3JldGVJbnRlcnBvbGFudCB9IGZyb20gJy4vbWF0aC9pbnRlcnBvbGFudHMvRGlzY3JldGVJbnRlcnBvbGFudC5qcyc7XHJcbmV4cG9ydCB7IEN1YmljSW50ZXJwb2xhbnQgfSBmcm9tICcuL21hdGgvaW50ZXJwb2xhbnRzL0N1YmljSW50ZXJwb2xhbnQuanMnO1xyXG5leHBvcnQgeyBJbnRlcnBvbGFudCB9IGZyb20gJy4vbWF0aC9JbnRlcnBvbGFudC5qcyc7XHJcbmV4cG9ydCB7IFRyaWFuZ2xlIH0gZnJvbSAnLi9tYXRoL1RyaWFuZ2xlLmpzJztcclxuZXhwb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcbmV4cG9ydCB7IFNwaGVyaWNhbCB9IGZyb20gJy4vbWF0aC9TcGhlcmljYWwuanMnO1xyXG5leHBvcnQgeyBDeWxpbmRyaWNhbCB9IGZyb20gJy4vbWF0aC9DeWxpbmRyaWNhbC5qcyc7XHJcbmV4cG9ydCB7IFBsYW5lIH0gZnJvbSAnLi9tYXRoL1BsYW5lLmpzJztcclxuZXhwb3J0IHsgRnJ1c3R1bSB9IGZyb20gJy4vbWF0aC9GcnVzdHVtLmpzJztcclxuZXhwb3J0IHsgU3BoZXJlIH0gZnJvbSAnLi9tYXRoL1NwaGVyZS5qcyc7XHJcbmV4cG9ydCB7IFJheSB9IGZyb20gJy4vbWF0aC9SYXkuanMnO1xyXG5leHBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9tYXRoL01hdHJpeDQuanMnO1xyXG5leHBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi9tYXRoL01hdHJpeDMuanMnO1xyXG5leHBvcnQgeyBCb3gzIH0gZnJvbSAnLi9tYXRoL0JveDMuanMnO1xyXG5leHBvcnQgeyBCb3gyIH0gZnJvbSAnLi9tYXRoL0JveDIuanMnO1xyXG5leHBvcnQgeyBMaW5lMyB9IGZyb20gJy4vbWF0aC9MaW5lMy5qcyc7XHJcbmV4cG9ydCB7IEV1bGVyIH0gZnJvbSAnLi9tYXRoL0V1bGVyLmpzJztcclxuZXhwb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4vbWF0aC9WZWN0b3I0LmpzJztcclxuZXhwb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vbWF0aC9WZWN0b3IzLmpzJztcclxuZXhwb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4vbWF0aC9WZWN0b3IyLmpzJztcclxuZXhwb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vbWF0aC9RdWF0ZXJuaW9uLmpzJztcclxuZXhwb3J0IHsgQ29sb3IgfSBmcm9tICcuL21hdGgvQ29sb3IuanMnO1xyXG5leHBvcnQgeyBDb2xvck1hbmFnZW1lbnQgfSBmcm9tICcuL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcclxuZXhwb3J0IHsgU3BoZXJpY2FsSGFybW9uaWNzMyB9IGZyb20gJy4vbWF0aC9TcGhlcmljYWxIYXJtb25pY3MzLmpzJztcclxuZXhwb3J0IHsgU3BvdExpZ2h0SGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL1Nwb3RMaWdodEhlbHBlci5qcyc7XHJcbmV4cG9ydCB7IFNrZWxldG9uSGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzJztcclxuZXhwb3J0IHsgUG9pbnRMaWdodEhlbHBlciB9IGZyb20gJy4vaGVscGVycy9Qb2ludExpZ2h0SGVscGVyLmpzJztcclxuZXhwb3J0IHsgSGVtaXNwaGVyZUxpZ2h0SGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL0hlbWlzcGhlcmVMaWdodEhlbHBlci5qcyc7XHJcbmV4cG9ydCB7IEdyaWRIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvR3JpZEhlbHBlci5qcyc7XHJcbmV4cG9ydCB7IFBvbGFyR3JpZEhlbHBlciB9IGZyb20gJy4vaGVscGVycy9Qb2xhckdyaWRIZWxwZXIuanMnO1xyXG5leHBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0SGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL0RpcmVjdGlvbmFsTGlnaHRIZWxwZXIuanMnO1xyXG5leHBvcnQgeyBDYW1lcmFIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzJztcclxuZXhwb3J0IHsgQm94SGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL0JveEhlbHBlci5qcyc7XHJcbmV4cG9ydCB7IEJveDNIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvQm94M0hlbHBlci5qcyc7XHJcbmV4cG9ydCB7IFBsYW5lSGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL1BsYW5lSGVscGVyLmpzJztcclxuZXhwb3J0IHsgQXJyb3dIZWxwZXIgfSBmcm9tICcuL2hlbHBlcnMvQXJyb3dIZWxwZXIuanMnO1xyXG5leHBvcnQgeyBBeGVzSGVscGVyIH0gZnJvbSAnLi9oZWxwZXJzL0F4ZXNIZWxwZXIuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2V4dHJhcy9jdXJ2ZXMvQ3VydmVzLmpzJztcclxuZXhwb3J0IHsgU2hhcGUgfSBmcm9tICcuL2V4dHJhcy9jb3JlL1NoYXBlLmpzJztcclxuZXhwb3J0IHsgUGF0aCB9IGZyb20gJy4vZXh0cmFzL2NvcmUvUGF0aC5qcyc7XHJcbmV4cG9ydCB7IFNoYXBlUGF0aCB9IGZyb20gJy4vZXh0cmFzL2NvcmUvU2hhcGVQYXRoLmpzJztcclxuZXhwb3J0IHsgQ3VydmVQYXRoIH0gZnJvbSAnLi9leHRyYXMvY29yZS9DdXJ2ZVBhdGguanMnO1xyXG5leHBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4vZXh0cmFzL2NvcmUvQ3VydmUuanMnO1xyXG5leHBvcnQgeyBEYXRhVXRpbHMgfSBmcm9tICcuL2V4dHJhcy9EYXRhVXRpbHMuanMnO1xyXG5leHBvcnQgeyBJbWFnZVV0aWxzIH0gZnJvbSAnLi9leHRyYXMvSW1hZ2VVdGlscy5qcyc7XHJcbmV4cG9ydCB7IFNoYXBlVXRpbHMgfSBmcm9tICcuL2V4dHJhcy9TaGFwZVV0aWxzLmpzJztcclxuZXhwb3J0IHsgUE1SRU1HZW5lcmF0b3IgfSBmcm9tICcuL2V4dHJhcy9QTVJFTUdlbmVyYXRvci5qcyc7XHJcbmV4cG9ydCB7IFdlYkdMVXRpbHMgfSBmcm9tICcuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFV0aWxzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb25zdGFudHMuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL1RocmVlLkxlZ2FjeS5qcyc7XHJcblxyXG5pZiAoIHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnICkge1xyXG5cclxuXHRfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudCggbmV3IEN1c3RvbUV2ZW50KCAncmVnaXN0ZXInLCB7IGRldGFpbDoge1xyXG5cdFx0cmV2aXNpb246IFJFVklTSU9OLFxyXG5cdH0gfSApICk7XHJcblxyXG59XHJcblxyXG5pZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICkge1xyXG5cclxuXHRpZiAoIHdpbmRvdy5fX1RIUkVFX18gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogTXVsdGlwbGUgaW5zdGFuY2VzIG9mIFRocmVlLmpzIGJlaW5nIGltcG9ydGVkLicgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR3aW5kb3cuX19USFJFRV9fID0gUkVWSVNJT047XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFZO0FBQ1o7QUFDWTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1o7QUFDWTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1o7QUFDWTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1o7QUFDWTtBQUNaO0FBQ1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNaO0FBQ0E7QUFDWTtBQUNBO0FBQ0E7QUFDQTtBQUNaO0FBQ1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNaO0FBQ1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNaO0FBQ1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNaO0FBQ1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1o7QUFDWTtBQUNBO0FBQ1o7QUFDWTtBQUNaO0FBQ1k7QUFDQTs7QUN4TVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDbkZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCTDs7QUM1VUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ2hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1RUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ1k7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FDdEdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzFuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDdHFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQ2h0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDL2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDdmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7Ozs7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQzU0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUN2OEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ2pVQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvZUE7Ozs7Ozs7OztBQVNBOzs7O0FBSUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FDMW1CQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0s7OztBQUdMOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7Ozs7QUFJQTs7O0FBR0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7QUFHQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDemlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDcmFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNLOztBQ3JHTDs7QUNBQTs7O0FDT0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDbkxBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUNsT0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDbktBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ25CQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQzNMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUMvRkE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7OztBQ1lBOzs7O0FDSUE7Ozs7QUNBQTs7OztBQ3dCQTs7OztBQ0ZBOzs7O0FDeEJBOzs7O0FDZ0JBOzs7O0FDVUE7Ozs7QUNRQTs7OztBQ0xBOzs7O0FDRUE7Ozs7QUNHQTs7OztBQ1NBOzs7O0FDWEE7Ozs7QUNHQTs7OztBQ3JCQTs7OztBQ2dCQTs7O0FDZ0ZZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEdaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FDM05LO0FBQ0w7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6VkE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoUEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbG5CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7OztBQUdBOzs7OztBQUtBOzs7OztBQUtBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQ2hIQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQzdGQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7OztBQVFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEVBOzs7O0FBSUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDdm5DQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDSEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7QUFHQTs7QUFFQTs7OztBQUlBOzs7QUFHQTs7O0FBR0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ3QrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOzs7Ozs7O0FBT0E7OztBQUdBOzs7Ozs7QUFNQTs7QUFFQTs7OztBQUlBOzs7QUFHQTs7O0FBR0E7Ozs7QUFJQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7O0FBR0E7Ozs7QUFJQTs7Ozs7O0FBTUE7O0FBRUE7OztBQUdBOzs7QUFHQTs7O0FBR0E7Ozs7O0FBS0E7Ozs7QUFJQTs7OztBQUlBOzs7O0FBSUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFHQTs7QUFFQTs7OztBQUlBOzs7QUFHQTs7O0FBR0E7Ozs7QUFJQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQU9BOzs7QUFHQTtBQUNBO0FBQ0E7O0FDOW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOzs7OztBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUNwakJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUNuR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNoREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDakNBOzs7QUNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQzlYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7Ozs7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7OztBQUdBOztBQUVBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7O0FBR0E7OztBQUdBOztBQUVBOzs7QUFHQTs7O0FBR0E7OztBQUdBOztBQUVBOzs7Ozs7OztBQVFBOzs7QUFHQTs7Ozs7OztBQU9BOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUNueENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTlEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1FBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ1hBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUMvVUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQzFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUM1dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FDbmpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUNqNEVBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzdCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQy9CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDblVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQ3BRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNqUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDL01BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNWQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNqQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUN4WkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FDdkVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDdEVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUN4RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNoRkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7OztBQ25FQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUMvT0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FDekxBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDeEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDM0ZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUN6VEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNqSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7O0FBS0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQ2h4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ3Z5QkE7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNuQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNySEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQzNMQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNuSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUMxQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ2hIQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDN0pBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNsTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUMvQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDUkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ25IQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDdk5BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDL0dBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQzlGQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNwREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUMzR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQzNFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0s7Ozs7Ozs7OztBQVNMOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQ2hKQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQ1pBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FDeGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUN0ZEs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0s7O0FDeklMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUNoRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNuUkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FDN0hBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDakZBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDN0dBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUMxQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQzVPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDZEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDeldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ3hCQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDOUpBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3ZqQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQ3pEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ25JQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUNyWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUMxVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQ3ZzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUMvcUJBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDL3ZCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FDVkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQ3RGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQzdDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FDekdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDN0NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FDcFFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUN2R0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQzVDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUNsREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7O0FDdkdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQzlIQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
